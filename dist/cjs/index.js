'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var bcoinBrowser$1 = {};

var btc = {};

/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */

var assert_1$1;
var hasRequiredAssert$1;

function requireAssert$1 () {
	if (hasRequiredAssert$1) return assert_1$1;
	hasRequiredAssert$1 = 1;

	/**
	 * AssertionError
	 */

	class AssertionError extends Error {
	  constructor(options) {
	    if (typeof options === 'string')
	      options = { message: options };

	    if (options === null || typeof options !== 'object')
	      options = {};

	    let message = null;
	    let operator = 'fail';
	    let generatedMessage = Boolean(options.generatedMessage);
	    let start = null;

	    if (options.message != null)
	      message = toString(options.message);

	    if (typeof options.operator === 'string')
	      operator = options.operator;

	    if (message == null) {
	      if (operator === 'fail') {
	        message = 'Assertion failed.';
	      } else {
	        const a = stringify(options.actual);
	        const b = stringify(options.expected);

	        message = `${a} ${operator} ${b}`;
	      }

	      generatedMessage = true;
	    }

	    if (typeof options.stackStartFunction === 'function')
	      start = options.stackStartFunction;
	    else if (typeof options.stackStartFn === 'function')
	      start = options.stackStartFn;

	    super(message);

	    this.generatedMessage = generatedMessage;
	    this.code = 'ERR_ASSERTION';
	    this.actual = options.actual;
	    this.expected = options.expected;
	    this.operator = operator;

	    Object.defineProperty(this, 'name', {
	      value: 'AssertionError [ERR_ASSERTION]',
	      enumerable: false,
	      writable: true,
	      configurable: true
	    });

	    if (Error.captureStackTrace && start != null)
	      Error.captureStackTrace(this, start);

	    this.stack;
	    this.name = 'AssertionError';
	  }

	  toString() {
	    return `${this.name} [${this.code}]: ${this.message}`;
	  }
	}

	AssertionError.prototype.name = 'AssertionError';
	AssertionError.prototype.type = 'AssertionError'; // Deprecated.

	/*
	 * Assert
	 */

	function assert(value, message) {
	  if (!value) {
	    let generatedMessage = false;

	    if (arguments.length === 0) {
	      message = 'No value argument passed to `assert()`.';
	      generatedMessage = true;
	    } else if (message == null) {
	      message = 'Assertion failed.';
	      generatedMessage = true;
	    } else if (isError(message)) {
	      throw message;
	    }

	    throw new AssertionError({
	      message,
	      actual: value,
	      expected: true,
	      operator: '==',
	      generatedMessage,
	      stackStartFn: assert
	    });
	  }
	}

	function equal(actual, expected, message) {
	  if (!Object.is(actual, expected)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual,
	      expected,
	      operator: 'strictEqual',
	      stackStartFn: equal
	    });
	  }
	}

	function notEqual(actual, expected, message) {
	  if (Object.is(actual, expected)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual,
	      expected,
	      operator: 'notStrictEqual',
	      stackStartFn: notEqual
	    });
	  }
	}

	function fail(message) {
	  let generatedMessage = false;

	  if (isError(message))
	    throw message;

	  if (message == null) {
	    message = 'Assertion failed.';
	    generatedMessage = true;
	  }

	  throw new AssertionError({
	    message,
	    actual: false,
	    expected: true,
	    operator: 'fail',
	    generatedMessage,
	    stackStartFn: fail
	  });
	}

	function throws(func, expected, message) {
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = undefined;
	  }

	  let thrown = false;
	  let err = null;

	  enforce(typeof func === 'function', 'func', 'function');

	  try {
	    func();
	  } catch (e) {
	    thrown = true;
	    err = e;
	  }

	  if (!thrown) {
	    let generatedMessage = false;

	    if (message == null) {
	      message = 'Missing expected exception.';
	      generatedMessage = true;
	    }

	    throw new AssertionError({
	      message,
	      actual: undefined,
	      expected,
	      operator: 'throws',
	      generatedMessage,
	      stackStartFn: throws
	    });
	  }

	  if (!testError(err, expected, message, throws))
	    throw err;
	}

	function doesNotThrow(func, expected, message) {
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = undefined;
	  }

	  let thrown = false;
	  let err = null;

	  enforce(typeof func === 'function', 'func', 'function');

	  try {
	    func();
	  } catch (e) {
	    thrown = true;
	    err = e;
	  }

	  if (!thrown)
	    return;

	  if (testError(err, expected, message, doesNotThrow)) {
	    let generatedMessage = false;

	    if (message == null) {
	      message = 'Got unwanted exception.';
	      generatedMessage = true;
	    }

	    throw new AssertionError({
	      message,
	      actual: err,
	      expected,
	      operator: 'doesNotThrow',
	      generatedMessage,
	      stackStartFn: doesNotThrow
	    });
	  }

	  throw err;
	}

	async function rejects(func, expected, message) {
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = undefined;
	  }

	  let thrown = false;
	  let err = null;

	  if (typeof func !== 'function')
	    enforce(isPromise(func), 'func', 'promise');

	  try {
	    if (isPromise(func))
	      await func;
	    else
	      await func();
	  } catch (e) {
	    thrown = true;
	    err = e;
	  }

	  if (!thrown) {
	    let generatedMessage = false;

	    if (message == null) {
	      message = 'Missing expected rejection.';
	      generatedMessage = true;
	    }

	    throw new AssertionError({
	      message,
	      actual: undefined,
	      expected,
	      operator: 'rejects',
	      generatedMessage,
	      stackStartFn: rejects
	    });
	  }

	  if (!testError(err, expected, message, rejects))
	    throw err;
	}

	async function doesNotReject(func, expected, message) {
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = undefined;
	  }

	  let thrown = false;
	  let err = null;

	  if (typeof func !== 'function')
	    enforce(isPromise(func), 'func', 'promise');

	  try {
	    if (isPromise(func))
	      await func;
	    else
	      await func();
	  } catch (e) {
	    thrown = true;
	    err = e;
	  }

	  if (!thrown)
	    return;

	  if (testError(err, expected, message, doesNotReject)) {
	    let generatedMessage = false;

	    if (message == null) {
	      message = 'Got unwanted rejection.';
	      generatedMessage = true;
	    }

	    throw new AssertionError({
	      message,
	      actual: undefined,
	      expected,
	      operator: 'doesNotReject',
	      generatedMessage,
	      stackStartFn: doesNotReject
	    });
	  }

	  throw err;
	}

	function ifError(err) {
	  if (err != null) {
	    let message = 'ifError got unwanted exception: ';

	    if (typeof err === 'object' && typeof err.message === 'string') {
	      if (err.message.length === 0 && err.constructor)
	        message += err.constructor.name;
	      else
	        message += err.message;
	    } else {
	      message += stringify(err);
	    }

	    throw new AssertionError({
	      message,
	      actual: err,
	      expected: null,
	      operator: 'ifError',
	      generatedMessage: true,
	      stackStartFn: ifError
	    });
	  }
	}

	function match(string, regexp, message) {
	  testMatch(string, regexp, message, match, true);
	}

	function doesNotMatch(string, regexp, message) {
	  testMatch(string, regexp, message, doesNotMatch, false);
	}

	function deepEqual(actual, expected, message) {
	  if (!isDeepEqual(actual, expected, false)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual,
	      expected,
	      operator: 'deepStrictEqual',
	      stackStartFn: deepEqual
	    });
	  }
	}

	function notDeepEqual(actual, expected, message) {
	  if (isDeepEqual(actual, expected, true)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual,
	      expected,
	      operator: 'notDeepStrictEqual',
	      stackStartFn: notDeepEqual
	    });
	  }
	}

	function bufferEqual(actual, expected, enc, message) {
	  if (!isEncoding(enc)) {
	    message = enc;
	    enc = null;
	  }

	  if (enc == null)
	    enc = 'hex';

	  expected = bufferize(actual, expected, enc);

	  enforce(isBuffer(actual), 'actual', 'buffer');
	  enforce(isBuffer(expected), 'expected', 'buffer');

	  if (actual !== expected && !actual.equals(expected)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual: actual.toString(enc),
	      expected: expected.toString(enc),
	      operator: 'bufferEqual',
	      stackStartFn: bufferEqual
	    });
	  }
	}

	function notBufferEqual(actual, expected, enc, message) {
	  if (!isEncoding(enc)) {
	    message = enc;
	    enc = null;
	  }

	  if (enc == null)
	    enc = 'hex';

	  expected = bufferize(actual, expected, enc);

	  enforce(isBuffer(actual), 'actual', 'buffer');
	  enforce(isBuffer(expected), 'expected', 'buffer');

	  if (actual === expected || actual.equals(expected)) {
	    if (isError(message))
	      throw message;

	    throw new AssertionError({
	      message,
	      actual: actual.toString(enc),
	      expected: expected.toString(enc),
	      operator: 'notBufferEqual',
	      stackStartFn: notBufferEqual
	    });
	  }
	}

	function enforce(value, name, type) {
	  if (!value) {
	    let msg;

	    if (name == null) {
	      msg = 'Invalid type for parameter.';
	    } else {
	      if (type == null)
	        msg = `Invalid type for "${name}".`;
	      else
	        msg = `"${name}" must be a(n) ${type}.`;
	    }

	    const err = new TypeError(msg);

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, enforce);

	    throw err;
	  }
	}

	function range(value, name) {
	  if (!value) {
	    const msg = name != null
	      ? `"${name}" is out of range.`
	      : 'Parameter is out of range.';

	    const err = new RangeError(msg);

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, range);

	    throw err;
	  }
	}

	/*
	 * Stringification
	 */

	function stringify(value) {
	  switch (typeof value) {
	    case 'undefined':
	      return 'undefined';
	    case 'object':
	      if (value === null)
	        return 'null';
	      return `[${objectName(value)}]`;
	    case 'boolean':
	      return `${value}`;
	    case 'number':
	      return `${value}`;
	    case 'string':
	      if (value.length > 80)
	        value = `${value.substring(0, 77)}...`;
	      return JSON.stringify(value);
	    case 'symbol':
	      return tryString(value);
	    case 'function':
	      return `[${funcName(value)}]`;
	    case 'bigint':
	      return `${value}n`;
	    default:
	      return `[${typeof value}]`;
	  }
	}

	function toString(value) {
	  if (typeof value === 'string')
	    return value;

	  if (isError(value))
	    return tryString(value);

	  return stringify(value);
	}

	function tryString(value) {
	  try {
	    return String(value);
	  } catch (e) {
	    return 'Object';
	  }
	}

	/*
	 * Error Testing
	 */

	function testError(err, expected, message, func) {
	  if (expected == null)
	    return true;

	  if (isRegExp(expected))
	    return expected.test(err);

	  if (typeof expected !== 'function') {
	    if (func === doesNotThrow || func === doesNotReject)
	      throw new TypeError('"expected" must not be an object.');

	    if (typeof expected !== 'object')
	      throw new TypeError('"expected" must be an object.');

	    let generatedMessage = false;

	    if (message == null) {
	      const name = func === rejects ? 'rejection' : 'exception';
	      message = `Missing expected ${name}.`;
	      generatedMessage = true;
	    }

	    if (err == null || typeof err !== 'object') {
	      throw new AssertionError({
	        actual: err,
	        expected,
	        message,
	        operator: func.name,
	        generatedMessage,
	        stackStartFn: func
	      });
	    }

	    const keys = Object.keys(expected);

	    if (isError(expected))
	      keys.push('name', 'message');

	    if (keys.length === 0)
	      throw new TypeError('"expected" may not be an empty object.');

	    for (const key of keys) {
	      const expect = expected[key];
	      const value = err[key];

	      if (typeof value === 'string' &&
	          isRegExp(expect) &&
	          expect.test(value)) {
	        continue;
	      }

	      if ((key in err) && isDeepEqual(value, expect, false))
	        continue;

	      throw new AssertionError({
	        actual: err,
	        expected: expected,
	        message,
	        operator: func.name,
	        generatedMessage,
	        stackStartFn: func
	      });
	    }

	    return true;
	  }

	  if (expected.prototype !== undefined && (err instanceof expected))
	    return true;

	  // eslint-disable-next-line no-prototype-builtins
	  if (Error.isPrototypeOf(expected))
	    return false;

	  return expected.call({}, err) === true;
	}

	function testMatch(string, regexp, message, fn, expect) {
	  enforce(typeof string === 'string', 'string', 'string');
	  enforce(isRegExp(regexp), 'regexp', 'RegExp');

	  if (regexp.test(string) !== expect) {
	    if (isError(message))
	      throw message;

	    let generatedMessage = false;

	    if (message == null) {
	      message = `The input ${expect ? 'did' : 'was expected to'} `
	              + `not match the regular expression ${regexp}. `
	              + `Input:\n\n${stringify(string)}\n`;

	      generatedMessage = true;
	    }

	    throw new AssertionError({
	      actual: string,
	      expected: regexp,
	      message,
	      operator: fn.name,
	      generatedMessage,
	      stackStartFn: fn
	    });
	  }
	}

	/*
	 * Comparisons
	 */

	function isDeepEqual(x, y, fail) {
	  try {
	    return compare(x, y, null);
	  } catch (e) {
	    return fail;
	  }
	}

	function compare(a, b, cache) {
	  // Primitives.
	  if (Object.is(a, b))
	    return true;

	  if (!isObject(a) || !isObject(b))
	    return false;

	  // Semi-primitives.
	  if (objectString(a) !== objectString(b))
	    return false;

	  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;

	  if (isBuffer(a) && isBuffer(b))
	    return a.equals(b);

	  if (isDate(a))
	    return Object.is(a.getTime(), b.getTime());

	  if (isRegExp(a))
	    return a.source === b.source && a.flags === b.flags;

	  if (isError(a)) {
	    if (a.message !== b.message)
	      return false;
	  }

	  if (isArrayBuffer(a)) {
	    a = new Uint8Array(a);
	    b = new Uint8Array(b);
	  }

	  if (isView(a) && !isBuffer(a)) {
	    if (isBuffer(b))
	      return false;

	    const x = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
	    const y = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);

	    if (x.length !== y.length)
	      return false;

	    for (let i = 0; i < x.length; i++) {
	      if (x[i] !== y[i])
	        return false;
	    }

	    return true;
	  }

	  if (isSet(a)) {
	    if (a.size !== b.size)
	      return false;

	    const keys = new Set([...a, ...b]);

	    return keys.size === a.size;
	  }

	  // Recursive.
	  if (!cache) {
	    cache = {
	      a: new Map(),
	      b: new Map(),
	      p: 0
	    };
	  } else {
	    const aa = cache.a.get(a);

	    if (aa != null) {
	      const bb = cache.b.get(b);
	      if (bb != null)
	        return aa === bb;
	    }

	    cache.p += 1;
	  }

	  cache.a.set(a, cache.p);
	  cache.b.set(b, cache.p);

	  const ret = recurse(a, b, cache);

	  cache.a.delete(a);
	  cache.b.delete(b);

	  return ret;
	}

	function recurse(a, b, cache) {
	  if (isMap(a)) {
	    if (a.size !== b.size)
	      return false;

	    const keys = new Set([...a.keys(), ...b.keys()]);

	    if (keys.size !== a.size)
	      return false;

	    for (const key of keys) {
	      if (!compare(a.get(key), b.get(key), cache))
	        return false;
	    }

	    return true;
	  }

	  if (isArray(a)) {
	    if (a.length !== b.length)
	      return false;

	    for (let i = 0; i < a.length; i++) {
	      if (!compare(a[i], b[i], cache))
	        return false;
	    }

	    return true;
	  }

	  const ak = ownKeys(a);
	  const bk = ownKeys(b);

	  if (ak.length !== bk.length)
	    return false;

	  const keys = new Set([...ak, ...bk]);

	  if (keys.size !== ak.length)
	    return false;

	  for (const key of keys) {
	    if (!compare(a[key], b[key], cache))
	      return false;
	  }

	  return true;
	}

	function ownKeys(obj) {
	  const keys = Object.keys(obj);

	  if (!Object.getOwnPropertySymbols)
	    return keys;

	  if (!Object.getOwnPropertyDescriptor)
	    return keys;

	  const symbols = Object.getOwnPropertySymbols(obj);

	  for (const symbol of symbols) {
	    const desc = Object.getOwnPropertyDescriptor(obj, symbol);

	    if (desc && desc.enumerable) {
	      // @ts-ignore
	      keys.push(symbol);
	    }
	  }

	  return keys;
	}

	/*
	 * Helpers
	 */

	function objectString(obj) {
	  if (obj === undefined)
	    return '[object Undefined]';

	  if (obj === null)
	    return '[object Null]';

	  try {
	    return Object.prototype.toString.call(obj);
	  } catch (e) {
	    return '[object Object]';
	  }
	}

	function objectType(obj) {
	  return objectString(obj).slice(8, -1);
	}

	function objectName(obj) {
	  const type = objectType(obj);

	  if (obj == null)
	    return type;

	  if (type !== 'Object' && type !== 'Error')
	    return type;

	  let ctor, name;

	  try {
	    ctor = obj.constructor;
	  } catch (e) {
	  }

	  if (ctor == null)
	    return type;

	  try {
	    name = ctor.name;
	  } catch (e) {
	    return type;
	  }

	  if (typeof name !== 'string' || name.length === 0)
	    return type;

	  return name;
	}

	function funcName(func) {
	  let name;

	  try {
	    name = func.name;
	  } catch (e) {
	  }

	  if (typeof name !== 'string' || name.length === 0)
	    return 'Function';

	  return `Function: ${name}`;
	}

	function isArray(obj) {
	  return Array.isArray(obj);
	}

	function isArrayBuffer(obj) {
	  return obj instanceof ArrayBuffer;
	}

	function isBuffer(obj) {
	  return isObject(obj)
	      && typeof obj.writeUInt32LE === 'function'
	      && typeof obj.equals === 'function';
	}

	function isDate(obj) {
	  return obj instanceof Date;
	}

	function isError(obj) {
	  return obj instanceof Error;
	}

	function isMap(obj) {
	  return obj instanceof Map;
	}

	function isObject(obj) {
	  return obj && typeof obj === 'object';
	}

	function isPromise(obj) {
	  return obj instanceof Promise;
	}

	function isRegExp(obj) {
	  return obj instanceof RegExp;
	}

	function isSet(obj) {
	  return obj instanceof Set;
	}

	function isView(obj) {
	  return ArrayBuffer.isView(obj);
	}

	function isEncoding(enc) {
	  if (typeof enc !== 'string')
	    return false;

	  if (enc.length > 9)
	    return false;

	  switch (enc.toLowerCase()) {
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'base64url':
	    case 'hex':
	    case 'latin1':
	    case 'ucs2':
	    case 'utf8':
	    case 'utf16le':
	    case 'ucs-2':
	    case 'utf-8':
	    case 'utf-16le':
	      return true;
	  }

	  return false;
	}

	function bufferize(actual, expected, enc) {
	  if (typeof expected === 'string') {
	    if (!isBuffer(actual))
	      return null;

	    const {constructor} = actual;

	    if (!constructor || typeof constructor.from !== 'function')
	      return null;

	    if (!isEncoding(enc))
	      return null;

	    const raw = constructor.from(expected, enc);

	    if (enc.length === 3 && raw.length * 2 !== expected.length)
	      return null;

	    return raw;
	  }

	  return expected;
	}

	/*
	 * API
	 */

	assert.AssertionError = AssertionError;
	assert.assert = assert;
	assert.strict = assert;
	assert.ok = assert;
	assert.equal = equal;
	assert.notEqual = notEqual;
	assert.strictEqual = equal;
	assert.notStrictEqual = notEqual;
	assert.fail = fail;
	assert.throws = throws;
	assert.doesNotThrow = doesNotThrow;
	assert.rejects = rejects;
	assert.doesNotReject = doesNotReject;
	assert.ifError = ifError;
	assert.match = match;
	assert.doesNotMatch = doesNotMatch;
	assert.deepEqual = deepEqual;
	assert.notDeepEqual = notDeepEqual;
	assert.deepStrictEqual = deepEqual;
	assert.notDeepStrictEqual = notDeepEqual;
	assert.bufferEqual = bufferEqual;
	assert.notBufferEqual = notBufferEqual;
	assert.enforce = enforce;
	assert.range = range;

	/*
	 * Expose
	 */

	assert_1$1 = assert;
	return assert_1$1;
}

var fixed = {};

/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredFixed;

function requireFixed () {
	if (hasRequiredFixed) return fixed;
	hasRequiredFixed = 1;
	(function (exports) {

		const assert = requireAssert$1();

		/**
		 * Convert int to fixed number string and reduce by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {String} Fixed number string.
		 */

		exports.encode = function encode(num, exp) {
		  assert(Number.isSafeInteger(num), 'Invalid integer value.');
		  let sign = '';
		  if (num < 0) {
		    num = -num;
		    sign = '-';
		  }
		  const mult = pow10(exp);
		  let lo = num % mult;
		  let hi = (num - lo) / mult;
		  lo = lo.toString(10);
		  hi = hi.toString(10);
		  while (lo.length < exp) lo = '0' + lo;
		  lo = lo.replace(/0+$/, '');
		  assert(lo.length <= exp, 'Invalid integer value.');
		  if (lo.length === 0) lo = '0';
		  if (exp === 0) return `${sign}${hi}`;
		  return `${sign}${hi}.${lo}`;
		};

		/**
		 * Parse a fixed number string and multiply by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {String} str
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Integer.
		 */

		exports.decode = function decode(str, exp) {
		  assert(typeof str === 'string');
		  assert(str.length <= 32, 'Fixed number string too large.');
		  let sign = 1;
		  if (str.length > 0 && str[0] === '-') {
		    str = str.substring(1);
		    sign = -1;
		  }
		  let hi = str;
		  let lo = '0';
		  const index = str.indexOf('.');
		  if (index !== -1) {
		    hi = str.substring(0, index);
		    lo = str.substring(index + 1);
		  }
		  hi = hi.replace(/^0+/, '');
		  lo = lo.replace(/0+$/, '');
		  assert(hi.length <= 16 - exp, 'Fixed number string exceeds 2^53-1.');
		  assert(lo.length <= exp, 'Too many decimal places in fixed number string.');
		  if (hi.length === 0) hi = '0';
		  while (lo.length < exp) lo += '0';
		  if (lo.length === 0) lo = '0';
		  assert(/^\d+$/.test(hi) && /^\d+$/.test(lo), 'Non-numeric characters in fixed number string.');
		  hi = parseInt(hi, 10);
		  lo = parseInt(lo, 10);
		  const mult = pow10(exp);
		  const maxLo = modSafe(mult);
		  const maxHi = divSafe(mult);
		  assert(hi < maxHi || hi === maxHi && lo <= maxLo, 'Fixed number string exceeds 2^53-1.');
		  return sign * (hi * mult + lo);
		};

		/**
		 * Convert int to float and reduce by a power
		 * of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Double float.
		 */

		exports.toFloat = function toFloat(num, exp) {
		  return parseFloat(exports.encode(num, exp));
		};

		/**
		 * Parse a double float number and multiply by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Integer.
		 */

		exports.fromFloat = function fromFloat(num, exp) {
		  assert(typeof num === 'number' && isFinite(num));
		  assert(Number.isSafeInteger(exp));
		  return exports.decode(num.toFixed(exp), exp);
		};

		/*
		 * Helpers
		 */

		function pow10(exp) {
		  switch (exp) {
		    case 0:
		      return 1;
		    case 1:
		      return 10;
		    case 2:
		      return 100;
		    case 3:
		      return 1000;
		    case 4:
		      return 10000;
		    case 5:
		      return 100000;
		    case 6:
		      return 1000000;
		    case 7:
		      return 10000000;
		    case 8:
		      return 100000000;
		  }
		  throw new Error('Exponent is too large.');
		}
		function modSafe(mod) {
		  switch (mod) {
		    case 1:
		      return 0;
		    case 10:
		      return 1;
		    case 100:
		      return 91;
		    case 1000:
		      return 991;
		    case 10000:
		      return 991;
		    case 100000:
		      return 40991;
		    case 1000000:
		      return 740991;
		    case 10000000:
		      return 4740991;
		    case 100000000:
		      return 54740991;
		  }
		  throw new Error('Exponent is too large.');
		}
		function divSafe(div) {
		  switch (div) {
		    case 1:
		      return 9007199254740991;
		    case 10:
		      return 900719925474099;
		    case 100:
		      return 90071992547409;
		    case 1000:
		      return 9007199254740;
		    case 10000:
		      return 900719925474;
		    case 100000:
		      return 90071992547;
		    case 1000000:
		      return 9007199254;
		    case 10000000:
		      return 900719925;
		    case 100000000:
		      return 90071992;
		  }
		  throw new Error('Exponent is too large.');
		} 
	} (fixed));
	return fixed;
}

/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var amount;
var hasRequiredAmount;

function requireAmount () {
	if (hasRequiredAmount) return amount;
	hasRequiredAmount = 1;

	const assert = requireAssert$1();
	const fixed = requireFixed();

	/**
	 * Amount
	 * Represents a bitcoin amount (satoshis internally).
	 * @alias module:btc.Amount
	 * @property {Amount} value
	 */

	class Amount {
	  /**
	   * Create an amount.
	   * @constructor
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   */

	  constructor(value, unit) {
	    this.value = 0;
	    if (value != null) this.fromOptions(value, unit);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   * @returns {Amount}
	   */

	  fromOptions(value, unit) {
	    if (typeof unit === 'string') return this.from(unit, value);
	    if (typeof value === 'number') return this.fromValue(value);
	    return this.fromBTC(value);
	  }

	  /**
	   * Get satoshi value.
	   * @returns {Amount}
	   */

	  toValue() {
	    return this.value;
	  }

	  /**
	   * Get satoshi string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toSatoshis(num) {
	    if (num) return this.value;
	    return this.value.toString(10);
	  }

	  /**
	   * Get bits string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toBits(num) {
	    return Amount.encode(this.value, 2, num);
	  }

	  /**
	   * Get mbtc string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toMBTC(num) {
	    return Amount.encode(this.value, 5, num);
	  }

	  /**
	   * Get btc string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toBTC(num) {
	    return Amount.encode(this.value, 8, num);
	  }

	  /**
	   * Get unit string or value.
	   * @param {String} unit - Can be `sat`,
	   * `ubtc`, `bits`, `mbtc`, or `btc`.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  to(unit, num) {
	    switch (unit) {
	      case 'sat':
	        return this.toSatoshis(num);
	      case 'ubtc':
	      case 'bits':
	        return this.toBits(num);
	      case 'mbtc':
	        return this.toMBTC(num);
	      case 'btc':
	        return this.toBTC(num);
	    }
	    throw new Error(`Unknown unit "${unit}".`);
	  }

	  /**
	   * Convert amount to bitcoin string.
	   * @returns {String}
	   */

	  toString() {
	    return this.toBTC();
	  }

	  /**
	   * Inject properties from value.
	   * @private
	   * @param {Amount} value
	   * @returns {Amount}
	   */

	  fromValue(value) {
	    assert(Number.isSafeInteger(value) && value >= 0, 'Value must be an int64.');
	    this.value = value;
	    return this;
	  }

	  /**
	   * Inject properties from satoshis.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromSatoshis(value) {
	    this.value = Amount.decode(value, 0);
	    return this;
	  }

	  /**
	   * Inject properties from bits.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromBits(value) {
	    this.value = Amount.decode(value, 2);
	    return this;
	  }

	  /**
	   * Inject properties from mbtc.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromMBTC(value) {
	    this.value = Amount.decode(value, 5);
	    return this;
	  }

	  /**
	   * Inject properties from btc.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromBTC(value) {
	    this.value = Amount.decode(value, 8);
	    return this;
	  }

	  /**
	   * Inject properties from unit.
	   * @private
	   * @param {String} unit
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  from(unit, value) {
	    switch (unit) {
	      case 'sat':
	        return this.fromSatoshis(value);
	      case 'ubtc':
	      case 'bits':
	        return this.fromBits(value);
	      case 'mbtc':
	        return this.fromMBTC(value);
	      case 'btc':
	        return this.fromBTC(value);
	    }
	    throw new Error(`Unknown unit "${unit}".`);
	  }

	  /**
	   * Instantiate amount from options.
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   * @returns {Amount}
	   */

	  static fromOptions(value, unit) {
	    return new this().fromOptions(value, unit);
	  }

	  /**
	   * Instantiate amount from value.
	   * @private
	   * @param {Amount} value
	   * @returns {Amount}
	   */

	  static fromValue(value) {
	    return new this().fromValue(value);
	  }

	  /**
	   * Instantiate amount from satoshis.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromSatoshis(value) {
	    return new this().fromSatoshis(value);
	  }

	  /**
	   * Instantiate amount from bits.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromBits(value) {
	    return new this().fromBits(value);
	  }

	  /**
	   * Instantiate amount from mbtc.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromMBTC(value) {
	    return new this().fromMBTC(value);
	  }

	  /**
	   * Instantiate amount from btc.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromBTC(value) {
	    return new this().fromBTC(value);
	  }

	  /**
	   * Instantiate amount from unit.
	   * @param {String} unit
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static from(unit, value) {
	    return new this().from(unit, value);
	  }

	  /**
	   * Inspect amount.
	   * @returns {String}
	   */

	  inspect() {
	    return `<Amount: ${this.toString()}>`;
	  }

	  /**
	   * Safely convert satoshis to a BTC string.
	   * This function explicitly avoids any
	   * floating point arithmetic.
	   * @param {Amount} value - Satoshis.
	   * @returns {String} BTC string.
	   */

	  static btc(value, num) {
	    if (typeof value === 'string') return value;
	    return Amount.encode(value, 8, num);
	  }

	  /**
	   * Safely convert a BTC string to satoshis.
	   * @param {String} str - BTC
	   * @returns {Amount} Satoshis.
	   * @throws on parse error
	   */

	  static value(str) {
	    if (typeof str === 'number') return str;
	    return Amount.decode(str, 8);
	  }

	  /**
	   * Safely convert satoshis to a BTC string.
	   * @param {Amount} value
	   * @param {Number} exp - Exponent.
	   * @param {Boolean} num - Return a number.
	   * @returns {String|Number}
	   */

	  static encode(value, exp, num) {
	    if (num) return fixed.toFloat(value, exp);
	    return fixed.encode(value, exp);
	  }

	  /**
	   * Safely convert a BTC string to satoshis.
	   * @param {String|Number} value - BTC
	   * @param {Number} exp - Exponent.
	   * @returns {Amount} Satoshis.
	   * @throws on parse error
	   */

	  static decode(value, exp) {
	    if (typeof value === 'number') return fixed.fromFloat(value, exp);
	    return fixed.decode(value, exp);
	  }
	}

	/*
	 * Expose
	 */

	amount = Amount;
	return amount;
}

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var bufio = {};

var custom$2 = {};

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding$1(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding$1,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
function format$1(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$1(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect$1(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (browser$1.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format$1.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect$1(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect$1.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect$1.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];

  if (style) {
    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
           '\u001b[' + inspect$1.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect$1 &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray$1(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty$1(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty$1(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray$1(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNullOrUndefined(arg) {
  return arg == null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return Buffer$1.isBuffer(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format$1.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

var _polyfillNode_util = {
  inherits: inherits,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray$1,
  inspect: inspect$1,
  deprecate: deprecate,
  format: format$1,
  debuglog: debuglog,
  promisify: promisify,
  callbackify: callbackify,
};

var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_extend: _extend,
	callbackify: callbackify,
	debuglog: debuglog,
	default: _polyfillNode_util,
	deprecate: deprecate,
	format: format$1,
	inherits: inherits,
	inspect: inspect$1,
	isArray: isArray$1,
	isBoolean: isBoolean,
	isBuffer: isBuffer,
	isDate: isDate,
	isError: isError,
	isFunction: isFunction,
	isNull: isNull,
	isNullOrUndefined: isNullOrUndefined,
	isNumber: isNumber,
	isObject: isObject,
	isPrimitive: isPrimitive,
	isRegExp: isRegExp,
	isString: isString,
	isSymbol: isSymbol,
	isUndefined: isUndefined,
	log: log,
	promisify: promisify
});

var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

var hasRequiredCustom$2;

function requireCustom$2 () {
	if (hasRequiredCustom$2) return custom$2;
	hasRequiredCustom$2 = 1;

	const {inspect} = require$$0$4;

	custom$2.custom = inspect.custom || 'inspect';
	return custom$2;
}

var encoding = {};

/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var enforce_1;
var hasRequiredEnforce;

function requireEnforce () {
	if (hasRequiredEnforce) return enforce_1;
	hasRequiredEnforce = 1;

	/*
	 * Enforce
	 */

	function enforce(value, name, type) {
	  if (!value) {
	    const err = new TypeError(`'${name}' must be a(n) ${type}.`);

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, enforce);

	    throw err;
	  }
	}

	/*
	 * Expose
	 */

	enforce_1 = enforce;
	return enforce_1;
}

/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var error$1;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error$1;
	hasRequiredError = 1;

	/**
	 * Encoding Error
	 * @extends {Error}
	 */

	class EncodingError extends Error {
	  /**
	   * Create an encoding error.
	   * @constructor
	   * @param {Number} offset
	   * @param {String} reason
	   */

	  constructor(offset, reason, start) {
	    super();

	    this.type = 'EncodingError';
	    this.name = 'EncodingError';
	    this.code = 'ERR_ENCODING';
	    this.message = `${reason} (offset=${offset}).`;

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(this, start || EncodingError);
	  }
	}

	/*
	 * Expose
	 */

	error$1 = EncodingError;
	return error$1;
}

var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;

	const enforce = requireEnforce();
	const EncodingError = requireError();

	/*
	 * Constants
	 */

	const HI = 1 / 0x100000000;
	const {MAX_SAFE_INTEGER} = Number;
	const F32_ARRAY = new Float32Array(1);
	const F328_ARRAY = new Uint8Array(F32_ARRAY.buffer);
	const F64_ARRAY = new Float64Array(1);
	const F648_ARRAY = new Uint8Array(F64_ARRAY.buffer);

	F32_ARRAY[0] = -1;

	const BIG_ENDIAN = F328_ARRAY[3] === 0;

	/*
	 * Read Unsigned LE
	 */

	function readU(data, off, len) {
	  switch (len) {
	    case 8:
	      return readU64(data, off);
	    case 7:
	      return readU56(data, off);
	    case 6:
	      return readU48(data, off);
	    case 5:
	      return readU40(data, off);
	    case 4:
	      return readU32(data, off);
	    case 3:
	      return readU24(data, off);
	    case 2:
	      return readU16(data, off);
	    case 1:
	      return readU8(data, off);
	    default:
	      throw new EncodingError(off, 'Invalid read length');
	  }
	}

	function readU64(data, off) {
	  const hi = readU32(data, off + 4);
	  const lo = readU32(data, off);

	  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readU56(data, off) {
	  const hi = readU24(data, off + 4);
	  const lo = readU32(data, off);

	  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readU48(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off++] * 0x1000000
	        + data[off++] * 0x100000000
	        + data[off] * 0x10000000000);
	}

	function readU40(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off++] * 0x1000000
	        + data[off] * 0x100000000);
	}

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	function readU24(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off] * 0x10000);
	}

	function readU16(data, off) {
	  return data[off++] + data[off] * 0x100;
	}

	function readU8(data, off) {
	  return data[off];
	}

	/*
	 * Read Unsigned BE
	 */

	function readUBE(data, off, len) {
	  switch (len) {
	    case 8:
	      return readU64BE(data, off);
	    case 7:
	      return readU56BE(data, off);
	    case 6:
	      return readU48BE(data, off);
	    case 5:
	      return readU40BE(data, off);
	    case 4:
	      return readU32BE(data, off);
	    case 3:
	      return readU24BE(data, off);
	    case 2:
	      return readU16BE(data, off);
	    case 1:
	      return readU8(data, off);
	    default:
	      throw new EncodingError(off, 'Invalid read length');
	  }
	}

	function readU64BE(data, off) {
	  const hi = readU32BE(data, off);
	  const lo = readU32BE(data, off + 4);

	  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readU56BE(data, off) {
	  const hi = readU24BE(data, off);
	  const lo = readU32BE(data, off + 3);

	  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readU48BE(data, off) {
	  return (data[off++] * 0x10000000000
	        + data[off++] * 0x100000000
	        + data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readU40BE(data, off) {
	  return (data[off++] * 0x100000000
	        + data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readU32BE(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readU24BE(data, off) {
	  return (data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readU16BE(data, off) {
	  return data[off++] * 0x100 + data[off];
	}

	/*
	 * Read Signed LE
	 */

	function readI(data, off, len) {
	  switch (len) {
	    case 8:
	      return readI64(data, off);
	    case 7:
	      return readI56(data, off);
	    case 6:
	      return readI48(data, off);
	    case 5:
	      return readI40(data, off);
	    case 4:
	      return readI32(data, off);
	    case 3:
	      return readI24(data, off);
	    case 2:
	      return readI16(data, off);
	    case 1:
	      return readI8(data, off);
	    default:
	      throw new EncodingError(off, 'Invalid read length');
	  }
	}

	function readI64(data, off) {
	  const hi = readI32(data, off + 4);
	  const lo = readU32(data, off);

	  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readI56(data, off) {
	  const hi = readI24(data, off + 4);
	  const lo = readU32(data, off);

	  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readI48(data, off) {
	  const val = data[off + 4] + data[off + 5] * 0x100;

	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000
	        + (val | (val & 0x8000) * 0x1fffe) * 0x100000000);
	}

	function readI40(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off++] * 0x1000000
	        + (data[off] | (data[off] & 0x80) * 0x1fffffe) * 0x100000000);
	}

	function readI32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + (data[off] << 24));
	}

	function readI24(data, off) {
	  const val = (data[off++]
	             + data[off++] * 0x100
	             + data[off] * 0x10000);

	  return val | (val & 0x800000) * 0x1fe;
	}

	function readI16(data, off) {
	  const val = data[off++] + data[off] * 0x100;
	  return val | (val & 0x8000) * 0x1fffe;
	}

	function readI8(data, off) {
	  const val = data[off];
	  return val | (val & 0x80) * 0x1fffffe;
	}

	/*
	 * Read Signed BE
	 */

	function readIBE(data, off, len) {
	  switch (len) {
	    case 8:
	      return readI64BE(data, off);
	    case 7:
	      return readI56BE(data, off);
	    case 6:
	      return readI48BE(data, off);
	    case 5:
	      return readI40BE(data, off);
	    case 4:
	      return readI32BE(data, off);
	    case 3:
	      return readI24BE(data, off);
	    case 2:
	      return readI16BE(data, off);
	    case 1:
	      return readI8(data, off);
	    default:
	      throw new EncodingError(off, 'Invalid read length');
	  }
	}

	function readI64BE(data, off) {
	  const hi = readI32BE(data, off);
	  const lo = readU32BE(data, off + 4);

	  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readI56BE(data, off) {
	  const hi = readI24BE(data, off);
	  const lo = readU32BE(data, off + 3);

	  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

	  return hi * 0x100000000 + lo;
	}

	function readI48BE(data, off) {
	  const val = data[off++] * 0x100 + data[off++];

	  return ((val | (val & 0x8000) * 0x1fffe) * 0x100000000
	        + data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readI40BE(data, off) {
	  const val = data[off++];

	  return ((val | (val & 0x80) * 0x1fffffe) * 0x100000000
	        + data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readI32BE(data, off) {
	  return ((data[off++] << 24)
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function readI24BE(data, off) {
	  const val = (data[off++] * 0x10000
	             + data[off++] * 0x100
	             + data[off]);

	  return val | (val & 0x800000) * 0x1fe;
	}

	function readI16BE(data, off) {
	  const val = data[off++] * 0x100 + data[off];
	  return val | (val & 0x8000) * 0x1fffe;
	}

	/*
	 * Read Float
	 */

	function _readFloatBackwards(data, off) {
	  F328_ARRAY[3] = data[off++];
	  F328_ARRAY[2] = data[off++];
	  F328_ARRAY[1] = data[off++];
	  F328_ARRAY[0] = data[off];
	  return F32_ARRAY[0];
	}

	function _readFloatForwards(data, off) {
	  F328_ARRAY[0] = data[off++];
	  F328_ARRAY[1] = data[off++];
	  F328_ARRAY[2] = data[off++];
	  F328_ARRAY[3] = data[off];
	  return F32_ARRAY[0];
	}

	function _readDoubleBackwards(data, off) {
	  F648_ARRAY[7] = data[off++];
	  F648_ARRAY[6] = data[off++];
	  F648_ARRAY[5] = data[off++];
	  F648_ARRAY[4] = data[off++];
	  F648_ARRAY[3] = data[off++];
	  F648_ARRAY[2] = data[off++];
	  F648_ARRAY[1] = data[off++];
	  F648_ARRAY[0] = data[off];
	  return F64_ARRAY[0];
	}

	function _readDoubleForwards(data, off) {
	  F648_ARRAY[0] = data[off++];
	  F648_ARRAY[1] = data[off++];
	  F648_ARRAY[2] = data[off++];
	  F648_ARRAY[3] = data[off++];
	  F648_ARRAY[4] = data[off++];
	  F648_ARRAY[5] = data[off++];
	  F648_ARRAY[6] = data[off++];
	  F648_ARRAY[7] = data[off];
	  return F64_ARRAY[0];
	}

	const readFloat = BIG_ENDIAN ? _readFloatBackwards : _readFloatForwards;
	const readFloatBE = BIG_ENDIAN ? _readFloatForwards : _readFloatBackwards;
	const readDouble = BIG_ENDIAN ? _readDoubleBackwards : _readDoubleForwards;
	const readDoubleBE = BIG_ENDIAN ? _readDoubleForwards : _readDoubleBackwards;

	/*
	 * Write Unsigned LE
	 */

	function writeU(dst, num, off, len) {
	  switch (len) {
	    case 8:
	      return writeU64(dst, num, off);
	    case 7:
	      return writeU56(dst, num, off);
	    case 6:
	      return writeU48(dst, num, off);
	    case 5:
	      return writeU40(dst, num, off);
	    case 4:
	      return writeU32(dst, num, off);
	    case 3:
	      return writeU24(dst, num, off);
	    case 2:
	      return writeU16(dst, num, off);
	    case 1:
	      return writeU8(dst, num, off);
	    default:
	      throw new EncodingError(off, 'Invalid write length');
	  }
	}

	function writeU64(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');
	  return write64(dst, num, off, false);
	}

	function writeU56(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');
	  return write56(dst, num, off, false);
	}

	function writeU48(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  const hi = (num * HI) | 0;

	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  dst[off++] = hi;
	  dst[off++] = hi >>> 8;

	  return off;
	}

	function writeU40(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  const hi = (num * HI) | 0;

	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  dst[off++] = hi;

	  return off;
	}

	function writeU32(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;

	  return off;
	}

	function writeU24(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;

	  return off;
	}

	function writeU16(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off++] = num;
	  dst[off++] = num >>> 8;

	  return off;
	}

	function writeU8(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off] = num;

	  return off + 1;
	}

	/*
	 * Write Unsigned BE
	 */

	function writeUBE(dst, num, off, len) {
	  switch (len) {
	    case 8:
	      return writeU64BE(dst, num, off);
	    case 7:
	      return writeU56BE(dst, num, off);
	    case 6:
	      return writeU48BE(dst, num, off);
	    case 5:
	      return writeU40BE(dst, num, off);
	    case 4:
	      return writeU32BE(dst, num, off);
	    case 3:
	      return writeU24BE(dst, num, off);
	    case 2:
	      return writeU16BE(dst, num, off);
	    case 1:
	      return writeU8(dst, num, off);
	    default:
	      throw new EncodingError(off, 'Invalid write length');
	  }
	}

	function writeU64BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');
	  return write64(dst, num, off, true);
	}

	function writeU56BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');
	  return write56(dst, num, off, true);
	}

	function writeU48BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  const hi = (num * HI) | 0;

	  dst[off++] = hi >>> 8;
	  dst[off++] = hi;
	  dst[off + 3] = num;
	  num >>>= 8;
	  dst[off + 2] = num;
	  num >>>= 8;
	  dst[off + 1] = num;
	  num >>>= 8;
	  dst[off] = num;

	  return off + 4;
	}

	function writeU40BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  const hi = (num * HI) | 0;

	  dst[off++] = hi;
	  dst[off + 3] = num;
	  num >>>= 8;
	  dst[off + 2] = num;
	  num >>>= 8;
	  dst[off + 1] = num;
	  num >>>= 8;
	  dst[off] = num;

	  return off + 4;
	}

	function writeU32BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off + 3] = num;
	  num >>>= 8;
	  dst[off + 2] = num;
	  num >>>= 8;
	  dst[off + 1] = num;
	  num >>>= 8;
	  dst[off] = num;

	  return off + 4;
	}

	function writeU24BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off + 2] = num;
	  num >>>= 8;
	  dst[off + 1] = num;
	  num >>>= 8;
	  dst[off] = num;

	  return off + 3;
	}

	function writeU16BE(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  dst[off++] = num >>> 8;
	  dst[off++] = num;

	  return off;
	}

	/*
	 * Write Signed LE
	 */

	function writeI(dst, num, off, len) {
	  switch (len) {
	    case 8:
	      return writeU64(dst, num, off);
	    case 7:
	      return writeU56(dst, num, off);
	    case 6:
	      return writeU48(dst, num, off);
	    case 5:
	      return writeU40(dst, num, off);
	    case 4:
	      return writeU24(dst, num, off);
	    case 3:
	      return writeU32(dst, num, off);
	    case 2:
	      return writeU16(dst, num, off);
	    case 1:
	      return writeU8(dst, num, off);
	    default:
	      throw new EncodingError(off, 'Invalid write length');
	  }
	}

	function writeI64(dst, num, off) {
	  return writeU64(dst, num, off);
	}

	function writeI56(dst, num, off) {
	  return writeU56(dst, num, off);
	}

	function writeI48(dst, num, off) {
	  return writeU48(dst, num, off);
	}

	function writeI40(dst, num, off) {
	  return writeU40(dst, num, off);
	}

	function writeI32(dst, num, off) {
	  return writeU32(dst, num, off);
	}

	function writeI24(dst, num, off) {
	  return writeU24(dst, num, off);
	}

	function writeI16(dst, num, off) {
	  return writeU16(dst, num, off);
	}

	function writeI8(dst, num, off) {
	  return writeU8(dst, num, off);
	}

	/*
	 * Write Signed BE
	 */

	function writeIBE(dst, num, off, len) {
	  switch (len) {
	    case 8:
	      return writeU64BE(dst, num, off);
	    case 7:
	      return writeU56BE(dst, num, off);
	    case 6:
	      return writeU48BE(dst, num, off);
	    case 5:
	      return writeU40BE(dst, num, off);
	    case 4:
	      return writeU32BE(dst, num, off);
	    case 3:
	      return writeU24BE(dst, num, off);
	    case 2:
	      return writeU16BE(dst, num, off);
	    case 1:
	      return writeU8(dst, num, off);
	    default:
	      throw new EncodingError(off, 'Invalid write length');
	  }
	}

	function writeI64BE(dst, num, off) {
	  return writeU64BE(dst, num, off);
	}

	function writeI56BE(dst, num, off) {
	  return writeU56BE(dst, num, off);
	}

	function writeI48BE(dst, num, off) {
	  return writeU48BE(dst, num, off);
	}

	function writeI40BE(dst, num, off) {
	  return writeU40BE(dst, num, off);
	}

	function writeI32BE(dst, num, off) {
	  return writeU32BE(dst, num, off);
	}

	function writeI24BE(dst, num, off) {
	  return writeU24BE(dst, num, off);
	}

	function writeI16BE(dst, num, off) {
	  return writeU16BE(dst, num, off);
	}

	function _writeDoubleForwards(dst, num, off) {
	  enforce(isNumber(num), 'num', 'number');

	  F64_ARRAY[0] = num;

	  dst[off++] = F648_ARRAY[0];
	  dst[off++] = F648_ARRAY[1];
	  dst[off++] = F648_ARRAY[2];
	  dst[off++] = F648_ARRAY[3];
	  dst[off++] = F648_ARRAY[4];
	  dst[off++] = F648_ARRAY[5];
	  dst[off++] = F648_ARRAY[6];
	  dst[off++] = F648_ARRAY[7];

	  return off;
	}

	function _writeDoubleBackwards(dst, num, off) {
	  enforce(isNumber(num), 'num', 'number');

	  F64_ARRAY[0] = num;

	  dst[off++] = F648_ARRAY[7];
	  dst[off++] = F648_ARRAY[6];
	  dst[off++] = F648_ARRAY[5];
	  dst[off++] = F648_ARRAY[4];
	  dst[off++] = F648_ARRAY[3];
	  dst[off++] = F648_ARRAY[2];
	  dst[off++] = F648_ARRAY[1];
	  dst[off++] = F648_ARRAY[0];

	  return off;
	}

	function _writeFloatForwards(dst, num, off) {
	  enforce(isNumber(num), 'num', 'number');

	  F32_ARRAY[0] = num;

	  dst[off++] = F328_ARRAY[0];
	  dst[off++] = F328_ARRAY[1];
	  dst[off++] = F328_ARRAY[2];
	  dst[off++] = F328_ARRAY[3];

	  return off;
	}

	function _writeFloatBackwards(dst, num, off) {
	  enforce(isNumber(num), 'num', 'number');

	  F32_ARRAY[0] = num;

	  dst[off++] = F328_ARRAY[3];
	  dst[off++] = F328_ARRAY[2];
	  dst[off++] = F328_ARRAY[1];
	  dst[off++] = F328_ARRAY[0];

	  return off;
	}

	const writeFloat = BIG_ENDIAN ? _writeFloatBackwards : _writeFloatForwards;
	const writeFloatBE = BIG_ENDIAN ? _writeFloatForwards : _writeFloatBackwards;
	const writeDouble = BIG_ENDIAN ? _writeDoubleBackwards : _writeDoubleForwards;
	const writeDoubleBE = BIG_ENDIAN ? _writeDoubleForwards : _writeDoubleBackwards;

	/*
	 * Varints
	 */

	function readVarint(data, off) {
	  let value, size;

	  checkRead(off < data.length, off);

	  switch (data[off]) {
	    case 0xff:
	      size = 9;
	      checkRead(off + size <= data.length, off);
	      value = readU64(data, off + 1);
	      check(value > 0xffffffff, off, 'Non-canonical varint');
	      break;
	    case 0xfe:
	      size = 5;
	      checkRead(off + size <= data.length, off);
	      value = readU32(data, off + 1);
	      check(value > 0xffff, off, 'Non-canonical varint');
	      break;
	    case 0xfd:
	      size = 3;
	      checkRead(off + size <= data.length, off);
	      value = readU16(data, off + 1);
	      check(value >= 0xfd, off, 'Non-canonical varint');
	      break;
	    default:
	      size = 1;
	      value = data[off];
	      break;
	  }

	  return new Varint(size, value);
	}

	function writeVarint(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  if (num < 0xfd) {
	    dst[off++] = num;
	    return off;
	  }

	  if (num <= 0xffff) {
	    dst[off++] = 0xfd;
	    return writeU16(dst, num, off);
	  }

	  if (num <= 0xffffffff) {
	    dst[off++] = 0xfe;
	    return writeU32(dst, num, off);
	  }

	  dst[off++] = 0xff;

	  return writeU64(dst, num, off);
	}

	function sizeVarint(num) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  if (num < 0xfd)
	    return 1;

	  if (num <= 0xffff)
	    return 3;

	  if (num <= 0xffffffff)
	    return 5;

	  return 9;
	}

	function readVarint2(data, off) {
	  let num = 0;
	  let size = 0;

	  for (;;) {
	    checkRead(off < data.length, off);

	    const ch = data[off++];

	    size += 1;

	    // Number.MAX_SAFE_INTEGER >>> 7
	    check(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1');

	    // num = (num << 7) | (ch & 0x7f);
	    num = (num * 0x80) + (ch & 0x7f);

	    if ((ch & 0x80) === 0)
	      break;

	    check(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');
	    num += 1;
	  }

	  return new Varint(size, num);
	}

	function writeVarint2(dst, num, off) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  const tmp = [];

	  let len = 0;

	  for (;;) {
	    tmp[len] = (num & 0x7f) | (len ? 0x80 : 0x00);

	    if (num <= 0x7f)
	      break;

	    // num = (num >>> 7) - 1;
	    num = ((num - (num % 0x80)) / 0x80) - 1;
	    len += 1;
	  }

	  checkRead(off + len + 1 <= dst.length, off);

	  do {
	    dst[off++] = tmp[len];
	  } while (len--);

	  return off;
	}

	function sizeVarint2(num) {
	  enforce(Number.isSafeInteger(num), 'num', 'integer');

	  let size = 0;

	  for (;;) {
	    size += 1;

	    if (num <= 0x7f)
	      break;

	    // num = (num >>> 7) - 1;
	    num = ((num - (num % 0x80)) / 0x80) - 1;
	  }

	  return size;
	}

	/*
	 * Bytes
	 */

	function sliceBytes(data, off, size) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  enforce((off >>> 0) === off, 'off', 'integer');
	  enforce((size >>> 0) === size, 'size', 'integer');

	  if (off + size > data.length)
	    throw new EncodingError(off, 'Out of bounds read');

	  return data.slice(off, off + size);
	}

	function readBytes(data, off, size) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  enforce((off >>> 0) === off, 'off', 'integer');
	  enforce((size >>> 0) === size, 'size', 'integer');

	  if (off + size > data.length)
	    throw new EncodingError(off, 'Out of bounds read');

	  const buf = Buffer$1.allocUnsafeSlow(size);

	  data.copy(buf, 0, off, off + size);

	  return buf;
	}

	function writeBytes(data, value, off) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  enforce(Buffer$1.isBuffer(value), 'value', 'buffer');
	  enforce((off >>> 0) === off, 'off', 'integer');

	  if (off + value.length > data.length)
	    throw new EncodingError(off, 'Out of bounds write');

	  return value.copy(data, off, 0, value.length);
	}

	function readString(data, off, size, enc) {
	  if (enc == null)
	    enc = 'binary';

	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  enforce((off >>> 0) === off, 'off', 'integer');
	  enforce((size >>> 0) === size, 'size', 'integer');
	  enforce(typeof enc === 'string', 'enc', 'string');

	  if (off + size > data.length)
	    throw new EncodingError(off, 'Out of bounds read');

	  return data.toString(enc, off, off + size);
	}

	function writeString(data, str, off, enc) {
	  if (enc == null)
	    enc = 'binary';

	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  enforce(typeof str === 'string', 'str', 'string');
	  enforce((off >>> 0) === off, 'off', 'integer');
	  enforce(typeof enc === 'string', 'enc', 'string');

	  if (str.length === 0)
	    return 0;

	  const size = Buffer$1.byteLength(str, enc);

	  if (off + size > data.length)
	    throw new EncodingError(off, 'Out of bounds write');

	  return data.write(str, off, enc);
	}

	function realloc(data, size) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');

	  const buf = Buffer$1.allocUnsafeSlow(size);

	  data.copy(buf, 0);

	  return buf;
	}

	function copy(data) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  return realloc(data, data.length);
	}

	function concat(a, b) {
	  enforce(Buffer$1.isBuffer(a), 'a', 'buffer');
	  enforce(Buffer$1.isBuffer(b), 'b', 'buffer');

	  const size = a.length + b.length;
	  const buf = Buffer$1.allocUnsafeSlow(size);

	  a.copy(buf, 0);
	  b.copy(buf, a.length);

	  return buf;
	}

	/*
	 * Size Helpers
	 */

	function sizeVarBytes(data) {
	  enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	  return sizeVarint(data.length) + data.length;
	}

	function sizeVarlen(len) {
	  return sizeVarint(len) + len;
	}

	function sizeVarString(str, enc) {
	  if (enc == null)
	    enc = 'binary';

	  enforce(typeof str === 'string', 'str', 'string');
	  enforce(typeof enc === 'string', 'enc', 'string');

	  if (str.length === 0)
	    return 1;

	  const len = Buffer$1.byteLength(str, enc);

	  return sizeVarint(len) + len;
	}

	/*
	 * Helpers
	 */

	function isSafe(hi, lo) {
	  if (hi < 0) {
	    hi = ~hi;
	    if (lo === 0)
	      hi += 1;
	  }

	  return (hi & 0xffe00000) === 0;
	}

	function write64(dst, num, off, be) {
	  let neg = false;

	  if (num < 0) {
	    num = -num;
	    neg = true;
	  }

	  let hi = (num * HI) | 0;
	  let lo = num | 0;

	  if (neg) {
	    if (lo === 0) {
	      hi = (~hi + 1) | 0;
	    } else {
	      hi = ~hi;
	      lo = ~lo + 1;
	    }
	  }

	  if (be) {
	    off = writeI32BE(dst, hi, off);
	    off = writeI32BE(dst, lo, off);
	  } else {
	    off = writeI32(dst, lo, off);
	    off = writeI32(dst, hi, off);
	  }

	  return off;
	}

	function write56(dst, num, off, be) {
	  let neg = false;

	  if (num < 0) {
	    num = -num;
	    neg = true;
	  }

	  let hi = (num * HI) | 0;
	  let lo = num | 0;

	  if (neg) {
	    if (lo === 0) {
	      hi = (~hi + 1) | 0;
	    } else {
	      hi = ~hi;
	      lo = ~lo + 1;
	    }
	  }

	  if (be) {
	    off = writeI24BE(dst, hi, off);
	    off = writeI32BE(dst, lo, off);
	  } else {
	    off = writeI32(dst, lo, off);
	    off = writeI24(dst, hi, off);
	  }

	  return off;
	}

	class Varint {
	  constructor(size, value) {
	    this.size = size;
	    this.value = value;
	  }
	}

	function isNumber(num) {
	  return typeof num === 'number' && isFinite(num);
	}

	function checkRead(value, offset) {
	  if (!value)
	    throw new EncodingError(offset, 'Out of bounds read', checkRead);
	}

	function check(value, offset, reason) {
	  if (!value)
	    throw new EncodingError(offset, reason, check);
	}

	/*
	 * Expose
	 */

	encoding.readU = readU;
	encoding.readU64 = readU64;
	encoding.readU56 = readU56;
	encoding.readU48 = readU48;
	encoding.readU40 = readU40;
	encoding.readU32 = readU32;
	encoding.readU24 = readU24;
	encoding.readU16 = readU16;
	encoding.readU8 = readU8;

	encoding.readUBE = readUBE;
	encoding.readU64BE = readU64BE;
	encoding.readU56BE = readU56BE;
	encoding.readU48BE = readU48BE;
	encoding.readU40BE = readU40BE;
	encoding.readU32BE = readU32BE;
	encoding.readU24BE = readU24BE;
	encoding.readU16BE = readU16BE;

	encoding.readI = readI;
	encoding.readI64 = readI64;
	encoding.readI56 = readI56;
	encoding.readI48 = readI48;
	encoding.readI40 = readI40;
	encoding.readI32 = readI32;
	encoding.readI24 = readI24;
	encoding.readI16 = readI16;
	encoding.readI8 = readI8;

	encoding.readIBE = readIBE;
	encoding.readI64BE = readI64BE;
	encoding.readI56BE = readI56BE;
	encoding.readI48BE = readI48BE;
	encoding.readI40BE = readI40BE;
	encoding.readI32BE = readI32BE;
	encoding.readI24BE = readI24BE;
	encoding.readI16BE = readI16BE;

	encoding.readFloat = readFloat;
	encoding.readFloatBE = readFloatBE;
	encoding.readDouble = readDouble;
	encoding.readDoubleBE = readDoubleBE;

	encoding.writeU = writeU;
	encoding.writeU64 = writeU64;
	encoding.writeU56 = writeU56;
	encoding.writeU48 = writeU48;
	encoding.writeU40 = writeU40;
	encoding.writeU32 = writeU32;
	encoding.writeU24 = writeU24;
	encoding.writeU16 = writeU16;
	encoding.writeU8 = writeU8;

	encoding.writeUBE = writeUBE;
	encoding.writeU64BE = writeU64BE;
	encoding.writeU56BE = writeU56BE;
	encoding.writeU48BE = writeU48BE;
	encoding.writeU40BE = writeU40BE;
	encoding.writeU32BE = writeU32BE;
	encoding.writeU24BE = writeU24BE;
	encoding.writeU16BE = writeU16BE;

	encoding.writeI = writeI;
	encoding.writeI64 = writeI64;
	encoding.writeI56 = writeI56;
	encoding.writeI48 = writeI48;
	encoding.writeI40 = writeI40;
	encoding.writeI32 = writeI32;
	encoding.writeI24 = writeI24;
	encoding.writeI16 = writeI16;
	encoding.writeI8 = writeI8;

	encoding.writeIBE = writeIBE;
	encoding.writeI64BE = writeI64BE;
	encoding.writeI56BE = writeI56BE;
	encoding.writeI48BE = writeI48BE;
	encoding.writeI40BE = writeI40BE;
	encoding.writeI32BE = writeI32BE;
	encoding.writeI24BE = writeI24BE;
	encoding.writeI16BE = writeI16BE;

	encoding.writeFloat = writeFloat;
	encoding.writeFloatBE = writeFloatBE;
	encoding.writeDouble = writeDouble;
	encoding.writeDoubleBE = writeDoubleBE;

	encoding.readVarint = readVarint;
	encoding.writeVarint = writeVarint;
	encoding.sizeVarint = sizeVarint;
	encoding.readVarint2 = readVarint2;
	encoding.writeVarint2 = writeVarint2;
	encoding.sizeVarint2 = sizeVarint2;

	encoding.sliceBytes = sliceBytes;
	encoding.readBytes = readBytes;
	encoding.writeBytes = writeBytes;
	encoding.readString = readString;
	encoding.writeString = writeString;

	encoding.realloc = realloc;
	encoding.copy = copy;
	encoding.concat = concat;

	encoding.sizeVarBytes = sizeVarBytes;
	encoding.sizeVarlen = sizeVarlen;
	encoding.sizeVarString = sizeVarString;
	return encoding;
}

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;

	const enforce = requireEnforce();
	const encoding = requireEncoding();
	const EncodingError = requireError();

	/*
	 * Constants
	 */

	const EMPTY = Buffer$1.alloc(0);

	/**
	 * Buffer Reader
	 */

	class BufferReader {
	  /**
	   * Create a buffer reader.
	   * @constructor
	   * @param {Buffer} data
	   * @param {Boolean?} zeroCopy - Do not reallocate buffers when
	   * slicing. Note that this can lead to memory leaks if not used
	   * carefully.
	   */

	  constructor(data, zeroCopy = false) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

	    this.data = data;
	    this.offset = 0;
	    this.zeroCopy = zeroCopy;
	    this.stack = [];
	  }

	  /**
	   * Assertion.
	   * @param {Number} size
	   */

	  check(size) {
	    if (this.offset + size > this.data.length)
	      throw new EncodingError(this.offset, 'Out of bounds read', this.check);
	  }

	  /**
	   * Get total size of passed-in Buffer.
	   * @returns {Buffer}
	   */

	  getSize() {
	    return this.data.length;
	  }

	  /**
	   * Calculate number of bytes left to read.
	   * @returns {Number}
	   */

	  left() {
	    this.check(0);
	    return this.data.length - this.offset;
	  }

	  /**
	   * Seek to a position to read from by offset.
	   * @param {Number} off - Offset (positive or negative).
	   */

	  seek(off) {
	    enforce(Number.isSafeInteger(off), 'off', 'integer');

	    if (this.offset + off < 0)
	      throw new EncodingError(this.offset, 'Out of bounds read');

	    this.check(off);
	    this.offset += off;

	    return this;
	  }

	  /**
	   * Mark the current starting position.
	   */

	  start() {
	    this.stack.push(this.offset);
	    return this.offset;
	  }

	  /**
	   * Stop reading. Pop the start position off the stack
	   * and calculate the size of the data read.
	   * @returns {Number} Size.
	   * @throws on empty stack.
	   */

	  end() {
	    if (this.stack.length === 0)
	      throw new Error('Cannot end without a stack item.');

	    const start = this.stack.pop();

	    return this.offset - start;
	  }

	  /**
	   * Stop reading. Pop the start position off the stack
	   * and return the data read.
	   * @param {Bolean?} zeroCopy - Do a fast buffer
	   * slice instead of allocating a new buffer (warning:
	   * may cause memory leaks if not used with care).
	   * @returns {Buffer} Data read.
	   * @throws on empty stack.
	   */

	  endData(zeroCopy = false) {
	    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

	    if (this.stack.length === 0)
	      throw new Error('Cannot end without a stack item.');

	    const start = this.stack.pop();
	    const end = this.offset;
	    const size = end - start;
	    const data = this.data;

	    if (size === data.length)
	      return data;

	    if (this.zeroCopy || zeroCopy)
	      return data.slice(start, end);

	    const ret = Buffer$1.allocUnsafeSlow(size);

	    data.copy(ret, 0, start, end);

	    return ret;
	  }

	  /**
	   * Destroy the reader. Remove references to the data.
	   */

	  destroy() {
	    this.data = EMPTY;
	    this.offset = 0;
	    this.stack.length = 0;
	    return this;
	  }

	  /**
	   * Read uint8.
	   * @returns {Number}
	   */

	  readU8() {
	    this.check(1);

	    const ret = this.data[this.offset];

	    this.offset += 1;

	    return ret;
	  }

	  /**
	   * Read uint16le.
	   * @returns {Number}
	   */

	  readU16() {
	    this.check(2);

	    const ret = encoding.readU16(this.data, this.offset);

	    this.offset += 2;

	    return ret;
	  }

	  /**
	   * Read uint16be.
	   * @returns {Number}
	   */

	  readU16BE() {
	    this.check(2);

	    const ret = encoding.readU16BE(this.data, this.offset);

	    this.offset += 2;

	    return ret;
	  }

	  /**
	   * Read uint24le.
	   * @returns {Number}
	   */

	  readU24() {
	    this.check(3);

	    const ret = encoding.readU24(this.data, this.offset);

	    this.offset += 3;

	    return ret;
	  }

	  /**
	   * Read uint24be.
	   * @returns {Number}
	   */

	  readU24BE() {
	    this.check(3);

	    const ret = encoding.readU24BE(this.data, this.offset);

	    this.offset += 3;

	    return ret;
	  }

	  /**
	   * Read uint32le.
	   * @returns {Number}
	   */

	  readU32() {
	    this.check(4);

	    const ret = encoding.readU32(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read uint32be.
	   * @returns {Number}
	   */

	  readU32BE() {
	    this.check(4);

	    const ret = encoding.readU32BE(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read uint40le.
	   * @returns {Number}
	   */

	  readU40() {
	    this.check(5);

	    const ret = encoding.readU40(this.data, this.offset);

	    this.offset += 5;

	    return ret;
	  }

	  /**
	   * Read uint40be.
	   * @returns {Number}
	   */

	  readU40BE() {
	    this.check(5);

	    const ret = encoding.readU40BE(this.data, this.offset);

	    this.offset += 5;

	    return ret;
	  }

	  /**
	   * Read uint48le.
	   * @returns {Number}
	   */

	  readU48() {
	    this.check(6);

	    const ret = encoding.readU48(this.data, this.offset);

	    this.offset += 6;

	    return ret;
	  }

	  /**
	   * Read uint48be.
	   * @returns {Number}
	   */

	  readU48BE() {
	    this.check(6);

	    const ret = encoding.readU48BE(this.data, this.offset);

	    this.offset += 6;

	    return ret;
	  }

	  /**
	   * Read uint56le.
	   * @returns {Number}
	   */

	  readU56() {
	    this.check(7);

	    const ret = encoding.readU56(this.data, this.offset);

	    this.offset += 7;

	    return ret;
	  }

	  /**
	   * Read uint56be.
	   * @returns {Number}
	   */

	  readU56BE() {
	    this.check(7);

	    const ret = encoding.readU56BE(this.data, this.offset);

	    this.offset += 7;

	    return ret;
	  }

	  /**
	   * Read uint64le as a js number.
	   * @returns {Number}
	   * @throws on num > MAX_SAFE_INTEGER
	   */

	  readU64() {
	    this.check(8);

	    const ret = encoding.readU64(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read uint64be as a js number.
	   * @returns {Number}
	   * @throws on num > MAX_SAFE_INTEGER
	   */

	  readU64BE() {
	    this.check(8);

	    const ret = encoding.readU64BE(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read int8.
	   * @returns {Number}
	   */

	  readI8() {
	    this.check(1);

	    const ret = encoding.readI8(this.data, this.offset);

	    this.offset += 1;

	    return ret;
	  }

	  /**
	   * Read int16le.
	   * @returns {Number}
	   */

	  readI16() {
	    this.check(2);

	    const ret = encoding.readI16(this.data, this.offset);

	    this.offset += 2;

	    return ret;
	  }

	  /**
	   * Read int16be.
	   * @returns {Number}
	   */

	  readI16BE() {
	    this.check(2);

	    const ret = encoding.readI16BE(this.data, this.offset);

	    this.offset += 2;

	    return ret;
	  }

	  /**
	   * Read int24le.
	   * @returns {Number}
	   */

	  readI24() {
	    this.check(3);

	    const ret = encoding.readI24(this.data, this.offset);

	    this.offset += 3;

	    return ret;
	  }

	  /**
	   * Read int24be.
	   * @returns {Number}
	   */

	  readI24BE() {
	    this.check(3);

	    const ret = encoding.readI24BE(this.data, this.offset);

	    this.offset += 3;

	    return ret;
	  }

	  /**
	   * Read int32le.
	   * @returns {Number}
	   */

	  readI32() {
	    this.check(4);

	    const ret = encoding.readI32(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read int32be.
	   * @returns {Number}
	   */

	  readI32BE() {
	    this.check(4);

	    const ret = encoding.readI32BE(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read int40le.
	   * @returns {Number}
	   */

	  readI40() {
	    this.check(5);

	    const ret = encoding.readI40(this.data, this.offset);

	    this.offset += 5;

	    return ret;
	  }

	  /**
	   * Read int40be.
	   * @returns {Number}
	   */

	  readI40BE() {
	    this.check(5);

	    const ret = encoding.readI40BE(this.data, this.offset);

	    this.offset += 5;

	    return ret;
	  }

	  /**
	   * Read int48le.
	   * @returns {Number}
	   */

	  readI48() {
	    this.check(6);

	    const ret = encoding.readI48(this.data, this.offset);

	    this.offset += 6;

	    return ret;
	  }

	  /**
	   * Read int48be.
	   * @returns {Number}
	   */

	  readI48BE() {
	    this.check(6);

	    const ret = encoding.readI48BE(this.data, this.offset);

	    this.offset += 6;

	    return ret;
	  }

	  /**
	   * Read int56le.
	   * @returns {Number}
	   */

	  readI56() {
	    this.check(7);

	    const ret = encoding.readI56(this.data, this.offset);

	    this.offset += 7;

	    return ret;
	  }

	  /**
	   * Read int56be.
	   * @returns {Number}
	   */

	  readI56BE() {
	    this.check(7);

	    const ret = encoding.readI56BE(this.data, this.offset);

	    this.offset += 7;

	    return ret;
	  }

	  /**
	   * Read int64le as a js number.
	   * @returns {Number}
	   * @throws on num > MAX_SAFE_INTEGER
	   */

	  readI64() {
	    this.check(8);

	    const ret = encoding.readI64(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read int64be as a js number.
	   * @returns {Number}
	   * @throws on num > MAX_SAFE_INTEGER
	   */

	  readI64BE() {
	    this.check(8);

	    const ret = encoding.readI64BE(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read float le.
	   * @returns {Number}
	   */

	  readFloat() {
	    this.check(4);

	    const ret = encoding.readFloat(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read float be.
	   * @returns {Number}
	   */

	  readFloatBE() {
	    this.check(4);

	    const ret = encoding.readFloatBE(this.data, this.offset);

	    this.offset += 4;

	    return ret;
	  }

	  /**
	   * Read double float le.
	   * @returns {Number}
	   */

	  readDouble() {
	    this.check(8);

	    const ret = encoding.readDouble(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read double float be.
	   * @returns {Number}
	   */

	  readDoubleBE() {
	    this.check(8);

	    const ret = encoding.readDoubleBE(this.data, this.offset);

	    this.offset += 8;

	    return ret;
	  }

	  /**
	   * Read a varint.
	   * @returns {Number}
	   */

	  readVarint() {
	    const {size, value} = encoding.readVarint(this.data, this.offset);

	    this.offset += size;

	    return value;
	  }

	  /**
	   * Read a varint (type 2).
	   * @returns {Number}
	   */

	  readVarint2() {
	    const {size, value} = encoding.readVarint2(this.data, this.offset);

	    this.offset += size;

	    return value;
	  }

	  /**
	   * Read N bytes (will do a fast slice if zero copy).
	   * @param {Number} size
	   * @param {Bolean?} zeroCopy - Do a fast buffer
	   * slice instead of allocating a new buffer (warning:
	   * may cause memory leaks if not used with care).
	   * @returns {Buffer}
	   */

	  readBytes(size, zeroCopy = false) {
	    enforce((size >>> 0) === size, 'size', 'integer');
	    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

	    this.check(size);

	    let ret;

	    if (this.zeroCopy || zeroCopy) {
	      ret = this.data.slice(this.offset, this.offset + size);
	    } else {
	      ret = Buffer$1.allocUnsafeSlow(size);
	      this.data.copy(ret, 0, this.offset, this.offset + size);
	    }

	    this.offset += size;

	    return ret;
	  }

	  /**
	   * Read a varint number of bytes (will do a fast slice if zero copy).
	   * @param {Bolean?} zeroCopy - Do a fast buffer
	   * slice instead of allocating a new buffer (warning:
	   * may cause memory leaks if not used with care).
	   * @returns {Buffer}
	   */

	  readVarBytes(zeroCopy = false) {
	    return this.readBytes(this.readVarint(), zeroCopy);
	  }

	  /**
	   * Slice N bytes and create a child reader.
	   * @param {Number} size
	   * @returns {BufferReader}
	   */

	  readChild(size) {
	    enforce((size >>> 0) === size, 'size', 'integer');

	    this.check(size);

	    const data = this.data.slice(0, this.offset + size);
	    const br = new this.constructor(data);

	    br.offset = this.offset;

	    this.offset += size;

	    return br;
	  }

	  /**
	   * Read a string.
	   * @param {Number} size
	   * @param {String} enc - Any buffer-supported encoding.
	   * @returns {String}
	   */

	  readString(size, enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce((size >>> 0) === size, 'size', 'integer');
	    enforce(typeof enc === 'string', 'enc', 'string');

	    this.check(size);

	    const ret = this.data.toString(enc, this.offset, this.offset + size);

	    this.offset += size;

	    return ret;
	  }

	  /**
	   * Read a 32-byte hash.
	   * @param {String} enc - `"hex"` or `null`.
	   * @returns {Hash|Buffer}
	   */

	  readHash(enc) {
	    if (enc)
	      return this.readString(32, enc);
	    return this.readBytes(32);
	  }

	  /**
	   * Read string of a varint length.
	   * @param {String} enc - Any buffer-supported encoding.
	   * @param {Number?} limit - Size limit.
	   * @returns {String}
	   */

	  readVarString(enc, limit = 0) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof enc === 'string', 'enc', 'string');
	    enforce((limit >>> 0) === limit, 'limit', 'integer');

	    const size = this.readVarint();

	    if (limit !== 0 && size > limit)
	      throw new EncodingError(this.offset, 'String exceeds limit');

	    return this.readString(size, enc);
	  }

	  /**
	   * Read a null-terminated string.
	   * @param {String} enc - Any buffer-supported encoding.
	   * @returns {String}
	   */

	  readNullString(enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof enc === 'string', 'enc', 'string');

	    let i = this.offset;

	    for (; i < this.data.length; i++) {
	      if (this.data[i] === 0)
	        break;
	    }

	    if (i === this.data.length)
	      throw new EncodingError(this.offset, 'No NUL terminator');

	    const ret = this.readString(i - this.offset, enc);

	    this.offset = i + 1;

	    return ret;
	  }

	  /**
	   * Create a checksum from the last start position.
	   * @param {Function} hash
	   * @returns {Number} Checksum.
	   */

	  createChecksum(hash) {
	    if (!hash || typeof hash.digest !== 'function')
	      enforce(typeof hash === 'function', 'hash', 'function');

	    let start = 0;

	    if (this.stack.length > 0)
	      start = this.stack[this.stack.length - 1];

	    const data = this.data.slice(start, this.offset);
	    const raw = hash.digest ? hash.digest(data) : hash(data);

	    return encoding.readU32(raw, 0);
	  }

	  /**
	   * Verify a 4-byte checksum against a calculated checksum.
	   * @param {Function} hash
	   * @returns {Number} checksum
	   * @throws on bad checksum
	   */

	  verifyChecksum(hash) {
	    const checksum = this.createChecksum(hash);
	    const expect = this.readU32();

	    if (checksum !== expect)
	      throw new EncodingError(this.offset, 'Checksum mismatch');

	    return checksum;
	  }
	}

	/*
	 * Expose
	 */

	reader = BufferReader;
	return reader;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;

	const enforce = requireEnforce();
	const encoding = requireEncoding();
	const EncodingError = requireError();

	/*
	 * Constants
	 */

	const SEEK = 0;
	const U8 = 1;
	const U16 = 2;
	const U16BE = 3;
	const U24 = 4;
	const U24BE = 5;
	const U32 = 6;
	const U32BE = 7;
	const U40 = 8;
	const U40BE = 9;
	const U48 = 10;
	const U48BE = 11;
	const U56 = 12;
	const U56BE = 13;
	const U64 = 14;
	const U64BE = 15;
	const I8 = 16;
	const I16 = 17;
	const I16BE = 18;
	const I24 = 19;
	const I24BE = 20;
	const I32 = 21;
	const I32BE = 22;
	const I40 = 23;
	const I40BE = 24;
	const I48 = 25;
	const I48BE = 26;
	const I56 = 27;
	const I56BE = 28;
	const I64 = 29;
	const I64BE = 30;
	const FL = 31;
	const FLBE = 32;
	const DBL = 33;
	const DBLBE = 34;
	const VARINT = 35;
	const VARINT2 = 36;
	const BYTES = 37;
	const STR = 38;
	const CHECKSUM = 39;
	const FILL = 40;

	/**
	 * Buffer Writer
	 */

	class BufferWriter {
	  /**
	   * Create a buffer writer.
	   * @constructor
	   */

	  constructor() {
	    this.ops = [];
	    this.offset = 0;
	  }

	  /**
	   * Allocate and render the final buffer.
	   * @returns {Buffer} Rendered buffer.
	   */

	  render() {
	    const data = Buffer$1.allocUnsafeSlow(this.offset);

	    let off = 0;

	    for (const op of this.ops) {
	      switch (op.type) {
	        case SEEK:
	          off += op.value;
	          break;
	        case U8:
	          off = encoding.writeU8(data, op.value, off);
	          break;
	        case U16:
	          off = encoding.writeU16(data, op.value, off);
	          break;
	        case U16BE:
	          off = encoding.writeU16BE(data, op.value, off);
	          break;
	        case U24:
	          off = encoding.writeU24(data, op.value, off);
	          break;
	        case U24BE:
	          off = encoding.writeU24BE(data, op.value, off);
	          break;
	        case U32:
	          off = encoding.writeU32(data, op.value, off);
	          break;
	        case U32BE:
	          off = encoding.writeU32BE(data, op.value, off);
	          break;
	        case U40:
	          off = encoding.writeU40(data, op.value, off);
	          break;
	        case U40BE:
	          off = encoding.writeU40BE(data, op.value, off);
	          break;
	        case U48:
	          off = encoding.writeU48(data, op.value, off);
	          break;
	        case U48BE:
	          off = encoding.writeU48BE(data, op.value, off);
	          break;
	        case U56:
	          off = encoding.writeU56(data, op.value, off);
	          break;
	        case U56BE:
	          off = encoding.writeU56BE(data, op.value, off);
	          break;
	        case U64:
	          off = encoding.writeU64(data, op.value, off);
	          break;
	        case U64BE:
	          off = encoding.writeU64BE(data, op.value, off);
	          break;
	        case I8:
	          off = encoding.writeI8(data, op.value, off);
	          break;
	        case I16:
	          off = encoding.writeI16(data, op.value, off);
	          break;
	        case I16BE:
	          off = encoding.writeI16BE(data, op.value, off);
	          break;
	        case I24:
	          off = encoding.writeI24(data, op.value, off);
	          break;
	        case I24BE:
	          off = encoding.writeI24BE(data, op.value, off);
	          break;
	        case I32:
	          off = encoding.writeI32(data, op.value, off);
	          break;
	        case I32BE:
	          off = encoding.writeI32BE(data, op.value, off);
	          break;
	        case I40:
	          off = encoding.writeI40(data, op.value, off);
	          break;
	        case I40BE:
	          off = encoding.writeI40BE(data, op.value, off);
	          break;
	        case I48:
	          off = encoding.writeI48(data, op.value, off);
	          break;
	        case I48BE:
	          off = encoding.writeI48BE(data, op.value, off);
	          break;
	        case I56:
	          off = encoding.writeI56(data, op.value, off);
	          break;
	        case I56BE:
	          off = encoding.writeI56BE(data, op.value, off);
	          break;
	        case I64:
	          off = encoding.writeI64(data, op.value, off);
	          break;
	        case I64BE:
	          off = encoding.writeI64BE(data, op.value, off);
	          break;
	        case FL:
	          off = encoding.writeFloat(data, op.value, off);
	          break;
	        case FLBE:
	          off = encoding.writeFloatBE(data, op.value, off);
	          break;
	        case DBL:
	          off = encoding.writeDouble(data, op.value, off);
	          break;
	        case DBLBE:
	          off = encoding.writeDoubleBE(data, op.value, off);
	          break;
	        case VARINT:
	          off = encoding.writeVarint(data, op.value, off);
	          break;
	        case VARINT2:
	          off = encoding.writeVarint2(data, op.value, off);
	          break;
	        case BYTES:
	          off += op.data.copy(data, off);
	          break;
	        case STR:
	          off += data.write(op.value, off, op.enc);
	          break;
	        case CHECKSUM:
	          off += op.func(data.slice(0, off)).copy(data, off, 0, 4);
	          break;
	        case FILL:
	          data.fill(op.value, off, off + op.size);
	          off += op.size;
	          break;
	        default:
	          throw new Error('Invalid type.');
	      }
	    }

	    if (off !== data.length)
	      throw new EncodingError(off, 'Out of bounds write');

	    this.destroy();

	    return data;
	  }

	  /**
	   * Get size of data written so far.
	   * @returns {Number}
	   */

	  getSize() {
	    return this.offset;
	  }

	  /**
	   * Seek to relative offset.
	   * @param {Number} offset
	   */

	  seek(off) {
	    enforce(Number.isSafeInteger(off), 'off', 'integer');

	    if (this.offset + off < 0)
	      throw new EncodingError(this.offset, 'Out of bounds write');

	    this.offset += off;
	    this.ops.push(new NumberOp(SEEK, off));

	    return this;
	  }

	  /**
	   * Destroy the buffer writer. Remove references to `ops`.
	   */

	  destroy() {
	    this.ops.length = 0;
	    this.offset = 0;
	    return this;
	  }

	  /**
	   * Write uint8.
	   * @param {Number} value
	   */

	  writeU8(value) {
	    this.offset += 1;
	    this.ops.push(new NumberOp(U8, value));
	    return this;
	  }

	  /**
	   * Write uint16le.
	   * @param {Number} value
	   */

	  writeU16(value) {
	    this.offset += 2;
	    this.ops.push(new NumberOp(U16, value));
	    return this;
	  }

	  /**
	   * Write uint16be.
	   * @param {Number} value
	   */

	  writeU16BE(value) {
	    this.offset += 2;
	    this.ops.push(new NumberOp(U16BE, value));
	    return this;
	  }

	  /**
	   * Write uint24le.
	   * @param {Number} value
	   */

	  writeU24(value) {
	    this.offset += 3;
	    this.ops.push(new NumberOp(U24, value));
	    return this;
	  }

	  /**
	   * Write uint24be.
	   * @param {Number} value
	   */

	  writeU24BE(value) {
	    this.offset += 3;
	    this.ops.push(new NumberOp(U24BE, value));
	    return this;
	  }

	  /**
	   * Write uint32le.
	   * @param {Number} value
	   */

	  writeU32(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(U32, value));
	    return this;
	  }

	  /**
	   * Write uint32be.
	   * @param {Number} value
	   */

	  writeU32BE(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(U32BE, value));
	    return this;
	  }

	  /**
	   * Write uint40le.
	   * @param {Number} value
	   */

	  writeU40(value) {
	    this.offset += 5;
	    this.ops.push(new NumberOp(U40, value));
	    return this;
	  }

	  /**
	   * Write uint40be.
	   * @param {Number} value
	   */

	  writeU40BE(value) {
	    this.offset += 5;
	    this.ops.push(new NumberOp(U40BE, value));
	    return this;
	  }

	  /**
	   * Write uint48le.
	   * @param {Number} value
	   */

	  writeU48(value) {
	    this.offset += 6;
	    this.ops.push(new NumberOp(U48, value));
	    return this;
	  }

	  /**
	   * Write uint48be.
	   * @param {Number} value
	   */

	  writeU48BE(value) {
	    this.offset += 6;
	    this.ops.push(new NumberOp(U48BE, value));
	    return this;
	  }

	  /**
	   * Write uint56le.
	   * @param {Number} value
	   */

	  writeU56(value) {
	    this.offset += 7;
	    this.ops.push(new NumberOp(U56, value));
	    return this;
	  }

	  /**
	   * Write uint56be.
	   * @param {Number} value
	   */

	  writeU56BE(value) {
	    this.offset += 7;
	    this.ops.push(new NumberOp(U56BE, value));
	    return this;
	  }

	  /**
	   * Write uint64le.
	   * @param {Number} value
	   */

	  writeU64(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(U64, value));
	    return this;
	  }

	  /**
	   * Write uint64be.
	   * @param {Number} value
	   */

	  writeU64BE(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(U64BE, value));
	    return this;
	  }

	  /**
	   * Write int8.
	   * @param {Number} value
	   */

	  writeI8(value) {
	    this.offset += 1;
	    this.ops.push(new NumberOp(I8, value));
	    return this;
	  }

	  /**
	   * Write int16le.
	   * @param {Number} value
	   */

	  writeI16(value) {
	    this.offset += 2;
	    this.ops.push(new NumberOp(I16, value));
	    return this;
	  }

	  /**
	   * Write int16be.
	   * @param {Number} value
	   */

	  writeI16BE(value) {
	    this.offset += 2;
	    this.ops.push(new NumberOp(I16BE, value));
	    return this;
	  }

	  /**
	   * Write int24le.
	   * @param {Number} value
	   */

	  writeI24(value) {
	    this.offset += 3;
	    this.ops.push(new NumberOp(I24, value));
	    return this;
	  }

	  /**
	   * Write int24be.
	   * @param {Number} value
	   */

	  writeI24BE(value) {
	    this.offset += 3;
	    this.ops.push(new NumberOp(I24BE, value));
	    return this;
	  }

	  /**
	   * Write int32le.
	   * @param {Number} value
	   */

	  writeI32(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(I32, value));
	    return this;
	  }

	  /**
	   * Write int32be.
	   * @param {Number} value
	   */

	  writeI32BE(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(I32BE, value));
	    return this;
	  }

	  /**
	   * Write int40le.
	   * @param {Number} value
	   */

	  writeI40(value) {
	    this.offset += 5;
	    this.ops.push(new NumberOp(I40, value));
	    return this;
	  }

	  /**
	   * Write int40be.
	   * @param {Number} value
	   */

	  writeI40BE(value) {
	    this.offset += 5;
	    this.ops.push(new NumberOp(I40BE, value));
	    return this;
	  }

	  /**
	   * Write int48le.
	   * @param {Number} value
	   */

	  writeI48(value) {
	    this.offset += 6;
	    this.ops.push(new NumberOp(I48, value));
	    return this;
	  }

	  /**
	   * Write int48be.
	   * @param {Number} value
	   */

	  writeI48BE(value) {
	    this.offset += 6;
	    this.ops.push(new NumberOp(I48BE, value));
	    return this;
	  }

	  /**
	   * Write int56le.
	   * @param {Number} value
	   */

	  writeI56(value) {
	    this.offset += 7;
	    this.ops.push(new NumberOp(I56, value));
	    return this;
	  }

	  /**
	   * Write int56be.
	   * @param {Number} value
	   */

	  writeI56BE(value) {
	    this.offset += 7;
	    this.ops.push(new NumberOp(I56BE, value));
	    return this;
	  }

	  /**
	   * Write int64le.
	   * @param {Number} value
	   */

	  writeI64(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(I64, value));
	    return this;
	  }

	  /**
	   * Write int64be.
	   * @param {Number} value
	   */

	  writeI64BE(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(I64BE, value));
	    return this;
	  }

	  /**
	   * Write float le.
	   * @param {Number} value
	   */

	  writeFloat(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(FL, value));
	    return this;
	  }

	  /**
	   * Write float be.
	   * @param {Number} value
	   */

	  writeFloatBE(value) {
	    this.offset += 4;
	    this.ops.push(new NumberOp(FLBE, value));
	    return this;
	  }

	  /**
	   * Write double le.
	   * @param {Number} value
	   */

	  writeDouble(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(DBL, value));
	    return this;
	  }

	  /**
	   * Write double be.
	   * @param {Number} value
	   */

	  writeDoubleBE(value) {
	    this.offset += 8;
	    this.ops.push(new NumberOp(DBLBE, value));
	    return this;
	  }

	  /**
	   * Write a varint.
	   * @param {Number} value
	   */

	  writeVarint(value) {
	    this.offset += encoding.sizeVarint(value);
	    this.ops.push(new NumberOp(VARINT, value));
	    return this;
	  }

	  /**
	   * Write a varint (type 2).
	   * @param {Number} value
	   */

	  writeVarint2(value) {
	    this.offset += encoding.sizeVarint2(value);
	    this.ops.push(new NumberOp(VARINT2, value));
	    return this;
	  }

	  /**
	   * Write bytes.
	   * @param {Buffer} value
	   */

	  writeBytes(value) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');

	    if (value.length === 0)
	      return this;

	    this.offset += value.length;
	    this.ops.push(new BufferOp(BYTES, value));

	    return this;
	  }

	  /**
	   * Write bytes with a varint length before them.
	   * @param {Buffer} value
	   */

	  writeVarBytes(value) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');

	    this.offset += encoding.sizeVarint(value.length);
	    this.ops.push(new NumberOp(VARINT, value.length));

	    if (value.length === 0)
	      return this;

	    this.offset += value.length;
	    this.ops.push(new BufferOp(BYTES, value));

	    return this;
	  }

	  /**
	   * Copy bytes.
	   * @param {Buffer} value
	   * @param {Number} start
	   * @param {Number} end
	   */

	  copy(value, start, end) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');
	    enforce((start >>> 0) === start, 'start', 'integer');
	    enforce((end >>> 0) === end, 'end', 'integer');
	    enforce(end >= start, 'start', 'integer');

	    const buf = value.slice(start, end);

	    this.writeBytes(buf);

	    return this;
	  }

	  /**
	   * Write string to buffer.
	   * @param {String} value
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeString(value, enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof value === 'string', 'value', 'string');
	    enforce(typeof enc === 'string', 'enc', 'string');

	    if (value.length === 0)
	      return this;

	    this.offset += Buffer$1.byteLength(value, enc);
	    this.ops.push(new StringOp(STR, value, enc));

	    return this;
	  }

	  /**
	   * Write a 32 byte hash.
	   * @param {Hash} value
	   */

	  writeHash(value) {
	    if (typeof value !== 'string') {
	      enforce(Buffer$1.isBuffer(value), 'value', 'buffer');
	      enforce(value.length === 32, 'value', '32-byte hash');
	      this.writeBytes(value);
	      return this;
	    }

	    enforce(value.length === 64, 'value', '32-byte hash');

	    this.writeString(value, 'hex');

	    return this;
	  }

	  /**
	   * Write a string with a varint length before it.
	   * @param {String}
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeVarString(value, enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof value === 'string', 'value', 'string');
	    enforce(typeof enc === 'string', 'enc', 'string');

	    if (value.length === 0) {
	      this.ops.push(new NumberOp(VARINT, 0));
	      return this;
	    }

	    const size = Buffer$1.byteLength(value, enc);

	    this.offset += encoding.sizeVarint(size);
	    this.offset += size;

	    this.ops.push(new NumberOp(VARINT, size));
	    this.ops.push(new StringOp(STR, value, enc));

	    return this;
	  }

	  /**
	   * Write a null-terminated string.
	   * @param {String|Buffer}
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeNullString(value, enc) {
	    this.writeString(value, enc);
	    this.writeU8(0);
	    return this;
	  }

	  /**
	   * Calculate and write a checksum for the data written so far.
	   * @param {Function} hash
	   */

	  writeChecksum(hash) {
	    if (hash && typeof hash.digest === 'function')
	      hash = hash.digest.bind(hash);

	    enforce(typeof hash === 'function', 'hash', 'function');

	    this.offset += 4;
	    this.ops.push(new FunctionOp(CHECKSUM, hash));

	    return this;
	  }

	  /**
	   * Fill N bytes with value.
	   * @param {Number} value
	   * @param {Number} size
	   */

	  fill(value, size) {
	    enforce((value & 0xff) === value, 'value', 'byte');
	    enforce((size >>> 0) === size, 'size', 'integer');

	    if (size === 0)
	      return this;

	    this.offset += size;
	    this.ops.push(new FillOp(FILL, value, size));

	    return this;
	  }
	}

	/*
	 * Helpers
	 */

	class WriteOp {
	  constructor(type) {
	    this.type = type;
	  }
	}

	class NumberOp extends WriteOp {
	  constructor(type, value) {
	    super(type);
	    this.value = value;
	  }
	}

	class BufferOp extends WriteOp {
	  constructor(type, data) {
	    super(type);
	    this.data = data;
	  }
	}

	class StringOp extends WriteOp {
	  constructor(type, value, enc) {
	    super(type);
	    this.value = value;
	    this.enc = enc;
	  }
	}

	class FunctionOp extends WriteOp {
	  constructor(type, func) {
	    super(type);
	    this.func = func;
	  }
	}

	class FillOp extends WriteOp {
	  constructor(type, value, size) {
	    super(type);
	    this.value = value;
	    this.size = size;
	  }
	}

	/*
	 * Expose
	 */

	writer = BufferWriter;
	return writer;
}

var staticwriter;
var hasRequiredStaticwriter;

function requireStaticwriter () {
	if (hasRequiredStaticwriter) return staticwriter;
	hasRequiredStaticwriter = 1;

	const enforce = requireEnforce();
	const encoding = requireEncoding();
	const EncodingError = requireError();

	/*
	 * Constants
	 */

	const EMPTY = Buffer$1.alloc(0);
	const POOL_SIZE = 100 << 10;

	let POOL = null;

	/**
	 * Statically Allocated Writer
	 */

	class StaticWriter {
	  /**
	   * Statically allocated buffer writer.
	   * @constructor
	   * @param {Number|Buffer} options
	   */

	  constructor(options) {
	    this.data = EMPTY;
	    this.offset = 0;

	    if (options != null)
	      this.init(options);
	  }

	  /**
	   * Assertion.
	   * @param {Number} size
	   */

	  check(size) {
	    if (this.offset + size > this.data.length)
	      throw new EncodingError(this.offset, 'Out of bounds write', this.check);
	  }

	  /**
	   * Initialize options.
	   * @param {Object} options
	   */

	  init(options) {
	    if (Buffer$1.isBuffer(options)) {
	      this.data = options;
	      this.offset = 0;
	      return this;
	    }

	    enforce((options >>> 0) === options, 'size', 'integer');

	    this.data = Buffer$1.allocUnsafeSlow(options);
	    this.offset = 0;

	    return this;
	  }

	  /**
	   * Allocate writer from preallocated 100kb pool.
	   * @param {Number} size
	   * @returns {StaticWriter}
	   */

	  static pool(size) {
	    enforce((size >>> 0) === size, 'size', 'integer');

	    if (size <= POOL_SIZE) {
	      if (!POOL)
	        POOL = Buffer$1.allocUnsafeSlow(POOL_SIZE);

	      const bw = new StaticWriter();

	      bw.data = POOL.slice(0, size);

	      return bw;
	    }

	    return new StaticWriter(size);
	  }

	  /**
	   * Allocate and render the final buffer.
	   * @returns {Buffer} Rendered buffer.
	   */

	  render() {
	    const {data, offset} = this;

	    if (offset !== data.length)
	      throw new EncodingError(offset, 'Out of bounds write');

	    this.destroy();

	    return data;
	  }

	  /**
	   * Slice the final buffer at written offset.
	   * @returns {Buffer} Rendered buffer.
	   */

	  slice() {
	    const {data, offset} = this;

	    if (offset > data.length)
	      throw new EncodingError(offset, 'Out of bounds write');

	    this.destroy();

	    return data.slice(0, offset);
	  }

	  /**
	   * Get size of data written so far.
	   * @returns {Number}
	   */

	  getSize() {
	    return this.offset;
	  }

	  /**
	   * Seek to relative offset.
	   * @param {Number} off
	   */

	  seek(off) {
	    enforce(Number.isSafeInteger(off), 'off', 'integer');

	    if (this.offset + off < 0)
	      throw new EncodingError(this.offset, 'Out of bounds write');

	    this.check(off);
	    this.offset += off;

	    return this;
	  }

	  /**
	   * Destroy the buffer writer.
	   */

	  destroy() {
	    this.data = EMPTY;
	    this.offset = 0;
	    return this;
	  }

	  /**
	   * Write uint8.
	   * @param {Number} value
	   */

	  writeU8(value) {
	    this.check(1);
	    this.offset = encoding.writeU8(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint16le.
	   * @param {Number} value
	   */

	  writeU16(value) {
	    this.check(2);
	    this.offset = encoding.writeU16(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint16be.
	   * @param {Number} value
	   */

	  writeU16BE(value) {
	    this.check(2);
	    this.offset = encoding.writeU16BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint24le.
	   * @param {Number} value
	   */

	  writeU24(value) {
	    this.check(3);
	    this.offset = encoding.writeU24(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint24be.
	   * @param {Number} value
	   */

	  writeU24BE(value) {
	    this.check(3);
	    this.offset = encoding.writeU24BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint32le.
	   * @param {Number} value
	   */

	  writeU32(value) {
	    this.check(4);
	    this.offset = encoding.writeU32(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint32be.
	   * @param {Number} value
	   */

	  writeU32BE(value) {
	    this.check(4);
	    this.offset = encoding.writeU32BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint40le.
	   * @param {Number} value
	   */

	  writeU40(value) {
	    this.check(5);
	    this.offset = encoding.writeU40(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint40be.
	   * @param {Number} value
	   */

	  writeU40BE(value) {
	    this.check(5);
	    this.offset = encoding.writeU40BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint48le.
	   * @param {Number} value
	   */

	  writeU48(value) {
	    this.check(6);
	    this.offset = encoding.writeU48(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint48be.
	   * @param {Number} value
	   */

	  writeU48BE(value) {
	    this.check(6);
	    this.offset = encoding.writeU48BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint56le.
	   * @param {Number} value
	   */

	  writeU56(value) {
	    this.check(7);
	    this.offset = encoding.writeU56(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint56be.
	   * @param {Number} value
	   */

	  writeU56BE(value) {
	    this.check(7);
	    this.offset = encoding.writeU56BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint64le.
	   * @param {Number} value
	   */

	  writeU64(value) {
	    this.check(8);
	    this.offset = encoding.writeU64(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write uint64be.
	   * @param {Number} value
	   */

	  writeU64BE(value) {
	    this.check(8);
	    this.offset = encoding.writeU64BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int8.
	   * @param {Number} value
	   */

	  writeI8(value) {
	    this.check(1);
	    this.offset = encoding.writeI8(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int16le.
	   * @param {Number} value
	   */

	  writeI16(value) {
	    this.check(2);
	    this.offset = encoding.writeI16(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int16be.
	   * @param {Number} value
	   */

	  writeI16BE(value) {
	    this.check(2);
	    this.offset = encoding.writeI16BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int24le.
	   * @param {Number} value
	   */

	  writeI24(value) {
	    this.check(3);
	    this.offset = encoding.writeI24(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int24be.
	   * @param {Number} value
	   */

	  writeI24BE(value) {
	    this.check(3);
	    this.offset = encoding.writeI24BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int32le.
	   * @param {Number} value
	   */

	  writeI32(value) {
	    this.check(4);
	    this.offset = encoding.writeI32(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int32be.
	   * @param {Number} value
	   */

	  writeI32BE(value) {
	    this.check(4);
	    this.offset = encoding.writeI32BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int40le.
	   * @param {Number} value
	   */

	  writeI40(value) {
	    this.check(5);
	    this.offset = encoding.writeI40(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int40be.
	   * @param {Number} value
	   */

	  writeI40BE(value) {
	    this.check(5);
	    this.offset = encoding.writeI40BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int48le.
	   * @param {Number} value
	   */

	  writeI48(value) {
	    this.check(6);
	    this.offset = encoding.writeI48(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int48be.
	   * @param {Number} value
	   */

	  writeI48BE(value) {
	    this.check(6);
	    this.offset = encoding.writeI48BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int56le.
	   * @param {Number} value
	   */

	  writeI56(value) {
	    this.check(7);
	    this.offset = encoding.writeI56(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int56be.
	   * @param {Number} value
	   */

	  writeI56BE(value) {
	    this.check(7);
	    this.offset = encoding.writeI56BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int64le.
	   * @param {Number} value
	   */

	  writeI64(value) {
	    this.check(8);
	    this.offset = encoding.writeI64(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write int64be.
	   * @param {Number} value
	   */

	  writeI64BE(value) {
	    this.check(8);
	    this.offset = encoding.writeI64BE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write float le.
	   * @param {Number} value
	   */

	  writeFloat(value) {
	    this.check(4);
	    this.offset = encoding.writeFloat(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write float be.
	   * @param {Number} value
	   */

	  writeFloatBE(value) {
	    this.check(4);
	    this.offset = encoding.writeFloatBE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write double le.
	   * @param {Number} value
	   */

	  writeDouble(value) {
	    this.check(8);
	    this.offset = encoding.writeDouble(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write double be.
	   * @param {Number} value
	   */

	  writeDoubleBE(value) {
	    this.check(8);
	    this.offset = encoding.writeDoubleBE(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write a varint.
	   * @param {Number} value
	   */

	  writeVarint(value) {
	    this.offset = encoding.writeVarint(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write a varint (type 2).
	   * @param {Number} value
	   */

	  writeVarint2(value) {
	    this.offset = encoding.writeVarint2(this.data, value, this.offset);
	    return this;
	  }

	  /**
	   * Write bytes.
	   * @param {Buffer} value
	   */

	  writeBytes(value) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');

	    this.check(value.length);
	    this.offset += value.copy(this.data, this.offset);

	    return this;
	  }

	  /**
	   * Write bytes with a varint length before them.
	   * @param {Buffer} value
	   */

	  writeVarBytes(value) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');

	    this.writeVarint(value.length);
	    this.writeBytes(value);

	    return this;
	  }

	  /**
	   * Copy bytes.
	   * @param {Buffer} value
	   * @param {Number} start
	   * @param {Number} end
	   */

	  copy(value, start, end) {
	    enforce(Buffer$1.isBuffer(value), 'value', 'buffer');
	    enforce((start >>> 0) === start, 'start', 'integer');
	    enforce((end >>> 0) === end, 'end', 'integer');
	    enforce(end >= start, 'start', 'integer');

	    this.check(end - start);
	    this.offset += value.copy(this.data, this.offset, start, end);

	    return this;
	  }

	  /**
	   * Write string to buffer.
	   * @param {String} value
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeString(value, enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof value === 'string', 'value', 'string');
	    enforce(typeof enc === 'string', 'enc', 'string');

	    if (value.length === 0)
	      return this;

	    const size = Buffer$1.byteLength(value, enc);

	    this.check(size);

	    this.offset += this.data.write(value, this.offset, enc);

	    return this;
	  }

	  /**
	   * Write a 32 byte hash.
	   * @param {Hash} value
	   */

	  writeHash(value) {
	    if (typeof value !== 'string') {
	      enforce(Buffer$1.isBuffer(value), 'value', 'buffer');
	      enforce(value.length === 32, 'value', '32-byte hash');
	      this.writeBytes(value);
	      return this;
	    }

	    enforce(value.length === 64, 'value', '32-byte hash');

	    this.check(32);
	    this.offset += this.data.write(value, this.offset, 'hex');

	    return this;
	  }

	  /**
	   * Write a string with a varint length before it.
	   * @param {String}
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeVarString(value, enc) {
	    if (enc == null)
	      enc = 'binary';

	    enforce(typeof value === 'string', 'value', 'string');
	    enforce(typeof enc === 'string', 'enc', 'string');

	    if (value.length === 0) {
	      this.writeVarint(0);
	      return this;
	    }

	    const size = Buffer$1.byteLength(value, enc);

	    this.writeVarint(size);
	    this.check(size);
	    this.offset += this.data.write(value, this.offset, enc);

	    return this;
	  }

	  /**
	   * Write a null-terminated string.
	   * @param {String|Buffer}
	   * @param {String?} enc - Any buffer-supported encoding.
	   */

	  writeNullString(value, enc) {
	    this.writeString(value, enc);
	    this.writeU8(0);
	    return this;
	  }

	  /**
	   * Calculate and write a checksum for the data written so far.
	   * @param {Function} hash
	   */

	  writeChecksum(hash) {
	    if (!hash || typeof hash.digest !== 'function')
	      enforce(typeof hash === 'function', 'hash', 'function');

	    this.check(4);

	    const data = this.data.slice(0, this.offset);
	    const raw = hash.digest ? hash.digest(data) : hash(data);

	    raw.copy(this.data, this.offset, 0, 4);

	    this.offset += 4;

	    return this;
	  }

	  /**
	   * Fill N bytes with value.
	   * @param {Number} value
	   * @param {Number} size
	   */

	  fill(value, size) {
	    enforce((value & 0xff) === value, 'value', 'byte');
	    enforce((size >>> 0) === size, 'size', 'integer');

	    this.check(size);

	    this.data.fill(value, this.offset, this.offset + size);
	    this.offset += size;

	    return this;
	  }
	}

	/*
	 * Expose
	 */

	staticwriter = StaticWriter;
	return staticwriter;
}

var struct;
var hasRequiredStruct;

function requireStruct () {
	if (hasRequiredStruct) return struct;
	hasRequiredStruct = 1;

	const enforce = requireEnforce();
	const BufferReader = requireReader();
	const BufferWriter = requireWriter();
	const StaticWriter = requireStaticwriter();
	const {custom} = requireCustom$2();

	/**
	 * Struct
	 */

	class Struct {
	  constructor() {}

	  inject(obj) {
	    enforce(obj instanceof this.constructor, 'obj', 'struct');
	    return this.decode(obj.encode());
	  }

	  clone() {
	    const copy = new this.constructor();
	    return copy.inject(this);
	  }

	  /*
	   * Bindable
	   */

	  getSize(extra) {
	    return -1;
	  }

	  write(bw, extra) {
	    return bw;
	  }

	  read(br, extra) {
	    return this;
	  }

	  toString() {
	    return Object.prototype.toString.call(this);
	  }

	  fromString(str, extra) {
	    return this;
	  }

	  getJSON() {
	    return this;
	  }

	  fromJSON(json, extra) {
	    return this;
	  }

	  fromOptions(options, extra) {
	    return this;
	  }

	  from(options, extra) {
	    return this.fromOptions(options, extra);
	  }

	  format() {
	    return this.getJSON();
	  }

	  /*
	   * API
	   */

	  encode(extra) {
	    const size = this.getSize(extra);
	    const bw = size === -1
	      ? new BufferWriter()
	      : new StaticWriter(size);

	    this.write(bw, extra);

	    return bw.render();
	  }

	  decode(data, extra) {
	    const br = new BufferReader(data);

	    this.read(br, extra);

	    return this;
	  }

	  toHex(extra) {
	    return this.encode(extra).toString('hex');
	  }

	  fromHex(str, extra) {
	    enforce(typeof str === 'string', 'str', 'string');

	    const size = str.length >>> 1;
	    const data = Buffer$1.from(str, 'hex');

	    if (data.length !== size)
	      throw new Error('Invalid hex string.');

	    return this.decode(data, extra);
	  }

	  toBase64(extra) {
	    return this.encode(extra).toString('base64');
	  }

	  fromBase64(str, extra) {
	    enforce(typeof str === 'string', 'str', 'string');

	    const data = Buffer$1.from(str, 'base64');

	    if (str.length > size64(data.length))
	      throw new Error('Invalid base64 string.');

	    return this.decode(data, extra);
	  }

	  toJSON() {
	    return this.getJSON();
	  }

	  [custom]() {
	    return this.format();
	  }

	  /*
	   * Static API
	   */

	  static read(br, extra) {
	    return new this().read(br, extra);
	  }

	  static decode(data, extra) {
	    return new this().decode(data, extra);
	  }

	  static fromHex(str, extra) {
	    return new this().fromHex(str, extra);
	  }

	  static fromBase64(str, extra) {
	    return new this().fromBase64(str, extra);
	  }

	  static fromString(str, extra) {
	    return new this().fromString(str, extra);
	  }

	  static fromJSON(json, extra) {
	    return new this().fromJSON(json, extra);
	  }

	  static fromOptions(options, extra) {
	    return new this().fromOptions(options, extra);
	  }

	  static from(options, extra) {
	    return new this().from(options, extra);
	  }

	  /*
	   * Aliases
	   */

	  toWriter(bw, extra) {
	    return this.write(bw, extra);
	  }

	  fromReader(br, extra) {
	    return this.read(br, extra);
	  }

	  toRaw(extra) {
	    return this.encode(extra);
	  }

	  fromRaw(data, extra) {
	    return this.decode(data, extra);
	  }

	  /*
	   * Static Aliases
	   */

	  static fromReader(br, extra) {
	    return this.read(br, extra);
	  }

	  static fromRaw(data, extra) {
	    return this.decode(data, extra);
	  }
	}

	/*
	 * Helpers
	 */

	function size64(size) {
	  const expect = ((4 * size / 3) + 3) & -4;
	  return expect >>> 0;
	}

	/*
	 * Expose
	 */

	struct = Struct;
	return struct;
}

var hasRequiredBufio;

function requireBufio () {
	if (hasRequiredBufio) return bufio;
	hasRequiredBufio = 1;

	const custom = requireCustom$2();
	const encoding = requireEncoding();
	const enforce = requireEnforce();
	const EncodingError = requireError();
	const BufferReader = requireReader();
	const BufferWriter = requireWriter();
	const StaticWriter = requireStaticwriter();
	const Struct = requireStruct();

	bufio.custom = custom;
	bufio.encoding = encoding;
	bufio.EncodingError = EncodingError;
	bufio.BufferReader = BufferReader;
	bufio.BufferWriter = BufferWriter;
	bufio.StaticWriter = StaticWriter;
	bufio.Struct = Struct;

	bufio.read = function read(data, zeroCopy) {
	  return new BufferReader(data, zeroCopy);
	};

	bufio.write = function write(size) {
	  return size != null
	    ? new StaticWriter(size)
	    : new BufferWriter();
	};

	bufio.pool = function pool(size) {
	  return StaticWriter.pool(size);
	};

	function _read(func, size) {
	  return function(data, off) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');

	    if (off + size > data.length)
	      throw new EncodingError(off, 'Out of bounds read');

	    return func(data, off);
	  };
	}

	function _readn(func) {
	  return function(data, off, len) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');
	    enforce((len >>> 0) === len, 'len', 'integer');

	    if (off + len > data.length)
	      throw new EncodingError(off, 'Out of bounds read');

	    return func(data, off, len);
	  };
	}

	function _readvar(func) {
	  return function(data, off) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');
	    return func(data, off);
	  };
	}

	function _write(func, size) {
	  return function(data, num, off) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');

	    if (off + size > data.length)
	      throw new EncodingError(off, 'Out of bounds write');

	    return func(data, num, off);
	  };
	}

	function _writen(func) {
	  return function(data, num, off, len) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');
	    enforce((len >>> 0) === len, 'len', 'integer');

	    if (off + len > data.length)
	      throw new EncodingError(off, 'Out of bounds write');

	    return func(data, num, off, len);
	  };
	}

	function _writecb(func, size) {
	  return function(data, num, off) {
	    enforce(Buffer$1.isBuffer(data), 'data', 'buffer');
	    enforce((off >>> 0) === off, 'off', 'integer');

	    if (off + size(num) > data.length)
	      throw new EncodingError(off, 'Out of bounds write');

	    return func(data, num, off);
	  };
	}

	bufio.readU = _readn(encoding.readU);
	bufio.readU64 = _read(encoding.readU64, 8);
	bufio.readU56 = _read(encoding.readU56, 7);
	bufio.readU48 = _read(encoding.readU48, 6);
	bufio.readU40 = _read(encoding.readU40, 5);
	bufio.readU32 = _read(encoding.readU32, 4);
	bufio.readU24 = _read(encoding.readU24, 3);
	bufio.readU16 = _read(encoding.readU16, 2);
	bufio.readU8 = _read(encoding.readU8, 1);

	bufio.readUBE = _readn(encoding.readUBE);
	bufio.readU64BE = _read(encoding.readU64BE, 8);
	bufio.readU56BE = _read(encoding.readU56BE, 7);
	bufio.readU48BE = _read(encoding.readU48BE, 6);
	bufio.readU40BE = _read(encoding.readU40BE, 5);
	bufio.readU32BE = _read(encoding.readU32BE, 4);
	bufio.readU24BE = _read(encoding.readU24BE, 3);
	bufio.readU16BE = _read(encoding.readU16BE, 2);

	bufio.readI = _readn(encoding.readI);
	bufio.readI64 = _read(encoding.readI64, 8);
	bufio.readI56 = _read(encoding.readI56, 7);
	bufio.readI48 = _read(encoding.readI48, 6);
	bufio.readI40 = _read(encoding.readI40, 5);
	bufio.readI32 = _read(encoding.readI32, 4);
	bufio.readI24 = _read(encoding.readI24, 3);
	bufio.readI16 = _read(encoding.readI16, 2);
	bufio.readI8 = _read(encoding.readI8, 1);

	bufio.readIBE = _readn(encoding.readIBE);
	bufio.readI64BE = _read(encoding.readI64BE, 8);
	bufio.readI56BE = _read(encoding.readI56BE, 7);
	bufio.readI48BE = _read(encoding.readI48BE, 6);
	bufio.readI40BE = _read(encoding.readI40BE, 5);
	bufio.readI32BE = _read(encoding.readI32BE, 4);
	bufio.readI24BE = _read(encoding.readI24BE, 3);
	bufio.readI16BE = _read(encoding.readI16BE, 2);

	bufio.readFloat = _read(encoding.readFloat, 4);
	bufio.readFloatBE = _read(encoding.readFloatBE, 4);
	bufio.readDouble = _read(encoding.readDouble, 8);
	bufio.readDoubleBE = _read(encoding.readDoubleBE, 8);

	bufio.writeU = _writen(encoding.writeU);
	bufio.writeU64 = _write(encoding.writeU64, 8);
	bufio.writeU56 = _write(encoding.writeU56, 7);
	bufio.writeU48 = _write(encoding.writeU48, 6);
	bufio.writeU40 = _write(encoding.writeU40, 5);
	bufio.writeU32 = _write(encoding.writeU32, 4);
	bufio.writeU24 = _write(encoding.writeU24, 3);
	bufio.writeU16 = _write(encoding.writeU16, 2);
	bufio.writeU8 = _write(encoding.writeU8, 1);

	bufio.writeUBE = _writen(encoding.writeUBE);
	bufio.writeU64BE = _write(encoding.writeU64BE, 8);
	bufio.writeU56BE = _write(encoding.writeU56BE, 7);
	bufio.writeU48BE = _write(encoding.writeU48BE, 6);
	bufio.writeU40BE = _write(encoding.writeU40BE, 5);
	bufio.writeU32BE = _write(encoding.writeU32BE, 4);
	bufio.writeU24BE = _write(encoding.writeU24BE, 3);
	bufio.writeU16BE = _write(encoding.writeU16BE, 2);

	bufio.writeI = _writen(encoding.writeI);
	bufio.writeI64 = _write(encoding.writeI64, 8);
	bufio.writeI56 = _write(encoding.writeI56, 7);
	bufio.writeI48 = _write(encoding.writeI48, 6);
	bufio.writeI40 = _write(encoding.writeI40, 5);
	bufio.writeI32 = _write(encoding.writeI32, 4);
	bufio.writeI24 = _write(encoding.writeI24, 3);
	bufio.writeI16 = _write(encoding.writeI16, 2);
	bufio.writeI8 = _write(encoding.writeI8, 1);

	bufio.writeIBE = _writen(encoding.writeIBE);
	bufio.writeI64BE = _write(encoding.writeI64BE, 8);
	bufio.writeI56BE = _write(encoding.writeI56BE, 7);
	bufio.writeI48BE = _write(encoding.writeI48BE, 6);
	bufio.writeI40BE = _write(encoding.writeI40BE, 5);
	bufio.writeI32BE = _write(encoding.writeI32BE, 4);
	bufio.writeI24BE = _write(encoding.writeI24BE, 3);
	bufio.writeI16BE = _write(encoding.writeI16BE, 2);

	bufio.writeFloat = _write(encoding.writeFloat, 4);
	bufio.writeFloatBE = _write(encoding.writeFloatBE, 4);
	bufio.writeDouble = _write(encoding.writeDouble, 8);
	bufio.writeDoubleBE = _write(encoding.writeDoubleBE, 8);

	bufio.readVarint = _readvar(encoding.readVarint);
	bufio.writeVarint = _writecb(encoding.writeVarint, encoding.sizeVarint);
	bufio.sizeVarint = encoding.sizeVarint;
	bufio.readVarint2 = _readvar(encoding.readVarint2);
	bufio.writeVarint2 = _writecb(encoding.writeVarint2, encoding.sizeVarint2);
	bufio.sizeVarint2 = encoding.sizeVarint2;

	bufio.sliceBytes = encoding.sliceBytes;
	bufio.readBytes = encoding.readBytes;
	bufio.writeBytes = encoding.writeBytes;
	bufio.readString = encoding.readString;
	bufio.writeString = encoding.writeString;

	bufio.realloc = encoding.realloc;
	bufio.copy = encoding.copy;
	bufio.concat = encoding.concat;

	bufio.sizeVarBytes = encoding.sizeVarBytes;
	bufio.sizeVarlen = encoding.sizeVarlen;
	bufio.sizeVarString = encoding.sizeVarString;
	return bufio;
}

var bstring = {};

var base58 = {exports: {}};

var __dirname$1 = '/home/henrik/Documents/dev/devkit2/checkout-components/node_modules/bstring/lib';

var binding = {};

var _polyfillNode_fs = {};

var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: _polyfillNode_fs
});

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter$1 = ':';

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var _polyfillNode_path = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter$1,
  relative: relative,
  join: join,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};
function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	basename: basename,
	default: _polyfillNode_path,
	delimiter: delimiter$1,
	dirname: dirname,
	extname: extname,
	isAbsolute: isAbsolute,
	join: join,
	normalize: normalize,
	relative: relative,
	resolve: resolve,
	sep: sep
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

/*! https://mths.be/punycode v1.4.1 by @mathias */


/** Highest positive signed 32-bit float value */
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base$1 = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors$1 = {
  'overflow': 'Overflow: input needs wider integers to process',
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base$1 - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
  throw new RangeError(errors$1[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map$1(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
  var parts = string.split('@');
  var result = '';
  if (parts.length > 1) {
    // In email addresses, only the domain name should be punycoded. Leave
    // the local part (i.e. everything up to `@`) intact.
    result = parts[0] + '@';
    string = parts[1];
  }
  // Avoid `split(regex)` for IE8 compatibility. See #17.
  string = string.replace(regexSeparators, '\x2E');
  var labels = string.split('.');
  var encoded = map$1(labels, fn).join('.');
  return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
  var output = [],
    counter = 0,
    length = string.length,
    value,
    extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
function digitToBasic(digit, flag) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base$1) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
function encode(input) {
  var n,
    delta,
    handledCPCount,
    basicLength,
    bias,
    j,
    m,
    q,
    k,
    t,
    currentValue,
    output = [],
    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,
    /** Cached calculation results */
    handledCPCountPlusOne,
    baseMinusT,
    qMinusT;

  // Convert the input in UCS-2 to Unicode
  input = ucs2decode(input);

  // Cache the length
  inputLength = input.length;

  // Initialize the state
  n = initialN;
  delta = 0;
  bias = initialBias;

  // Handle the basic code points
  for (j = 0; j < inputLength; ++j) {
    currentValue = input[j];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  handledCPCount = basicLength = output.length;

  // `handledCPCount` is the number of code points that have been handled;
  // `basicLength` is the number of basic code points.

  // Finish the basic string - if it is not empty - with a delimiter
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {

    // All non-basic code points < n have been handled already. Find the next
    // larger one:
    for (m = maxInt, j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    // but guard against overflow
    handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow');
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < n && ++delta > maxInt) {
        error('overflow');
      }

      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer
        for (q = delta, k = base$1; /* no condition */ ; k += base$1) {
          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) {
            break;
          }
          qMinusT = q - t;
          baseMinusT = base$1 - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;

  }
  return output.join('');
}

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ?
      'xn--' + encode(string) :
      string;
  });
}

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function stringify (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys$1(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
}
function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys$1 = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

function parse$1(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
}

// WHATWG API
const URL = global$1.URL;
const URLSearchParams = global$1.URLSearchParams;
var _polyfillNode_url = {
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  Url: Url,

  // WHATWG API
  URL,
  URLSearchParams,  
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
  hostEndingChars = ['/', '?', '#'],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    'javascript': true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  };

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  return parse(this, url, parseQueryString, slashesDenoteHost);
};

function parse(self, url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
    splitter =
    (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self.path = rest;
      self.href = rest;
      self.pathname = simplePath[1];
      if (simplePath[2]) {
        self.search = simplePath[2];
        if (parseQueryString) {
          self.query = parse$1(self.search.substr(1));
        } else {
          self.query = self.search.substr(1);
        }
      } else if (parseQueryString) {
        self.search = '';
        self.query = {};
      }
      return self;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self.slashes = true;
    }
  }
  var i, hec, l, p;
  if (!hostlessProtocol[proto] &&
    (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    self.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    parseHost(self);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    self.hostname = self.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = self.hostname[0] === '[' &&
      self.hostname[self.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = self.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            self.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (self.hostname.length > hostnameMaxLen) {
      self.hostname = '';
    } else {
      // hostnames are always lower case.
      self.hostname = self.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      self.hostname = toASCII(self.hostname);
    }

    p = self.port ? ':' + self.port : '';
    var h = self.hostname || '';
    self.host = h + p;
    self.href += self.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      self.hostname = self.hostname.substr(1, self.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    self.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    self.search = rest.substr(qm);
    self.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self.query = parse$1(self.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    self.search = '';
    self.query = {};
  }
  if (rest) self.pathname = rest;
  if (slashedProtocol[lowerProto] &&
    self.hostname && !self.pathname) {
    self.pathname = '/';
  }

  //to support http.request
  if (self.pathname || self.search) {
    p = self.pathname || '';
    var s = self.search || '';
    self.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  self.href = format(self);
  return self;
}

function urlFileURLToPath(path) {
  if (typeof path === 'string')
    path = new Url().parse(path);
  else if (!(path instanceof Url))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + (typeof path) + String(path));
  if (path.protocol !== 'file:')
    throw new TypeError('The URL must be of scheme file');
  return getPathFromURLPosix(path);
}

function getPathFromURLPosix(url) {
  const pathname = url.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === '%') {
      const third = pathname.codePointAt(n + 2) | 0x20;
      if (pathname[n + 1] === '2' && third === 102) {
        throw new TypeError(
          'must not include encoded / characters'
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = parse({}, obj);
  return format(obj);
}

function format(self) {
  var auth = self.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = self.protocol || '',
    pathname = self.pathname || '',
    hash = self.hash || '',
    host = false,
    query = '';

  if (self.host) {
    host = auth + self.host;
  } else if (self.hostname) {
    host = auth + (self.hostname.indexOf(':') === -1 ?
      self.hostname :
      '[' + this.hostname + ']');
    if (self.port) {
      host += ':' + self.port;
    }
  }

  if (self.query &&
    isObject(self.query) &&
    Object.keys(self.query).length) {
    query = stringify(self.query);
  }

  var search = self.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (self.slashes ||
    (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
}

Url.prototype.format = function() {
  return format(this);
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
      result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
    isRelAbs = (
      relative.host ||
      relative.pathname && relative.pathname.charAt(0) === '/'
    ),
    mustEndAbs = (isRelAbs || isSourceAbs ||
      (result.host && relative.pathname)),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative.pathname && relative.pathname.split('/') || [];
  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }
  var authInHost;
  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
      relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      authInHost = result.host && result.host.indexOf('@') > 0 ?
        result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
        (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
    (result.host || relative.host || srcPath.length > 1) &&
    (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
    (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
    (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
      srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    authInHost = result.host && result.host.indexOf('@') > 0 ?
      result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
      (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  return parseHost(this);
};

function parseHost(self) {
  var host = self.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      self.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) self.hostname = host;
}

var _polyfillNode_url$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	URL: URL,
	URLSearchParams: URLSearchParams,
	Url: Url,
	default: _polyfillNode_url,
	fileURLToPath: urlFileURLToPath,
	format: urlFormat,
	parse: urlParse,
	resolve: urlResolve,
	resolveObject: urlResolveObject
});

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_url$1);

var loady;
var hasRequiredLoady;

function requireLoady () {
	if (hasRequiredLoady) return loady;
	hasRequiredLoady = 1;

	const fs = require$$0$3;
	const path = require$$1;

	/*
	 * Constants
	 */

	const types = [
	  'Debug',
	  'Release',
	  'MinSizeRel',
	  'RelWithDebInfo'
	];

	/**
	 * Resolve
	 */

	function resolve(name, root) {
	  if (typeof name !== 'string')
	    throw new TypeError('"name" must be a string.');

	  if (typeof root !== 'string')
	    throw new TypeError('"root" must be a string.');

	  if (!fs.existsSync)
	    throw moduleError(name);

	  if (path.extname(name) !== '.node')
	    name += '.node';

	  root = ensurePath(root);

	  const key = `${name}\0${root}`;

	  if (resolve.cache[key])
	    return resolve.cache[key];

	  if (browser$1.pkg && !isPath(name))
	    name = path.resolve(browser$1.execPath, '..', name);

	  if (isPath(name)) {
	    const file = path.resolve(root, name);

	    if (!fs.existsSync(file))
	      throw moduleError(file);

	    const real = realpath(file);

	    resolve.cache[key] = real;

	    return real;
	  }

	  for (;;) {
	    const build = path.join(root, 'build');

	    if (fs.existsSync(build)) {
	      const files = [path.join(build, name)];

	      for (const type of types)
	        files.push(path.join(build, type, name));

	      for (const file of files) {
	        if (fs.existsSync(file)) {
	          const real = realpath(file);
	          resolve.cache[key] = real;
	          return real;
	        }
	      }
	    }

	    const next = path.dirname(root);

	    if (next === root)
	      break;

	    root = next;
	  }

	  throw moduleError(name);
	}

	resolve.cache = Object.create(null);

	/**
	 * Load
	 */

	function load(name, root) {
	  const file = resolve(name, root);

	  if (load.cache[file])
	    return load.cache[file];

	  if (!browser$1.dlopen)
	    throw new Error(`${name}: cannot open shared object file`);

	  const module = { exports: {} };

	  browser$1.dlopen(module, file);

	  load.cache[file] = module.exports;

	  return module.exports;
	}

	load.cache = Object.create(null);

	/*
	 * Helpers
	 */

	function isPath(str) {
	  if (browser$1.platform === 'win32')
	    str = str.replace('\\', '/');

	  return str[0] === '/'
	      || str.startsWith('./')
	      || str.startsWith('../');
	}

	function ensurePath(str) {
	  if (str.indexOf('file:') === 0) {
	    const url = require$$2$1;

	    if (!url.fileURLToPath)
	      throw new Error('File URLs are unsupported on this platform.');

	    // Assume this is an import.meta.url.
	    return path.resolve(url.fileURLToPath(str), '..');
	  }

	  return path.resolve(str);
	}

	function realpath(file) {
	  try {
	    return fs.realpathSync(file);
	  } catch (e) {
	    return path.resolve(file);
	  }
	}

	function moduleError(name) {
	  const err = new Error(`Cannot find module '${name}'`);
	  err.code = 'MODULE_NOT_FOUND';
	  throw err;
	}

	/*
	 * Expose
	 */

	load.load = load;
	load.resolve = resolve;

	loady = load;
	return loady;
}

var hasRequiredBinding;

function requireBinding () {
	if (hasRequiredBinding) return binding;
	hasRequiredBinding = 1;

	if (browser$1.env.NODE_BACKEND && browser$1.env.NODE_BACKEND !== 'native')
	  throw new Error('Non-native backend selected.');

	const assert = requireAssert$1();
	const binding$1 = requireLoady()('bstring', __dirname$1);

	binding.base58 = {
	  encode: binding$1.base58_encode,
	  decode: binding$1.base58_decode,
	  test: binding$1.base58_test
	};

	binding.bech32 = {
	  serialize: binding$1.bech32_serialize,
	  deserialize: binding$1.bech32_deserialize,
	  is: binding$1.bech32_is,
	  convertBits: binding$1.bech32_convert_bits,
	  encode: binding$1.bech32_encode,
	  decode: binding$1.bech32_decode,
	  test: binding$1.bech32_test
	};

	binding.cashaddr = {
	  encode(prefix, type, hash) {
	    assert((type & 0x0f) === type, 'Invalid cashaddr type.');
	    return binding$1.cashaddr_encode(prefix, type, hash);
	  },
	  decode(str, defaultPrefix = 'bitcoincash') {
	    return binding$1.cashaddr_decode(str, defaultPrefix);
	  },
	  test(str, defaultPrefix = 'bitcoincash') {
	    return binding$1.cashaddr_test(str, defaultPrefix);
	  }
	};
	return binding;
}

var base58Browser = {};

var hasRequiredBase58Browser;

function requireBase58Browser () {
	if (hasRequiredBase58Browser) return base58Browser;
	hasRequiredBase58Browser = 1;

	const assert = requireAssert$1();

	/*
	 * Constants
	 */

	const CHARSET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
	const TABLE = [
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8, -1, -1, -1, -1, -1, -1,
	  -1,  9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1,
	  22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1,
	  -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46,
	  47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1
	];

	/**
	 * Encode a base58 string.
	 * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
	 * @param {Buffer} data
	 * @returns {String}
	 */

	base58Browser.encode = function encode(data) {
	  assert(Buffer$1.isBuffer(data));

	  let zeroes = 0;
	  let i = 0;

	  for (; i < data.length; i++) {
	    if (data[i] !== 0)
	      break;
	    zeroes += 1;
	  }

	  const b58 = Buffer$1.allocUnsafe(((data.length * 138 / 100) | 0) + 1);
	  b58.fill(0);

	  let length = 0;

	  for (; i < data.length; i++) {
	    let carry = data[i];
	    let j = 0;

	    for (let k = b58.length - 1; k >= 0; k--, j++) {
	      if (carry === 0 && j >= length)
	        break;
	      carry += 256 * b58[k];
	      b58[k] = carry % 58;
	      carry = carry / 58 | 0;
	    }

	    assert(carry === 0);
	    length = j;
	  }

	  i = b58.length - length;
	  while (i < b58.length && b58[i] === 0)
	    i += 1;

	  let str = '';

	  for (let j = 0; j < zeroes; j++)
	    str += '1';

	  for (; i < b58.length; i++)
	    str += CHARSET[b58[i]];

	  return str;
	};

	/**
	 * Decode a base58 string.
	 * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
	 * @param {String} str
	 * @returns {Buffer}
	 * @throws on non-base58 character.
	 */

	base58Browser.decode = function decode(str) {
	  assert(typeof str === 'string');

	  let zeroes = 0;
	  let i = 0;

	  for (; i < str.length; i++) {
	    if (str[i] !== '1')
	      break;
	    zeroes += 1;
	  }

	  const b256 = Buffer$1.allocUnsafe(((str.length * 733) / 1000 | 0) + 1);
	  b256.fill(0);

	  let length = 0;

	  for (; i < str.length; i++) {
	    const ch = str.charCodeAt(i);
	    const v = (ch & 0xff80) ? -1 : TABLE[ch];

	    if (v === -1)
	      throw new Error('Non-base58 character.');

	    let carry = v;
	    let j = 0;

	    for (let k = b256.length - 1; k >= 0; k--, j++) {
	      if (carry === 0 && j >= length)
	        break;
	      carry += 58 * b256[k];
	      b256[k] = carry & 0xff;
	      carry >>>= 8;
	    }

	    assert(carry === 0);
	    length = j;
	  }

	  i = 0;
	  while (i < b256.length && b256[i] === 0)
	    i += 1;

	  const out = Buffer$1.allocUnsafe(zeroes + (b256.length - i));

	  let j;
	  for (j = 0; j < zeroes; j++)
	    out[j] = 0;

	  while (i < b256.length)
	    out[j++] = b256[i++];

	  return out;
	};

	/**
	 * Test whether the string is a base58 string.
	 * @param {String} str
	 * @returns {Buffer}
	 */

	base58Browser.test = function test(str) {
	  if (typeof str !== 'string')
	    return false;

	  for (let i = 0; i < str.length; i++) {
	    const ch = str.charCodeAt(i);

	    if (ch & 0xff80)
	      return false;

	    if (TABLE[ch] === -1)
	      return false;
	  }

	  return true;
	};
	return base58Browser;
}

var hasRequiredBase58;

function requireBase58 () {
	if (hasRequiredBase58) return base58.exports;
	hasRequiredBase58 = 1;

	try {
	  base58.exports = requireBinding().base58;
	} catch (e) {
	  base58.exports = requireBase58Browser();
	}
	return base58.exports;
}

var bech32 = {exports: {}};

var bech32Browser = {};

var hasRequiredBech32Browser;

function requireBech32Browser () {
	if (hasRequiredBech32Browser) return bech32Browser;
	hasRequiredBech32Browser = 1;

	const assert = requireAssert$1();

	/**
	 * Constants
	 */

	const POOL66 = Buffer$1.allocUnsafe(66);
	const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
	const TABLE = [
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
	  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
	   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
	  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
	   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
	];

	/**
	 * Update checksum.
	 * @ignore
	 * @param {Number} chk
	 * @returns {Number}
	 */

	function polymod(pre) {
	  const b = pre >>> 25;
	  return ((pre & 0x1ffffff) << 5)
	    ^ (-((b >>> 0) & 1) & 0x3b6a57b2)
	    ^ (-((b >>> 1) & 1) & 0x26508e6d)
	    ^ (-((b >>> 2) & 1) & 0x1ea119fa)
	    ^ (-((b >>> 3) & 1) & 0x3d4233dd)
	    ^ (-((b >>> 4) & 1) & 0x2a1462b3);
	}

	/**
	 * Encode hrp and data as a bech32 string.
	 * @ignore
	 * @param {String} hrp
	 * @param {Buffer} data
	 * @returns {String}
	 */

	function serialize(hrp, data) {
	  assert(typeof hrp === 'string');
	  assert(Buffer$1.isBuffer(data));

	  let chk = 1;
	  let i;

	  for (i = 0; i < hrp.length; i++) {
	    const ch = hrp.charCodeAt(i);

	    if ((ch & 0xff00) || (ch >>> 5) === 0)
	      throw new Error('Invalid bech32 character.');

	    chk = polymod(chk) ^ (ch >>> 5);
	  }

	  if (i + 7 + data.length > 90)
	    throw new Error('Invalid bech32 data length.');

	  chk = polymod(chk);

	  let str = '';

	  for (let i = 0; i < hrp.length; i++) {
	    const ch = hrp.charCodeAt(i);
	    chk = polymod(chk) ^ (ch & 0x1f);
	    str += hrp[i];
	  }

	  str += '1';

	  for (let i = 0; i < data.length; i++) {
	    const ch = data[i];

	    if ((ch >>> 5) !== 0)
	      throw new Error('Invalid bech32 value.');

	    chk = polymod(chk) ^ ch;
	    str += CHARSET[ch];
	  }

	  for (let i = 0; i < 6; i++)
	    chk = polymod(chk);

	  chk ^= 1;

	  for (let i = 0; i < 6; i++)
	    str += CHARSET[(chk >>> ((5 - i) * 5)) & 0x1f];

	  return str;
	}

	/**
	 * Decode a bech32 string.
	 * @param {String} str
	 * @returns {Array} [hrp, data]
	 */

	function deserialize(str) {
	  assert(typeof str === 'string');

	  if (str.length < 8 || str.length > 90)
	    throw new Error('Invalid bech32 string length.');

	  let dlen = 0;

	  while (dlen < str.length && str[(str.length - 1) - dlen] !== '1')
	    dlen += 1;

	  const hlen = str.length - (1 + dlen);

	  if (1 + dlen >= str.length || dlen < 6)
	    throw new Error('Invalid bech32 data length.');

	  dlen -= 6;

	  const data = Buffer$1.allocUnsafe(dlen);

	  let chk = 1;
	  let lower = false;
	  let upper = false;
	  let hrp = '';

	  for (let i = 0; i < hlen; i++) {
	    let ch = str.charCodeAt(i);

	    if (ch < 0x21 || ch > 0x7e)
	      throw new Error('Invalid bech32 character.');

	    if (ch >= 0x61 && ch <= 0x7a) {
	      lower = true;
	    } else if (ch >= 0x41 && ch <= 0x5a) {
	      upper = true;
	      ch = (ch - 0x41) + 0x61;
	    }

	    hrp += String.fromCharCode(ch);
	    chk = polymod(chk) ^ (ch >>> 5);
	  }

	  chk = polymod(chk);

	  let i;
	  for (i = 0; i < hlen; i++)
	    chk = polymod(chk) ^ (str.charCodeAt(i) & 0x1f);

	  i += 1;

	  while (i < str.length) {
	    const ch = str.charCodeAt(i);
	    const v = (ch & 0xff80) ? -1 : TABLE[ch];

	    if (v === -1)
	      throw new Error('Invalid bech32 character.');

	    if (ch >= 0x61 && ch <= 0x7a)
	      lower = true;
	    else if (ch >= 0x41 && ch <= 0x5a)
	      upper = true;

	    chk = polymod(chk) ^ v;

	    if (i + 6 < str.length)
	      data[i - (1 + hlen)] = v;

	    i += 1;
	  }

	  if (lower && upper)
	    throw new Error('Invalid bech32 casing.');

	  if (chk !== 1)
	    throw new Error('Invalid bech32 checksum.');

	  return [hrp, data.slice(0, dlen)];
	}

	/**
	 * Test whether a string is a bech32 string.
	 * @param {String} str
	 * @returns {Boolean}
	 */

	function is(str) {
	  if (typeof str !== 'string')
	    return false;

	  try {
	    deserialize(str);
	  } catch (e) {
	    return false;
	  }

	  return true;
	}

	/**
	 * Convert serialized data to another base.
	 * @param {Buffer} input
	 * @param {Number} i
	 * @param {Buffer} output
	 * @param {Number} j
	 * @param {Number} frombits
	 * @param {Number} tobits
	 * @param {Boolean} pad
	 * @returns {Buffer}
	 */

	function convert(input, i, output, j, frombits, tobits, pad) {
	  assert(Buffer$1.isBuffer(input));
	  assert((i >>> 0) === i);
	  assert(Buffer$1.isBuffer(output));
	  assert((j >>> 0) === j);
	  assert((frombits & 0xff) === frombits);
	  assert((tobits & 0xff) === tobits);
	  assert(typeof pad === 'boolean');

	  const maxv = (1 << tobits) - 1;

	  let acc = 0;
	  let bits = 0;

	  for (; i < input.length; i++) {
	    const value = input[i];

	    if ((value >>> frombits) !== 0)
	      throw new Error('Invalid bits.');

	    acc = (acc << frombits) | value;
	    bits += frombits;

	    while (bits >= tobits) {
	      bits -= tobits;
	      output[j++] = (acc >>> bits) & maxv;
	    }
	  }

	  if (pad) {
	    if (bits)
	      output[j++] = (acc << (tobits - bits)) & maxv;
	  } else {
	    if (bits >= frombits || ((acc << (tobits - bits)) & maxv))
	      throw new Error('Invalid bits.');
	  }

	  assert(j <= output.length);

	  return output.slice(0, j);
	}

	/**
	 * Calculate size required for bit conversion.
	 * @param {Number} len
	 * @param {Number} frombits
	 * @param {Number} tobits
	 * @param {Boolean} pad
	 * @returns {Number}
	 */

	function convertSize(len, frombits, tobits, pad) {
	  assert((len >>> 0) === len);
	  assert((frombits & 0xff) === frombits);
	  assert((tobits & 0xff) === tobits);
	  assert(typeof pad === 'boolean');
	  assert(tobits !== 0);

	  let size = (len * frombits + (tobits - 1)) / tobits;

	  size >>>= 0;

	  if (pad)
	    size += 1;

	  return size;
	}

	/**
	 * Convert serialized data to another base.
	 * @param {Buffer} data
	 * @param {Number} frombits
	 * @param {Number} tobits
	 * @param {Boolean} pad
	 * @returns {Buffer}
	 */

	function convertBits(data, frombits, tobits, pad) {
	  assert(Buffer$1.isBuffer(data));
	  assert((frombits & 0xff) === frombits);
	  assert((tobits & 0xff) === tobits);
	  assert(typeof pad === 'boolean');

	  const size = convertSize(data.length, frombits, tobits, pad);
	  const out = Buffer$1.allocUnsafe(size);

	  return convert(data, 0, out, 0, frombits, tobits, pad);
	}

	/**
	 * Serialize data to bech32 address.
	 * @param {String} hrp
	 * @param {Number} version
	 * @param {Buffer} hash
	 * @returns {String}
	 */

	function encode(hrp, version, hash) {
	  assert(typeof hrp === 'string');
	  assert((version & 0xff) === version);
	  assert(Buffer$1.isBuffer(hash));

	  if (version < 0 || version > 31)
	    throw new Error('Invalid bech32 version.');

	  if (hash.length < 2 || hash.length > 40)
	    throw new Error('Invalid bech32 data length.');

	  const out = POOL66;
	  out[0] = version;

	  const data = convert(hash, 0, out, 1, 8, 5, true);

	  return serialize(hrp, data);
	}

	/**
	 * Deserialize data from bech32 address.
	 * @param {String} str
	 * @returns {Object}
	 */

	function decode(str) {
	  assert(typeof str === 'string');

	  const [hrp, data] = deserialize(str);

	  if (data.length === 0 || data.length > 65)
	    throw new Error('Invalid bech32 data length.');

	  const version = data[0];

	  if (version > 31)
	    throw new Error('Invalid bech32 version.');

	  const hash = convert(data, 1, data, 0, 5, 8, false);

	  if (hash.length < 2 || hash.length > 40)
	    throw new Error('Invalid bech32 data length.');

	  return new AddrResult(hrp, version, hash);
	}

	/**
	 * Test whether a string is a bech32 string.
	 * @param {String} str
	 * @returns {Boolean}
	 */

	function test(str) {
	  if (typeof str !== 'string')
	    return false;

	  let data;

	  try {
	    [, data] = deserialize(str);
	  } catch (e) {
	    return false;
	  }

	  if (data.length === 0 || data.length > 65)
	    return false;

	  const version = data[0];

	  if (version > 31)
	    return false;

	  return true;
	}

	/**
	 * AddrResult
	 * @constructor
	 * @private
	 * @param {String} hrp
	 * @param {Number} version
	 * @param {Buffer} hash
	 * @property {String} hrp
	 * @property {Number} version
	 * @property {Buffer} hash
	 */

	class AddrResult {
	  constructor(hrp, version, hash) {
	    this.hrp = hrp;
	    this.version = version;
	    this.hash = hash;
	  }
	}

	/*
	 * Expose
	 */

	bech32Browser.serialize = serialize;
	bech32Browser.deserialize = deserialize;
	bech32Browser.is = is;
	bech32Browser.convertBits = convertBits;
	bech32Browser.encode = encode;
	bech32Browser.decode = decode;
	bech32Browser.test = test;
	return bech32Browser;
}

var hasRequiredBech32;

function requireBech32 () {
	if (hasRequiredBech32) return bech32.exports;
	hasRequiredBech32 = 1;

	try {
	  bech32.exports = requireBinding().bech32;
	} catch (e) {
	  bech32.exports = requireBech32Browser();
	}
	return bech32.exports;
}

var cashaddr$1 = {exports: {}};

var cashaddrBrowser = {};

var hasRequiredCashaddrBrowser;

function requireCashaddrBrowser () {
	if (hasRequiredCashaddrBrowser) return cashaddrBrowser;
	hasRequiredCashaddrBrowser = 1;

	const assert = requireAssert$1();

	/**
	 * U64
	 */

	class U64 {
	  constructor(hi, lo) {
	    this.hi = hi | 0;
	    this.lo = lo | 0;
	  }

	  ushrn32(bits) {
	    bits &= 63;

	    let lo = this.lo;

	    if (bits === 0)
	      return lo;

	    if (bits < 32) {
	      lo >>>= bits;
	      lo |= this.hi << (32 - bits);
	    } else {
	      lo = this.hi >>> (bits - 32);
	    }

	    return lo;
	  }
	}

	/**
	 * Constants
	 */

	const POOL105 = Buffer$1.allocUnsafe(105);
	const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

	const TABLE = [
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	  15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,
	  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
	   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,
	  -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,
	   1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1
	];

	const CHECKSUM_MASK = new U64(0x00000007, 0xffffffff);

	const GENERATOR = [
	  new U64(0x00000098, 0xf2bc8e61),
	  new U64(0x00000079, 0xb76d99e2),
	  new U64(0x000000f3, 0x3e5fb3c4),
	  new U64(0x000000ae, 0x2eabe2a8),
	  new U64(0x0000001e, 0x4f43e470)
	];

	/**
	 * Update checksum
	 * @ignore
	 * @param {U64} chk
	 * @param {Number} x
	 * @returns {U64} -- new checksum
	 */

	function polymod(pre, x) {
	  const c = pre;

	  // b = c >> 35
	  const b = c.hi >>> 3;

	  // c = (c & CHECKSUM_MASK) << 5
	  c.hi &= CHECKSUM_MASK.hi;
	  c.lo &= CHECKSUM_MASK.lo;
	  c.hi <<= 5;
	  c.hi |= c.lo >>> 27;
	  c.lo <<= 5;

	  for (let i = 0; i < GENERATOR.length; i++) {
	    if ((b >>> i) & 1) {
	      // c ^= GENERATOR[i]
	      c.hi ^= GENERATOR[i].hi;
	      c.lo ^= GENERATOR[i].lo;
	    }
	  }

	  // c ^= x
	  c.lo ^= x;

	  return c;
	}

	/**
	 * Serialize data to cashaddr.
	 * @param {String} prefix
	 * @param {Buffer} data - 5bit serialized
	 * @returns {String}
	 */

	function serialize(prefix, data) {
	  assert(typeof prefix === 'string');
	  assert(Buffer$1.isBuffer(data));

	  const chk = new U64(0, 1);

	  let str = '';

	  let upper = false;
	  let lower = false;

	  for (let i = 0; i < prefix.length; i++) {
	    let ch = prefix.charCodeAt(i);

	    if ((ch & 0xff00) || (ch >>> 5) === 0)
	      throw new Error('Invalid cashaddr character.');

	    if (ch >= 0x61 && ch <= 0x7a) {
	      lower = true;
	    } else if (ch >= 0x41 && ch <= 0x5a) {
	      upper = true;
	      ch = (ch - 0x41) + 0x61;
	    } else if (ch >= 0x30 && ch <= 0x39) {
	      throw new Error('Invalid cashaddr prefix.');
	    }

	    polymod(chk, ch & 0x1f);

	    str += String.fromCharCode(ch);
	  }

	  if (lower && upper)
	    throw new Error('Invalid cashaddr prefix.');

	  polymod(chk, 0);
	  str += ':';

	  for (let i = 0; i < data.length; i++) {
	    const ch = data[i];

	    if ((ch >>> 5) !== 0)
	      throw new Error('Invalid cashaddr value.');

	    polymod(chk, ch);

	    str += CHARSET[ch];
	  }

	  for (let i = 0; i < 8; i++)
	    polymod(chk, 0);

	  chk.lo ^= 1;

	  for (let i = 0; i < 8; i++) {
	    const v = chk.ushrn32((7 - i) * 5) & 0x1f;

	    str += CHARSET[v];
	  }

	  return str;
	}

	/**
	 * Decode CashAddr string.
	 * @param {String} str
	 * @param {String} defaultPrefix (lowercase and w/o numbers)
	 * @returns {Array} [prefix, data]
	 */

	function deserialize(str, defaultPrefix) {
	  assert(typeof str === 'string');

	  if (str.length < 8 || str.length > 196) // 83 + 1 + 112
	    throw new Error('Invalid cashaddr data length.');

	  let lower = false;
	  let upper = false;
	  let number = false;
	  let plen = 0;

	  // Process lower/upper, make sure we have prefix.
	  for (let i = 0; i < str.length; i++) {
	    const ch = str.charCodeAt(i);

	    if (ch >= 0x61 && ch <= 0x7a) {
	      lower = true;
	      continue;
	    }

	    if (ch >= 0x41 && ch <= 0x5a) {
	      upper = true;
	      continue;
	    }

	    if (ch >= 0x30 && ch <= 0x39) {
	      number = true;
	      continue;
	    }

	    if (ch === 0x3a) { // :
	      if (number || i === 0 || i > 83)
	        throw new Error('Invalid cashaddr prefix.');

	      if (plen !== 0)
	        throw new Error('Invalid cashaddr separators.');

	      plen = i;

	      continue;
	    }

	    throw new Error('Invalid cashaddr character.');
	  }

	  if (upper && lower)
	    throw new Error('Invalid cashaddr casing.');

	  // Process checksum.
	  const chk = new U64(0, 1);

	  let prefix;

	  if (plen === 0) {
	    prefix = defaultPrefix.toLowerCase();
	  } else {
	    prefix = str.substring(0, plen).toLowerCase();
	    plen += 1;
	  }

	  // Process prefix.
	  for (let i = 0; i < prefix.length; i++) {
	    const ch = prefix.charCodeAt(i);

	    polymod(chk, (ch | 0x20) & 0x1f);
	  }

	  polymod(chk, 0);

	  const dlen = str.length - plen;

	  if (dlen <= 8 || dlen > 112)
	    throw new Error('Invalid cashaddr data length.');

	  const data = Buffer$1.allocUnsafe(dlen);

	  for (let i = plen; i < str.length; i++) {
	    const ch = str.charCodeAt(i);
	    const v = (ch & 0xff80) ? -1 : TABLE[ch];

	    if (v === -1)
	      throw new Error('Invalid cashaddr character.');

	    polymod(chk, v);

	    if (i + 8 < str.length)
	      data[i - plen] = v;
	  }

	  const valid = chk.hi === 0 && chk.lo === 1 && prefix === defaultPrefix;

	  if (!valid)
	    throw new Error('Invalid cashaddr checksum.');

	  return [prefix, data.slice(0, -8)];
	}

	/**
	 * Convert serialized data to another base.
	 * @param {Buffer} input
	 * @param {Number} i
	 * @param {Buffer} output
	 * @param {Number} j
	 * @param {Number} frombits
	 * @param {Number} tobits
	 * @param {Boolean} pad
	 * @returns {Buffer}
	 */

	function convert(input, i, output, j, frombits, tobits, pad) {
	  assert(Buffer$1.isBuffer(input));
	  assert((i >>> 0) === i);
	  assert(Buffer$1.isBuffer(output));
	  assert((j >>> 0) === j);
	  assert((frombits & 0xff) === frombits);
	  assert((tobits & 0xff) === tobits);
	  assert(typeof pad === 'boolean');

	  const maxv = (1 << tobits) - 1;

	  let acc = 0;
	  let bits = 0;

	  for (; i < input.length; i++) {
	    const value = input[i];

	    if ((value >>> frombits) !== 0)
	      throw new Error('Invalid bits.');

	    acc = (acc << frombits) | value;
	    bits += frombits;

	    while (bits >= tobits) {
	      bits -= tobits;
	      output[j++] = (acc >>> bits) & maxv;
	    }
	  }

	  if (pad) {
	    if (bits)
	      output[j++] = (acc << (tobits - bits)) & maxv;
	  } else {
	    if (bits >= frombits || ((acc << (tobits - bits)) & maxv))
	      throw new Error('Invalid bits.');
	  }

	  assert(j <= output.length);

	  return output.slice(0, j);
	}

	/**
	 * Get cashaddr encoded size.
	 * @param {Number} size
	 * @returns {Number}
	 */

	function encodedSize(size) {
	  assert((size >>> 0) === size);

	  switch (size) {
	    case 20:
	      return 0;
	    case 24:
	      return 1;
	    case 28:
	      return 2;
	    case 32:
	      return 3;
	    case 40:
	      return 4;
	    case 48:
	      return 5;
	    case 56:
	      return 6;
	    case 64:
	      return 7;
	    default:
	      throw new Error('Non standard length.');
	  }
	}

	/**
	 * Serialize data to cashaddr
	 * @param {String} prefix
	 * @param {Number} type - (0 = P2PKH, 1 = P2SH)
	 * @param {Buffer} hash
	 * @returns {String}
	 */

	function encode(prefix, type, hash) {
	  assert(typeof prefix === 'string');
	  // There are 4 bits available for the version (2 ^ 4 = 16)
	  assert((type & 0x0f) === type, 'Invalid cashaddr type.');
	  assert(Buffer$1.isBuffer(hash));

	  if (prefix.length === 0 || prefix.length > 83)
	    throw new Error('Invalid cashaddr prefix.');

	  const size = encodedSize(hash.length);
	  const data = Buffer$1.allocUnsafe(hash.length + 1);
	  data[0] = (type << 3) | size;
	  hash.copy(data, 1);

	  const output = POOL105;
	  const converted = convert(data, 0, output, 0, 8, 5, true);

	  return serialize(prefix, converted);
	}

	/**
	 * Deserialize data from CashAddr address.
	 * @param {String} str
	 * @param {String} defaultPrefix (lowercase and w/o numbers)
	 * @returns {Object}
	 */

	function decode(str, defaultPrefix = 'bitcoincash') {
	  assert(typeof str === 'string');
	  assert(typeof defaultPrefix === 'string');

	  const [prefix, data] = deserialize(str, defaultPrefix);
	  const extrabits = (data.length * 5) & 7;

	  if (extrabits >= 5)
	    throw new Error('Invalid padding in data.');

	  const last = data[data.length - 1];
	  const mask = (1 << extrabits) - 1;

	  if (last & mask)
	    throw new Error('Non zero padding.');

	  const output = data;
	  const converted = convert(data, 0, output, 0, 5, 8, false);

	  const type = (converted[0] >>> 3) & 0x1f;
	  const hash = converted.slice(1);

	  let size = 20 + 4 * (converted[0] & 0x03);

	  if (converted[0] & 0x04)
	    size *= 2;

	  if (size !== hash.length)
	    throw new Error('Invalid cashaddr data length.');

	  return new AddrResult(prefix, type, hash);
	}

	/**
	 * Test whether a string is a cashaddr string.
	 * @param {String} str
	 * @param {String} defaultPrefix (lowercase and w/o numbers)
	 * @returns {Boolean}
	 */

	function test(str, defaultPrefix = 'bitcoincash') {
	  try {
	    decode(str, defaultPrefix);
	  } catch (e) {
	    return false;
	  }
	  return true;
	}

	/**
	 * AddrResult
	 * @private
	 * @property {String} prefix
	 * @property {Number} type (0 = P2PKH, 1 = P2SH)
	 * @property {Buffer} hash
	 */

	class AddrResult {
	  constructor(prefix, type, hash) {
	    this.prefix = prefix;
	    this.type = type;
	    this.hash = hash;
	  }
	}

	cashaddrBrowser.encode = encode;
	cashaddrBrowser.decode = decode;
	cashaddrBrowser.test = test;
	return cashaddrBrowser;
}

var hasRequiredCashaddr$1;

function requireCashaddr$1 () {
	if (hasRequiredCashaddr$1) return cashaddr$1.exports;
	hasRequiredCashaddr$1 = 1;

	try {
	  cashaddr$1.exports = requireBinding().cashaddr;
	} catch (e) {
	  cashaddr$1.exports = requireCashaddrBrowser();
	}
	return cashaddr$1.exports;
}

/*!
 * bstring
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bstring
 */

var hasRequiredBstring;

function requireBstring () {
	if (hasRequiredBstring) return bstring;
	hasRequiredBstring = 1;

	bstring.base58 = requireBase58();
	bstring.bech32 = requireBech32();
	bstring.cashaddr = requireCashaddr$1();
	return bstring;
}

/**
 * @license
 * https://reviews.bitcoinabc.org
 * Copyright (c) 2017-2020 Emilio Almansi
 * Copyright (c) 2023 Bitcoin ABC
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */

var validation;
var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;

	/**
	 * Validation utility.
	 *
	 * @module validation
	 */

	/**
	 * Error thrown when encoding or decoding fail due to invalid input.
	 *
	 * @constructor ValidationError
	 * @param {string} message Error description.
	 */
	function ValidationError(message) {
	    var error = new Error();
	    this.name = error.name = 'ValidationError';
	    this.message = error.message = message;
	    this.stack = error.stack;
	}

	ValidationError.prototype = Object.create(Error.prototype);

	/**
	 * Validates a given condition, throwing a {@link ValidationError} if
	 * the given condition does not hold.
	 *
	 * @static
	 * @param {boolean} condition Condition to validate.
	 * @param {string} message Error message in case the condition does not hold.
	 */
	function validate(condition, message) {
	    if (!condition) {
	        throw new ValidationError(message);
	    }
	}

	validation = {
	    ValidationError: ValidationError,
	    validate: validate,
	};
	return validation;
}

/**
 * @license
 * https://reviews.bitcoinabc.org
 * Copyright (c) 2017-2020 Emilio Almansi
 * Copyright (c) 2023 Bitcoin ABC
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */

var base32;
var hasRequiredBase32;

function requireBase32 () {
	if (hasRequiredBase32) return base32;
	hasRequiredBase32 = 1;

	var validate = requireValidation().validate;

	/**
	 * Base32 encoding and decoding.
	 *
	 * @module base32
	 */

	/**
	 * Charset containing the 32 symbols used in the base32 encoding.
	 * @private
	 */
	var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

	/**
	 * Inverted index mapping each symbol into its index within the charset.
	 * @private
	 */
	var CHARSET_INVERSE_INDEX = {
	    q: 0,
	    p: 1,
	    z: 2,
	    r: 3,
	    y: 4,
	    9: 5,
	    x: 6,
	    8: 7,
	    g: 8,
	    f: 9,
	    2: 10,
	    t: 11,
	    v: 12,
	    d: 13,
	    w: 14,
	    0: 15,
	    s: 16,
	    3: 17,
	    j: 18,
	    n: 19,
	    5: 20,
	    4: 21,
	    k: 22,
	    h: 23,
	    c: 24,
	    e: 25,
	    6: 26,
	    m: 27,
	    u: 28,
	    a: 29,
	    7: 30,
	    l: 31,
	};

	/**
	 * Encodes the given array of 5-bit integers as a base32-encoded string.
	 *
	 * @static
	 * @param {Uint8Array} data Array of integers between 0 and 31 inclusive.
	 * @returns {string}
	 * @throws {ValidationError}
	 */
	function encode(data) {
	    validate(data instanceof Uint8Array, 'Invalid data: ' + data + '.');
	    var base32 = '';
	    for (var i = 0; i < data.length; ++i) {
	        var value = data[i];
	        validate(0 <= value && value < 32, 'Invalid value: ' + value + '.');
	        base32 += CHARSET[value];
	    }
	    return base32;
	}

	/**
	 * Decodes the given base32-encoded string into an array of 5-bit integers.
	 *
	 * @static
	 * @param {string} string
	 * @returns {Uint8Array}
	 * @throws {ValidationError}
	 */
	function decode(string) {
	    validate(
	        typeof string === 'string',
	        'Invalid base32-encoded string: ' + string + '.',
	    );
	    var data = new Uint8Array(string.length);
	    for (var i = 0; i < string.length; ++i) {
	        var value = string[i];
	        validate(
	            value in CHARSET_INVERSE_INDEX,
	            'Invalid value: ' + value + '.',
	        );
	        data[i] = CHARSET_INVERSE_INDEX[value];
	    }
	    return data;
	}

	base32 = {
	    encode: encode,
	    decode: decode,
	};
	return base32;
}

var BigInteger = {exports: {}};

var hasRequiredBigInteger;

function requireBigInteger () {
	if (hasRequiredBigInteger) return BigInteger.exports;
	hasRequiredBigInteger = 1;
	(function (module) {
		var bigInt = (function (undefined$1) {

		    var BASE = 1e7,
		        LOG_BASE = 7,
		        MAX_INT = 9007199254740992,
		        MAX_INT_ARR = smallToArray(MAX_INT),
		        LOG_MAX_INT = Math.log(MAX_INT);

		    function Integer(v, radix) {
		        if (typeof v === "undefined") return Integer[0];
		        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
		        return parseValue(v);
		    }

		    function BigInteger(value, sign) {
		        this.value = value;
		        this.sign = sign;
		        this.isSmall = false;
		    }
		    BigInteger.prototype = Object.create(Integer.prototype);

		    function SmallInteger(value) {
		        this.value = value;
		        this.sign = value < 0;
		        this.isSmall = true;
		    }
		    SmallInteger.prototype = Object.create(Integer.prototype);

		    function isPrecise(n) {
		        return -9007199254740992 < n && n < MAX_INT;
		    }

		    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
		        if (n < 1e7)
		            return [n];
		        if (n < 1e14)
		            return [n % 1e7, Math.floor(n / 1e7)];
		        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
		    }

		    function arrayToSmall(arr) { // If BASE changes this function may need to change
		        trim(arr);
		        var length = arr.length;
		        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
		            switch (length) {
		                case 0: return 0;
		                case 1: return arr[0];
		                case 2: return arr[0] + arr[1] * BASE;
		                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
		            }
		        }
		        return arr;
		    }

		    function trim(v) {
		        var i = v.length;
		        while (v[--i] === 0);
		        v.length = i + 1;
		    }

		    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
		        var x = new Array(length);
		        var i = -1;
		        while (++i < length) {
		            x[i] = 0;
		        }
		        return x;
		    }

		    function truncate(n) {
		        if (n > 0) return Math.floor(n);
		        return Math.ceil(n);
		    }

		    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
		        var l_a = a.length,
		            l_b = b.length,
		            r = new Array(l_a),
		            carry = 0,
		            base = BASE,
		            sum, i;
		        for (i = 0; i < l_b; i++) {
		            sum = a[i] + b[i] + carry;
		            carry = sum >= base ? 1 : 0;
		            r[i] = sum - carry * base;
		        }
		        while (i < l_a) {
		            sum = a[i] + carry;
		            carry = sum === base ? 1 : 0;
		            r[i++] = sum - carry * base;
		        }
		        if (carry > 0) r.push(carry);
		        return r;
		    }

		    function addAny(a, b) {
		        if (a.length >= b.length) return add(a, b);
		        return add(b, a);
		    }

		    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
		        var l = a.length,
		            r = new Array(l),
		            base = BASE,
		            sum, i;
		        for (i = 0; i < l; i++) {
		            sum = a[i] - base + carry;
		            carry = Math.floor(sum / base);
		            r[i] = sum - carry * base;
		            carry += 1;
		        }
		        while (carry > 0) {
		            r[i++] = carry % base;
		            carry = Math.floor(carry / base);
		        }
		        return r;
		    }

		    BigInteger.prototype.add = function (v) {
		        var n = parseValue(v);
		        if (this.sign !== n.sign) {
		            return this.subtract(n.negate());
		        }
		        var a = this.value, b = n.value;
		        if (n.isSmall) {
		            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
		        }
		        return new BigInteger(addAny(a, b), this.sign);
		    };
		    BigInteger.prototype.plus = BigInteger.prototype.add;

		    SmallInteger.prototype.add = function (v) {
		        var n = parseValue(v);
		        var a = this.value;
		        if (a < 0 !== n.sign) {
		            return this.subtract(n.negate());
		        }
		        var b = n.value;
		        if (n.isSmall) {
		            if (isPrecise(a + b)) return new SmallInteger(a + b);
		            b = smallToArray(Math.abs(b));
		        }
		        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
		    };
		    SmallInteger.prototype.plus = SmallInteger.prototype.add;

		    function subtract(a, b) { // assumes a and b are arrays with a >= b
		        var a_l = a.length,
		            b_l = b.length,
		            r = new Array(a_l),
		            borrow = 0,
		            base = BASE,
		            i, difference;
		        for (i = 0; i < b_l; i++) {
		            difference = a[i] - borrow - b[i];
		            if (difference < 0) {
		                difference += base;
		                borrow = 1;
		            } else borrow = 0;
		            r[i] = difference;
		        }
		        for (i = b_l; i < a_l; i++) {
		            difference = a[i] - borrow;
		            if (difference < 0) difference += base;
		            else {
		                r[i++] = difference;
		                break;
		            }
		            r[i] = difference;
		        }
		        for (; i < a_l; i++) {
		            r[i] = a[i];
		        }
		        trim(r);
		        return r;
		    }

		    function subtractAny(a, b, sign) {
		        var value;
		        if (compareAbs(a, b) >= 0) {
		            value = subtract(a, b);
		        } else {
		            value = subtract(b, a);
		            sign = !sign;
		        }
		        value = arrayToSmall(value);
		        if (typeof value === "number") {
		            if (sign) value = -value;
		            return new SmallInteger(value);
		        }
		        return new BigInteger(value, sign);
		    }

		    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
		        var l = a.length,
		            r = new Array(l),
		            carry = -b,
		            base = BASE,
		            i, difference;
		        for (i = 0; i < l; i++) {
		            difference = a[i] + carry;
		            carry = Math.floor(difference / base);
		            difference %= base;
		            r[i] = difference < 0 ? difference + base : difference;
		        }
		        r = arrayToSmall(r);
		        if (typeof r === "number") {
		            if (sign) r = -r;
		            return new SmallInteger(r);
		        } return new BigInteger(r, sign);
		    }

		    BigInteger.prototype.subtract = function (v) {
		        var n = parseValue(v);
		        if (this.sign !== n.sign) {
		            return this.add(n.negate());
		        }
		        var a = this.value, b = n.value;
		        if (n.isSmall)
		            return subtractSmall(a, Math.abs(b), this.sign);
		        return subtractAny(a, b, this.sign);
		    };
		    BigInteger.prototype.minus = BigInteger.prototype.subtract;

		    SmallInteger.prototype.subtract = function (v) {
		        var n = parseValue(v);
		        var a = this.value;
		        if (a < 0 !== n.sign) {
		            return this.add(n.negate());
		        }
		        var b = n.value;
		        if (n.isSmall) {
		            return new SmallInteger(a - b);
		        }
		        return subtractSmall(b, Math.abs(a), a >= 0);
		    };
		    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

		    BigInteger.prototype.negate = function () {
		        return new BigInteger(this.value, !this.sign);
		    };
		    SmallInteger.prototype.negate = function () {
		        var sign = this.sign;
		        var small = new SmallInteger(-this.value);
		        small.sign = !sign;
		        return small;
		    };

		    BigInteger.prototype.abs = function () {
		        return new BigInteger(this.value, false);
		    };
		    SmallInteger.prototype.abs = function () {
		        return new SmallInteger(Math.abs(this.value));
		    };

		    function multiplyLong(a, b) {
		        var a_l = a.length,
		            b_l = b.length,
		            l = a_l + b_l,
		            r = createArray(l),
		            base = BASE,
		            product, carry, i, a_i, b_j;
		        for (i = 0; i < a_l; ++i) {
		            a_i = a[i];
		            for (var j = 0; j < b_l; ++j) {
		                b_j = b[j];
		                product = a_i * b_j + r[i + j];
		                carry = Math.floor(product / base);
		                r[i + j] = product - carry * base;
		                r[i + j + 1] += carry;
		            }
		        }
		        trim(r);
		        return r;
		    }

		    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
		        var l = a.length,
		            r = new Array(l),
		            base = BASE,
		            carry = 0,
		            product, i;
		        for (i = 0; i < l; i++) {
		            product = a[i] * b + carry;
		            carry = Math.floor(product / base);
		            r[i] = product - carry * base;
		        }
		        while (carry > 0) {
		            r[i++] = carry % base;
		            carry = Math.floor(carry / base);
		        }
		        return r;
		    }

		    function shiftLeft(x, n) {
		        var r = [];
		        while (n-- > 0) r.push(0);
		        return r.concat(x);
		    }

		    function multiplyKaratsuba(x, y) {
		        var n = Math.max(x.length, y.length);

		        if (n <= 30) return multiplyLong(x, y);
		        n = Math.ceil(n / 2);

		        var b = x.slice(n),
		            a = x.slice(0, n),
		            d = y.slice(n),
		            c = y.slice(0, n);

		        var ac = multiplyKaratsuba(a, c),
		            bd = multiplyKaratsuba(b, d),
		            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

		        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
		        trim(product);
		        return product;
		    }

		    // The following function is derived from a surface fit of a graph plotting the performance difference
		    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
		    function useKaratsuba(l1, l2) {
		        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
		    }

		    BigInteger.prototype.multiply = function (v) {
		        var n = parseValue(v),
		            a = this.value, b = n.value,
		            sign = this.sign !== n.sign,
		            abs;
		        if (n.isSmall) {
		            if (b === 0) return Integer[0];
		            if (b === 1) return this;
		            if (b === -1) return this.negate();
		            abs = Math.abs(b);
		            if (abs < BASE) {
		                return new BigInteger(multiplySmall(a, abs), sign);
		            }
		            b = smallToArray(abs);
		        }
		        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
		            return new BigInteger(multiplyKaratsuba(a, b), sign);
		        return new BigInteger(multiplyLong(a, b), sign);
		    };

		    BigInteger.prototype.times = BigInteger.prototype.multiply;

		    function multiplySmallAndArray(a, b, sign) { // a >= 0
		        if (a < BASE) {
		            return new BigInteger(multiplySmall(b, a), sign);
		        }
		        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
		    }
		    SmallInteger.prototype._multiplyBySmall = function (a) {
		        if (isPrecise(a.value * this.value)) {
		            return new SmallInteger(a.value * this.value);
		        }
		        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
		    };
		    BigInteger.prototype._multiplyBySmall = function (a) {
		        if (a.value === 0) return Integer[0];
		        if (a.value === 1) return this;
		        if (a.value === -1) return this.negate();
		        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
		    };
		    SmallInteger.prototype.multiply = function (v) {
		        return parseValue(v)._multiplyBySmall(this);
		    };
		    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

		    function square(a) {
		        //console.assert(2 * BASE * BASE < MAX_INT);
		        var l = a.length,
		            r = createArray(l + l),
		            base = BASE,
		            product, carry, i, a_i, a_j;
		        for (i = 0; i < l; i++) {
		            a_i = a[i];
		            carry = 0 - a_i * a_i;
		            for (var j = i; j < l; j++) {
		                a_j = a[j];
		                product = 2 * (a_i * a_j) + r[i + j] + carry;
		                carry = Math.floor(product / base);
		                r[i + j] = product - carry * base;
		            }
		            r[i + l] = carry;
		        }
		        trim(r);
		        return r;
		    }

		    BigInteger.prototype.square = function () {
		        return new BigInteger(square(this.value), false);
		    };

		    SmallInteger.prototype.square = function () {
		        var value = this.value * this.value;
		        if (isPrecise(value)) return new SmallInteger(value);
		        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
		    };

		    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
		        var a_l = a.length,
		            b_l = b.length,
		            base = BASE,
		            result = createArray(b.length),
		            divisorMostSignificantDigit = b[b_l - 1],
		            // normalization
		            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
		            remainder = multiplySmall(a, lambda),
		            divisor = multiplySmall(b, lambda),
		            quotientDigit, shift, carry, borrow, i, l, q;
		        if (remainder.length <= a_l) remainder.push(0);
		        divisor.push(0);
		        divisorMostSignificantDigit = divisor[b_l - 1];
		        for (shift = a_l - b_l; shift >= 0; shift--) {
		            quotientDigit = base - 1;
		            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
		                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
		            }
		            // quotientDigit <= base - 1
		            carry = 0;
		            borrow = 0;
		            l = divisor.length;
		            for (i = 0; i < l; i++) {
		                carry += quotientDigit * divisor[i];
		                q = Math.floor(carry / base);
		                borrow += remainder[shift + i] - (carry - q * base);
		                carry = q;
		                if (borrow < 0) {
		                    remainder[shift + i] = borrow + base;
		                    borrow = -1;
		                } else {
		                    remainder[shift + i] = borrow;
		                    borrow = 0;
		                }
		            }
		            while (borrow !== 0) {
		                quotientDigit -= 1;
		                carry = 0;
		                for (i = 0; i < l; i++) {
		                    carry += remainder[shift + i] - base + divisor[i];
		                    if (carry < 0) {
		                        remainder[shift + i] = carry + base;
		                        carry = 0;
		                    } else {
		                        remainder[shift + i] = carry;
		                        carry = 1;
		                    }
		                }
		                borrow += carry;
		            }
		            result[shift] = quotientDigit;
		        }
		        // denormalization
		        remainder = divModSmall(remainder, lambda)[0];
		        return [arrayToSmall(result), arrayToSmall(remainder)];
		    }

		    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
		        // Performs faster than divMod1 on larger input sizes.
		        var a_l = a.length,
		            b_l = b.length,
		            result = [],
		            part = [],
		            base = BASE,
		            guess, xlen, highx, highy, check;
		        while (a_l) {
		            part.unshift(a[--a_l]);
		            trim(part);
		            if (compareAbs(part, b) < 0) {
		                result.push(0);
		                continue;
		            }
		            xlen = part.length;
		            highx = part[xlen - 1] * base + part[xlen - 2];
		            highy = b[b_l - 1] * base + b[b_l - 2];
		            if (xlen > b_l) {
		                highx = (highx + 1) * base;
		            }
		            guess = Math.ceil(highx / highy);
		            do {
		                check = multiplySmall(b, guess);
		                if (compareAbs(check, part) <= 0) break;
		                guess--;
		            } while (guess);
		            result.push(guess);
		            part = subtract(part, check);
		        }
		        result.reverse();
		        return [arrayToSmall(result), arrayToSmall(part)];
		    }

		    function divModSmall(value, lambda) {
		        var length = value.length,
		            quotient = createArray(length),
		            base = BASE,
		            i, q, remainder, divisor;
		        remainder = 0;
		        for (i = length - 1; i >= 0; --i) {
		            divisor = remainder * base + value[i];
		            q = truncate(divisor / lambda);
		            remainder = divisor - q * lambda;
		            quotient[i] = q | 0;
		        }
		        return [quotient, remainder | 0];
		    }

		    function divModAny(self, v) {
		        var value, n = parseValue(v);
		        var a = self.value, b = n.value;
		        var quotient;
		        if (b === 0) throw new Error("Cannot divide by zero");
		        if (self.isSmall) {
		            if (n.isSmall) {
		                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
		            }
		            return [Integer[0], self];
		        }
		        if (n.isSmall) {
		            if (b === 1) return [self, Integer[0]];
		            if (b == -1) return [self.negate(), Integer[0]];
		            var abs = Math.abs(b);
		            if (abs < BASE) {
		                value = divModSmall(a, abs);
		                quotient = arrayToSmall(value[0]);
		                var remainder = value[1];
		                if (self.sign) remainder = -remainder;
		                if (typeof quotient === "number") {
		                    if (self.sign !== n.sign) quotient = -quotient;
		                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
		                }
		                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
		            }
		            b = smallToArray(abs);
		        }
		        var comparison = compareAbs(a, b);
		        if (comparison === -1) return [Integer[0], self];
		        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

		        // divMod1 is faster on smaller input sizes
		        if (a.length + b.length <= 200)
		            value = divMod1(a, b);
		        else value = divMod2(a, b);

		        quotient = value[0];
		        var qSign = self.sign !== n.sign,
		            mod = value[1],
		            mSign = self.sign;
		        if (typeof quotient === "number") {
		            if (qSign) quotient = -quotient;
		            quotient = new SmallInteger(quotient);
		        } else quotient = new BigInteger(quotient, qSign);
		        if (typeof mod === "number") {
		            if (mSign) mod = -mod;
		            mod = new SmallInteger(mod);
		        } else mod = new BigInteger(mod, mSign);
		        return [quotient, mod];
		    }

		    BigInteger.prototype.divmod = function (v) {
		        var result = divModAny(this, v);
		        return {
		            quotient: result[0],
		            remainder: result[1]
		        };
		    };
		    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

		    BigInteger.prototype.divide = function (v) {
		        return divModAny(this, v)[0];
		    };
		    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

		    BigInteger.prototype.mod = function (v) {
		        return divModAny(this, v)[1];
		    };
		    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

		    BigInteger.prototype.pow = function (v) {
		        var n = parseValue(v),
		            a = this.value,
		            b = n.value,
		            value, x, y;
		        if (b === 0) return Integer[1];
		        if (a === 0) return Integer[0];
		        if (a === 1) return Integer[1];
		        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
		        if (n.sign) {
		            return Integer[0];
		        }
		        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
		        if (this.isSmall) {
		            if (isPrecise(value = Math.pow(a, b)))
		                return new SmallInteger(truncate(value));
		        }
		        x = this;
		        y = Integer[1];
		        while (true) {
		            if (b & 1 === 1) {
		                y = y.times(x);
		                --b;
		            }
		            if (b === 0) break;
		            b /= 2;
		            x = x.square();
		        }
		        return y;
		    };
		    SmallInteger.prototype.pow = BigInteger.prototype.pow;

		    BigInteger.prototype.modPow = function (exp, mod) {
		        exp = parseValue(exp);
		        mod = parseValue(mod);
		        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
		        var r = Integer[1],
		            base = this.mod(mod);
		        while (exp.isPositive()) {
		            if (base.isZero()) return Integer[0];
		            if (exp.isOdd()) r = r.multiply(base).mod(mod);
		            exp = exp.divide(2);
		            base = base.square().mod(mod);
		        }
		        return r;
		    };
		    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

		    function compareAbs(a, b) {
		        if (a.length !== b.length) {
		            return a.length > b.length ? 1 : -1;
		        }
		        for (var i = a.length - 1; i >= 0; i--) {
		            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
		        }
		        return 0;
		    }

		    BigInteger.prototype.compareAbs = function (v) {
		        var n = parseValue(v),
		            a = this.value,
		            b = n.value;
		        if (n.isSmall) return 1;
		        return compareAbs(a, b);
		    };
		    SmallInteger.prototype.compareAbs = function (v) {
		        var n = parseValue(v),
		            a = Math.abs(this.value),
		            b = n.value;
		        if (n.isSmall) {
		            b = Math.abs(b);
		            return a === b ? 0 : a > b ? 1 : -1;
		        }
		        return -1;
		    };

		    BigInteger.prototype.compare = function (v) {
		        // See discussion about comparison with Infinity:
		        // https://github.com/peterolson/BigInteger.js/issues/61
		        if (v === Infinity) {
		            return -1;
		        }
		        if (v === -Infinity) {
		            return 1;
		        }

		        var n = parseValue(v),
		            a = this.value,
		            b = n.value;
		        if (this.sign !== n.sign) {
		            return n.sign ? 1 : -1;
		        }
		        if (n.isSmall) {
		            return this.sign ? -1 : 1;
		        }
		        return compareAbs(a, b) * (this.sign ? -1 : 1);
		    };
		    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

		    SmallInteger.prototype.compare = function (v) {
		        if (v === Infinity) {
		            return -1;
		        }
		        if (v === -Infinity) {
		            return 1;
		        }

		        var n = parseValue(v),
		            a = this.value,
		            b = n.value;
		        if (n.isSmall) {
		            return a == b ? 0 : a > b ? 1 : -1;
		        }
		        if (a < 0 !== n.sign) {
		            return a < 0 ? -1 : 1;
		        }
		        return a < 0 ? 1 : -1;
		    };
		    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

		    BigInteger.prototype.equals = function (v) {
		        return this.compare(v) === 0;
		    };
		    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

		    BigInteger.prototype.notEquals = function (v) {
		        return this.compare(v) !== 0;
		    };
		    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

		    BigInteger.prototype.greater = function (v) {
		        return this.compare(v) > 0;
		    };
		    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

		    BigInteger.prototype.lesser = function (v) {
		        return this.compare(v) < 0;
		    };
		    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

		    BigInteger.prototype.greaterOrEquals = function (v) {
		        return this.compare(v) >= 0;
		    };
		    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

		    BigInteger.prototype.lesserOrEquals = function (v) {
		        return this.compare(v) <= 0;
		    };
		    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

		    BigInteger.prototype.isEven = function () {
		        return (this.value[0] & 1) === 0;
		    };
		    SmallInteger.prototype.isEven = function () {
		        return (this.value & 1) === 0;
		    };

		    BigInteger.prototype.isOdd = function () {
		        return (this.value[0] & 1) === 1;
		    };
		    SmallInteger.prototype.isOdd = function () {
		        return (this.value & 1) === 1;
		    };

		    BigInteger.prototype.isPositive = function () {
		        return !this.sign;
		    };
		    SmallInteger.prototype.isPositive = function () {
		        return this.value > 0;
		    };

		    BigInteger.prototype.isNegative = function () {
		        return this.sign;
		    };
		    SmallInteger.prototype.isNegative = function () {
		        return this.value < 0;
		    };

		    BigInteger.prototype.isUnit = function () {
		        return false;
		    };
		    SmallInteger.prototype.isUnit = function () {
		        return Math.abs(this.value) === 1;
		    };

		    BigInteger.prototype.isZero = function () {
		        return false;
		    };
		    SmallInteger.prototype.isZero = function () {
		        return this.value === 0;
		    };
		    BigInteger.prototype.isDivisibleBy = function (v) {
		        var n = parseValue(v);
		        var value = n.value;
		        if (value === 0) return false;
		        if (value === 1) return true;
		        if (value === 2) return this.isEven();
		        return this.mod(n).equals(Integer[0]);
		    };
		    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

		    function isBasicPrime(v) {
		        var n = v.abs();
		        if (n.isUnit()) return false;
		        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
		        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
		        if (n.lesser(49)) return true;
		        // we don't know if it's prime: let the other functions figure it out
		    }
		    
		    function millerRabinTest(n, a) {
		        var nPrev = n.prev(),
		            b = nPrev,
		            r = 0,
		            d, i, x;
		        while (b.isEven()) b = b.divide(2), r++;
		        next : for (i = 0; i < a.length; i++) {
		            if (n.lesser(a[i])) continue;
		            x = bigInt(a[i]).modPow(b, n);
		            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
		            for (d = r - 1; d != 0; d--) {
		                x = x.square().mod(n);
		                if (x.isUnit()) return false;    
		                if (x.equals(nPrev)) continue next;
		            }
		            return false;
		        }
		        return true;
		    }
		    
		// Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
		    BigInteger.prototype.isPrime = function (strict) {
		        var isPrime = isBasicPrime(this);
		        if (isPrime !== undefined$1) return isPrime;
		        var n = this.abs();
		        var bits = n.bitLength();
		        if(bits <= 64)
		            return millerRabinTest(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
		        var logN = Math.log(2) * bits;
		        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
		        for (var a = [], i = 0; i < t; i++) {
		            a.push(bigInt(i + 2));
		        }
		        return millerRabinTest(n, a);
		    };
		    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

		    BigInteger.prototype.isProbablePrime = function (iterations) {
		        var isPrime = isBasicPrime(this);
		        if (isPrime !== undefined$1) return isPrime;
		        var n = this.abs();
		        var t = iterations === undefined$1 ? 5 : iterations;
		        for (var a = [], i = 0; i < t; i++) {
		            a.push(bigInt.randBetween(2, n.minus(2)));
		        }
		        return millerRabinTest(n, a);
		    };
		    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

		    BigInteger.prototype.modInv = function (n) {
		        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
		        while (!newR.equals(bigInt.zero)) {
		            q = r.divide(newR);
		            lastT = t;
		            lastR = r;
		            t = newT;
		            r = newR;
		            newT = lastT.subtract(q.multiply(newT));
		            newR = lastR.subtract(q.multiply(newR));
		        }
		        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
		        if (t.compare(0) === -1) {
		            t = t.add(n);
		        }
		        if (this.isNegative()) {
		            return t.negate();
		        }
		        return t;
		    };

		    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

		    BigInteger.prototype.next = function () {
		        var value = this.value;
		        if (this.sign) {
		            return subtractSmall(value, 1, this.sign);
		        }
		        return new BigInteger(addSmall(value, 1), this.sign);
		    };
		    SmallInteger.prototype.next = function () {
		        var value = this.value;
		        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
		        return new BigInteger(MAX_INT_ARR, false);
		    };

		    BigInteger.prototype.prev = function () {
		        var value = this.value;
		        if (this.sign) {
		            return new BigInteger(addSmall(value, 1), true);
		        }
		        return subtractSmall(value, 1, this.sign);
		    };
		    SmallInteger.prototype.prev = function () {
		        var value = this.value;
		        if (value - 1 > -9007199254740992) return new SmallInteger(value - 1);
		        return new BigInteger(MAX_INT_ARR, true);
		    };

		    var powersOfTwo = [1];
		    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
		    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

		    function shift_isSmall(n) {
		        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||
		            (n instanceof BigInteger && n.value.length <= 1);
		    }

		    BigInteger.prototype.shiftLeft = function (n) {
		        if (!shift_isSmall(n)) {
		            throw new Error(String(n) + " is too large for shifting.");
		        }
		        n = +n;
		        if (n < 0) return this.shiftRight(-n);
		        var result = this;
		        if (result.isZero()) return result;
		        while (n >= powers2Length) {
		            result = result.multiply(highestPower2);
		            n -= powers2Length - 1;
		        }
		        return result.multiply(powersOfTwo[n]);
		    };
		    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

		    BigInteger.prototype.shiftRight = function (n) {
		        var remQuo;
		        if (!shift_isSmall(n)) {
		            throw new Error(String(n) + " is too large for shifting.");
		        }
		        n = +n;
		        if (n < 0) return this.shiftLeft(-n);
		        var result = this;
		        while (n >= powers2Length) {
		            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
		            remQuo = divModAny(result, highestPower2);
		            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
		            n -= powers2Length - 1;
		        }
		        remQuo = divModAny(result, powersOfTwo[n]);
		        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
		    };
		    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

		    function bitwise(x, y, fn) {
		        y = parseValue(y);
		        var xSign = x.isNegative(), ySign = y.isNegative();
		        var xRem = xSign ? x.not() : x,
		            yRem = ySign ? y.not() : y;
		        var xDigit = 0, yDigit = 0;
		        var xDivMod = null, yDivMod = null;
		        var result = [];
		        while (!xRem.isZero() || !yRem.isZero()) {
		            xDivMod = divModAny(xRem, highestPower2);
		            xDigit = xDivMod[1].toJSNumber();
		            if (xSign) {
		                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
		            }

		            yDivMod = divModAny(yRem, highestPower2);
		            yDigit = yDivMod[1].toJSNumber();
		            if (ySign) {
		                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
		            }

		            xRem = xDivMod[0];
		            yRem = yDivMod[0];
		            result.push(fn(xDigit, yDigit));
		        }
		        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
		        for (var i = result.length - 1; i >= 0; i -= 1) {
		            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
		        }
		        return sum;
		    }

		    BigInteger.prototype.not = function () {
		        return this.negate().prev();
		    };
		    SmallInteger.prototype.not = BigInteger.prototype.not;

		    BigInteger.prototype.and = function (n) {
		        return bitwise(this, n, function (a, b) { return a & b; });
		    };
		    SmallInteger.prototype.and = BigInteger.prototype.and;

		    BigInteger.prototype.or = function (n) {
		        return bitwise(this, n, function (a, b) { return a | b; });
		    };
		    SmallInteger.prototype.or = BigInteger.prototype.or;

		    BigInteger.prototype.xor = function (n) {
		        return bitwise(this, n, function (a, b) { return a ^ b; });
		    };
		    SmallInteger.prototype.xor = BigInteger.prototype.xor;

		    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -1e7) * (BASE & -1e7) | LOBMASK_I;
		    function roughLOB(n) { // get lowestOneBit (rough)
		        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
		        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
		        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
		        return x & -x;
		    }

		    function integerLogarithm(value, base) {
		        if (base.compareTo(value) <= 0) {
		            var tmp = integerLogarithm(value, base.square(base));
		            var p = tmp.p;
		            var e = tmp.e;
		            var t = p.multiply(base);
		            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
		        }
		        return { p: bigInt(1), e: 0 };
		    }

		    BigInteger.prototype.bitLength = function () {
		        var n = this;
		        if (n.compareTo(bigInt(0)) < 0) {
		            n = n.negate().subtract(bigInt(1));
		        }
		        if (n.compareTo(bigInt(0)) === 0) {
		            return bigInt(0);
		        }
		        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
		    };
		    SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

		    function max(a, b) {
		        a = parseValue(a);
		        b = parseValue(b);
		        return a.greater(b) ? a : b;
		    }
		    function min(a, b) {
		        a = parseValue(a);
		        b = parseValue(b);
		        return a.lesser(b) ? a : b;
		    }
		    function gcd(a, b) {
		        a = parseValue(a).abs();
		        b = parseValue(b).abs();
		        if (a.equals(b)) return a;
		        if (a.isZero()) return b;
		        if (b.isZero()) return a;
		        var c = Integer[1], d, t;
		        while (a.isEven() && b.isEven()) {
		            d = Math.min(roughLOB(a), roughLOB(b));
		            a = a.divide(d);
		            b = b.divide(d);
		            c = c.multiply(d);
		        }
		        while (a.isEven()) {
		            a = a.divide(roughLOB(a));
		        }
		        do {
		            while (b.isEven()) {
		                b = b.divide(roughLOB(b));
		            }
		            if (a.greater(b)) {
		                t = b; b = a; a = t;
		            }
		            b = b.subtract(a);
		        } while (!b.isZero());
		        return c.isUnit() ? a : a.multiply(c);
		    }
		    function lcm(a, b) {
		        a = parseValue(a).abs();
		        b = parseValue(b).abs();
		        return a.divide(gcd(a, b)).multiply(b);
		    }
		    function randBetween(a, b) {
		        a = parseValue(a);
		        b = parseValue(b);
		        var low = min(a, b), high = max(a, b);
		        var range = high.subtract(low).add(1);
		        if (range.isSmall) return low.add(Math.floor(Math.random() * range));
		        var length = range.value.length - 1;
		        var result = [], restricted = true;
		        for (var i = length; i >= 0; i--) {
		            var top = restricted ? range.value[i] : BASE;
		            var digit = truncate(Math.random() * top);
		            result.unshift(digit);
		            if (digit < top) restricted = false;
		        }
		        result = arrayToSmall(result);
		        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
		    }
		    var parseBase = function (text, base) {
		        var length = text.length;
		        var i;
		        var absBase = Math.abs(base);
		        for (var i = 0; i < length; i++) {
		            var c = text[i].toLowerCase();
		            if (c === "-") continue;
		            if (/[a-z0-9]/.test(c)) {
		                if (/[0-9]/.test(c) && +c >= absBase) {
		                    if (c === "1" && absBase === 1) continue;
		                    throw new Error(c + " is not a valid digit in base " + base + ".");
		                } else if (c.charCodeAt(0) - 87 >= absBase) {
		                    throw new Error(c + " is not a valid digit in base " + base + ".");
		                }
		            }
		        }
		        if (2 <= base && base <= 36) {
		            if (length <= LOG_MAX_INT / Math.log(base)) {
		                var result = parseInt(text, base);
		                if (isNaN(result)) {
		                    throw new Error(c + " is not a valid digit in base " + base + ".");
		                }
		                return new SmallInteger(parseInt(text, base));
		            }
		        }
		        base = parseValue(base);
		        var digits = [];
		        var isNegative = text[0] === "-";
		        for (i = isNegative ? 1 : 0; i < text.length; i++) {
		            var c = text[i].toLowerCase(),
		                charCode = c.charCodeAt(0);
		            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
		            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
		            else if (c === "<") {
		                var start = i;
		                do { i++; } while (text[i] !== ">");
		                digits.push(parseValue(text.slice(start + 1, i)));
		            }
		            else throw new Error(c + " is not a valid character");
		        }
		        return parseBaseFromArray(digits, base, isNegative);
		    };

		    function parseBaseFromArray(digits, base, isNegative) {
		        var val = Integer[0], pow = Integer[1], i;
		        for (i = digits.length - 1; i >= 0; i--) {
		            val = val.add(digits[i].times(pow));
		            pow = pow.times(base);
		        }
		        return isNegative ? val.negate() : val;
		    }

		    function stringify(digit) {
		        if (digit <= 35) {
		            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);
		        }
		        return "<" + digit + ">";
		    }

		    function toBase(n, base) {
		        base = bigInt(base);
		        if (base.isZero()) {
		            if (n.isZero()) return { value: [0], isNegative: false };
		            throw new Error("Cannot convert nonzero numbers to base 0.");
		        }
		        if (base.equals(-1)) {
		            if (n.isZero()) return { value: [0], isNegative: false };
		            if (n.isNegative())
		                return {
		                    value: [].concat.apply([], Array.apply(null, Array(-n))
		                        .map(Array.prototype.valueOf, [1, 0])
		                    ),
		                    isNegative: false
		                };

		            var arr = Array.apply(null, Array(+n - 1))
		                .map(Array.prototype.valueOf, [0, 1]);
		            arr.unshift([1]);
		            return {
		                value: [].concat.apply([], arr),
		                isNegative: false
		            };
		        }

		        var neg = false;
		        if (n.isNegative() && base.isPositive()) {
		            neg = true;
		            n = n.abs();
		        }
		        if (base.equals(1)) {
		            if (n.isZero()) return { value: [0], isNegative: false };

		            return {
		                value: Array.apply(null, Array(+n))
		                    .map(Number.prototype.valueOf, 1),
		                isNegative: neg
		            };
		        }
		        var out = [];
		        var left = n, divmod;
		        while (left.isNegative() || left.compareAbs(base) >= 0) {
		            divmod = left.divmod(base);
		            left = divmod.quotient;
		            var digit = divmod.remainder;
		            if (digit.isNegative()) {
		                digit = base.minus(digit).abs();
		                left = left.next();
		            }
		            out.push(digit.toJSNumber());
		        }
		        out.push(left.toJSNumber());
		        return { value: out.reverse(), isNegative: neg };
		    }

		    function toBaseString(n, base) {
		        var arr = toBase(n, base);
		        return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join('');
		    }

		    BigInteger.prototype.toArray = function (radix) {
		        return toBase(this, radix);
		    };

		    SmallInteger.prototype.toArray = function (radix) {
		        return toBase(this, radix);
		    };

		    BigInteger.prototype.toString = function (radix) {
		        if (radix === undefined$1) radix = 10;
		        if (radix !== 10) return toBaseString(this, radix);
		        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
		        while (--l >= 0) {
		            digit = String(v[l]);
		            str += zeros.slice(digit.length) + digit;
		        }
		        var sign = this.sign ? "-" : "";
		        return sign + str;
		    };

		    SmallInteger.prototype.toString = function (radix) {
		        if (radix === undefined$1) radix = 10;
		        if (radix != 10) return toBaseString(this, radix);
		        return String(this.value);
		    };
		    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };

		    BigInteger.prototype.valueOf = function () {
		        return parseInt(this.toString(), 10);
		    };
		    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

		    SmallInteger.prototype.valueOf = function () {
		        return this.value;
		    };
		    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

		    function parseStringValue(v) {
		        if (isPrecise(+v)) {
		            var x = +v;
		            if (x === truncate(x))
		                return new SmallInteger(x);
		            throw new Error("Invalid integer: " + v);
		        }
		        var sign = v[0] === "-";
		        if (sign) v = v.slice(1);
		        var split = v.split(/e/i);
		        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
		        if (split.length === 2) {
		            var exp = split[1];
		            if (exp[0] === "+") exp = exp.slice(1);
		            exp = +exp;
		            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
		            var text = split[0];
		            var decimalPlace = text.indexOf(".");
		            if (decimalPlace >= 0) {
		                exp -= text.length - decimalPlace - 1;
		                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
		            }
		            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
		            text += (new Array(exp + 1)).join("0");
		            v = text;
		        }
		        var isValid = /^([0-9][0-9]*)$/.test(v);
		        if (!isValid) throw new Error("Invalid integer: " + v);
		        var r = [], max = v.length, l = LOG_BASE, min = max - l;
		        while (max > 0) {
		            r.push(+v.slice(min, max));
		            min -= l;
		            if (min < 0) min = 0;
		            max -= l;
		        }
		        trim(r);
		        return new BigInteger(r, sign);
		    }

		    function parseNumberValue(v) {
		        if (isPrecise(v)) {
		            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
		            return new SmallInteger(v);
		        }
		        return parseStringValue(v.toString());
		    }

		    function parseValue(v) {
		        if (typeof v === "number") {
		            return parseNumberValue(v);
		        }
		        if (typeof v === "string") {
		            return parseStringValue(v);
		        }
		        return v;
		    }
		    // Pre-define numbers in range [-999,999]
		    for (var i = 0; i < 1000; i++) {
		        Integer[i] = new SmallInteger(i);
		        if (i > 0) Integer[-i] = new SmallInteger(-i);
		    }
		    // Backwards compatibility
		    Integer.one = Integer[1];
		    Integer.zero = Integer[0];
		    Integer.minusOne = Integer[-1];
		    Integer.max = max;
		    Integer.min = min;
		    Integer.gcd = gcd;
		    Integer.lcm = lcm;
		    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };
		    Integer.randBetween = randBetween;

		    Integer.fromArray = function (digits, base, isNegative) {
		        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
		    };

		    return Integer;
		})();

		// Node.js check
		if (module.hasOwnProperty("exports")) {
		    module.exports = bigInt;
		}
	} (BigInteger));
	return BigInteger.exports;
}

var sha256$1 = {};

var _md = {};

var _assert = {};

var hasRequired_assert;

function require_assert () {
	if (hasRequired_assert) return _assert;
	hasRequired_assert = 1;
	Object.defineProperty(_assert, "__esModule", { value: true });
	_assert.isBytes = isBytes;
	_assert.number = number;
	_assert.bool = bool;
	_assert.bytes = bytes;
	_assert.hash = hash;
	_assert.exists = exists;
	_assert.output = output;
	function number(n) {
	    if (!Number.isSafeInteger(n) || n < 0)
	        throw new Error(`positive integer expected, not ${n}`);
	}
	function bool(b) {
	    if (typeof b !== 'boolean')
	        throw new Error(`boolean expected, not ${b}`);
	}
	// copied from utils
	function isBytes(a) {
	    return (a instanceof Uint8Array ||
	        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
	}
	function bytes(b, ...lengths) {
	    if (!isBytes(b))
	        throw new Error('Uint8Array expected');
	    if (lengths.length > 0 && !lengths.includes(b.length))
	        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
	}
	function hash(h) {
	    if (typeof h !== 'function' || typeof h.create !== 'function')
	        throw new Error('Hash should be wrapped by utils.wrapConstructor');
	    number(h.outputLen);
	    number(h.blockLen);
	}
	function exists(instance, checkFinished = true) {
	    if (instance.destroyed)
	        throw new Error('Hash instance has been destroyed');
	    if (checkFinished && instance.finished)
	        throw new Error('Hash#digest() has already been called');
	}
	function output(out, instance) {
	    bytes(out);
	    const min = instance.outputLen;
	    if (out.length < min) {
	        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
	    }
	}
	const assert = { number, bool, bytes, hash, exists, output };
	_assert.default = assert;
	
	return _assert;
}

var utils$1 = {};

var crypto = {};

var hasRequiredCrypto;

function requireCrypto () {
	if (hasRequiredCrypto) return crypto;
	hasRequiredCrypto = 1;
	Object.defineProperty(crypto, "__esModule", { value: true });
	crypto.crypto = void 0;
	crypto.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
	
	return crypto;
}

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports) {
		/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
		exports.isBytes = isBytes;
		exports.byteSwap32 = byteSwap32;
		exports.bytesToHex = bytesToHex;
		exports.hexToBytes = hexToBytes;
		exports.asyncLoop = asyncLoop;
		exports.utf8ToBytes = utf8ToBytes;
		exports.toBytes = toBytes;
		exports.concatBytes = concatBytes;
		exports.checkOpts = checkOpts;
		exports.wrapConstructor = wrapConstructor;
		exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
		exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
		exports.randomBytes = randomBytes;
		// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
		// node.js versions earlier than v19 don't declare it in global scope.
		// For node.js, package.json#exports field mapping rewrites import
		// from `crypto` to `cryptoNode`, which imports native module.
		// Makes the utils un-importable in browsers without a bundler.
		// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
		const crypto_1 = requireCrypto();
		const _assert_js_1 = /*@__PURE__*/ require_assert();
		// export { isBytes } from './_assert.js';
		// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
		function isBytes(a) {
		    return (a instanceof Uint8Array ||
		        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
		}
		// Cast array to different type
		const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.u8 = u8;
		const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
		exports.u32 = u32;
		// Cast array to view
		const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.createView = createView;
		// The rotate right (circular right shift) operation for uint32
		const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
		exports.rotr = rotr;
		// The rotate left (circular left shift) operation for uint32
		const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
		exports.rotl = rotl;
		exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
		// The byte swap operation for uint32
		const byteSwap = (word) => ((word << 24) & 0xff000000) |
		    ((word << 8) & 0xff0000) |
		    ((word >>> 8) & 0xff00) |
		    ((word >>> 24) & 0xff);
		exports.byteSwap = byteSwap;
		// Conditionally byte swap if on a big-endian platform
		exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
		// In place byte swap for Uint32Array
		function byteSwap32(arr) {
		    for (let i = 0; i < arr.length; i++) {
		        arr[i] = (0, exports.byteSwap)(arr[i]);
		    }
		}
		// Array where index 0xf0 (240) is mapped to string 'f0'
		const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
		/**
		 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
		 */
		function bytesToHex(bytes) {
		    (0, _assert_js_1.bytes)(bytes);
		    // pre-caching improves the speed 6x
		    let hex = '';
		    for (let i = 0; i < bytes.length; i++) {
		        hex += hexes[bytes[i]];
		    }
		    return hex;
		}
		// We use optimized technique to convert hex string to byte array
		const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
		function asciiToBase16(char) {
		    if (char >= asciis._0 && char <= asciis._9)
		        return char - asciis._0;
		    if (char >= asciis._A && char <= asciis._F)
		        return char - (asciis._A - 10);
		    if (char >= asciis._a && char <= asciis._f)
		        return char - (asciis._a - 10);
		    return;
		}
		/**
		 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
		 */
		function hexToBytes(hex) {
		    if (typeof hex !== 'string')
		        throw new Error('hex string expected, got ' + typeof hex);
		    const hl = hex.length;
		    const al = hl / 2;
		    if (hl % 2)
		        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
		    const array = new Uint8Array(al);
		    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		        const n1 = asciiToBase16(hex.charCodeAt(hi));
		        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
		        if (n1 === undefined || n2 === undefined) {
		            const char = hex[hi] + hex[hi + 1];
		            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
		        }
		        array[ai] = n1 * 16 + n2;
		    }
		    return array;
		}
		// There is no setImmediate in browser and setTimeout is slow.
		// call of async fn will return Promise, which will be fullfiled only on
		// next scheduler queue processing step and this is exactly what we need.
		const nextTick = async () => { };
		exports.nextTick = nextTick;
		// Returns control to thread each 'tick' ms to avoid blocking
		async function asyncLoop(iters, tick, cb) {
		    let ts = Date.now();
		    for (let i = 0; i < iters; i++) {
		        cb(i);
		        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
		        const diff = Date.now() - ts;
		        if (diff >= 0 && diff < tick)
		            continue;
		        await (0, exports.nextTick)();
		        ts += diff;
		    }
		}
		/**
		 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
		 */
		function utf8ToBytes(str) {
		    if (typeof str !== 'string')
		        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
		    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
		}
		/**
		 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
		 * Warning: when Uint8Array is passed, it would NOT get copied.
		 * Keep in mind for future mutable operations.
		 */
		function toBytes(data) {
		    if (typeof data === 'string')
		        data = utf8ToBytes(data);
		    (0, _assert_js_1.bytes)(data);
		    return data;
		}
		/**
		 * Copies several Uint8Arrays into one.
		 */
		function concatBytes(...arrays) {
		    let sum = 0;
		    for (let i = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        (0, _assert_js_1.bytes)(a);
		        sum += a.length;
		    }
		    const res = new Uint8Array(sum);
		    for (let i = 0, pad = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        res.set(a, pad);
		        pad += a.length;
		    }
		    return res;
		}
		// For runtime check if class implements interface
		class Hash {
		    // Safe version that clones internal state
		    clone() {
		        return this._cloneInto();
		    }
		}
		exports.Hash = Hash;
		const toStr = {}.toString;
		function checkOpts(defaults, opts) {
		    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
		        throw new Error('Options should be object or undefined');
		    const merged = Object.assign(defaults, opts);
		    return merged;
		}
		function wrapConstructor(hashCons) {
		    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
		    const tmp = hashCons();
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = () => hashCons();
		    return hashC;
		}
		function wrapConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		function wrapXOFConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		/**
		 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
		 */
		function randomBytes(bytesLength = 32) {
		    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
		        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
		    }
		    // Legacy Node.js compatibility
		    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
		        return crypto_1.crypto.randomBytes(bytesLength);
		    }
		    throw new Error('crypto.getRandomValues must be defined');
		}
		
	} (utils$1));
	return utils$1;
}

var hasRequired_md;

function require_md () {
	if (hasRequired_md) return _md;
	hasRequired_md = 1;
	Object.defineProperty(_md, "__esModule", { value: true });
	_md.HashMD = _md.Maj = _md.Chi = void 0;
	const _assert_js_1 = /*@__PURE__*/ require_assert();
	const utils_js_1 = /*@__PURE__*/ requireUtils$1();
	/**
	 * Polyfill for Safari 14
	 */
	function setBigUint64(view, byteOffset, value, isLE) {
	    if (typeof view.setBigUint64 === 'function')
	        return view.setBigUint64(byteOffset, value, isLE);
	    const _32n = BigInt(32);
	    const _u32_max = BigInt(0xffffffff);
	    const wh = Number((value >> _32n) & _u32_max);
	    const wl = Number(value & _u32_max);
	    const h = isLE ? 4 : 0;
	    const l = isLE ? 0 : 4;
	    view.setUint32(byteOffset + h, wh, isLE);
	    view.setUint32(byteOffset + l, wl, isLE);
	}
	/**
	 * Choice: a ? b : c
	 */
	const Chi = (a, b, c) => (a & b) ^ (~a & c);
	_md.Chi = Chi;
	/**
	 * Majority function, true if any two inputs is true
	 */
	const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
	_md.Maj = Maj;
	/**
	 * Merkle-Damgard hash construction base class.
	 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
	 */
	class HashMD extends utils_js_1.Hash {
	    constructor(blockLen, outputLen, padOffset, isLE) {
	        super();
	        this.blockLen = blockLen;
	        this.outputLen = outputLen;
	        this.padOffset = padOffset;
	        this.isLE = isLE;
	        this.finished = false;
	        this.length = 0;
	        this.pos = 0;
	        this.destroyed = false;
	        this.buffer = new Uint8Array(blockLen);
	        this.view = (0, utils_js_1.createView)(this.buffer);
	    }
	    update(data) {
	        (0, _assert_js_1.exists)(this);
	        const { view, buffer, blockLen } = this;
	        data = (0, utils_js_1.toBytes)(data);
	        const len = data.length;
	        for (let pos = 0; pos < len;) {
	            const take = Math.min(blockLen - this.pos, len - pos);
	            // Fast path: we have at least one block in input, cast it to view and process
	            if (take === blockLen) {
	                const dataView = (0, utils_js_1.createView)(data);
	                for (; blockLen <= len - pos; pos += blockLen)
	                    this.process(dataView, pos);
	                continue;
	            }
	            buffer.set(data.subarray(pos, pos + take), this.pos);
	            this.pos += take;
	            pos += take;
	            if (this.pos === blockLen) {
	                this.process(view, 0);
	                this.pos = 0;
	            }
	        }
	        this.length += data.length;
	        this.roundClean();
	        return this;
	    }
	    digestInto(out) {
	        (0, _assert_js_1.exists)(this);
	        (0, _assert_js_1.output)(out, this);
	        this.finished = true;
	        // Padding
	        // We can avoid allocation of buffer for padding completely if it
	        // was previously not allocated here. But it won't change performance.
	        const { buffer, view, blockLen, isLE } = this;
	        let { pos } = this;
	        // append the bit '1' to the message
	        buffer[pos++] = 0b10000000;
	        this.buffer.subarray(pos).fill(0);
	        // we have less than padOffset left in buffer, so we cannot put length in
	        // current block, need process it and pad again
	        if (this.padOffset > blockLen - pos) {
	            this.process(view, 0);
	            pos = 0;
	        }
	        // Pad until full block byte with zeros
	        for (let i = pos; i < blockLen; i++)
	            buffer[i] = 0;
	        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
	        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
	        // So we just write lowest 64 bits of that value.
	        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
	        this.process(view, 0);
	        const oview = (0, utils_js_1.createView)(out);
	        const len = this.outputLen;
	        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
	        if (len % 4)
	            throw new Error('_sha2: outputLen should be aligned to 32bit');
	        const outLen = len / 4;
	        const state = this.get();
	        if (outLen > state.length)
	            throw new Error('_sha2: outputLen bigger than state');
	        for (let i = 0; i < outLen; i++)
	            oview.setUint32(4 * i, state[i], isLE);
	    }
	    digest() {
	        const { buffer, outputLen } = this;
	        this.digestInto(buffer);
	        const res = buffer.slice(0, outputLen);
	        this.destroy();
	        return res;
	    }
	    _cloneInto(to) {
	        to || (to = new this.constructor());
	        to.set(...this.get());
	        const { blockLen, buffer, length, finished, destroyed, pos } = this;
	        to.length = length;
	        to.pos = pos;
	        to.finished = finished;
	        to.destroyed = destroyed;
	        if (length % blockLen)
	            to.buffer.set(buffer);
	        return to;
	    }
	}
	_md.HashMD = HashMD;
	
	return _md;
}

var hasRequiredSha256$1;

function requireSha256$1 () {
	if (hasRequiredSha256$1) return sha256$1;
	hasRequiredSha256$1 = 1;
	Object.defineProperty(sha256$1, "__esModule", { value: true });
	sha256$1.sha224 = sha256$1.sha256 = sha256$1.SHA256 = void 0;
	const _md_js_1 = /*@__PURE__*/ require_md();
	const utils_js_1 = /*@__PURE__*/ requireUtils$1();
	// SHA2-256 need to try 2^128 hashes to execute birthday attack.
	// BTC network is doing 2^67 hashes/sec as per early 2023.
	// Round constants:
	// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
	// prettier-ignore
	const SHA256_K = /* @__PURE__ */ new Uint32Array([
	    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	]);
	// Initial state:
	// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
	// prettier-ignore
	const SHA256_IV = /* @__PURE__ */ new Uint32Array([
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	]);
	// Temporary buffer, not used to store anything between runs
	// Named this way because it matches specification.
	const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
	class SHA256 extends _md_js_1.HashMD {
	    constructor() {
	        super(64, 32, 8, false);
	        // We cannot use array here since array allows indexing by variable
	        // which means optimizer/compiler cannot use registers.
	        this.A = SHA256_IV[0] | 0;
	        this.B = SHA256_IV[1] | 0;
	        this.C = SHA256_IV[2] | 0;
	        this.D = SHA256_IV[3] | 0;
	        this.E = SHA256_IV[4] | 0;
	        this.F = SHA256_IV[5] | 0;
	        this.G = SHA256_IV[6] | 0;
	        this.H = SHA256_IV[7] | 0;
	    }
	    get() {
	        const { A, B, C, D, E, F, G, H } = this;
	        return [A, B, C, D, E, F, G, H];
	    }
	    // prettier-ignore
	    set(A, B, C, D, E, F, G, H) {
	        this.A = A | 0;
	        this.B = B | 0;
	        this.C = C | 0;
	        this.D = D | 0;
	        this.E = E | 0;
	        this.F = F | 0;
	        this.G = G | 0;
	        this.H = H | 0;
	    }
	    process(view, offset) {
	        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
	        for (let i = 0; i < 16; i++, offset += 4)
	            SHA256_W[i] = view.getUint32(offset, false);
	        for (let i = 16; i < 64; i++) {
	            const W15 = SHA256_W[i - 15];
	            const W2 = SHA256_W[i - 2];
	            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
	            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
	            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
	        }
	        // Compression function main loop, 64 rounds
	        let { A, B, C, D, E, F, G, H } = this;
	        for (let i = 0; i < 64; i++) {
	            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
	            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
	            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
	            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
	            H = G;
	            G = F;
	            F = E;
	            E = (D + T1) | 0;
	            D = C;
	            C = B;
	            B = A;
	            A = (T1 + T2) | 0;
	        }
	        // Add the compressed chunk to the current hash value
	        A = (A + this.A) | 0;
	        B = (B + this.B) | 0;
	        C = (C + this.C) | 0;
	        D = (D + this.D) | 0;
	        E = (E + this.E) | 0;
	        F = (F + this.F) | 0;
	        G = (G + this.G) | 0;
	        H = (H + this.H) | 0;
	        this.set(A, B, C, D, E, F, G, H);
	    }
	    roundClean() {
	        SHA256_W.fill(0);
	    }
	    destroy() {
	        this.set(0, 0, 0, 0, 0, 0, 0, 0);
	        this.buffer.fill(0);
	    }
	}
	sha256$1.SHA256 = SHA256;
	// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
	class SHA224 extends SHA256 {
	    constructor() {
	        super();
	        this.A = 0xc1059ed8 | 0;
	        this.B = 0x367cd507 | 0;
	        this.C = 0x3070dd17 | 0;
	        this.D = 0xf70e5939 | 0;
	        this.E = 0xffc00b31 | 0;
	        this.F = 0x68581511 | 0;
	        this.G = 0x64f98fa7 | 0;
	        this.H = 0xbefa4fa4 | 0;
	        this.outputLen = 28;
	    }
	}
	/**
	 * SHA2-256 hash function
	 * @param message - data that would be hashed
	 */
	sha256$1.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
	/**
	 * SHA2-224 hash function
	 */
	sha256$1.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
	
	return sha256$1;
}

var src;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	// base-x encoding / decoding
	// Copyright (c) 2018 base-x contributors
	// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
	// Distributed under the MIT software license, see the accompanying
	// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
	function base (ALPHABET) {
	  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
	  var BASE_MAP = new Uint8Array(256);
	  for (var j = 0; j < BASE_MAP.length; j++) {
	    BASE_MAP[j] = 255;
	  }
	  for (var i = 0; i < ALPHABET.length; i++) {
	    var x = ALPHABET.charAt(i);
	    var xc = x.charCodeAt(0);
	    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
	    BASE_MAP[xc] = i;
	  }
	  var BASE = ALPHABET.length;
	  var LEADER = ALPHABET.charAt(0);
	  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
	  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
	  function encode (source) {
	    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
	      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
	    } else if (Array.isArray(source)) {
	      source = Uint8Array.from(source);
	    }
	    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
	    if (source.length === 0) { return '' }
	        // Skip & count leading zeroes.
	    var zeroes = 0;
	    var length = 0;
	    var pbegin = 0;
	    var pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	      pbegin++;
	      zeroes++;
	    }
	        // Allocate enough space in big-endian base58 representation.
	    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    var b58 = new Uint8Array(size);
	        // Process the bytes.
	    while (pbegin !== pend) {
	      var carry = source[pbegin];
	            // Apply "b58 = b58 * 256 + ch".
	      var i = 0;
	      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
	        carry += (256 * b58[it1]) >>> 0;
	        b58[it1] = (carry % BASE) >>> 0;
	        carry = (carry / BASE) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      pbegin++;
	    }
	        // Skip leading zeroes in base58 result.
	    var it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	      it2++;
	    }
	        // Translate the result into a string.
	    var str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
	    return str
	  }
	  function decodeUnsafe (source) {
	    if (typeof source !== 'string') { throw new TypeError('Expected String') }
	    if (source.length === 0) { return new Uint8Array() }
	    var psz = 0;
	        // Skip and count leading '1's.
	    var zeroes = 0;
	    var length = 0;
	    while (source[psz] === LEADER) {
	      zeroes++;
	      psz++;
	    }
	        // Allocate enough space in big-endian base256 representation.
	    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
	    var b256 = new Uint8Array(size);
	        // Process the characters.
	    while (source[psz]) {
	            // Decode character
	      var carry = BASE_MAP[source.charCodeAt(psz)];
	            // Invalid character
	      if (carry === 255) { return }
	      var i = 0;
	      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
	        carry += (BASE * b256[it3]) >>> 0;
	        b256[it3] = (carry % 256) >>> 0;
	        carry = (carry / 256) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      psz++;
	    }
	        // Skip leading zeroes in b256.
	    var it4 = size - length;
	    while (it4 !== size && b256[it4] === 0) {
	      it4++;
	    }
	    var vch = new Uint8Array(zeroes + (size - it4));
	    var j = zeroes;
	    while (it4 !== size) {
	      vch[j++] = b256[it4++];
	    }
	    return vch
	  }
	  function decode (string) {
	    var buffer = decodeUnsafe(string);
	    if (buffer) { return buffer }
	    throw new Error('Non-base' + BASE + ' character')
	  }
	  return {
	    encode: encode,
	    decodeUnsafe: decodeUnsafe,
	    decode: decode
	  }
	}
	src = base;
	return src;
}

var bs58;
var hasRequiredBs58;

function requireBs58 () {
	if (hasRequiredBs58) return bs58;
	hasRequiredBs58 = 1;
	const basex = requireSrc();
	const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

	bs58 = basex(ALPHABET);
	return bs58;
}

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;

	var base58 = requireBs58();

	base = function (checksumFn) {
	  // Encode a buffer as a base58-check encoded string
	  function encode (payload) {
	    var payloadU8 = Uint8Array.from(payload);
	    var checksum = checksumFn(payloadU8);
	    var length = payloadU8.length + 4;
	    var both = new Uint8Array(length);
	    both.set(payloadU8, 0);
	    both.set(checksum.subarray(0, 4), payloadU8.length);
	    return base58.encode(both, length)
	  }

	  function decodeRaw (buffer) {
	    var payload = buffer.slice(0, -4);
	    var checksum = buffer.slice(-4);
	    var newChecksum = checksumFn(payload);

	    if (checksum[0] ^ newChecksum[0] |
	        checksum[1] ^ newChecksum[1] |
	        checksum[2] ^ newChecksum[2] |
	        checksum[3] ^ newChecksum[3]) return

	    return payload
	  }

	  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
	  function decodeUnsafe (string) {
	    var buffer = base58.decodeUnsafe(string);
	    if (!buffer) return

	    return decodeRaw(buffer)
	  }

	  function decode (string) {
	    var buffer = base58.decode(string);
	    var payload = decodeRaw(buffer);
	    if (!payload) throw new Error('Invalid checksum')
	    return payload
	  }

	  return {
	    encode: encode,
	    decode: decode,
	    decodeUnsafe: decodeUnsafe
	  }
	};
	return base;
}

var bs58check;
var hasRequiredBs58check;

function requireBs58check () {
	if (hasRequiredBs58check) return bs58check;
	hasRequiredBs58check = 1;

	var { sha256 } = /*@__PURE__*/ requireSha256$1();
	var bs58checkBase = requireBase();

	// SHA256(SHA256(buffer))
	function sha256x2 (buffer) {
	  return sha256(sha256(buffer))
	}

	bs58check = bs58checkBase(sha256x2);
	return bs58check;
}

var convertBits;
var hasRequiredConvertBits;

function requireConvertBits () {
	if (hasRequiredConvertBits) return convertBits;
	hasRequiredConvertBits = 1;

	var validate = requireValidation().validate;

	/**
	 * Converts an array of integers made up of 'from' bits into an
	 * array of integers made up of 'to' bits. The output array is
	 * zero-padded if necessary, unless strict mode is true.
	 * Throws a {@link ValidationError} if input is invalid.
	 * Original by Pieter Wuille: https://github.com/sipa/bech32.
	 *
	 * @param {Uint8Array} data Array of integers made up of 'from' bits.
	 * @param {number} from Length in bits of elements in the input array.
	 * @param {number} to Length in bits of elements in the output array.
	 * @param {bool} strictMode Require the conversion to be completed without padding.
	 * @returns {Uint8Array}
	 */
	convertBits = function (data, from, to, strictMode) {
	    var length = strictMode
	        ? Math.floor((data.length * from) / to)
	        : Math.ceil((data.length * from) / to);
	    var mask = (1 << to) - 1;
	    var result = new Uint8Array(length);
	    var index = 0;
	    var accumulator = 0;
	    var bits = 0;
	    for (var i = 0; i < data.length; ++i) {
	        var value = data[i];
	        validate(
	            0 <= value && value >> from === 0,
	            'Invalid value: ' + value + '.',
	        );
	        accumulator = (accumulator << from) | value;
	        bits += from;
	        while (bits >= to) {
	            bits -= to;
	            result[index] = (accumulator >> bits) & mask;
	            ++index;
	        }
	    }
	    if (!strictMode) {
	        if (bits > 0) {
	            result[index] = (accumulator << (to - bits)) & mask;
	            ++index;
	        }
	    } else {
	        validate(
	            bits < from && ((accumulator << (to - bits)) & mask) === 0,
	            'Input cannot be converted to ' +
	                to +
	                ' bits without padding, but strict mode was used.',
	        );
	    }
	    return result;
	};
	return convertBits;
}

var cashaddr;
var hasRequiredCashaddr;

function requireCashaddr () {
	if (hasRequiredCashaddr) return cashaddr;
	hasRequiredCashaddr = 1;

	var base32 = requireBase32();
	var bigInt = requireBigInteger();
	var bs58check = requireBs58check();
	var convertBits = requireConvertBits();
	var validation = requireValidation();
	var validate = validation.validate;

	/**
	 * Encoding and decoding of the new Cash Address format for eCash. <br />
	 * Compliant with the original cashaddr specification:
	 * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}
	 * @module cashaddr
	 */

	/**
	 * Encodes a hash from a given type into an eCash address with the given prefix.
	 *
	 * @static
	 * @param {string} prefix Cash address prefix. E.g.: 'ecash'.
	 * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'. Case-insensitive.
	 * @param {Uint8Array or string} hash Hash to encode represented as an array of 8-bit integers.
	 * @returns {string}
	 * @throws {ValidationError}
	 */
	function encode(prefix, type, hash) {
	    validate(
	        typeof prefix === 'string' && isValidPrefix(prefix),
	        'Invalid prefix: ' + prefix + '.',
	    );
	    validate(typeof type === 'string', 'Invalid type: ' + type + '.');
	    validate(
	        hash instanceof Uint8Array || typeof hash === 'string',
	        'Invalid hash: ' + hash + '. Must be string or Uint8Array.',
	    );
	    if (typeof hash === 'string') {
	        hash = stringToUint8Array(hash);
	    }
	    var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));
	    var versionByte = getTypeBits(type.toUpperCase()) + getHashSizeBits(hash);
	    var payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));
	    var checksumData = concat(
	        concat(prefixData, payloadData),
	        new Uint8Array(8),
	    );
	    var payload = concat(
	        payloadData,
	        checksumToUint5Array(polymod(checksumData)),
	    );
	    return prefix + ':' + base32.encode(payload);
	}

	/**
	 * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.
	 *
	 * @static
	 * @param {string} address Address to decode. E.g.: 'ecash:qpm2qsznhks23z7629mms6s4cwef74vcwva87rkuu2'.
	 * @param {chronikReady} bool Return hash160 as a string, and return type as lowercase. Inputs expected by chronik.
	 * @returns {object}
	 * @throws {ValidationError}
	 */
	function decode(address, chronikReady = false) {
	    validate(
	        typeof address === 'string' && hasSingleCase(address),
	        'Invalid address: ' + address + '.',
	    );
	    var pieces = address.toLowerCase().split(':');
	    // if there is no prefix, it might still be valid
	    let prefix, payload;
	    if (pieces.length === 1) {
	        // Check and see if it has a valid checksum for accepted prefixes
	        let hasValidChecksum = false;
	        for (let i = 0; i < VALID_PREFIXES.length; i += 1) {
	            const testedPrefix = VALID_PREFIXES[i];
	            const prefixlessPayload = base32.decode(pieces[0]);
	            hasValidChecksum = validChecksum(testedPrefix, prefixlessPayload);
	            if (hasValidChecksum) {
	                // Here's your prefix
	                prefix = testedPrefix;
	                payload = prefixlessPayload;
	                // Stop testing other prefixes
	                break;
	            }
	        }
	        validate(
	            hasValidChecksum,
	            `Prefixless address ${address} does not have valid checksum for any valid prefix (${VALID_PREFIXES.join(
	                ', ',
	            )})`,
	        );
	    } else {
	        validate(pieces.length === 2, 'Invalid address: ' + address + '.');
	        prefix = pieces[0];
	        payload = base32.decode(pieces[1]);
	        validate(
	            validChecksum(prefix, payload),
	            'Invalid checksum: ' + address + '.',
	        );
	    }

	    var payloadData = fromUint5Array(payload.subarray(0, -8));
	    var versionByte = payloadData[0];
	    var hash = payloadData.subarray(1);
	    validate(
	        getHashSize(versionByte) === hash.length * 8,
	        'Invalid hash size: ' + address + '.',
	    );
	    var type = getType(versionByte);
	    return {
	        prefix: prefix,
	        type: chronikReady ? type.toLowerCase() : type,
	        hash: chronikReady ? uint8arraytoString(hash) : hash,
	    };
	}

	/**
	 * Error thrown when encoding or decoding fail due to invalid input.
	 *
	 * @constructor ValidationError
	 * @param {string} message Error description.
	 */
	var ValidationError = validation.ValidationError;

	/**
	 * All valid address prefixes.
	 *
	 * @private
	 */
	var VALID_PREFIXES = [
	    'ecash',
	    'bitcoincash',
	    'simpleledger',
	    'etoken',
	    'ectest',
	    'ecregtest',
	    'bchtest',
	    'bchreg',
	];

	/**
	 * Valid mainnet prefixes
	 *
	 * @private
	 */
	var VALID_PREFIXES_MAINNET = ['ecash', 'bitcoincash', 'simpleledger', 'etoken'];

	/**
	 * Checks whether a string is a valid prefix; ie., it has a single letter case
	 * and is one of 'ecash', 'ectest', 'etoken', etc
	 *
	 * @private
	 * @param {string} prefix
	 * @returns {boolean}
	 */
	function isValidPrefix(prefix) {
	    return (
	        hasSingleCase(prefix) &&
	        VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1
	    );
	}

	/**
	 * Derives an array from the given prefix to be used in the computation
	 * of the address' checksum.
	 *
	 * @private
	 * @param {string} prefix Cash address prefix. E.g.: 'ecash'.
	 * @returns {Uint8Array}
	 */
	function prefixToUint5Array(prefix) {
	    var result = new Uint8Array(prefix.length);
	    for (var i = 0; i < prefix.length; ++i) {
	        result[i] = prefix[i].charCodeAt(0) & 31;
	    }
	    return result;
	}

	/**
	 * Returns an array representation of the given checksum to be encoded
	 * within the address' payload.
	 *
	 * @private
	 * @param {BigInteger} checksum Computed checksum.
	 * @returns {Uint8Array}
	 */
	function checksumToUint5Array(checksum) {
	    var result = new Uint8Array(8);
	    for (var i = 0; i < 8; ++i) {
	        result[7 - i] = checksum.and(31).toJSNumber();
	        checksum = checksum.shiftRight(5);
	    }
	    return result;
	}

	/**
	 * Returns the bit representation of the given type within the version
	 * byte.
	 *
	 * @private
	 * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.
	 * @returns {number}
	 * @throws {ValidationError}
	 */
	function getTypeBits(type) {
	    switch (type) {
	        case 'p2pkh':
	        case 'P2PKH':
	            return 0;
	        case 'p2sh':
	        case 'P2SH':
	            return 8;
	        default:
	            throw new ValidationError('Invalid type: ' + type + '.');
	    }
	}

	/**
	 * Retrieves the address type from its bit representation within the
	 * version byte.
	 *
	 * @private
	 * @param {number} versionByte
	 * @returns {string}
	 * @throws {ValidationError}
	 */
	function getType(versionByte) {
	    switch (versionByte & 120) {
	        case 0:
	            return 'P2PKH';
	        case 8:
	            return 'P2SH';
	        default:
	            throw new ValidationError(
	                'Invalid address type in version byte: ' + versionByte + '.',
	            );
	    }
	}

	/**
	 * Returns the bit representation of the length in bits of the given
	 * hash within the version byte.
	 *
	 * @private
	 * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.
	 * @returns {number}
	 * @throws {ValidationError}
	 */
	function getHashSizeBits(hash) {
	    switch (hash.length * 8) {
	        case 160:
	            return 0;
	        case 192:
	            return 1;
	        case 224:
	            return 2;
	        case 256:
	            return 3;
	        case 320:
	            return 4;
	        case 384:
	            return 5;
	        case 448:
	            return 6;
	        case 512:
	            return 7;
	        default:
	            throw new ValidationError(
	                'Invalid hash size: ' + hash.length + '.',
	            );
	    }
	}

	/**
	 * Retrieves the the length in bits of the encoded hash from its bit
	 * representation within the version byte.
	 *
	 * @private
	 * @param {number} versionByte
	 * @returns {number}
	 */
	function getHashSize(versionByte) {
	    switch (versionByte & 7) {
	        case 0:
	            return 160;
	        case 1:
	            return 192;
	        case 2:
	            return 224;
	        case 3:
	            return 256;
	        case 4:
	            return 320;
	        case 5:
	            return 384;
	        case 6:
	            return 448;
	        case 7:
	            return 512;
	    }
	}

	/**
	 * Converts an array of 8-bit integers into an array of 5-bit integers,
	 * right-padding with zeroes if necessary.
	 *
	 * @private
	 * @param {Uint8Array} data
	 * @returns {Uint8Array}
	 */
	function toUint5Array(data) {
	    return convertBits(data, 8, 5);
	}

	/**
	 * Converts an array of 5-bit integers back into an array of 8-bit integers,
	 * removing extra zeroes left from padding if necessary.
	 * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.
	 *
	 * @private
	 * @param {Uint8Array} data
	 * @returns {Uint8Array}
	 * @throws {ValidationError}
	 */
	function fromUint5Array(data) {
	    return convertBits(data, 5, 8, true);
	}

	/**
	 * Returns the concatenation a and b.
	 *
	 * @private
	 * @param {Uint8Array} a
	 * @param {Uint8Array} b
	 * @returns {Uint8Array}
	 * @throws {ValidationError}
	 */
	function concat(a, b) {
	    var ab = new Uint8Array(a.length + b.length);
	    ab.set(a);
	    ab.set(b, a.length);
	    return ab;
	}

	/**
	 * Computes a checksum from the given input data as specified for the CashAddr
	 * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.
	 *
	 * @private
	 * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.
	 * @returns {BigInteger}
	 */
	function polymod(data) {
	    var GENERATOR = [
	        0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470,
	    ];
	    var checksum = bigInt(1);
	    for (var i = 0; i < data.length; ++i) {
	        var value = data[i];
	        var topBits = checksum.shiftRight(35);
	        checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);
	        for (var j = 0; j < GENERATOR.length; ++j) {
	            if (topBits.shiftRight(j).and(1).equals(1)) {
	                checksum = checksum.xor(GENERATOR[j]);
	            }
	        }
	    }
	    return checksum.xor(1);
	}

	/**
	 * Verify that the payload has not been corrupted by checking that the
	 * checksum is valid.
	 *
	 * @private
	 * @param {string} prefix Cash address prefix. E.g.: 'ecash'.
	 * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.
	 * @returns {boolean}
	 */
	function validChecksum(prefix, payload) {
	    var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));
	    var checksumData = concat(prefixData, payload);
	    return polymod(checksumData).equals(0);
	}

	/**
	 * Returns true if, and only if, the given string contains either uppercase
	 * or lowercase letters, but not both.
	 *
	 * @private
	 * @param {string} string Input string.
	 * @returns {boolean}
	 */
	function hasSingleCase(string) {
	    return string === string.toLowerCase() || string === string.toUpperCase();
	}

	/**
	 * Returns a uint8array for a given string input
	 *
	 * @private
	 * @param {string} string Input string.
	 * @returns {Uint8Array}
	 */
	function stringToUint8Array(string) {
	    const buffer = Buffer$1.from(string, 'hex');
	    const arrayBuffer = new ArrayBuffer(buffer.length);
	    const uint8Array = new Uint8Array(arrayBuffer);
	    for (let i = 0; i < uint8Array.length; i += 1) {
	        uint8Array[i] = buffer[i];
	    }
	    return uint8Array;
	}

	/**
	 * Returns a uint8array for a given string input
	 *
	 * @private
	 * @param {Uint8Array} uint8Array Input string.
	 * @returns {string}
	 */
	function uint8arraytoString(uint8Array) {
	    let buffer = [];
	    for (let i = 0; i < uint8Array.length; i += 1) {
	        buffer.push(uint8Array[i]);
	    }
	    const hexBuffer = Buffer$1.from(buffer, 'hex');
	    const string = hexBuffer.toString('hex');
	    return string;
	}

	/**
	 * Get type and hash from an outputScript
	 *
	 * Supported outputScripts:
	 *
	 * P2PKH: 76a914<hash>88ac
	 * P2SH:  a914<hash>87
	 *
	 * Validates for supported outputScript and hash length *
	 *
	 * @private
	 * @param {string} outputScript an ecash tx outputScript
	 * @returns {object}
	 * @throws {ValidationError}
	 */
	function getTypeAndHashFromOutputScript(outputScript) {
	    const p2pkhPrefix = '76a914';
	    const p2pkhSuffix = '88ac';

	    const p2shPrefix = 'a914';
	    const p2shSuffix = '87';

	    let hash, type;

	    // If outputScript begins with '76a914' and ends with '88ac'
	    if (
	        outputScript.slice(0, p2pkhPrefix.length) === p2pkhPrefix &&
	        outputScript.slice(-1 * p2pkhSuffix.length) === p2pkhSuffix
	    ) {
	        // We have type p2pkh
	        type = 'p2pkh';

	        // hash is the string in between '76a194' and '88ac'
	        hash = outputScript.substring(
	            outputScript.indexOf(p2pkhPrefix) + p2pkhPrefix.length,
	            outputScript.lastIndexOf(p2pkhSuffix),
	        );
	        // If outputScript begins with 'a914' and ends with '87'
	    } else if (
	        outputScript.slice(0, p2shPrefix.length) === p2shPrefix &&
	        outputScript.slice(-1 * p2shSuffix.length) === p2shSuffix
	    ) {
	        // We have type p2sh
	        type = 'p2sh';
	        // hash is the string in between 'a914' and '87'
	        hash = outputScript.substring(
	            outputScript.indexOf(p2shPrefix) + p2shPrefix.length,
	            outputScript.lastIndexOf(p2shSuffix),
	        );
	    } else {
	        // Throw validation error if outputScript not of these two types
	        throw new ValidationError('Unsupported outputScript: ' + outputScript);
	    }

	    // Throw validation error if hash is of invalid size
	    // Per spec, valid hash sizes in bytes
	    const VALID_SIZES = [20, 24, 28, 32, 40, 48, 56, 64];

	    if (!VALID_SIZES.includes(hash.length / 2)) {
	        throw new ValidationError(
	            'Invalid hash size in outputScript: ' + outputScript,
	        );
	    }
	    return { type, hash };
	}

	/**
	 * Encodes a given outputScript into an eCash address using the optionally specified prefix.
	 *
	 * @static
	 * @param {string} outputScript an ecash tx outputScript
	 * @param {string} prefix Cash address prefix. E.g.: 'ecash'.
	 * @returns {string}
	 * @throws {ValidationError}
	 */
	function encodeOutputScript(outputScript, prefix = 'ecash') {
	    // Get type and hash from outputScript
	    const { type, hash } = getTypeAndHashFromOutputScript(outputScript);

	    // The encode function validates hash for correct length
	    return encode(prefix, type, hash);
	}

	/**
	 * Converts an ecash address to legacy format
	 *
	 * @static
	 * @param {string} cashaddress a valid p2pkh or p2sh ecash address
	 * @returns {string}
	 * @throws {ValidationError}
	 */
	function toLegacy(cashaddress) {
	    const { prefix, type, hash } = decode(cashaddress);
	    const isMainnet = VALID_PREFIXES_MAINNET.includes(prefix);
	    // Get correct version byte for legacy format
	    let versionByte;
	    switch (type) {
	        case 'P2PKH':
	            versionByte = isMainnet ? 0 : 111;
	            break;
	        case 'P2SH':
	            versionByte = isMainnet ? 5 : 196;
	            break;
	        default:
	            throw new ValidationError('Unsupported address type: ' + type);
	    }
	    var buffer = Buffer$1.alloc(1 + hash.length);
	    buffer[0] = versionByte;
	    buffer.set(hash, 1);
	    return bs58check.encode(buffer);
	}

	/**
	 * Return true for a valid cashaddress
	 * Prefixless addresses with valid checksum are also valid
	 *
	 * @static
	 * @param {string} testedAddress a string tested for cashaddress validity
	 * @param {string} optionalPrefix cashaddr prefix
	 * @returns {bool}
	 * @throws {ValidationError}
	 */
	function isValidCashAddress(cashaddress, optionalPrefix = false) {
	    try {
	        const { prefix } = decode(cashaddress);
	        if (optionalPrefix) {
	            return prefix === optionalPrefix;
	        }
	        return true;
	    } catch (err) {
	        return false;
	    }
	}

	/**
	 * Return true for a valid cashaddress
	 * Prefixless addresses with valid checksum are also valid
	 *
	 * @static
	 * @param {string} address a valid p2pkh or p2sh cash address
	 * @returns {string} the outputScript associated with this address and type
	 * @throws {ValidationError} if decode fails
	 */
	function getOutputScriptFromAddress(address) {
	    const { type, hash } = decode(address, true);
	    let registrationOutputScript;
	    if (type === 'p2pkh') {
	        registrationOutputScript = `76a914${hash}88ac`;
	    } else {
	        registrationOutputScript = `a914${hash}87`;
	    }
	    return registrationOutputScript;
	}

	cashaddr = {
	    encode: encode,
	    decode: decode,
	    uint8arraytoString: uint8arraytoString,
	    encodeOutputScript: encodeOutputScript,
	    getTypeAndHashFromOutputScript: getTypeAndHashFromOutputScript,
	    toLegacy: toLegacy,
	    isValidCashAddress: isValidCashAddress,
	    getOutputScriptFromAddress: getOutputScriptFromAddress,
	    ValidationError: ValidationError,
	};
	return cashaddr;
}

/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var assert_1;
var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert_1;
	hasRequiredAssert = 1;

	/*
	 * Assert
	 */
	function assert(val, msg) {
	  if (!val) {
	    const err = new Error(msg || 'Assertion failed');
	    if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
	    throw err;
	  }
	}

	/*
	 * Expose
	 */

	assert_1 = assert;
	return assert_1;
}

/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */

var hmac;
var hasRequiredHmac;

function requireHmac () {
	if (hasRequiredHmac) return hmac;
	hasRequiredHmac = 1;

	const assert = requireAssert();

	/**
	 * HMAC
	 */

	class HMAC {
	  /**
	   * Create an HMAC.
	   * @param {Function} Hash
	   * @param {Number} size
	   * @param {Array} [x=[]]
	   * @param {Array} [y=[]]
	   */

	  constructor(Hash, size, x = [], y = []) {
	    assert(typeof Hash === 'function');
	    assert(size >>> 0 === size);
	    assert(Array.isArray(x));
	    assert(Array.isArray(y));
	    this.hash = Hash;
	    this.size = size;
	    this.x = x;
	    this.y = y;
	    this.inner = new Hash();
	    this.outer = new Hash();
	  }

	  /**
	   * Initialize HMAC context.
	   * @param {Buffer} data
	   */

	  init(key) {
	    assert(Buffer.isBuffer(key));

	    // Shorten key
	    if (key.length > this.size) {
	      const Hash = this.hash;
	      const h = new Hash();
	      h.init(...this.x);
	      h.update(key);
	      key = h.final(...this.y);
	      assert(key.length <= this.size);
	    }

	    // Pad key
	    const pad = Buffer.alloc(this.size);
	    for (let i = 0; i < key.length; i++) pad[i] = key[i] ^ 0x36;
	    for (let i = key.length; i < pad.length; i++) pad[i] = 0x36;
	    this.inner.init(...this.x);
	    this.inner.update(pad);
	    for (let i = 0; i < key.length; i++) pad[i] = key[i] ^ 0x5c;
	    for (let i = key.length; i < pad.length; i++) pad[i] = 0x5c;
	    this.outer.init(...this.x);
	    this.outer.update(pad);
	    return this;
	  }

	  /**
	   * Update HMAC context.
	   * @param {Buffer} data
	   */

	  update(data) {
	    this.inner.update(data);
	    return this;
	  }

	  /**
	   * Finalize HMAC context.
	   * @returns {Buffer}
	   */

	  final() {
	    this.outer.update(this.inner.final(...this.y));
	    return this.outer.final(...this.y);
	  }
	}

	/*
	 * Expose
	 */

	hmac = HMAC;
	return hmac;
}

/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */

var sha256;
var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256;
	hasRequiredSha256 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);
	PADDING[0] = 0x80;
	const K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);

	/**
	 * SHA256
	 */

	class SHA256 {
	  constructor() {
	    this.state = new Uint32Array(8);
	    this.msg = new Uint32Array(64);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }
	  init() {
	    this.state[0] = 0x6a09e667;
	    this.state[1] = 0xbb67ae85;
	    this.state[2] = 0x3c6ef372;
	    this.state[3] = 0xa54ff53a;
	    this.state[4] = 0x510e527f;
	    this.state[5] = 0x9b05688c;
	    this.state[6] = 0x1f83d9ab;
	    this.state[7] = 0x5be0cd19;
	    this.size = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }
	  final() {
	    return this._final(Buffer.alloc(32));
	  }
	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    let pos = this.size & 63;
	    let off = 0;
	    this.size += len;
	    if (pos > 0) {
	      let want = 64 - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < 64) return;
	      this._transform(this.block, 0);
	    }
	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	  }
	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    const pos = this.size & 63;
	    const len = this.size * 8;
	    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 0);
	    writeU32(DESC, len >>> 0, 4);
	    this._update(PADDING, 1 + (119 - pos & 63));
	    this._update(DESC, 8);
	    for (let i = 0; i < 8; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }
	    for (let i = 0; i < 64; i++) this.msg[i] = 0;
	    for (let i = 0; i < 64; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    return out;
	  }
	  _transform(chunk, pos) {
	    const W = this.msg;
	    let a = this.state[0];
	    let b = this.state[1];
	    let c = this.state[2];
	    let d = this.state[3];
	    let e = this.state[4];
	    let f = this.state[5];
	    let g = this.state[6];
	    let h = this.state[7];
	    let i = 0;
	    for (; i < 16; i++) W[i] = readU32(chunk, pos + i * 4);
	    for (; i < 64; i++) W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];
	    for (i = 0; i < 64; i++) {
	      const t1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];
	      const t2 = Sigma0(a) + Maj(a, b, c);
	      h = g;
	      g = f;
	      f = e;
	      e = d + t1 >>> 0;
	      d = c;
	      c = b;
	      b = a;
	      a = t1 + t2 >>> 0;
	    }
	    this.state[0] += a;
	    this.state[1] += b;
	    this.state[2] += c;
	    this.state[3] += d;
	    this.state[4] += e;
	    this.state[5] += f;
	    this.state[6] += g;
	    this.state[7] += h;
	  }
	  static hash() {
	    return new SHA256();
	  }
	  static hmac() {
	    return new HMAC(SHA256, 64);
	  }
	  static digest(data) {
	    return SHA256.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 32);
	    assert(Buffer.isBuffer(right) && right.length === 32);
	    return SHA256.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = SHA256;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return SHA256.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA256.native = 0;
	SHA256.id = 'SHA256';
	SHA256.size = 32;
	SHA256.bits = 256;
	SHA256.blockSize = 64;
	SHA256.zero = Buffer.alloc(32, 0x00);
	SHA256.ctx = new SHA256();

	/*
	 * Helpers
	 */

	function Sigma0(x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
	}
	function Sigma1(x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
	}
	function sigma0(x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
	}
	function sigma1(x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
	}
	function Ch(x, y, z) {
	  return z ^ x & (y ^ z);
	}
	function Maj(x, y, z) {
	  return x & y | z & (x | y);
	}
	function readU32(data, off) {
	  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
	}
	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha256 = SHA256;
	return sha256;
}

/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */

var ripemd160;
var hasRequiredRipemd160;

function requireRipemd160 () {
	if (hasRequiredRipemd160) return ripemd160;
	hasRequiredRipemd160 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);
	PADDING[0] = 0x80;
	const r = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
	const rh = new Uint8Array([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
	const s = new Uint8Array([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
	const sh = new Uint8Array([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);

	/**
	 * RIPEMD160
	 */

	class RIPEMD160 {
	  constructor() {
	    this.state = new Uint32Array(5);
	    this.msg = new Uint32Array(16);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }
	  init() {
	    this.state[0] = 0x67452301;
	    this.state[1] = 0xefcdab89;
	    this.state[2] = 0x98badcfe;
	    this.state[3] = 0x10325476;
	    this.state[4] = 0xc3d2e1f0;
	    this.size = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }
	  final() {
	    return this._final(Buffer.alloc(20));
	  }
	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    let pos = this.size & 63;
	    let off = 0;
	    this.size += len;
	    if (pos > 0) {
	      let want = 64 - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < 64) return;
	      this._transform(this.block, 0);
	    }
	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	  }
	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    const pos = this.size & 63;
	    const len = this.size * 8;
	    writeU32(DESC, len >>> 0, 0);
	    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 4);
	    this._update(PADDING, 1 + (119 - pos & 63));
	    this._update(DESC, 8);
	    for (let i = 0; i < 5; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }
	    for (let i = 0; i < 16; i++) this.msg[i] = 0;
	    for (let i = 0; i < 64; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    return out;
	  }
	  _transform(chunk, pos) {
	    const W = this.msg;
	    let A = this.state[0];
	    let B = this.state[1];
	    let C = this.state[2];
	    let D = this.state[3];
	    let E = this.state[4];
	    let Ah = A;
	    let Bh = B;
	    let Ch = C;
	    let Dh = D;
	    let Eh = E;
	    for (let i = 0; i < 16; i++) W[i] = readU32(chunk, pos + i * 4);
	    for (let j = 0; j < 80; j++) {
	      let a = A + f(j, B, C, D) + W[r[j]] + K(j);
	      let b = rotl32(a, s[j]);
	      let T = b + E;
	      A = E;
	      E = D;
	      D = rotl32(C, 10);
	      C = B;
	      B = T;
	      a = Ah + f(79 - j, Bh, Ch, Dh) + W[rh[j]] + Kh(j);
	      b = rotl32(a, sh[j]);
	      T = b + Eh;
	      Ah = Eh;
	      Eh = Dh;
	      Dh = rotl32(Ch, 10);
	      Ch = Bh;
	      Bh = T;
	    }
	    const T = this.state[1] + C + Dh;
	    this.state[1] = this.state[2] + D + Eh;
	    this.state[2] = this.state[3] + E + Ah;
	    this.state[3] = this.state[4] + A + Bh;
	    this.state[4] = this.state[0] + B + Ch;
	    this.state[0] = T;
	  }
	  static hash() {
	    return new RIPEMD160();
	  }
	  static hmac() {
	    return new HMAC(RIPEMD160, 64);
	  }
	  static digest(data) {
	    return RIPEMD160.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return RIPEMD160.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = RIPEMD160;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return RIPEMD160.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	RIPEMD160.native = 0;
	RIPEMD160.id = 'RIPEMD160';
	RIPEMD160.size = 20;
	RIPEMD160.bits = 160;
	RIPEMD160.blockSize = 64;
	RIPEMD160.zero = Buffer.alloc(20, 0x00);
	RIPEMD160.ctx = new RIPEMD160();

	/*
	 * Helpers
	 */

	function rotl32(w, b) {
	  return w << b | w >>> 32 - b;
	}
	function f(j, x, y, z) {
	  if (j <= 15) return x ^ y ^ z;
	  if (j <= 31) return x & y | ~x & z;
	  if (j <= 47) return (x | ~y) ^ z;
	  if (j <= 63) return x & z | y & ~z;
	  return x ^ (y | ~z);
	}
	function K(j) {
	  if (j <= 15) return 0x00000000;
	  if (j <= 31) return 0x5a827999;
	  if (j <= 47) return 0x6ed9eba1;
	  if (j <= 63) return 0x8f1bbcdc;
	  return 0xa953fd4e;
	}
	function Kh(j) {
	  if (j <= 15) return 0x50a28be6;
	  if (j <= 31) return 0x5c4dd124;
	  if (j <= 47) return 0x6d703ef3;
	  if (j <= 63) return 0x7a6d76e9;
	  return 0x00000000;
	}
	function readU32(data, off) {
	  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
	}
	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	ripemd160 = RIPEMD160;
	return ripemd160;
}

/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

var hash160;
var hasRequiredHash160;

function requireHash160 () {
	if (hasRequiredHash160) return hash160;
	hasRequiredHash160 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const RIPEMD160 = requireRipemd160();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const rmd = new RIPEMD160();

	/**
	 * Hash160
	 */

	class Hash160 {
	  constructor() {
	    this.ctx = new SHA256();
	  }
	  init() {
	    this.ctx.init();
	    return this;
	  }
	  update(data) {
	    this.ctx.update(data);
	    return this;
	  }
	  final() {
	    const out = Buffer.alloc(32);
	    this.ctx._final(out);
	    rmd.init();
	    rmd.update(out);
	    rmd._final(out);
	    return out.slice(0, 20);
	  }
	  static hash() {
	    return new Hash160();
	  }
	  static hmac() {
	    return new HMAC(Hash160, 64);
	  }
	  static digest(data) {
	    return Hash160.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return Hash160.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = Hash160;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return Hash160.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Hash160.native = 0;
	Hash160.id = 'HASH160';
	Hash160.size = 20;
	Hash160.bits = 160;
	Hash160.blockSize = 64;
	Hash160.zero = Buffer.alloc(20, 0x00);
	Hash160.ctx = new Hash160();

	/*
	 * Expose
	 */

	hash160 = Hash160;
	return hash160;
}

/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

var hash256;
var hasRequiredHash256;

function requireHash256 () {
	if (hasRequiredHash256) return hash256;
	hasRequiredHash256 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const HMAC = requireHmac();

	/**
	 * Hash256
	 */

	class Hash256 {
	  constructor() {
	    this.ctx = new SHA256();
	  }
	  init() {
	    this.ctx.init();
	    return this;
	  }
	  update(data) {
	    this.ctx.update(data);
	    return this;
	  }
	  final() {
	    const out = Buffer.alloc(32);
	    this.ctx._final(out);
	    this.ctx.init();
	    this.ctx.update(out);
	    this.ctx._final(out);
	    return out;
	  }
	  static hash() {
	    return new Hash256();
	  }
	  static hmac() {
	    return new HMAC(Hash256, 64);
	  }
	  static digest(data) {
	    return Hash256.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 32);
	    assert(Buffer.isBuffer(right) && right.length === 32);
	    return Hash256.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = Hash256;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return Hash256.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Hash256.native = 0;
	Hash256.id = 'HASH256';
	Hash256.size = 32;
	Hash256.bits = 256;
	Hash256.blockSize = 64;
	Hash256.zero = Buffer.alloc(32, 0x00);
	Hash256.ctx = new Hash256();

	/*
	 * Expose
	 */

	hash256 = Hash256;
	return hash256;
}

var binary = {};

/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBinary;

function requireBinary () {
	if (hasRequiredBinary) return binary;
	hasRequiredBinary = 1;
	(function (exports) {

		/**
		 * Perform a binary search on a sorted array.
		 * @param {Array} items
		 * @param {Object} key
		 * @param {Function} compare
		 * @param {Boolean?} insert
		 * @returns {Number} Index.
		 */
		exports.search = function search(items, key, compare, insert) {
		  let start = 0;
		  let end = items.length - 1;
		  while (start <= end) {
		    const pos = start + end >>> 1;
		    const cmp = compare(items[pos], key);
		    if (cmp === 0) return pos;
		    if (cmp < 0) start = pos + 1;else end = pos - 1;
		  }
		  if (!insert) return -1;
		  return start;
		};

		/**
		 * Perform a binary insert on a sorted array.
		 * @param {Array} items
		 * @param {Object} item
		 * @param {Function} compare
		 * @returns {Number} index
		 */

		exports.insert = function insert(items, item, compare, uniq) {
		  const i = exports.search(items, item, compare, true);
		  if (uniq && i < items.length) {
		    if (compare(items[i], item) === 0) return -1;
		  }
		  if (i === 0) items.unshift(item);else if (i === items.length) items.push(item);else items.splice(i, 0, item);
		  return i;
		};

		/**
		 * Perform a binary removal on a sorted array.
		 * @param {Array} items
		 * @param {Object} item
		 * @param {Function} compare
		 * @returns {Boolean}
		 */

		exports.remove = function remove(items, item, compare) {
		  const i = exports.search(items, item, compare, false);
		  if (i === -1) return false;
		  splice(items, i);
		  return true;
		};

		/*
		 * Helpers
		 */

		function splice(list, i) {
		  if (i === 0) {
		    list.shift();
		    return;
		  }
		  let k = i + 1;
		  while (k < list.length) list[i++] = list[k++];
		  list.pop();
		} 
	} (binary));
	return binary;
}

var networks = {};

var custom$1 = {};

/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredCustom$1;

function requireCustom$1 () {
	if (hasRequiredCustom$1) return custom$1;
	hasRequiredCustom$1 = 1;

	const {
	  inspect
	} = require$$0$4;
	custom$1.custom = inspect.custom || 'inspect';
	return custom$1;
}

/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */

var bn;
var hasRequiredBn;

function requireBn () {
	if (hasRequiredBn) return bn;
	hasRequiredBn = 1;

	const {
	  custom
	} = requireCustom$1();

	/*
	 * Constants
	 */

	const zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
	const groupSizes = [0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05];
	const groupBases = [0x00000000, 0x02000000, 0x0290d741, 0x01000000, 0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000, 0x0290d741, 0x00989680, 0x012959c3, 0x0222c000, 0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000, 0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000, 0x003e5185, 0x004ea360, 0x006235f7, 0x00798000, 0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00, 0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000, 0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400];
	const primes = {
	  p192: null,
	  p224: null,
	  p521: null,
	  k256: null,
	  p251: null,
	  p25519: null,
	  p448: null
	};
	const modes = {
	  NONE: 0,
	  QUO: 1,
	  REM: 2,
	  BOTH: 3,
	  EUCLID: 4,
	  ALL: 7
	};
	const WND_WIDTH = 4;
	const WND_SIZE = 1 << WND_WIDTH - 1;
	const HAS_BIGINT = typeof BigInt === 'function';

	/**
	 * BN
	 */

	class BN {
	  constructor(num, base, endian) {
	    this.words = [0];
	    this.length = 1;
	    this.negative = 0;
	    this.red = null;
	    this.from(num, base, endian);
	  }

	  /*
	   * Addition Engine
	   */

	  _iadd(a, b) {
	    let carry = 0;
	    let i = 0;

	    // a.length > b.length
	    if (a.length < b.length) [a, b] = [b, a];
	    if (a !== this) this._alloc(a.length);
	    for (; i < b.length; i++) {
	      const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      const r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    this.length = a.length;
	    if (carry !== 0) {
	      this._alloc(this.length + 1);
	      this.words[this.length++] = carry;
	    } else if (a !== this) {
	      // Copy the rest of the words.
	      for (; i < a.length; i++) this.words[i] = a.words[i];
	    }

	    // Note: we shouldn't need to strip here.
	    return this;
	  }
	  _iaddn(num) {
	    this.words[0] += num;
	    if (this.words[0] < 0x4000000) return this;

	    // Carry.
	    let i = 0;
	    this._alloc(this.length + 1);
	    this.words[this.length] = 0;
	    for (; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      this.words[i + 1] += 1;
	    }
	    this.length = Math.max(this.length, i + 1);

	    // Note: we shouldn't need to strip here.
	    return this;
	  }

	  /*
	   * Addition
	   */

	  iadd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.negative === num.negative) {
	      // x + y == x + y
	      // (-x) + (-y) == -(x + y)
	      this._iadd(this, num);
	    } else {
	      // x + (-y) == x - y == -(y - x)
	      // (-x) + y == y - x == -(x - y)
	      const cmp = this.ucmp(num);

	      // x + (-x) == (-x) + x == 0
	      if (cmp === 0) {
	        this.words[0] = 0;
	        this.length = 1;
	        this.negative = 0;
	        return this;
	      }
	      if (cmp < 0) {
	        this._isub(num, this);
	        this.negative ^= 1;
	      } else {
	        this._isub(this, num);
	      }
	    }
	    return this;
	  }
	  iaddn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    const negative = num < 0 | 0;
	    if (negative) num = -num;
	    if (this.negative === negative) {
	      // x + y == x + y
	      // (-x) + (-y) == -(x + y)
	      this._iaddn(num);
	    } else {
	      // x + (-y) == x - y == -(y - x)
	      // (-x) + y == y - x == -(x - y)
	      if (this.length === 1 && this.words[0] < num) {
	        this.words[0] = num - this.words[0];
	        this.negative ^= 1;
	      } else {
	        this._isubn(num);
	      }
	    }
	    return this;
	  }
	  add(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (num.length > this.length) return num.clone().iadd(this);
	    return this.clone().iadd(num);
	  }
	  addn(num) {
	    return this.clone().iaddn(num);
	  }

	  /*
	   * Subtraction Engine
	   */

	  _isub(a, b) {
	    let carry = 0;
	    let i = 0;

	    // a > b
	    assert(a.length >= b.length);
	    if (a !== this) this._alloc(a.length);
	    for (; i < b.length; i++) {
	      const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      const r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    assert(carry === 0);

	    // Copy rest of the words.
	    if (a !== this) {
	      for (; i < a.length; i++) this.words[i] = a.words[i];
	    }
	    this.length = Math.max(this.length, i);
	    return this._strip();
	  }
	  _isubn(num) {
	    this.words[0] -= num;
	    if (this.words[0] >= 0) return this._normalize();
	    assert(this.length !== 1);

	    // Carry.
	    this._alloc(this.length + 1);
	    for (let i = 0; i < this.length && this.words[i] < 0; i++) {
	      this.words[i] += 0x4000000;
	      this.words[i + 1] -= 1;
	    }
	    this.words[this.length] = 0;
	    return this._strip();
	  }

	  /*
	   * Subtraction
	   */

	  isub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.negative !== num.negative) {
	      // x - (-y) == x + y
	      // (-x) - y == -(x + y)
	      this._iadd(this, num);
	    } else {
	      // x - y == x - y == -(y - x)
	      // (-x) - (-y) == y - x == -(x - y)
	      const cmp = this.ucmp(num);

	      // x - x == 0
	      if (cmp === 0) {
	        this.words[0] = 0;
	        this.length = 1;
	        this.negative = 0;
	        return this;
	      }
	      if (cmp < 0) {
	        this._isub(num, this);
	        this.negative ^= 1;
	      } else {
	        this._isub(this, num);
	      }
	    }
	    return this;
	  }
	  isubn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    const negative = num < 0 | 0;
	    if (negative) num = -num;
	    if (this.negative !== negative) {
	      // x - (-y) == x + y
	      // (-x) - y == -(x + y)
	      this._iaddn(num);
	    } else {
	      // x - y == x - y == -(y - x)
	      // (-x) - (-y) == y - x == -(x - y)
	      if (this.length === 1 && this.words[0] < num) {
	        this.words[0] = num - this.words[0];
	        this.negative ^= 1;
	      } else {
	        this._isubn(num);
	      }
	    }
	    return this;
	  }
	  sub(num) {
	    return this.clone().isub(num);
	  }
	  subn(num) {
	    return this.clone().isubn(num);
	  }

	  /*
	   * Multiplication Engine
	   */

	  _mul(num, out) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    enforce(BN.isBN(out), 'out', 'bignum');
	    if (this.length === 10 && num.length === 10) return comb10MulTo(this, num, out);
	    const len = this.length + num.length;
	    if (len < 63) return smallMulTo(this, num, out);
	    if (len < 1024) return bigMulTo(this, num, out);
	    return jumboMulTo(this, num, out);
	  }

	  /*
	   * Multiplication
	   */

	  imul(num) {
	    return this.mul(num)._move(this);
	  }
	  imuln(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    const neg = num < 0 | 0;
	    if (neg) num = -num;

	    // Carry.
	    let carry = 0;
	    for (let i = 0; i < this.length; i++) {
	      const w = this.words[i] * num;
	      const lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += w / 0x4000000 | 0;
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }
	    this.negative ^= neg;
	    if (carry !== 0) {
	      this._alloc(this.length + 1);
	      this.words[this.length++] = carry;
	    } else {
	      this._strip();
	    }
	    return this;
	  }
	  mul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    const len = this.length + num.length;
	    const out = new BN();
	    out.words = new Array(len);
	    for (let i = 0; i < len; i++) out.words[i] = 0;
	    return this._mul(num, out);
	  }
	  muln(num) {
	    return this.clone().imuln(num);
	  }

	  /*
	   * Multiplication + Shift
	   */

	  mulShift(num, bits) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    const r = this.mul(num);
	    const b = r.utestn(bits - 1);
	    r.iushrn(bits);
	    if (this.negative ^ num.negative) return r.isubn(b);
	    return r.iaddn(b);
	  }

	  /*
	   * Division Engine
	   */

	  _div(num, flags) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    assert((flags & modes.ALL) === flags);
	    assert(flags !== modes.NONE);
	    const a = this;
	    const b = num;
	    nonzero(!b.isZero());
	    if (a.isZero()) return [new BN(0), new BN(0)];
	    const as = a.negative;
	    const bs = b.negative;
	    a.negative = 0;
	    b.negative = 0;
	    let q = null;
	    let r = null;
	    if (a.ucmp(b) < 0) {
	      if (flags & modes.QUO) q = new BN(0);
	      if (flags & modes.REM) r = a.clone();
	    } else if (b.length === 1) {
	      if (flags & modes.QUO) q = a.quon(b.words[0]);
	      if (flags & modes.REM) r = a.remn(b.words[0]);
	    } else {
	      [q, r] = a._wordDiv(b, flags);
	    }
	    a.negative = as;
	    b.negative = bs;
	    if (flags & modes.QUO) {
	      q.negative = a.negative ^ b.negative;
	      q._normalize();
	    }
	    if (flags & modes.REM) {
	      r.negative = a.negative;
	      r._normalize();
	    }
	    if (flags & modes.EUCLID) {
	      if (flags & modes.QUO) {
	        assert((flags & modes.REM) !== 0);
	        if (r.negative !== 0) {
	          if (b.negative !== 0) q.iaddn(1);else q.isubn(1);
	        }
	      }
	      if (flags & modes.REM) {
	        if (r.negative !== 0) {
	          if (b.negative !== 0) r.isub(b);else r.iadd(b);
	        }
	      }
	    }
	    return [q, r];
	  }
	  _wordDiv(num, flags) {
	    let a = this.clone();
	    let b = num;
	    let q = null;
	    let hi;

	    // Normalize.
	    const word = b.words[b.length - 1] | 0;
	    const shift = 26 - countBits(word);
	    if (shift !== 0) {
	      b = b.clone();
	      a.iushln(shift);
	      b.iushln(shift);
	      hi = b.words[b.length - 1] | 0;
	    } else {
	      hi = word;
	    }

	    // Initialize quotient.
	    const m = a.length - b.length;
	    assert(m >= 0);
	    if (flags & modes.QUO) {
	      q = new BN(0);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (let i = 0; i < q.length; i++) q.words[i] = 0;
	    }

	    // Diff.
	    const d = a.clone();
	    d._ishlnsubmul(b, 1, m);
	    if (d.negative === 0) {
	      if (q) q.words[m] = 1;
	      a = d;
	    }

	    // Divide.
	    for (let j = m - 1; j >= 0; j--) {
	      const ahi = a.words[b.length + j];
	      const alo = a.words[b.length + j - 1];
	      const quo = (ahi * 0x4000000 + alo) / hi | 0;
	      let qj = Math.min(quo, 0x3ffffff);
	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj -= 1;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        a.ineg();
	      }
	      if (q) q.words[j] = qj;
	    }

	    // Strip.
	    if (q) q._strip();

	    // Denormalize.
	    // Note: we shouldn't need to strip `a` here.
	    if (flags & modes.REM && shift !== 0) a.iushrn(shift);
	    return [q, a];
	  }
	  _ishlnsubmul(num, mul, shift) {
	    let carry = 0;
	    let i = 0;
	    this._expand(num.length + shift);
	    for (; i < num.length; i++) {
	      const k = (this.words[i + shift] | 0) + carry;
	      const r = num.words[i] * mul;
	      const w = k - (r & 0x3ffffff);
	      carry = (w >> 26) - (r / 0x4000000 | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      const w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    if (carry === 0) return this._strip();

	    // Subtraction overflow.
	    assert(carry === -1);
	    carry = 0;
	    for (let i = 0; i < this.length; i++) {
	      const w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;
	    return this._strip();
	  }

	  /*
	   * Truncation Division + Modulo
	   */

	  quorem(num) {
	    return this._div(num, modes.BOTH);
	  }

	  /*
	   * Truncation Division
	   */

	  iquo(num) {
	    return this.quo(num)._move(this);
	  }
	  iquon(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    nonzero(num !== 0);
	    const neg = num < 0 | 0;
	    if (neg) num = -num;
	    let carry = 0;
	    for (let i = this.length - 1; i >= 0; i--) {
	      const w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = w / num | 0;
	      carry = w % num;
	    }
	    this.negative ^= neg;
	    return this._strip();
	  }
	  quo(num) {
	    return this._div(num, modes.QUO)[0];
	  }
	  quon(num) {
	    return this.clone().iquon(num);
	  }

	  /*
	   * Truncation Modulo
	   */

	  irem(num) {
	    return this.rem(num)._move(this);
	  }
	  iremn(num) {
	    let m = this.remrn(num);
	    if (m < 0) m = -m;
	    this.words[0] = m;
	    this.length = 1;
	    return this._normalize();
	  }
	  rem(num) {
	    return this._div(num, modes.REM)[1];
	  }
	  remn(num) {
	    return this.clone().iremn(num);
	  }
	  remrn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    nonzero(num !== 0);
	    if (num < 0) num = -num;
	    const p = (1 << 26) % num;
	    let acc = 0;
	    for (let i = this.length - 1; i >= 0; i--) acc = (p * acc + (this.words[i] | 0)) % num;
	    return this.negative !== 0 ? -acc | 0 : acc;
	  }

	  /*
	   * Euclidean Division + Modulo
	   */

	  divmod(num) {
	    return this._div(num, modes.BOTH | modes.EUCLID);
	  }

	  /*
	   * Euclidean Division
	   */

	  idiv(num) {
	    return this.div(num)._move(this);
	  }
	  idivn(num) {
	    if (this.negative === 0) return this.iquon(num);
	    const r = this.remrn(num);
	    this.iquon(num);
	    if (r < 0) {
	      if (num < 0) this.iaddn(1);else this.isubn(1);
	    }
	    return this;
	  }
	  div(num) {
	    return this._div(num, modes.BOTH | modes.EUCLID)[0];
	  }
	  divn(num) {
	    return this.clone().idivn(num);
	  }

	  /*
	   * Euclidean Modulo
	   */

	  imod(num) {
	    if (this.ucmp(num) < 0) {
	      if (this.negative !== 0) {
	        this._isub(num, this);
	        this.negative = 0;
	      }
	      return this;
	    }
	    return this.mod(num)._move(this);
	  }
	  imodn(num) {
	    this.words[0] = this.modrn(num);
	    this.length = 1;
	    this.negative = 0;
	    return this;
	  }
	  mod(num) {
	    return this._div(num, modes.REM | modes.EUCLID)[1];
	  }
	  modn(num) {
	    return this.clone().imodn(num);
	  }
	  modrn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    let r = this.remrn(num);
	    if (r < 0) {
	      if (num < 0) r -= num;else r += num;
	    }
	    return r;
	  }

	  /*
	   * Round Division
	   */

	  divRound(num) {
	    const [q, r] = this.quorem(num);

	    // Fast case - exact division.
	    if (r.isZero()) return q;
	    const bit = num.words[0] & 1;
	    num.iushrn(1);
	    const cmp = r.ucmp(num);
	    num.iushln(1);
	    num.words[0] |= bit;

	    // Round down.
	    if (cmp < 0 || num.isOdd() && cmp === 0) return q;

	    // Round up.
	    if (this.negative ^ num.negative) return q.isubn(1);
	    return q.iaddn(1);
	  }

	  /*
	   * Exponentiation
	   */

	  ipow(num) {
	    return this.pow(num)._move(this);
	  }
	  ipown(num) {
	    return this.pown(num)._move(this);
	  }
	  pow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    let b = countBits(num.words[num.length - 1]);
	    let r = new BN(1);
	    for (let i = num.length - 1; i >= 0; i--) {
	      const word = num.words[i];
	      for (let j = b - 1; j >= 0; j--) {
	        r = r.sqr();
	        if (word >> j & 1) r = r.mul(this);
	      }
	      b = 26;
	    }
	    return r;
	  }
	  pown(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if (num < 0) num = -num;
	    if (num === 0) return new BN(1);
	    if (num === 1) return this.clone();
	    const bits = countBits(num);
	    let r = this;
	    for (let i = bits - 2; i >= 0; i--) {
	      r = r.sqr();
	      if (num >> i & 1) r = r.mul(this);
	    }
	    return r;
	  }
	  isqr() {
	    return this.imul(this);
	  }
	  sqr() {
	    return this.mul(this);
	  }

	  /*
	   * Roots Engine
	   */

	  _rootrem(pow, rem) {
	    enforce(pow >>> 0 === pow, 'num', 'uint32');
	    if (pow === 0) throw new RangeError('Zeroth root.');
	    if (~pow & this.negative) throw new RangeError('Negative with even root.');
	    if (this.ucmpn(1) <= 0) return [this.clone(), new BN(0)];
	    let u = new BN(0);
	    let t = BN.shift(1, this.bitLength() / pow + 1 | 0);
	    let v, r;
	    if (this.negative !== 0) t.ineg();
	    if (pow === 2) {
	      do {
	        u = t;
	        t = this.quo(u);
	        t.iadd(u);
	        t.iushrn(1);
	      } while (t.ucmp(u) < 0);
	    } else {
	      do {
	        u = t;
	        t = u.pown(pow - 1);
	        t = this.quo(t);
	        v = u.muln(pow - 1);
	        t.iadd(v);
	        t = t.quon(pow);
	      } while (t.ucmp(u) < 0);
	    }
	    if (rem) {
	      t = u.pown(pow);
	      r = this.sub(t);
	    }
	    return [u, r];
	  }

	  /*
	   * Roots
	   */

	  rootrem(pow) {
	    return this._rootrem(pow, 1);
	  }
	  iroot(pow) {
	    return this.root(pow)._move(this);
	  }
	  root(pow) {
	    return this._rootrem(pow, 0)[0];
	  }
	  isPower(pow) {
	    enforce(pow >>> 0 === pow, 'num', 'uint32');
	    if (pow === 0 || ~pow & this.negative) return false;
	    const [, r] = this.rootrem(pow);
	    return r.sign() === 0;
	  }
	  sqrtrem() {
	    return this.rootrem(2);
	  }
	  isqrt() {
	    return this.sqrt()._move(this);
	  }
	  sqrt() {
	    return this.root(2);
	  }
	  isSquare() {
	    return this.isPower(2);
	  }

	  /*
	   * AND
	   */

	  iand(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    let x = this;
	    let y = num;
	    if (x === y) return x;
	    if ((x.negative | y.negative) === 0) return x.iuand(y);
	    if ((x.negative & y.negative) === 1) {
	      // (-x) & (-y) == ~(x-1) & ~(y-1)
	      //             == ~((x-1) | (y-1))
	      //             == -(((x-1) | (y-1)) + 1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuor(y);
	      x.isubn(1);
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    if (x.negative !== 0) [x, y] = [y.clone(), x];

	    // x & (-y) == x & ~(y-1)
	    //          == x & ~(y-1)
	    const width = x.bitLength();
	    y.iaddn(1);
	    y.inotn(width);
	    x.iuand(y);
	    y.inotn(width);
	    y.isubn(1);
	    return x._move(this);
	  }
	  iandn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if ((this.negative | num < 0) !== 0) return this.iand(new BN(num));
	    this.words[0] &= num;
	    this.length = 1;
	    return this;
	  }
	  and(num) {
	    return this.clone().iand(num);
	  }
	  andn(num) {
	    return this.clone().iandn(num);
	  }
	  andrn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if ((this.negative | num < 0) !== 0) {
	      const n = this.iand(new BN(num));
	      if (n.length > 1) throw new RangeError('Number exceeds 26 bits.');
	      return n.negative !== 0 ? -n.words[0] : n.words[0];
	    }
	    return this.words[0] & num;
	  }

	  /*
	   * Unsigned AND
	   */

	  iuand(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    this.length = Math.min(this.length, num.length);
	    for (let i = 0; i < this.length; i++) this.words[i] &= num.words[i];
	    return this._strip();
	  }
	  iuandn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    this.words[0] &= Math.abs(num);
	    this.length = 1;
	    return this._normalize();
	  }
	  uand(num) {
	    return this.clone().iuand(num);
	  }
	  uandn(num) {
	    return this.clone().iuandn(num);
	  }
	  uandrn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    const n = this.words[0] & Math.abs(num);
	    return this.negative !== 0 ? -n | 0 : n;
	  }

	  /*
	   * OR
	   */

	  ior(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    let x = this;
	    let y = num;
	    if (x === y) return x;
	    if ((x.negative | y.negative) === 0) return x.iuor(y);
	    if ((x.negative & y.negative) === 1) {
	      // (-x) | (-y) == ~(x-1) | ~(y-1)
	      //             == ~((x-1) & (y-1))
	      //             == -(((x-1) & (y-1)) + 1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuand(y);
	      x.isubn(1);
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    y = y.clone();
	    if (x.negative !== 0) [x, y] = [y, x];

	    // x | (-y) == x | ~(y-1)
	    //          == ~((y-1) & ~x)
	    //          == -(((y-1) & ~x) + 1)
	    y.iaddn(1);
	    x.inotn(y.bitLength());
	    y.iuand(x);
	    y.isubn(1);
	    return y._move(this);
	  }
	  iorn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if ((this.negative | num < 0) !== 0) return this.ior(new BN(num));
	    this.words[0] |= num;
	    return this;
	  }
	  or(num) {
	    return this.clone().ior(num);
	  }
	  orn(num) {
	    return this.clone().iorn(num);
	  }

	  /*
	   * Unsigned OR
	   */

	  iuor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    this._expand(num.length);
	    for (let i = 0; i < num.length; i++) this.words[i] |= num.words[i];

	    // Note: we shouldn't need to strip here.
	    return this;
	  }
	  iuorn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    this.words[0] |= Math.abs(num);
	    return this;
	  }
	  uor(num) {
	    return this.clone().iuor(num);
	  }
	  uorn(num) {
	    return this.clone().iuorn(num);
	  }

	  /*
	   * XOR
	   */

	  ixor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    let x = this;
	    let y = num;
	    if (x === y) {
	      x.words[0] = 0;
	      x.length = 1;
	      x.negative = 0;
	      return x;
	    }
	    if ((x.negative | y.negative) === 0) return x.iuxor(y);
	    if ((x.negative & y.negative) === 1) {
	      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)
	      //             == (x-1) ^ (y-1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuxor(y);
	      x.ineg();
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    if (x.negative !== 0) [x, y] = [y.clone(), x];

	    // x ^ (-y) == x ^ ~(y-1)
	    //          == ~(x ^ (y-1))
	    //          == -((x ^ (y-1)) + 1)
	    y.iaddn(1);
	    x.iuxor(y);
	    x.iaddn(1);
	    x.ineg();
	    y.isubn(1);
	    return x._move(this);
	  }
	  ixorn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if ((this.negative | num < 0) !== 0) return this.ixor(new BN(num));
	    this.words[0] ^= num;
	    return this;
	  }
	  xor(num) {
	    return this.clone().ixor(num);
	  }
	  xorn(num) {
	    return this.clone().ixorn(num);
	  }

	  /*
	   * Unsigned XOR
	   */

	  iuxor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    let a = this;
	    let b = num;
	    if (a.length < b.length) [a, b] = [b, a];
	    let i = 0;
	    for (; i < b.length; i++) this.words[i] = a.words[i] ^ b.words[i];
	    if (a !== this) {
	      this._alloc(a.length);
	      for (; i < a.length; i++) this.words[i] = a.words[i];
	    }
	    this.length = a.length;
	    return this._strip();
	  }
	  iuxorn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    this.words[0] ^= Math.abs(num);
	    return this._normalize();
	  }
	  uxor(num) {
	    return this.clone().iuxor(num);
	  }
	  uxorn(num) {
	    return this.clone().iuxorn(num);
	  }

	  /*
	   * NOT
	   */

	  inot() {
	    if (this.negative !== 0) {
	      // ~(-x) == ~(~(x-1)) == x-1
	      this.ineg().isubn(1);
	    } else {
	      // ~x == -x-1 == -(x+1)
	      this.iaddn(1).ineg();
	    }
	    return this;
	  }
	  not() {
	    return this.clone().inot();
	  }
	  inotn(width) {
	    enforce(width >>> 0 === width, 'width', 'uint32');
	    const r = width % 26;
	    let s = Math.ceil(width / 26);
	    let i = 0;

	    // Extend the buffer with leading zeroes.
	    this._expand(s);
	    if (r > 0) s -= 1;

	    // Handle complete words.
	    for (; i < s; i++) this.words[i] ^= 0x3ffffff;

	    // Handle the residue.
	    if (r > 0) this.words[i] ^= (1 << r) - 1;

	    // And remove leading zeroes.
	    return this._strip();
	  }
	  notn(width) {
	    return this.clone().inotn(width);
	  }

	  /*
	   * Left Shift
	   */

	  ishl(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.ishln(num.toNumber());
	  }
	  ishln(bits) {
	    return this.iushln(bits);
	  }
	  shl(num) {
	    return this.clone().ishl(num);
	  }
	  shln(bits) {
	    return this.clone().ishln(bits);
	  }

	  /*
	   * Unsigned Left Shift
	   */

	  iushl(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.iushln(num.toNumber());
	  }
	  iushln(bits) {
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    const r = bits % 26;
	    const s = (bits - r) / 26;
	    const mask = (1 << r) - 1 << 26 - r;
	    if (r !== 0) {
	      let carry = 0;
	      for (let i = 0; i < this.length; i++) {
	        const ncarry = this.words[i] & mask;
	        const c = (this.words[i] | 0) - ncarry << r;
	        this.words[i] = c | carry;
	        carry = ncarry >>> 26 - r;
	      }
	      if (carry !== 0) {
	        this._alloc(this.length + 1);
	        this.words[this.length++] = carry;
	      }
	    }
	    if (s !== 0) {
	      this._alloc(this.length + s);
	      for (let i = this.length - 1; i >= 0; i--) this.words[i + s] = this.words[i];
	      for (let i = 0; i < s; i++) this.words[i] = 0;
	      this.length += s;
	    }
	    return this._strip();
	  }
	  ushl(num) {
	    return this.clone().iushl(num);
	  }
	  ushln(bits) {
	    return this.clone().iushln(bits);
	  }

	  /*
	   * Right Shift Engine
	   */

	  _split(bits, output) {
	    const r = bits % 26;
	    const s = Math.min((bits - r) / 26, this.length);
	    const mask = (1 << r) - 1;

	    // Extended mode, copy masked part.
	    if (output) {
	      output._alloc(s);
	      for (let i = 0; i < s; i++) output.words[i] = this.words[i];
	      output.length = s;
	    }
	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (let i = 0; i < this.length; i++) this.words[i] = this.words[i + s];
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }
	    let carry = 0;
	    if (r !== 0) {
	      for (let i = this.length - 1; i >= 0; i--) {
	        const word = this.words[i] | 0;
	        this.words[i] = carry << 26 - r | word >>> r;
	        carry = word & mask;
	      }
	    }

	    // Push carried bits as a mask.
	    if (output) {
	      if (carry !== 0) {
	        output._alloc(output.length + 1);
	        output.words[output.length++] = carry;
	      } else {
	        if (output.length === 0) output.words[output.length++] = 0;
	        output._strip();
	      }
	    }
	    return this._strip();
	  }

	  /*
	   * Right Shift
	   */

	  ishr(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.ishrn(num.toNumber());
	  }
	  ishrn(bits) {
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    if (this.negative !== 0) {
	      // (-x) >> y == ~(x-1) >> y
	      //           == ~((x-1) >> y)
	      //           == -(((x-1) >> y) + 1)
	      this.iaddn(1);
	      this.iushrn(bits);
	      this.isubn(1);
	      return this;
	    }
	    return this.iushrn(bits);
	  }
	  shr(num) {
	    return this.clone().ishr(num);
	  }
	  shrn(bits) {
	    return this.clone().ishrn(bits);
	  }

	  /*
	   * Unsigned Right Shift
	   */

	  iushr(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.iushrn(num.toNumber());
	  }
	  iushrn(bits) {
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    return this._split(bits, null);
	  }
	  ushr(num) {
	    return this.clone().iushr(num);
	  }
	  ushrn(bits) {
	    return this.clone().iushrn(bits);
	  }

	  /*
	   * Bit Manipulation
	   */

	  setn(bit, val) {
	    enforce(bit >>> 0 === bit, 'bit', 'uint32');
	    if (this.negative !== 0) {
	      this.iaddn(1);
	      this.usetn(bit, !val);
	      this.isubn(1);
	      return this;
	    }
	    return this.usetn(bit, val);
	  }
	  usetn(bit, val) {
	    enforce(bit >>> 0 === bit, 'bit', 'uint32');
	    const r = bit % 26;
	    const s = (bit - r) / 26;
	    this._expand(s + 1);
	    if (val) this.words[s] |= 1 << r;else this.words[s] &= ~(1 << r);
	    return this._strip();
	  }
	  testn(bit) {
	    enforce(bit >>> 0 === bit, 'bit', 'uint32');
	    const r = bit % 26;
	    const s = (bit - r) / 26;

	    // Fast case: bit is much higher than all existing words.
	    if (this.length <= s) return this.negative;

	    // Check bit and return.
	    const w = this.words[s];
	    const val = w >> r & 1;
	    if (this.negative !== 0) {
	      if (r > 0 && w & (1 << r) - 1) return val ^ 1;
	      let j = s;
	      while (j--) {
	        if (this.words[j] > 0) return val ^ 1;
	      }
	    }
	    return val;
	  }
	  utestn(bit) {
	    enforce(bit >>> 0 === bit, 'bit', 'uint32');
	    const r = bit % 26;
	    const s = (bit - r) / 26;

	    // Fast case: bit is much higher than all existing words.
	    if (this.length <= s) return 0;

	    // Check bit and return.
	    return this.words[s] >> r & 1;
	  }
	  imaskn(bits) {
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    if (this.negative !== 0) {
	      this.iaddn(1);
	      this.inotn(bits + 1);
	      this.ineg();
	    }
	    return this.iumaskn(bits);
	  }
	  maskn(bits) {
	    return this.clone().imaskn(bits);
	  }
	  iumaskn(bits) {
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    const r = bits % 26;
	    let s = (bits - r) / 26;
	    if (this.length <= s) return this;
	    if (r !== 0) s += 1;
	    this.length = Math.min(s, this.length);
	    if (r !== 0) this.words[this.length - 1] &= (1 << r) - 1;
	    if (this.length === 0) this.words[this.length++] = 0;
	    return this._strip();
	  }
	  umaskn(bits) {
	    return this.clone().iumaskn(bits);
	  }
	  andln(num) {
	    return this.words[0] & num;
	  }
	  bit(pos) {
	    return this.utestn(pos);
	  }
	  bits(pos, width) {
	    enforce(pos >>> 0 === pos, 'pos', 'uint32');
	    enforce(width >>> 0 === width, 'width', 'uint32');
	    enforce(width <= 26, 'width', 'width');
	    const shift = pos % 26;
	    const index = (pos - shift) / 26;
	    if (index >= this.length) return 0;
	    let bits = this.words[index] >> shift & (1 << width) - 1;
	    if (shift + width > 26 && index + 1 < this.length) {
	      const more = shift + width - 26;
	      const next = this.words[index + 1] & (1 << more) - 1;
	      bits |= next << 26 - shift;
	    }
	    return bits;
	  }

	  /*
	   * Negation
	   */

	  ineg() {
	    if (!this.isZero()) this.negative ^= 1;
	    return this;
	  }
	  neg() {
	    return this.clone().ineg();
	  }
	  iabs() {
	    this.negative = 0;
	    return this;
	  }
	  abs() {
	    return this.clone().iabs();
	  }

	  /*
	   * Comparison
	   */

	  cmp(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.negative !== num.negative) return num.negative - this.negative;
	    const res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  }
	  cmpn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    const negative = num < 0 | 0;
	    if (this.negative !== negative) return negative - this.negative;
	    const res = this.ucmpn(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  }
	  eq(num) {
	    return this.cmp(num) === 0;
	  }
	  eqn(num) {
	    return this.cmpn(num) === 0;
	  }
	  gt(num) {
	    return this.cmp(num) > 0;
	  }
	  gtn(num) {
	    return this.cmpn(num) > 0;
	  }
	  gte(num) {
	    return this.cmp(num) >= 0;
	  }
	  gten(num) {
	    return this.cmpn(num) >= 0;
	  }
	  lt(num) {
	    return this.cmp(num) < 0;
	  }
	  ltn(num) {
	    return this.cmpn(num) < 0;
	  }
	  lte(num) {
	    return this.cmp(num) <= 0;
	  }
	  lten(num) {
	    return this.cmpn(num) <= 0;
	  }
	  sign() {
	    if (this.negative !== 0) return -1;
	    if (this.length === 1 && this.words[0] === 0) return 0;
	    return 1;
	  }
	  isZero() {
	    return this.length === 1 && this.words[0] === 0;
	  }
	  isNeg() {
	    return this.negative !== 0;
	  }
	  isPos() {
	    return this.negative === 0;
	  }
	  isOdd() {
	    return (this.words[0] & 1) === 1;
	  }
	  isEven() {
	    return (this.words[0] & 1) === 0;
	  }

	  /*
	   * Unsigned Comparison
	   */

	  ucmp(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.length < num.length) return -1;
	    if (this.length > num.length) return 1;
	    for (let i = this.length - 1; i >= 0; i--) {
	      const a = this.words[i] | 0;
	      const b = num.words[i] | 0;
	      if (a === b) continue;
	      return (a > b) - (a < b);
	    }
	    return 0;
	  }
	  ucmpn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    if (this.length > 1) return 1;
	    const w = this.words[0] | 0;
	    if (num < 0) num = -num;
	    return (w > num) - (w < num);
	  }

	  /*
	   * Number Theoretic Functions
	   */

	  legendre(num) {
	    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
	    return this.toRed(red).redLegendre();
	  }
	  jacobi(num) {
	    // See: A Binary Algorithm for the Jacobi Symbol
	    //   J. Shallit, J. Sorenson
	    //   Page 3, Section 3
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (num.isZero() || num.isEven()) throw new Error('jacobi: `num` must be odd.');
	    let a = this._cloneNormal();
	    let b = num.clone();
	    let j = 1;
	    if (b.isNeg()) {
	      if (a.isNeg()) j = -1;
	      b.ineg();
	    }
	    if (a.isNeg() || a.ucmp(b) >= 0) a.imod(b);
	    while (!a.isZero()) {
	      const bits = a._makeOdd();
	      if (bits & 1) {
	        const bmod8 = b.andln(7);
	        if (bmod8 === 3 || bmod8 === 5) j = -j;
	      }
	      if (a.ucmp(b) < 0) {
	        [a, b] = [b, a];
	        if (a.andln(3) === 3 && b.andln(3) === 3) j = -j;
	      }
	      a._isub(a, b).iushrn(1);
	      const bmod8 = b.andln(7);
	      if (bmod8 === 3 || bmod8 === 5) j = -j;
	    }
	    if (b.cmpn(1) !== 0) return 0;
	    return j;
	  }
	  kronecker(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.isZero()) return num.ucmpn(1) === 0 ? 1 : 0;
	    if (num.isZero()) return this.ucmpn(1) === 0 ? 1 : 0;
	    if (((this.words[0] | num.words[0]) & 1) === 0) return 0;
	    const x = this;
	    const y = num.clone();
	    const bits = y._makeOdd();
	    const table = [0, 1, 0, -1, 0, -1, 0, 1];
	    let k = x.jacobi(y);
	    if (bits & 1) k *= table[x.andln(7)];
	    return k | 0;
	  }
	  igcd(num) {
	    return this.gcd(num)._move(this);
	  }
	  gcd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();
	    let a = this.clone();
	    let b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two.
	    const shift = a._factor2(b);
	    if (shift !== 0) {
	      a.iushrn(shift);
	      b.iushrn(shift);
	    }
	    for (;;) {
	      a._makeOdd();
	      b._makeOdd();
	      const cmp = a.ucmp(b);
	      if (cmp < 0) {
	        // a > b
	        [a, b] = [b, a];
	      } else if (cmp === 0 || b.ucmpn(1) === 0) {
	        // Break if a == b.
	        // Break if b == 1 to avoid repeated subtraction.
	        break;
	      }
	      a._isub(a, b);
	    }
	    return b.iushln(shift);
	  }
	  ilcm(num) {
	    return this.lcm(num)._move(this);
	  }
	  lcm(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.isZero() || num.isZero()) return new BN(0);
	    return this.quo(this.gcd(num)).mul(num).iabs();
	  }
	  egcd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    if (this.isZero()) {
	      return [new BN(0), new BN(num.sign()), num.abs()];
	    }
	    if (num.isZero()) {
	      return [new BN(this.sign()), new BN(0), this.abs()];
	    }
	    const x = this.clone();
	    const y = num.clone();
	    x.negative = 0;
	    y.negative = 0;

	    // A * x + B * y = x
	    const A = new BN(1);
	    const B = new BN(0);

	    // C * x + D * y = y
	    const C = new BN(0);
	    const D = new BN(1);

	    // Remove common factor of two.
	    const g = x._factor2(y);
	    if (g > 0) {
	      x.iushrn(g);
	      y.iushrn(g);
	    }
	    const xp = x.clone();
	    const yp = y.clone();
	    while (!x.isZero()) {
	      let i = x._makeOdd();
	      let j = y._makeOdd();
	      while (i--) {
	        if (A.isOdd() || B.isOdd()) {
	          A.iadd(yp);
	          B.isub(xp);
	        }
	        A.iushrn(1);
	        B.iushrn(1);
	      }
	      while (j--) {
	        if (C.isOdd() || D.isOdd()) {
	          C.iadd(yp);
	          D.isub(xp);
	        }
	        C.iushrn(1);
	        D.iushrn(1);
	      }
	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }
	    if (this.negative !== 0) C.ineg();
	    if (num.negative !== 0) D.ineg();
	    return [C, D, y.iushln(g)];
	  }
	  iinvert(num) {
	    return this.invert(num)._move(this);
	  }
	  invert(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    range(num.sign() > 0, 'invert');
	    if (num.isOdd()) return this._invertp(num);
	    if (num.cmpn(1) === 0) throw new RangeError('Not invertible.');
	    const [s,, g] = this.egcd(num);
	    if (g.cmpn(1) !== 0) throw new RangeError('Not invertible.');
	    return s.imod(num);
	  }
	  ifermat(num) {
	    return this.fermat(num)._move(this);
	  }
	  fermat(num) {
	    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
	    return this.toRed(red).redFermat().fromRed();
	  }
	  ipowm(y, m, mont) {
	    return this.powm(y, m, mont)._move(this);
	  }
	  powm(y, m, mont) {
	    const red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);
	    return this.toRed(red).redPow(y).fromRed();
	  }
	  ipowmn(y, m, mont) {
	    return this.powmn(y, m, mont)._move(this);
	  }
	  powmn(y, m, mont) {
	    const red = mont ? BN.mont(m) : BN.red(m);
	    return this.toRed(red).redPown(y).fromRed();
	  }
	  isqrtm(p) {
	    return this.sqrtm(p)._move(this);
	  }
	  sqrtm(p) {
	    enforce(BN.isBN(p), 'p', 'bignum');
	    let red;
	    if (p.andln(3) === 3 || p.andln(7) === 5) {
	      // Probably not worth the setup.
	      red = BN.red(p);
	    } else {
	      red = BN.mont(p);
	    }
	    return this.toRed(red).redSqrt().fromRed();
	  }
	  isqrtpq(p, q) {
	    return this.sqrtpq(p, q)._move(this);
	  }
	  sqrtpq(p, q) {
	    const sp = this.sqrtm(p);
	    const sq = this.sqrtm(q);
	    const [mp, mq] = p.egcd(q);
	    const lhs = sq.mul(mp).mul(p);
	    const rhs = sp.mul(mq).mul(q);
	    const n = p.mul(q);
	    return lhs.iadd(rhs).imod(n);
	  }

	  /*
	   * Primality Testing
	   */

	  isPrime(rng, reps, limit) {
	    enforce(reps >>> 0 === reps, 'reps', 'uint32');
	    if (!this.isPrimeMR(rng, reps + 1, true)) return false;
	    if (!this.isPrimeLucas(limit)) return false;
	    return true;
	  }
	  isPrimeMR(rng, reps, force2 = false) {
	    enforce(reps >>> 0 === reps, 'reps', 'uint32');
	    enforce(reps > 0, 'reps', 'integer');
	    enforce(typeof force2 === 'boolean', 'force2', 'boolean');
	    const n = this;
	    if (n.cmpn(7) < 0) {
	      return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;
	    }
	    if (n.isEven()) return false;
	    const nm1 = n.subn(1);
	    const nm3 = nm1.subn(2);
	    const k = nm1.zeroBits();
	    const q = nm1.ushrn(k);
	    const red = BN.red(n);
	    const rnm1 = nm1.toRed(red);
	    const rone = new BN(1).toRed(red);
	    next: for (let i = 0; i < reps; i++) {
	      let x;
	      if (i === reps - 1 && force2) {
	        x = new BN(2);
	      } else {
	        x = BN.random(rng, 0, nm3);
	        x.iaddn(2);
	      }
	      let y = x.toRed(red).redPow(q);
	      if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0) continue;
	      for (let j = 1; j < k; j++) {
	        y = y.redSqr();
	        if (y.cmp(rnm1) === 0) continue next;
	        if (y.cmp(rone) === 0) return false;
	      }
	      return false;
	    }
	    return true;
	  }
	  isPrimeLucas(limit = 0) {
	    enforce(limit >>> 0 === limit, 'limit', 'uint32');
	    const n = this;

	    // Ignore 0 and 1.
	    if (n.cmpn(1) <= 0) return false;

	    // Two is the only even prime.
	    if (n.isEven()) return n.cmpn(2) === 0;
	    let p = 3;
	    for (;;) {
	      if (p > 10000) {
	        // Thought to be impossible.
	        throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);
	      }
	      if (limit !== 0 && p > limit) {
	        // Optional DoS limit.
	        return false;
	      }
	      const d = new BN(p * p - 4);
	      const j = d.jacobi(n);
	      if (j === -1) break;
	      if (j === 0) return n.cmpn(p + 2) === 0;
	      if (p === 40) {
	        if (n.isSquare()) return false;
	      }
	      p += 1;
	    }
	    const s = n.addn(1);
	    const r = s._makeOdd();
	    let vk = new BN(2);
	    let vk1 = new BN(p);
	    for (let i = s.bitLength(); i >= 0; i--) {
	      if (s.utestn(i)) {
	        vk = vk.mul(vk1).isubn(p).imod(n);
	        vk1 = vk1.sqr().isubn(2).imod(n);
	      } else {
	        vk1 = vk1.mul(vk).isubn(p).imod(n);
	        vk = vk.sqr().isubn(2).imod(n);
	      }
	    }
	    if (vk.cmpn(2) === 0 || vk.cmp(n.subn(2)) === 0) {
	      const a = vk.muln(p).imod(n);
	      const b = vk1.ushln(1).imod(n);
	      if (a.cmp(b) === 0) return true;
	    }
	    for (let t = 0; t < r - 1; t++) {
	      if (vk.isZero()) return true;
	      if (vk.cmpn(2) === 0) return false;
	      vk = vk.sqr().isubn(2).imod(n);
	    }
	    return false;
	  }

	  /*
	   * Twos Complement
	   */

	  toTwos(width) {
	    if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
	    return this.clone();
	  }
	  fromTwos(width) {
	    enforce(width >>> 0 === width, 'width', 'uint32');
	    range(width > 0, 'width');
	    if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
	    return this.clone();
	  }

	  /*
	   * Reduction Context
	   */

	  toRed(ctx) {
	    enforce(ctx instanceof Red, 'ctx', 'reduction context');
	    if (this.red) throw new Error('Already in reduction context.');
	    return ctx.convertTo(this);
	  }
	  fromRed() {
	    red(this.red, 'fromRed');
	    return this.red.convertFrom(this);
	  }
	  forceRed(ctx) {
	    enforce(ctx instanceof Red, 'ctx', 'reduction context');
	    if (this.red) {
	      if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont) throw new Error('Already in reduction context.');
	    } else {
	      range(this.negative === 0, 'red');
	      range(this.ucmp(ctx.m) < 0, 'red');
	    }
	    return this.clone()._forceRed(ctx);
	  }
	  redIAdd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIAdd');
	    return this.red.iadd(this, num);
	  }
	  redAdd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redAdd');
	    return this.red.add(this, num);
	  }
	  redIAddn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIAddn');
	    return this.red.iaddn(this, num);
	  }
	  redAddn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redAddn');
	    return this.red.addn(this, num);
	  }
	  redISub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redISub');
	    return this.red.isub(this, num);
	  }
	  redSub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redSub');
	    return this.red.sub(this, num);
	  }
	  redISubn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redISubn');
	    return this.red.isubn(this, num);
	  }
	  redSubn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redSubn');
	    return this.red.subn(this, num);
	  }
	  redIMul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIMul');
	    return this.red.imul(this, num);
	  }
	  redMul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redMul');
	    return this.red.mul(this, num);
	  }
	  redIMuln(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIMuln');
	    return this.red.imuln(this, num);
	  }
	  redMuln(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redMuln');
	    return this.red.muln(this, num);
	  }
	  redIDiv(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIDiv');
	    return this.red.idiv(this, num);
	  }
	  redDiv(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redDiv');
	    return this.red.div(this, num);
	  }
	  redIDivn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIDivn');
	    return this.red.idivn(this, num);
	  }
	  redDivn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redDivn');
	    return this.red.divn(this, num);
	  }
	  redIPow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIPow');
	    nonred(!num.red, 'redIPow');
	    return this.red.ipow(this, num);
	  }
	  redPow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redPow');
	    nonred(!num.red, 'redPow');
	    return this.red.pow(this, num);
	  }
	  redIPown(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIPown');
	    return this.red.ipown(this, num);
	  }
	  redPown(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redPown');
	    return this.red.pown(this, num);
	  }
	  redISqr() {
	    red(this.red, 'redISqr');
	    return this.red.isqr(this);
	  }
	  redSqr() {
	    red(this.red, 'redSqr');
	    return this.red.sqr(this);
	  }
	  redISqrt() {
	    red(this.red, 'redISqrt');
	    return this.red.isqrt(this);
	  }
	  redSqrt() {
	    red(this.red, 'redSqrt');
	    return this.red.sqrt(this);
	  }
	  redIDivSqrt(v) {
	    red(this.red, 'redIDivSqrt');
	    return this.red.idivsqrt(this, v);
	  }
	  redDivSqrt(v) {
	    red(this.red, 'redDivSqrt');
	    return this.red.divsqrt(this, v);
	  }
	  redIsSquare() {
	    red(this.red, 'redIsSquare');
	    return this.red.isSquare(this);
	  }
	  redIShl(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIShl');
	    nonred(!num.red, 'redIShl');
	    return this.red.ishl(this, num);
	  }
	  redShl(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redShl');
	    nonred(!num.red, 'redShl');
	    return this.red.shl(this, num);
	  }
	  redIShln(num) {
	    enforce(num >>> 0 === num, 'num', 'uint32');
	    red(this.red, 'redIShln');
	    return this.red.ishln(this, num);
	  }
	  redShln(num) {
	    enforce(num >>> 0 === num, 'num', 'uint32');
	    red(this.red, 'redShln');
	    return this.red.shln(this, num);
	  }
	  redINeg() {
	    red(this.red, 'redINeg');
	    return this.red.ineg(this);
	  }
	  redNeg() {
	    red(this.red, 'redNeg');
	    return this.red.neg(this);
	  }
	  redEq(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redEq');
	    return this.red.eq(this, num);
	  }
	  redEqn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redEqn');
	    return this.red.eqn(this, num);
	  }
	  redIsHigh() {
	    red(this.red, 'redIsHigh');
	    return this.red.isHigh(this);
	  }
	  redIsLow() {
	    red(this.red, 'redIsLow');
	    return this.red.isLow(this);
	  }
	  redIsOdd() {
	    red(this.red, 'redIsOdd');
	    return this.red.isOdd(this);
	  }
	  redIsEven() {
	    red(this.red, 'redIsEven');
	    return this.red.isEven(this);
	  }
	  redLegendre() {
	    red(this.red, 'redLegendre');
	    return this.red.legendre(this);
	  }
	  redJacobi() {
	    red(this.red, 'redJacobi');
	    return this.red.jacobi(this);
	  }
	  redKronecker() {
	    red(this.red, 'redKronecker');
	    return this.red.kronecker(this);
	  }
	  redIInvert() {
	    red(this.red, 'redIInvert');
	    return this.red.iinvert(this);
	  }
	  redInvert() {
	    red(this.red, 'redInvert');
	    return this.red.invert(this);
	  }
	  redIFermat() {
	    red(this.red, 'redIFermat');
	    return this.red.ifermat(this);
	  }
	  redFermat() {
	    red(this.red, 'redFermat');
	    return this.red.fermat(this);
	  }

	  /*
	   * Internal
	   */

	  _move(dest) {
	    dest.words = this.words;
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	    return dest;
	  }
	  _alloc(size) {
	    while (this.words.length < size) this.words.push(0);
	    return this;
	  }
	  _expand(size) {
	    this._alloc(size);
	    while (this.length < size) this.words[this.length++] = 0;
	    return this;
	  }
	  _strip() {
	    while (this.length > 1 && this.words[this.length - 1] === 0) this.length -= 1;
	    return this._normalize();
	  }
	  _normalize() {
	    assert(this.length > 0);

	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) this.negative = 0;
	    return this;
	  }
	  _check() {
	    // We never have a zero length number.
	    assert(this.length > 0);

	    // Cannot exceed array bounds.
	    assert(this.length <= this.words.length);
	    if (this.length === 1) {
	      // Must be normalized.
	      if (this.words[0] === 0) assert(this.negative === 0);
	      return this;
	    }

	    // Must be stripped.
	    assert(this.words[this.length - 1] !== 0);
	    return this;
	  }
	  _invertp(p) {
	    // Penk's right shift binary EGCD.
	    //
	    // See: The Art of Computer Programming,
	    //      Volume 2, Seminumerical Algorithms
	    //   Donald E. Knuth
	    //   Exercise 4.5.2.39
	    enforce(BN.isBN(p), 'p', 'bignum');
	    range(p.sign() > 0, 'invert');
	    assert(p.isOdd());
	    if (p.cmpn(1) === 0) throw new RangeError('Not invertible.');
	    const a = this.clone();
	    const b = p.clone();
	    const u = new BN(1);
	    const v = new BN(0);
	    if (a.isNeg() || a.ucmp(b) >= 0) a.imod(b);
	    while (!a.isZero()) {
	      let i = a._makeOdd();
	      let j = b._makeOdd();
	      while (i--) {
	        if (u.isOdd()) u._iadd(u, p);
	        u.iushrn(1);
	      }
	      while (j--) {
	        if (v.isOdd()) v._iadd(v, p);
	        v.iushrn(1);
	      }
	      if (a.ucmp(b) >= 0) {
	        a._isub(a, b);
	        if (u.ucmp(v) < 0) {
	          u._isub(v, u);
	          u._isub(p, u);
	        } else {
	          u._isub(u, v);
	        }
	      } else {
	        b._isub(b, a);
	        if (v.ucmp(u) < 0) {
	          v._isub(u, v);
	          v._isub(p, v);
	        } else {
	          v._isub(v, u);
	        }
	      }
	    }
	    if (b.cmpn(1) !== 0) throw new RangeError('Not invertible.');
	    assert(v.negative === 0);
	    assert(v.ucmp(p) < 0);
	    return v;
	  }
	  _makeOdd() {
	    const shift = this.zeroBits();
	    if (shift > 0) this.iushrn(shift);
	    return shift;
	  }
	  _factor2(num) {
	    // Find common factor of two.
	    // Expects inputs to be non-zero.
	    if ((this.words[0] | num.words[0]) & 1) return 0;
	    const len = Math.min(this.length, num.length);
	    let r = 0;
	    for (let i = 0; i < len; i++) {
	      const b = zeroBits(this.words[i] | num.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  }
	  _cloneNormal() {
	    return this.red ? this.fromRed() : this.clone();
	  }
	  _forceRed(ctx) {
	    this.red = ctx;
	    return this;
	  }

	  /*
	   * Helpers
	   */

	  clone() {
	    const copy = new BN();
	    copy.words = new Array(this.length);
	    for (let i = 0; i < this.length; i++) copy.words[i] = this.words[i];
	    copy.length = this.length;
	    copy.negative = this.negative;
	    copy.red = this.red;
	    return copy;
	  }
	  inject(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    this._alloc(num.length);
	    for (let i = 0; i < num.length; i++) this.words[i] = num.words[i];
	    this.length = num.length;
	    this.negative = num.negative;
	    this.red = num.red;
	    return this;
	  }
	  set(num, endian) {
	    return this.fromNumber(num, endian);
	  }
	  swap(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    const x = this;
	    const y = num;
	    [x.words, y.words] = [y.words, x.words];
	    [x.length, y.length] = [y.length, x.length];
	    [x.negative, y.negative] = [y.negative, x.negative];
	    [x.red, y.red] = [y.red, x.red];
	    return x;
	  }
	  reverse() {
	    const neg = this.negative;
	    this.fromBuffer(this.toBuffer('be'), 'le');
	    this.negative = neg;
	    return this;
	  }
	  byteLength() {
	    return Math.ceil(this.bitLength() / 8);
	  }
	  bitLength() {
	    const w = this.words[this.length - 1];
	    const hi = countBits(w);
	    return (this.length - 1) * 26 + hi;
	  }
	  zeroBits() {
	    if (this.isZero()) return 0;
	    if (this.isOdd()) return 0;
	    let r = 0;
	    for (let i = 0; i < this.length; i++) {
	      const b = zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  }
	  isSafe() {
	    if (this.length <= 2) return true;
	    if (this.length === 3 && this.words[2] === 0x01) return true;
	    return false;
	  }
	  word(pos) {
	    enforce(pos >>> 0 === pos, 'pos', 'uint32');
	    if (pos >= this.length) return 0;
	    return this.words[pos];
	  }
	  [custom]() {
	    let prefix = 'BN';
	    if (this.red) prefix = 'BN-R';
	    return `<${prefix}: ${this.toString(10)}>`;
	  }

	  /*
	   * Conversion
	   */

	  toNumber() {
	    let num = this.words[0];
	    if (this.length === 2) {
	      num += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // Note: at this stage it is known that the top bit is set.
	      num += 0x10000000000000 + this.words[1] * 0x4000000;
	    } else if (this.length > 2) {
	      throw new RangeError('Number can only safely store up to 53 bits.');
	    }
	    return this.negative !== 0 ? -num : num;
	  }
	  toDouble() {
	    let num = 0;
	    for (let i = this.length - 1; i >= 0; i--) num = num * 0x4000000 + this.words[i];
	    return this.negative !== 0 ? -num : num;
	  }
	  valueOf() {
	    return this.toDouble();
	  }
	  toBigInt() {
	    if (!HAS_BIGINT) throw new Error('BigInt is not supported!');
	    const s52 = BigInt(52);
	    const s26 = BigInt(26);
	    let i = this.length - 1;
	    let num = BigInt(0);
	    for (; i >= 1; i -= 2) {
	      const hi = this.words[i] * 0x4000000;
	      const lo = this.words[i - 1];
	      num = num << s52 | BigInt(hi + lo);
	    }
	    if (i >= 0) num = num << s26 | BigInt(this.words[0]);
	    return this.negative !== 0 ? -num : num;
	  }
	  toBool() {
	    return !this.isZero();
	  }
	  toString(base, padding) {
	    base = getBase(base);
	    if (padding == null) padding = 0;
	    if (padding === 0) padding = 1;
	    enforce(base >>> 0 === base, 'base', 'uint32');
	    enforce(padding >>> 0 === padding, 'padding', 'uint32');
	    if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');
	    this._check();
	    if (base === 16) {
	      let out = '';
	      let off = 0;
	      let carry = 0;
	      for (let i = 0; i < this.length; i++) {
	        const w = this.words[i];
	        const word = ((w << off | carry) & 0xffffff).toString(16);
	        carry = w >>> 24 - off & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;else out = word + out;
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i -= 1;
	        }
	      }
	      if (carry !== 0) out = carry.toString(16) + out;
	      while (out.length % padding !== 0) out = '0' + out;
	      if (this.negative !== 0) out = '-' + out;
	      return out;
	    }
	    const groupSize = groupSizes[base - 1];
	    const groupBase = groupBases[base - 1];
	    const c = this.clone();
	    let out = '';
	    c.negative = 0;
	    while (!c.isZero()) {
	      const r = c.remrn(groupBase).toString(base);
	      c.iquon(groupBase);
	      if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;else out = r + out;
	    }
	    if (this.isZero()) out = '0';
	    while (out.length % padding !== 0) out = '0' + out;
	    if (this.negative !== 0) out = '-' + out;
	    return out;
	  }
	  toJSON() {
	    return this.toString(16, 2);
	  }
	  toArray(endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  }
	  toBuffer(endian, length) {
	    return this.toArrayLike(Buffer, endian, length);
	  }
	  toArrayLike(ArrayType, endian, length) {
	    if (endian == null) endian = 'be';
	    if (length == null) length = 0;
	    enforce(typeof ArrayType === 'function', 'ArrayType', 'function');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    enforce(length >>> 0 === length, 'length', 'uint32');
	    this._check();
	    const bytes = this.byteLength();
	    const size = length || Math.max(1, bytes);
	    if (bytes > size) throw new RangeError('Byte array longer than desired length.');
	    const res = allocate(ArrayType, size);

	    // See: https://github.com/indutny/bn.js/pull/222
	    if (endian === 'be') {
	      let pos = res.length - 1;
	      let carry = 0;
	      for (let i = 0; i < this.length; i++) {
	        const shift = (i & 3) << 1;
	        const word = this.words[i] << shift | carry;
	        res[pos--] = word & 0xff;
	        if (pos >= 0) res[pos--] = word >>> 8 & 0xff;
	        if (pos >= 0) res[pos--] = word >>> 16 & 0xff;
	        if (shift === 6) {
	          if (pos >= 0) res[pos--] = word >>> 24 & 0xff;
	          carry = 0;
	        } else {
	          carry = word >>> 24;
	        }
	      }
	      if (pos >= 0) {
	        res[pos--] = carry;
	        while (pos >= 0) res[pos--] = 0;
	        carry = 0;
	      }
	      assert(carry === 0);
	    } else {
	      let pos = 0;
	      let carry = 0;
	      for (let i = 0; i < this.length; i++) {
	        const shift = (i & 3) << 1;
	        const word = this.words[i] << shift | carry;
	        res[pos++] = word & 0xff;
	        if (pos < res.length) res[pos++] = word >>> 8 & 0xff;
	        if (pos < res.length) res[pos++] = word >>> 16 & 0xff;
	        if (shift === 6) {
	          if (pos < res.length) res[pos++] = word >>> 24 & 0xff;
	          carry = 0;
	        } else {
	          carry = word >>> 24;
	        }
	      }
	      if (pos < res.length) {
	        res[pos++] = carry;
	        while (pos < res.length) res[pos++] = 0;
	        carry = 0;
	      }
	      assert(carry === 0);
	    }
	    return res;
	  }
	  encode(endian, length) {
	    return this.toBuffer(endian, length);
	  }

	  /*
	   * Instantiation
	   */

	  of(num, endian) {
	    return this.fromNumber(num, endian);
	  }
	  fromNumber(num, endian) {
	    if (endian == null) endian = 'be';
	    enforce(isInteger(num), 'num', 'integer');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    const neg = num < 0 | 0;
	    if (neg) num = -num;
	    if (num < 0x4000000) {
	      this.words[0] = num & 0x3ffffff;
	      this.length = 1;
	    } else if (num < 0x10000000000000) {
	      this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff];
	      this.length = 2;
	    } else {
	      this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff, 1];
	      this.length = 3;
	    }
	    this.negative = neg;
	    if (endian === 'le') this.reverse();
	    return this;
	  }
	  fromDouble(num, endian) {
	    if (endian == null) endian = 'be';
	    enforce(typeof num === 'number', 'num', 'double');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    if (!isFinite(num)) num = 0;
	    const neg = num <= -1 | 0;
	    if (num < 0) num = -num;
	    num = Math.floor(num);
	    this.words = [];
	    while (num > 0) {
	      const lo = num % 0x4000000;
	      const hi = (num - lo) / 0x4000000;
	      this.words.push(lo);
	      num = hi;
	    }
	    if (this.words.length === 0) this.words.push(0);
	    this.length = this.words.length;
	    this.negative = neg;
	    if (endian === 'le') this.reverse();
	    return this;
	  }
	  fromBigInt(num, endian) {
	    if (endian == null) endian = 'be';
	    enforce(typeof num === 'bigint', 'num', 'bigint');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    if (!HAS_BIGINT) throw new Error('BigInt is not supported!');

	    // You know the implementation has a
	    // problem when strings are twice
	    // as fast as bigints.
	    const start = num < BigInt(0) | 0;
	    this._fromHex(num.toString(16), start);
	    this.negative = start;
	    if (endian === 'le') this.reverse();
	    return this;
	  }
	  fromBool(value) {
	    enforce(typeof value === 'boolean', 'value', 'boolean');
	    this.words[0] = value | 0;
	    this.length = 1;
	    this.negative = 0;
	    return this;
	  }
	  fromString(str, base, endian) {
	    if (base === 'le' || base === 'be') [base, endian] = [endian, base];
	    base = getBase(base);
	    if (endian == null) endian = 'be';
	    enforce(typeof str === 'string', 'string', 'string');
	    enforce(base >>> 0 === base, 'base', 'uint32');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    if (base < 2 || base > 36) throw new Error('Base ranges between 2 and 36.');
	    str = str.replace(/\s+/g, '');
	    let start = 0;
	    if (str.length > 0 && str.charCodeAt(0) === 0x2d) start = 1;
	    if (base === 16) this._fromHex(str, start);else this._fromBase(str, base, start);
	    this.negative = start;
	    this._normalize();
	    if (endian === 'le') this.reverse();
	    return this;
	  }
	  _fromHex(str, start) {
	    this.length = Math.max(2, Math.ceil((str.length - start) / 6));
	    this.words = new Array(this.length);
	    for (let i = 0; i < this.length; i++) this.words[i] = 0;

	    // Scan 24-bit chunks and add them to the number.
	    let off = 0;
	    let i = str.length - 6;
	    let j = 0;
	    for (; i >= start; i -= 6) {
	      const w = parseHex(str, i, i + 6);
	      this.words[j] |= w << off & 0x3ffffff;

	      // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.
	      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j += 1;
	      }
	    }
	    if (i + 6 !== start) {
	      const w = parseHex(str, start, i + 6);
	      this.words[j] |= w << off & 0x3ffffff;
	      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
	    }
	    return this._strip();
	  }
	  _fromBase(str, base, start) {
	    // Initialize as zero.
	    this.words[0] = 0;
	    this.length = 1;
	    this.negative = 0;

	    // Find length of limb in base.
	    let limbLen = 0;
	    let limbPow = 1;
	    for (; limbPow <= 0x3ffffff; limbPow *= base) limbLen += 1;
	    limbLen -= 1;
	    limbPow = limbPow / base | 0;
	    const total = str.length - start;
	    const mod = total % limbLen;
	    const end = Math.min(total, total - mod) + start;
	    let i = start;
	    for (; i < end; i += limbLen) {
	      const word = parseBase(str, i, i + limbLen, base);
	      this.imuln(limbPow);
	      this._iaddn(word);
	    }
	    if (mod !== 0) {
	      const pow = Math.pow(base, mod);
	      const word = parseBase(str, i, str.length, base);
	      this.imuln(pow);
	      this._iaddn(word);
	    }
	    return this;
	  }
	  fromJSON(json) {
	    if (BN.isBN(json)) {
	      if (json.red) return json.fromRed();
	      return json.clone();
	    }
	    if (Array.isArray(json)) {
	      for (const chunk of json) enforce(typeof chunk === 'string', 'chunk', 'string');
	      json = json.join('');
	    }
	    return this.fromString(json, 16);
	  }
	  fromBN(num) {
	    return this.inject(num);
	  }
	  fromArray(data, endian) {
	    enforce(Array.isArray(data), 'data', 'array');
	    return this.fromArrayLike(data, endian);
	  }
	  fromBuffer(data, endian) {
	    enforce(Buffer.isBuffer(data), 'data', 'buffer');
	    return this.fromArrayLike(data, endian);
	  }
	  fromArrayLike(data, endian) {
	    if (endian == null) endian = 'be';
	    enforce(data && data.length >>> 0 === data.length, 'data', 'array-like');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    if (data.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	      this.negative = 0;
	      return this;
	    }
	    this.length = Math.max(2, Math.ceil(data.length / 3));
	    this.words = new Array(this.length);
	    this.negative = 0;
	    for (let i = 0; i < this.length; i++) this.words[i] = 0;
	    const left = data.length % 3;
	    let off = 0;
	    let j = 0;
	    let w = 0;
	    if (endian === 'be') {
	      for (let i = data.length - 1; i >= 2; i -= 3) {
	        const w = data[i] | data[i - 1] << 8 | data[i - 2] << 16;
	        this.words[j] |= w << off & 0x3ffffff;
	        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j += 1;
	        }
	      }
	      switch (left) {
	        case 2:
	          w = data[1] | data[0] << 8;
	          break;
	        case 1:
	          w = data[0];
	          break;
	      }
	    } else {
	      const len = data.length - left;
	      for (let i = 0; i < len; i += 3) {
	        const w = data[i] | data[i + 1] << 8 | data[i + 2] << 16;
	        this.words[j] |= w << off & 0x3ffffff;
	        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j += 1;
	        }
	      }
	      switch (left) {
	        case 2:
	          w = data[len] | data[len + 1] << 8;
	          break;
	        case 1:
	          w = data[len];
	          break;
	      }
	    }
	    if (left > 0) {
	      this.words[j] |= w << off & 0x3ffffff;
	      this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
	    }
	    return this._strip();
	  }
	  decode(data, endian) {
	    return this.fromBuffer(data, endian);
	  }
	  from(num, base, endian) {
	    if (num == null) return this;
	    if (base === 'le' || base === 'be') [base, endian] = [endian, base];
	    if (typeof num === 'number') return this.fromNumber(num, endian);
	    if (typeof num === 'bigint') return this.fromBigInt(num, endian);
	    if (typeof num === 'string') return this.fromString(num, base, endian);
	    if (typeof num === 'object') {
	      if (BN.isBN(num)) return this.fromBN(num, endian);
	      if (num.length >>> 0 === num.length) return this.fromArrayLike(num, endian);
	    }
	    if (typeof num === 'boolean') return this.fromBool(num);
	    throw new TypeError('Non-numeric object passed to BN.');
	  }

	  /*
	   * Static Methods
	   */

	  static min(...args) {
	    let min = null;
	    for (const num of args) {
	      enforce(BN.isBN(num), 'num', 'bignum');
	      if (!min || num.cmp(min) < 0) min = num;
	    }
	    return min || new BN(0);
	  }
	  static max(...args) {
	    let max = null;
	    for (const num of args) {
	      enforce(BN.isBN(num), 'num', 'bignum');
	      if (!max || num.cmp(max) > 0) max = num;
	    }
	    return max || new BN(0);
	  }
	  static cmp(a, b) {
	    enforce(BN.isBN(a), 'a', 'bignum');
	    return a.cmp(b);
	  }
	  static ucmp(a, b) {
	    enforce(BN.isBN(a), 'a', 'bignum');
	    return a.ucmp(b);
	  }
	  static red(num) {
	    return new Red(num);
	  }
	  static barrett(num) {
	    return new Barrett(num);
	  }
	  static mont(num) {
	    return new Mont(num);
	  }
	  static _prime(name) {
	    if (primes[name]) return primes[name];
	    let prime;
	    if (name === 'p192') prime = new P192();else if (name === 'p224') prime = new P224();else if (name === 'p521') prime = new P521();else if (name === 'k256') prime = new K256();else if (name === 'p251') prime = new P251();else if (name === 'p25519') prime = new P25519();else if (name === 'p448') prime = new P448();else throw new Error(`Unknown prime: "${name}".`);
	    primes[name] = prime;
	    return prime;
	  }
	  static prime(name) {
	    return BN._prime(name).p.clone();
	  }
	  static pow(num, exp) {
	    if (num === 2) return BN.shift(1, exp);
	    return new BN().fromNumber(num).pown(exp);
	  }
	  static shift(num, bits) {
	    if (num === 1) return new BN(0).usetn(bits, 1);
	    return new BN().fromNumber(num).ishln(bits);
	  }
	  static mask(bits) {
	    return BN.shift(1, bits).isubn(1);
	  }
	  static randomBits(rng, bits) {
	    enforce(rng != null, 'rng', 'rng');
	    enforce(bits >>> 0 === bits, 'bits', 'uint32');
	    if (typeof rng === 'object') {
	      enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');
	      const size = bits + 7 >>> 3;
	      const total = size * 8;
	      const bytes = rng.randomBytes(size);
	      enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');
	      if (bytes.length !== size) throw new RangeError('Invalid number of bytes returned from RNG.');
	      const num = BN.fromBuffer(bytes);
	      if (total > bits) num.iushrn(total - bits);
	      return num;
	    }
	    enforce(typeof rng === 'function', 'rng', 'rng');
	    const num = rng(bits);
	    enforce(BN.isBN(num), 'num', 'bignum');
	    range(num.negative === 0, 'RNG');
	    nonred(!num.red, 'RNG');
	    if (num.bitLength() > bits) throw new RangeError('Invalid number of bits returned from RNG.');
	    return num;
	  }
	  static random(rng, min, max) {
	    min = BN.cast(min, 16);
	    max = BN.cast(max, 16);
	    if (min.cmp(max) > 0) throw new RangeError('Minimum cannot be greater than maximum.');
	    const space = max.sub(min).iabs();
	    const bits = space.bitLength();
	    if (bits === 0) return min.clone();
	    for (;;) {
	      const num = BN.randomBits(rng, bits);

	      // Maximum is _exclusive_!
	      if (num.cmp(space) >= 0) continue;

	      // Minimum is _inclusive_!
	      num.iadd(min);
	      return num;
	    }
	  }
	  static of(num, endian) {
	    return new BN().of(num, endian);
	  }
	  static fromNumber(num, endian) {
	    return new BN().fromNumber(num, endian);
	  }
	  static fromDouble(num, endian) {
	    return new BN().fromDouble(num, endian);
	  }
	  static fromBigInt(num, endian) {
	    return new BN().fromBigInt(num, endian);
	  }
	  static fromBool(value) {
	    return new BN().fromBool(value);
	  }
	  static fromString(str, base, endian) {
	    return new BN().fromString(str, base, endian);
	  }
	  static fromJSON(json) {
	    return new BN().fromJSON(json);
	  }
	  static fromBN(num) {
	    return new BN().fromBN(num);
	  }
	  static fromArray(data, endian) {
	    return new BN().fromArray(data, endian);
	  }
	  static fromBuffer(data, endian) {
	    return new BN().fromBuffer(data, endian);
	  }
	  static fromArrayLike(data, endian) {
	    return new BN().fromArrayLike(data, endian);
	  }
	  static decode(data, endian) {
	    return new BN().decode(data, endian);
	  }
	  static from(num, base, endian) {
	    return new BN().from(num, base, endian);
	  }
	  static cast(num, base, endian) {
	    if (BN.isBN(num)) return num;
	    return new BN(num, base, endian);
	  }
	  static isBN(obj) {
	    return obj instanceof BN;
	  }
	}

	/*
	 * Static
	 */

	BN.BN = BN;
	BN.wordSize = 26;
	BN.native = 0;

	/**
	 * Prime
	 */

	class Prime {
	  constructor(name, p) {
	    // P = 2^N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = BN.shift(1, this.n).isub(this.p);
	    this.lo = this.p.clone();
	    this.one = this.p.clone();
	  }
	  ireduce(num) {
	    // Assumes that `num` is less than `P^2`:
	    // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)
	    const neg = num.negative !== 0;

	    // Track bits.
	    let bits = num.bitLength();

	    // Must be less than P^2.
	    assert(bits <= this.n * 2);

	    // Ensure positive.
	    num.negative = 0;

	    // Reduce.
	    while (bits > this.n) {
	      // lo = num & ((1 << n) - 1)
	      // num = num >> n
	      this.split(num, this.lo);

	      // num = num * K
	      this.imulK(num);

	      // num = num + lo
	      num._iadd(num, this.lo);

	      // bits = bitlen(num)
	      bits = num.bitLength();
	    }

	    // Final reduction.
	    const cmp = bits < this.n ? -1 : num.ucmp(this.p);
	    if (cmp === 0) {
	      num.words[0] = 0;
	      num.length = 1;
	    } else if (cmp > 0) {
	      num._isub(num, this.p);
	    } else ;

	    // Adjust sign.
	    if (neg && !num.isZero()) num._isub(this.p, num);
	    return num;
	  }
	  split(input, out) {
	    input._split(this.n, out);
	  }
	  imulK(num) {
	    return num.imul(this.k);
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    throw new Error('Not implemented.');
	  }
	  fermat(x) {
	    return this.pm2(x);
	  }
	}

	/**
	 * Prime (3 mod 4)
	 */

	class Prime34 extends Prime {
	  constructor(name, p) {
	    super(name, p);
	  }
	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    throw new Error('Not implemented.');
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    throw new Error('Not implemented.');
	  }
	  sqrt(x) {
	    // r = x^((p + 1) / 4) mod p
	    const {
	      red
	    } = x;
	    const r = this.pp1d4(x);
	    if (!red.sqr(r).eq(x)) throw new SquareRootError(r);
	    return r;
	  }
	  divsqrt(u, v) {
	    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
	    const {
	      red
	    } = u;
	    const u2 = red.sqr(u);
	    const u3 = red.mul(u2, u);
	    const u5 = red.mul(u3, u2);
	    const v3 = red.mul(red.sqr(v), v);
	    const p = this.pm3d4(red.mul(u5, v3));
	    const x = red.mul(red.mul(u3, v), p);
	    const c = red.mul(v, red.sqr(x));
	    if (c.eq(u)) return x;
	    throw new SquareRootError(x);
	  }
	}

	/**
	 * Prime (5 mod 8)
	 */

	class Prime58 extends Prime {
	  constructor(name, p, sm1) {
	    super(name, p);
	    this.sm1 = new BN(sm1, 16);
	  }
	  pm5d8(x1) {
	    // Exponent: (p - 5) / 8
	    throw new Error('Not implemented.');
	  }
	  pp3d8(x1) {
	    // Exponent: (p + 3) / 8
	    throw new Error('Not implemented.');
	  }
	  sqrt(x) {
	    // r = x^((p + 3) / 8) mod p
	    const {
	      red
	    } = x;
	    const sm1 = this.sm1._forceRed(red);
	    const r = this.pp3d8(x);
	    if (red.sqr(r).eq(x)) return r;
	    const c = red.mul(r, sm1);
	    if (red.sqr(c).eq(x)) return c;
	    throw new SquareRootError(r);
	  }
	  divsqrt(u, v) {
	    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
	    const {
	      red
	    } = u;
	    const sm1 = this.sm1._forceRed(red);
	    const v3 = red.mul(red.sqr(v), v);
	    const v7 = red.mul(red.sqr(v3), v);
	    const p = this.pm5d8(red.mul(u, v7));
	    const x = red.mul(red.mul(u, v3), p);
	    const c = red.mul(v, red.sqr(x));
	    if (c.eq(u)) return x;
	    const mc = red.ineg(c);
	    if (mc.eq(u)) return red.mul(x, sm1);
	    if (mc.eq(red.mul(u, sm1))) throw new SquareRootError(red.mul(x, sm1));
	    throw new SquareRootError(x);
	  }
	}

	/**
	 * Prime (1 mod 16)
	 */

	class Prime116 extends Prime {
	  constructor(name, p, g) {
	    super(name, p);
	    this.g = new BN(g, 16);
	    this.z = this.p.subn(1).zeroBits();
	  }
	  powS(x1) {
	    // Exponent: (p - 1) / 2^k
	    throw new Error('Not implemented.');
	  }
	  powE(x1) {
	    // Exponent: (s + 1) / 2
	    throw new Error('Not implemented.');
	  }
	  sqrt(x) {
	    // Tonelli-Shanks (variable time).
	    //
	    // Constants:
	    //
	    //   k = factors of 2 for (p - 1)
	    //   s = (p - 1) / 2^k
	    //   e = (s + 1) / 2
	    //   n = first non-square in F(p)
	    //
	    // Algorithm:
	    //
	    //   g = n^s mod p
	    //   y = x^e mod p
	    //   b = x^s mod p
	    //
	    //   loop:
	    //     t = b
	    //     m = 0
	    //
	    //     while t != 1:
	    //       t = t^2 mod p
	    //       m += 1
	    //
	    //     if m == 0:
	    //       break
	    //
	    //     if m >= k:
	    //       fail
	    //
	    //     t = g^(2^(k - m - 1)) mod p
	    //     g = t^2 mod p
	    //     y = y * t mod p
	    //     b = b * g mod p
	    //     k = m
	    //
	    //   return y
	    //
	    const {
	      red
	    } = x;
	    switch (red.jacobi(x)) {
	      case -1:
	        throw new SquareRootError(x);
	      case 0:
	        return x.clone();
	    }
	    let g = this.g._forceRed(red);
	    let y = this.powE(x);
	    let b = this.powS(x);
	    let k = this.z;
	    for (;;) {
	      let t = b;
	      let m = 0;
	      while (t.cmpn(1) !== 0 && m < k) {
	        t = red.sqr(t);
	        m += 1;
	      }
	      if (m === 0) break;
	      assert(m < k);
	      t = red.sqrn(g, k - m - 1);
	      g = red.sqr(t);
	      y = red.mul(y, t);
	      b = red.mul(b, g);
	      k = m;
	    }
	    return y;
	  }
	  divsqrt(u, v) {
	    const {
	      red
	    } = u;
	    if (v.isZero()) throw new SquareRootError(v);
	    return this.sqrt(red.div(u, v));
	  }
	}

	/**
	 * P192
	 */

	class P192 extends Prime34 {
	  constructor() {
	    // 2^192 - 2^64 - 1 (= 3 mod 4)
	    super('p192', 'ffffffff ffffffff ffffffff fffffffe' + 'ffffffff ffffffff');
	  }
	  imulK(num) {
	    // K = 0x10000000000000001
	    // K = 2^64 + 1
	    const one = this.one.inject(num);
	    return num.iushln(64)._iadd(num, one);
	  }
	  core(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 127x1 1x0 62x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x30 = red.sqrnmul(x24, 6, x6);
	    const x31 = red.sqrnmul(x30, 1, x1);
	    const x62 = red.sqrnmul(x31, 31, x31);
	    const x124 = red.sqrnmul(x62, 62, x62);
	    const x127 = red.sqrnmul(x124, 3, x3);
	    const r0 = red.sqrn(x127, 1);
	    const r1 = red.sqrnmul(r0, 62, x62);
	    return r1;
	  }
	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 127x1 1x0 62x1
	    return this.core(x1);
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 127x1 1x0 62x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    return r2;
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 128x1 62x0
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x8 = red.sqrnmul(x4, 4, x4);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);
	    const r0 = red.sqrn(x128, 62);
	    return r0;
	  }
	}

	/**
	 * P224
	 */

	class P224 extends Prime116 {
	  constructor() {
	    // 2^224 - 2^96 + 1 (1 mod 16)
	    super('p224', 'ffffffff ffffffff ffffffff ffffffff' + '00000000 00000000 00000001', '6a0fec67 8598a792 0c55b2d4 0b2d6ffb' + 'bea3d8ce f3fb3632 dc691b74');
	  }
	  imulK(num) {
	    // K = 0xffffffffffffffffffffffff
	    // K = 2^96 - 1
	    const one = this.one.inject(num);
	    return num.iushln(96)._isub(num, one);
	  }
	  powS(x1) {
	    // Exponent: 2^128 - 1
	    // Bits: 128x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x8 = red.sqrnmul(x4, 4, x4);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);
	    return x128;
	  }
	  powE(x1) {
	    // Exponent: 2^127
	    // Bits: 1x1 127x0
	    const {
	      red
	    } = x1;
	    const r0 = red.sqrn(x1, 127);
	    return r0;
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 127x1 1x0 96x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x48 = red.sqrnmul(x24, 24, x24);
	    const x96 = red.sqrnmul(x48, 48, x48);
	    const x120 = red.sqrnmul(x96, 24, x24);
	    const x126 = red.sqrnmul(x120, 6, x6);
	    const x127 = red.sqrnmul(x126, 1, x1);
	    const r0 = red.sqrn(x127, 1);
	    const r1 = red.sqrnmul(r0, 96, x96);
	    return r1;
	  }
	}

	/**
	 * P521
	 */

	class P521 extends Prime34 {
	  constructor() {
	    // 2^521 - 1 (= 3 mod 4)
	    super('p521', '000001ff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff');
	  }
	  imulK(num) {
	    // K = 0x01
	    return num;
	  }
	  core(x1) {
	    // Exponent: 2^519 - 1
	    // Bits: 519x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x7 = red.sqrnmul(x6, 1, x1);
	    const x8 = red.sqrnmul(x7, 1, x1);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);
	    const x256 = red.sqrnmul(x128, 128, x128);
	    const x512 = red.sqrnmul(x256, 256, x256);
	    const x519 = red.sqrnmul(x512, 7, x7);
	    return x519;
	  }
	  pm3d4(x1) {
	    // Exponent: 2^519 - 1
	    // Bits: 519x1
	    return this.core(x1);
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 519x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    return r2;
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 1x1 519x0
	    const {
	      red
	    } = x1;
	    const r0 = red.sqrn(x1, 519);
	    return r0;
	  }
	}

	/**
	 * K256
	 */

	class K256 extends Prime34 {
	  constructor() {
	    // 2^256 - 2^32 - 977 (= 3 mod 4)
	    super('k256', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe fffffc2f');
	  }
	  split(input, output) {
	    // 256 = 9 * 26 + 22
	    const mask = 0x3fffff;
	    const len = Math.min(input.length, 9);
	    output._alloc(len + 1);
	    for (let i = 0; i < len; i++) output.words[i] = input.words[i];
	    output.length = len;
	    if (input.length <= 9) {
	      output._strip();
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs.
	    let prev = input.words[9];
	    let i = 10;
	    output.words[output.length++] = prev & mask;
	    output._strip();
	    for (; i < input.length; i++) {
	      const next = input.words[i] | 0;
	      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) input.length -= 10;else input.length -= 9;
	    input._strip(); // Unsure if we need this.
	  }
	  imulK(num) {
	    // K = 0x1000003d1 = [0x40, 0x3d1]
	    // K = 2^32 + 977
	    num._expand(num.length + 2);

	    // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    let lo = 0;
	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i];
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + Math.floor(lo / 0x4000000);
	    }

	    // Fast length reduction.
	    if (num.words[num.length - 1] === 0) {
	      num.length -= 1;
	      if (num.words[num.length - 1] === 0) num.length -= 1;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }
	  core(x1, x2) {
	    // Exponent: (p - 47) / 64
	    // Bits: 223x1 1x0 22x1 4x0
	    const {
	      red
	    } = x1;
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x9 = red.sqrnmul(x6, 3, x3);
	    const x11 = red.sqrnmul(x9, 2, x2);
	    const x22 = red.sqrnmul(x11, 11, x11);
	    const x44 = red.sqrnmul(x22, 22, x22);
	    const x88 = red.sqrnmul(x44, 44, x44);
	    const x176 = red.sqrnmul(x88, 88, x88);
	    const x220 = red.sqrnmul(x176, 44, x44);
	    const x223 = red.sqrnmul(x220, 3, x3);
	    const r0 = red.sqrn(x223, 1);
	    const r1 = red.sqrnmul(r0, 22, x22);
	    const r2 = red.sqrn(r1, 4);
	    return r2;
	  }
	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 1, x1);
	    const r4 = red.sqrn(r3, 1);
	    const r5 = red.sqrnmul(r4, 2, x2);
	    return r5;
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 1, x1);
	    const r4 = red.sqrn(r3, 1);
	    const r5 = red.sqrnmul(r4, 2, x2);
	    const r6 = red.sqrn(r5, 1);
	    const r7 = red.sqrnmul(r6, 1, x1);
	    return r7;
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 223x1 1x0 22x1 4x0 2x1 2x0
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 2, x2);
	    const r4 = red.sqrn(r3, 2);
	    return r4;
	  }
	}

	/**
	 * P251
	 */

	class P251 extends Prime34 {
	  constructor() {
	    // 2^251 - 9
	    super('p251', '07ffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff fffffff7');
	  }
	  imulK(num) {
	    // K = 0x09
	    if (num.isZero()) return num;
	    let carry = 0;
	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i] * 0x09 + carry;
	      carry = w >>> 26;
	      num.words[i] = w & 0x3ffffff;
	    }
	    if (carry !== 0) {
	      num._alloc(num.length + 1);
	      num.words[num.length++] = carry;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }
	  core(x1) {
	    // Exponent: 2^247 - 1
	    // Bits: 247x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x48 = red.sqrnmul(x24, 24, x24);
	    const x96 = red.sqrnmul(x48, 48, x48);
	    const x192 = red.sqrnmul(x96, 96, x96);
	    const x240 = red.sqrnmul(x192, 48, x48);
	    const x246 = red.sqrnmul(x240, 6, x6);
	    const x247 = red.sqrnmul(x246, 1, x1);
	    return x247;
	  }
	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 247x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    return r2;
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 247x1 1x0 1x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    const r3 = red.sqrn(r2, 1);
	    const r4 = red.sqrnmul(r3, 1, x1);
	    return r4;
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 248x1 1x0
	    const {
	      red
	    } = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrnmul(r0, 1, x1);
	    const r2 = red.sqrn(r1, 1);
	    return r2;
	  }
	}

	/**
	 * P25519
	 */

	class P25519 extends Prime58 {
	  constructor() {
	    // 2^255 - 19 (= 5 mod 8)
	    super('p25519', '7fffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffed', '2b832480 4fc1df0b 2b4d0099 3dfbd7a7' + '2f431806 ad2fe478 c4ee1b27 4a0ea0b0');
	  }
	  imulK(num) {
	    // K = 0x13
	    let carry = 0;
	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i] * 0x13 + carry;
	      carry = w >>> 26;
	      num.words[i] = w & 0x3ffffff;
	    }
	    if (carry !== 0) {
	      num._alloc(num.length + 1);
	      num.words[num.length++] = carry;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }
	  core(x1, x2) {
	    // Exponent: 2^250 - 1
	    // Bits: 250x1
	    const {
	      red
	    } = x1;
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x5 = red.sqrnmul(x4, 1, x1);
	    const x10 = red.sqrnmul(x5, 5, x5);
	    const x20 = red.sqrnmul(x10, 10, x10);
	    const x40 = red.sqrnmul(x20, 20, x20);
	    const x50 = red.sqrnmul(x40, 10, x10);
	    const x100 = red.sqrnmul(x50, 50, x50);
	    const x200 = red.sqrnmul(x100, 100, x100);
	    const x250 = red.sqrnmul(x200, 50, x50);
	    return x250;
	  }
	  pm5d8(x1) {
	    // Exponent: (p - 5) / 8
	    // Bits: 250x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    return r2;
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 250x1 1x0 1x1 1x0 2x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    const r3 = red.sqrn(r2, 1);
	    const r4 = red.sqrnmul(r3, 2, x2);
	    return r4;
	  }
	  pp3d8(x1) {
	    // Exponent: (p + 3) / 8
	    // Bits: 251x1 1x0
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrnmul(r0, 1, x1);
	    const r2 = red.sqrn(r1, 1);
	    return r2;
	  }
	}

	/**
	 * P448
	 */

	class P448 extends Prime34 {
	  constructor() {
	    // 2^448 - 2^224 - 1 (= 3 mod 4)
	    super('p448', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff');
	  }
	  imulK(num) {
	    // K = 0x100000000000000000000000000000000000000000000000000000001
	    // K = 2^224 + 1
	    const one = this.one.inject(num);
	    return num.iushln(224)._iadd(num, one);
	  }
	  core(x1, x2) {
	    // Exponent: 2^222 - 1
	    // Bits: 222x1
	    const {
	      red
	    } = x1;
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x9 = red.sqrnmul(x6, 3, x3);
	    const x11 = red.sqrnmul(x9, 2, x2);
	    const x22 = red.sqrnmul(x11, 11, x11);
	    const x44 = red.sqrnmul(x22, 22, x22);
	    const x88 = red.sqrnmul(x44, 44, x44);
	    const x176 = red.sqrnmul(x88, 88, x88);
	    const x220 = red.sqrnmul(x176, 44, x44);
	    const x222 = red.sqrnmul(x220, 2, x2);
	    return x222;
	  }
	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 223x1 1x0 222x1
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x222 = this.core(x1, x2);
	    const r0 = red.sqrnmul(x222, 1, x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 222, x222);
	    return r2;
	  }
	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 223x1 1x0 222x1 1x0 1x1
	    const {
	      red
	    } = x1;
	    const r0 = this.pm3d4(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    return r2;
	  }
	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 224x1 222x0
	    const {
	      red
	    } = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrnmul(r0, 2, x2);
	    const r2 = red.sqrn(r1, 222);
	    return r2;
	  }
	}

	/**
	 * Reduction Engine
	 */

	class Red {
	  constructor(m) {
	    let prime = null;
	    if (typeof m === 'string') {
	      prime = BN._prime(m);
	      m = prime.p;
	    }
	    enforce(BN.isBN(m), 'm', 'bignum');
	    nonred(!m.red, 'reduction');
	    range(m.sign() > 0, 'reduction');
	    this.m = m;
	    this.prime = prime;
	    this.mb = null;
	    this.sm1 = null;
	  }
	  _verify1(a) {
	    range(a.negative === 0, 'red');
	    red(a.red != null, 'red');
	  }
	  _verify2(a, b) {
	    range((a.negative | b.negative) === 0, 'red');
	    red(a.red != null && a.red === b.red, 'red');
	  }
	  get mont() {
	    return false;
	  }
	  precompute() {
	    // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.
	    if (this.sm1 === null && this.m.andln(7) === 5) {
	      if (this.prime) {
	        this.sm1 = this.prime.sm1.clone()._forceRed(this);
	      } else {
	        const x = new BN(2).toRed(this);
	        const e = this.m.subn(1).iushrn(2);

	        // sqrt(-1) = 2^((p - 1) / 4) mod p
	        this.sm1 = this.pow(x, e);
	      }
	    }
	    return this;
	  }
	  convertTo(num) {
	    const res = num.mod(this.m);
	    res.red = this;
	    return res;
	  }
	  convertFrom(num) {
	    const res = num.clone();
	    res.red = null;
	    return res;
	  }
	  intTo(a) {
	    return a;
	  }
	  intFrom(a) {
	    return a;
	  }
	  imod(a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.imod(this.m)._forceRed(this);
	  }
	  iadd(a, b) {
	    this._verify2(a, b);
	    a._iadd(a, b);
	    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
	    return a;
	  }
	  add(a, b) {
	    if (a.length < b.length) return this.iadd(b.clone(), a);
	    return this.iadd(a.clone(), b);
	  }
	  iaddn(a, num) {
	    this._verify1(a);
	    if (num < 0) return this.isubn(a, -num);
	    if (this.m.length === 1) num %= this.m.words[0];
	    a._iaddn(num);
	    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
	    return a;
	  }
	  addn(a, num) {
	    return this.iaddn(a.clone(), num);
	  }
	  isub(a, b) {
	    this._verify2(a, b);

	    //  0: a - a mod m == 0
	    // -1: a - b mod m == m - (b - a)
	    // +1: a - b mod m == a - b
	    const cmp = a.ucmp(b);
	    if (cmp === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }
	    if (cmp < 0) {
	      a._isub(b, a);
	      a._isub(this.m, a);
	    } else {
	      a._isub(a, b);
	    }
	    return a;
	  }
	  sub(a, b) {
	    return this.isub(a.clone(), b);
	  }
	  isubn(a, num) {
	    this._verify1(a);
	    if (num < 0) return this.iaddn(a, -num);
	    if (this.m.length === 1) num %= this.m.words[0];

	    //  <: a - b mod m == m - (b - a)
	    // >=: a - b mod m == a - b
	    if (a.length === 1 && a.words[0] < num) {
	      a.words[0] = num - a.words[0];
	      a._isub(this.m, a);
	    } else {
	      a._isubn(num);
	    }
	    return a;
	  }
	  subn(a, num) {
	    return this.isubn(a.clone(), num);
	  }
	  imul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  }
	  mul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  }
	  imuln(a, num) {
	    this._verify1(a);
	    if (a.isZero()) return a;
	    if (num === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }
	    const neg = num < 0;
	    if (neg) num = -num;
	    if (this.m.length === 1) num %= this.m.words[0];
	    a.imuln(num);
	    if (num <= 16) {
	      // Quick reduction.
	      while (a.ucmp(this.m) >= 0) a._isub(a, this.m);
	    } else {
	      this.imod(a);
	    }
	    if (neg) this.ineg(a);
	    return a;
	  }
	  muln(a, num) {
	    return this.imuln(a.clone(), num);
	  }
	  idiv(a, b) {
	    return this.div(a, b)._move(a);
	  }
	  div(a, b) {
	    return this.mul(a, this.invert(b));
	  }
	  idivn(a, num) {
	    return this.divn(a, num)._move(a);
	  }
	  divn(a, num) {
	    return this.div(a, this.convertTo(new BN(num)));
	  }
	  ipow(a, num) {
	    return this.pow(a, num)._move(a);
	  }
	  pow(a, num) {
	    this._verify1(a);
	    if (num.isNeg()) a = this.invert(a);

	    // Small exponent.
	    if (num.length === 1) return this.pown(a, num.words[0]);

	    // Call out to BigInt.
	    if (HAS_BIGINT && !this.prime) return this.powInt(a, num);

	    // Otherwise, a BN implementation.
	    return this.powNum(a, num);
	  }
	  powNum(a, num) {
	    // Sliding window (odd multiples only).
	    const one = new BN(1).toRed(this);
	    const wnd = new Array(WND_SIZE);
	    const a2 = this.sqr(a);
	    wnd[0] = a;
	    for (let i = 1; i < WND_SIZE; i++) wnd[i] = this.mul(wnd[i - 1], a2);
	    let i = num.bitLength();
	    let r = one;
	    while (i >= WND_WIDTH) {
	      let width = WND_WIDTH;
	      let bits = num.bits(i - width, width);
	      if (bits < WND_SIZE) {
	        r = this.sqr(r);
	        i -= 1;
	        continue;
	      }
	      while ((bits & 1) === 0) {
	        width -= 1;
	        bits >>= 1;
	      }
	      if (r === one) {
	        r = wnd[bits >> 1].clone();
	      } else {
	        r = this.sqrn(r, width);
	        r = this.mul(r, wnd[bits >> 1]);
	      }
	      i -= width;
	    }
	    if (i > 0) {
	      const bits = num.bits(0, i);
	      while (i--) {
	        r = this.sqr(r);
	        if (bits >> i & 1) r = this.mul(r, a);
	      }
	    }
	    return r;
	  }
	  powInt(a, num) {
	    if (this.mb === null) this.mb = this.m.toBigInt();
	    const x = this.intFrom(a.toBigInt());
	    const y = powInt(x, num, this.mb);
	    const z = this.intTo(y);
	    return BN.fromBigInt(z)._forceRed(this);
	  }
	  sqrn(a, n) {
	    while (n--) a = this.sqr(a);
	    return a;
	  }
	  sqrnmul(a, n, b) {
	    return this.mul(this.sqrn(a, n), b);
	  }
	  ipown(a, num) {
	    return this.pown(a, num)._move(a);
	  }
	  pown(a, num) {
	    this._verify1(a);
	    if (num < 0) {
	      a = this.invert(a);
	      num = -num;
	    }
	    if (num === 0) return new BN(1).toRed(this);
	    if (num === 1) return a.clone();
	    const bits = countBits(num);
	    let r = a;
	    for (let i = bits - 2; i >= 0; i--) {
	      r = this.sqr(r);
	      if (num >> i & 1) r = this.mul(r, a);
	    }
	    return r;
	  }
	  isqr(a) {
	    return this.imul(a, a);
	  }
	  sqr(a) {
	    return this.mul(a, a);
	  }
	  isqrt(x) {
	    return this.sqrt(x)._move(x);
	  }
	  sqrt(x) {
	    this._verify1(x);

	    // Optimized square root chain.
	    if (this.prime) return this.prime.sqrt(x);

	    // Fast case (p = 3 mod 4).
	    if (this.m.andln(3) === 3) return this.sqrt3mod4(x);

	    // Fast case (p = 5 mod 8).
	    if (this.m.andln(7) === 5) {
	      if (this.sm1 != null) return this.sqrt5mod8sm1(x);
	      return this.sqrt5mod8(x);
	    }

	    // Slow case (Tonelli-Shanks).
	    return this.sqrt0(x);
	  }
	  sqrt3mod4(x) {
	    const e = this.m.addn(1).iushrn(2); // (p + 1) / 4
	    const b = this.pow(x, e);
	    if (!this.sqr(b).eq(x)) throw new SquareRootError(b);
	    return b;
	  }
	  sqrt5mod8(x) {
	    // Atkin's Algorithm.
	    const one = new BN(1).toRed(this);
	    const e = this.m.ushrn(3); // (p - 5) / 8
	    const x2 = this.add(x, x);
	    const alpha = this.pow(x2, e);
	    const beta = this.mul(x2, this.sqr(alpha));
	    const b = this.mul(this.mul(alpha, x), this.isub(beta, one));
	    if (!this.sqr(b).eq(x)) throw new SquareRootError(b);
	    return b;
	  }
	  sqrt5mod8sm1(x) {
	    const e = this.m.addn(3).iushrn(3); // (p + 3) / 8
	    const b = this.pow(x, e);
	    if (this.sqr(b).eq(x)) return b;
	    const c = this.mul(b, this.sm1);
	    if (this.sqr(c).eq(x)) return c;
	    throw new SquareRootError(b);
	  }
	  sqrt0(x) {
	    if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error('Invalid prime.');
	    switch (this.jacobi(x)) {
	      case -1:
	        throw new SquareRootError(x);
	      case 0:
	        return x.clone();
	    }
	    const one = new BN(1).toRed(this);
	    const s = this.m.subn(1);
	    const e = s._makeOdd();
	    const n = new BN(2).toRed(this);
	    while (this.jacobi(n) !== -1) this.iadd(n, one);
	    let g = this.pow(n, s);
	    let b = this.pow(x, s);
	    let y = this.pow(x, s.iaddn(1).iushrn(1));
	    let k = e;
	    for (;;) {
	      let t = b;
	      let m = 0;
	      while (!t.eq(one) && m < k) {
	        t = this.sqr(t);
	        m += 1;
	      }
	      if (m === 0) break;
	      assert(m < k);
	      t = this.sqrn(g, k - m - 1);
	      g = this.sqr(t);
	      y = this.mul(y, t);
	      b = this.mul(b, g);
	      k = m;
	    }
	    return y;
	  }
	  idivsqrt(u, v) {
	    return this.divsqrt(u, v)._move(u);
	  }
	  divsqrt(u, v) {
	    this._verify2(u, v);

	    // u = 0, v = 0
	    if (u.isZero() && v.isZero()) throw new SquareRootError(v);

	    // Optimized inverse square root chain.
	    if (this.prime) return this.prime.divsqrt(u, v);

	    // p = 3 mod 4
	    if (this.m.andln(3) === 3) return this.divsqrt3mod4(u, v);

	    // p = 5 mod 8
	    if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(u, v);

	    // v = 0
	    if (v.isZero()) throw new SquareRootError(v);
	    return this.sqrt(this.div(u, v));
	  }
	  divsqrt3mod4(u, v) {
	    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
	    const e = this.m.subn(3).iushrn(2);
	    const u2 = this.sqr(u);
	    const u3 = this.mul(u2, u);
	    const u5 = this.mul(u3, u2);
	    const v3 = this.mul(this.sqr(v), v);
	    const p = this.pow(this.mul(u5, v3), e);
	    const x = this.mul(this.mul(u3, v), p);
	    const c = this.mul(v, this.sqr(x));
	    if (c.eq(u)) return x;
	    throw new SquareRootError(x);
	  }
	  divsqrt5mod8(u, v) {
	    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
	    const e = this.m.subn(5).iushrn(3);
	    const v3 = this.mul(this.sqr(v), v);
	    const v7 = this.mul(this.sqr(v3), v);
	    const p = this.pow(this.mul(u, v7), e);
	    const x = this.mul(this.mul(u, v3), p);
	    const c = this.mul(v, this.sqr(x));
	    if (c.eq(u)) return x;
	    const mc = this.ineg(c);
	    if (mc.eq(u)) return this.mul(x, this.sm1);
	    if (mc.eq(this.mul(u, this.sm1))) throw new SquareRootError(this.mul(x, this.sm1));
	    throw new SquareRootError(x);
	  }
	  isSquare(a) {
	    if (this.m.isOdd()) return this.jacobi(a) >= 0;
	    return this.kronecker(a) >= 0;
	  }
	  ishl(a, num) {
	    this._verify1(a);
	    return this.imod(a.iushl(num));
	  }
	  shl(a, num) {
	    return this.ishl(a.clone(), num);
	  }
	  ishln(a, num) {
	    this._verify1(a);
	    a.iushln(num);
	    if (num <= 4) {
	      // Quick reduction.
	      while (a.ucmp(this.m) >= 0) a._isub(a, this.m);
	    } else {
	      this.imod(a);
	    }
	    return a;
	  }
	  shln(a, num) {
	    return this.ishln(a.clone(), num);
	  }
	  ineg(a) {
	    this._verify1(a);
	    if (!a.isZero()) a._isub(this.m, a);
	    return a;
	  }
	  neg(a) {
	    return this.ineg(a.clone());
	  }
	  eq(a, b) {
	    this._verify2(a, b);
	    return a.ucmp(b) === 0;
	  }
	  eqn(a, num) {
	    this._verify1(a);
	    if (this.m.length === 1) {
	      num %= this.m.words[0];
	      if (num < 0) num += this.m.words[0];
	      return a.ucmpn(num) === 0;
	    }
	    if (num < 0) {
	      this.m._isubn(-num);
	      const cmp = a.ucmp(this.m);
	      this.m._iaddn(-num);
	      return cmp === 0;
	    }
	    return a.ucmpn(num) === 0;
	  }
	  isHigh(a) {
	    return !this.isLow(a);
	  }
	  isLow(a) {
	    this._verify1(a);
	    return a.ucmp(this.m.ushrn(1)) <= 0;
	  }
	  isOdd(a) {
	    this._verify1(a);
	    return a.isOdd();
	  }
	  isEven(a) {
	    this._verify1(a);
	    return a.isEven();
	  }
	  legendre(num) {
	    this._verify1(num);
	    if (this.m.isEven()) throw new Error('legendre: `num` must be odd.');

	    // Euler's criterion.
	    const e = this.m.subn(1).iushrn(1); // (p - 1) / 2
	    const symbol = this.pow(num, e);
	    if (symbol.isZero()) return 0;
	    const one = new BN(1).toRed(this);
	    if (symbol.eq(one)) return 1;
	    if (symbol.eq(this.ineg(one))) return -1;
	    throw new Error('Invalid prime.');
	  }
	  jacobi(a) {
	    this._verify1(a);
	    return a.jacobi(this.m);
	  }
	  kronecker(a) {
	    this._verify1(a);
	    return a.kronecker(this.m);
	  }
	  iinvert(a) {
	    return this.invert(a)._move(a);
	  }
	  invert(a) {
	    this._verify1(a);
	    return a.invert(this.m)._forceRed(this);
	  }
	  ifermat(a) {
	    return this.fermat(a)._move(a);
	  }
	  fermat(a) {
	    this._verify1(a);
	    if (a.isZero() || this.m.cmpn(1) === 0) throw new RangeError('Not invertible.');

	    // Optimized inversion chain.
	    if (this.prime) return this.prime.fermat(a);

	    // Invert using fermat's little theorem.
	    return this.pow(a, this.m.subn(2));
	  }
	  invertAll(elems) {
	    // Montgomery's trick.
	    enforce(Array.isArray(elems), 'elems', 'array');
	    for (const elem of elems) {
	      enforce(BN.isBN(elem), 'elem', 'bignum');
	      this._verify1(elem);
	    }
	    if (this.m.cmpn(1) === 0 || this.m.isEven()) throw new RangeError('Not invertible.');
	    const len = elems.length;
	    const invs = new Array(len);
	    if (len === 0) return invs;
	    let acc = new BN(1).toRed(this);
	    for (let i = 0; i < len; i++) {
	      if (elems[i].isZero()) {
	        invs[i] = elems[i].clone();
	        continue;
	      }
	      invs[i] = acc;
	      acc = this.mul(acc, elems[i]);
	    }
	    acc = this.invert(acc);
	    for (let i = len - 1; i >= 0; i--) {
	      if (elems[i].isZero()) continue;
	      invs[i] = this.mul(acc, invs[i]);
	      acc = this.mul(acc, elems[i]);
	    }
	    return invs;
	  }
	  [custom]() {
	    if (this.prime) return `<Red: ${this.prime.name}>`;
	    return `<Red: ${this.m.toString(10)}>`;
	  }
	}

	/**
	 * Barrett Engine
	 */

	class Barrett extends Red {
	  constructor(m) {
	    super(m);
	    this.prime = null;
	    this.n = this.m.bitLength();
	    if (this.n % 26 !== 0) this.n += 26 - this.n % 26;
	    this.k = this.n * 2;
	    this.w = this.k / 26;
	    this.b = BN.shift(1, this.k).div(this.m);
	  }
	  convertTo(num) {
	    if (num.length > this.w) return super.convertTo(num);
	    return this.imod(num.clone());
	  }
	  _shift(q) {
	    let i = 0;
	    let j = this.w;
	    while (j < q.length) q.words[i++] = q.words[j++];
	    if (i === 0) q.words[i++] = 0;
	    q.length = i;
	  }
	  imod(a) {
	    const neg = a.negative;
	    assert(a.length <= this.w);
	    a.negative = 0;
	    const q = a.mul(this.b);

	    // Shift right by `k` bits.
	    this._shift(q);
	    a._isub(a, q.mul(this.m));
	    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
	    if (neg && !a.isZero()) a._isub(this.m, a);
	    a.red = this;
	    return a;
	  }
	}

	/**
	 * Montgomery Engine
	 */

	class Mont extends Red {
	  constructor(m) {
	    super(m);

	    // Note that:
	    //
	    //   mi = (-m^-1 mod (2^(n * 2))) mod r
	    //
	    // and:
	    //
	    //   mi = (((2^n)^-1 mod m) * r^-1 - 1) / m
	    //
	    // are equivalent.
	    this.prime = null;
	    this.n = this.m.length * 26;
	    this.r = BN.shift(1, this.n);
	    this.r2 = BN.shift(1, this.n * 2).imod(this.m);
	    this.ri = this.r.invert(this.m);
	    this.mi = this.r.mul(this.ri).isubn(1).div(this.m);
	    this.rib = null;
	  }
	  get mont() {
	    return true;
	  }
	  convertTo(num) {
	    if (num.isNeg() || num.ucmp(this.m) >= 0) return this.imod(num.ushln(this.n));

	    // Equivalent to: (num * 2^n) mod m
	    return this.mul(num, this.r2);
	  }
	  convertFrom(num) {
	    // Equivalent to: num * r^-1 mod m
	    const r = this.mul(num, new BN(1));
	    r.red = null;
	    return r;
	  }
	  intTo(a) {
	    return (a << BigInt(this.n)) % this.mb;
	  }
	  intFrom(a) {
	    if (this.rib === null) this.rib = this.ri.toBigInt();
	    return a * this.rib % this.mb;
	  }
	  iaddn(a, num) {
	    return this.iadd(a, this.convertTo(new BN(num)));
	  }
	  isubn(a, num) {
	    return this.isub(a, this.convertTo(new BN(num)));
	  }
	  imul(a, b) {
	    return this.mul(a, b)._move(a);
	  }
	  mul(a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
	    const t = a.mul(b);
	    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);
	    const u = t.iadd(c.mul(this.m)).iushrn(this.n);
	    if (u.ucmp(this.m) >= 0) u._isub(u, this.m);
	    return u._forceRed(this);
	  }
	  imuln(a, num) {
	    this._verify1(a);
	    if (a.isZero()) return a;
	    if (num === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }
	    const neg = num < 0;
	    if (neg) num = -num;
	    if (this.m.length === 1) num %= this.m.words[0];
	    const bits = countBits(num);

	    // Potentially compute with additions.
	    // This avoids an expensive division.
	    if (bits > 5) {
	      // Slow case (num > 31).
	      this.imul(a, this.convertTo(new BN(num)));
	    } else if ((num & num - 1) === 0) {
	      // Optimize for powers of two.
	      for (let i = 0; i < bits - 1; i++) this.iadd(a, a);
	    } else {
	      // Multiply left to right.
	      const c = a.clone();
	      for (let i = bits - 2; i >= 0; i--) {
	        this.iadd(a, a);
	        if (num >> i & 1) this.iadd(a, c);
	      }
	    }
	    if (neg) this.ineg(a);
	    return a;
	  }
	  eqn(a, num) {
	    this._verify1(a);
	    if (num === 0) return a.isZero();
	    return a.ucmp(this.convertTo(new BN(num))) === 0;
	  }
	  isLow(a) {
	    this._verify1(a);
	    return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;
	  }
	  isOdd(a) {
	    this._verify1(a);
	    return this.convertFrom(a).isOdd();
	  }
	  isEven(a) {
	    this._verify1(a);
	    return this.convertFrom(a).isEven();
	  }
	  invert(a) {
	    this._verify1(a);

	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    return this.imod(a.invert(this.m).mul(this.r2));
	  }
	}

	/*
	 * Helpers
	 */

	function makeError(Error, msg, start) {
	  const err = new Error(msg);
	  if (Error.captureStackTrace) Error.captureStackTrace(err, start);
	  return err;
	}
	function assert(value, message) {
	  if (!value) {
	    const msg = message || 'Assertion failed.';
	    throw makeError(Error, msg, assert);
	  }
	}
	function enforce(value, name, type) {
	  if (!value) {
	    const msg = `"${name}" must be a(n) ${type}.`;
	    throw makeError(TypeError, msg, enforce);
	  }
	}
	function range(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with positive numbers.`;
	    throw makeError(RangeError, msg, range);
	  }
	}
	function red(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with red numbers.`;
	    throw makeError(TypeError, msg, red);
	  }
	}
	function nonred(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with normal numbers.`;
	    throw makeError(TypeError, msg, nonred);
	  }
	}
	function nonzero(value) {
	  if (!value) {
	    const msg = 'Cannot divide by zero.';
	    throw makeError(RangeError, msg, nonzero);
	  }
	}
	class SquareRootError extends Error {
	  constructor(result) {
	    super();
	    this.name = 'SquareRootError';
	    this.message = 'X is not a square mod P.';
	    this.result = result.fromRed();
	    if (Error.captureStackTrace) Error.captureStackTrace(this, SquareRootError);
	  }
	}
	function isInteger(num) {
	  return Number.isSafeInteger(num);
	}
	function isSMI(num) {
	  return isInteger(num) && num >= -67108863 && num <= 0x3ffffff;
	}
	function allocate(ArrayType, size) {
	  if (ArrayType.allocUnsafeSlow) return ArrayType.allocUnsafeSlow(size);
	  return new ArrayType(size);
	}
	function getBase(base) {
	  if (base == null) return 10;
	  if (typeof base === 'number') return base;
	  switch (base) {
	    case 'bin':
	      return 2;
	    case 'oct':
	      return 8;
	    case 'dec':
	      return 10;
	    case 'hex':
	      return 16;
	  }
	  return 0;
	}

	/*
	 * Internal
	 */

	function countBits(w) {
	  if (Math.clz32) return 32 - Math.clz32(w);
	  let t = w;
	  let r = 0;
	  if (t >= 0x1000) {
	    r += 13;
	    t >>>= 13;
	  }
	  if (t >= 0x40) {
	    r += 7;
	    t >>>= 7;
	  }
	  if (t >= 0x8) {
	    r += 4;
	    t >>>= 4;
	  }
	  if (t >= 0x02) {
	    r += 2;
	    t >>>= 2;
	  }
	  return r + t;
	}
	function zeroBits(w) {
	  // Shortcut.
	  if (w === 0) return 26;
	  let t = w;
	  let r = 0;
	  if ((t & 0x1fff) === 0) {
	    r += 13;
	    t >>>= 13;
	  }
	  if ((t & 0x7f) === 0) {
	    r += 7;
	    t >>>= 7;
	  }
	  if ((t & 0xf) === 0) {
	    r += 4;
	    t >>>= 4;
	  }
	  if ((t & 0x3) === 0) {
	    r += 2;
	    t >>>= 2;
	  }
	  if ((t & 0x1) === 0) r += 1;
	  return r;
	}
	function parseHex(str, start, end) {
	  const len = Math.min(str.length, end);
	  let r = 0;
	  let z = 0;
	  for (let i = start; i < len; i++) {
	    const c = str.charCodeAt(i) - 48;
	    r <<= 4;
	    let b;
	    if (c >= 49 && c <= 54) {
	      // 'a' - 'f'
	      b = c - 49 + 0xa;
	    } else if (c >= 17 && c <= 22) {
	      // 'A' - 'F'
	      b = c - 17 + 0xa;
	    } else {
	      // '0' - '9'
	      b = c;
	    }
	    r |= b;
	    z |= b;
	  }
	  if (z & -16) throw new Error('Invalid string.');
	  return r;
	}
	function parseBase(str, start, end, mul) {
	  const len = Math.min(str.length, end);
	  let r = 0;
	  for (let i = start; i < len; i++) {
	    const c = str.charCodeAt(i) - 48;
	    r *= mul;
	    let b;
	    if (c >= 49) {
	      // 'a'
	      b = c - 49 + 0xa;
	    } else if (c >= 17) {
	      // 'A'
	      b = c - 17 + 0xa;
	    } else {
	      // '0' - '9'
	      b = c;
	    }
	    if (c < 0 || c > 207 || b >= mul) throw new Error('Invalid string.');
	    r += b;
	  }
	  return r;
	}

	/*
	 * Exponentiation (bigint)
	 */

	function powInt(x, e, m) {
	  // Sliding window (odd multiples only).
	  const one = BigInt(1);
	  const wnd = new Array(WND_SIZE);
	  const x2 = x * x % m;
	  wnd[0] = x;
	  for (let i = 1; i < WND_SIZE; i++) wnd[i] = wnd[i - 1] * x2 % m;
	  let i = e.bitLength();
	  let r = one;
	  while (i >= WND_WIDTH) {
	    let width = WND_WIDTH;
	    let bits = e.bits(i - width, width);
	    if (bits < WND_SIZE) {
	      r = r * r % m;
	      i -= 1;
	      continue;
	    }
	    while ((bits & 1) === 0) {
	      width -= 1;
	      bits >>= 1;
	    }
	    if (r === one) {
	      r = wnd[bits >> 1];
	    } else {
	      r = sqrn(r, width, m);
	      r = r * wnd[bits >> 1] % m;
	    }
	    i -= width;
	  }
	  if (i > 0) {
	    const bits = e.bits(0, i);
	    while (i--) {
	      r = r * r % m;
	      if (bits >> i & 1) r = r * x % m;
	    }
	  }
	  return r;
	}
	function sqrn(x, n, m) {
	  for (let i = 0; i < n; i++) x = x * x % m;
	  return x;
	}

	/*
	 * Multiplication
	 */

	function smallMulTo(self, num, out) {
	  const len = self.length + num.length;
	  out.negative = self.negative ^ num.negative;
	  out._alloc(len);
	  out.length = len;

	  // Peel one iteration (compiler can't
	  // do it, because of code complexity).
	  const a = self.words[0];
	  const b = num.words[0];
	  const r = a * b;
	  const lo = r & 0x3ffffff;
	  let carry = r / 0x4000000 | 0;
	  let k = 1;
	  out.words[0] = lo;
	  for (; k < out.length - 1; k++) {
	    // Sum all words with the same
	    // `i + j = k` and accumulate
	    // `ncarry`, note that ncarry
	    // could be >= 0x3ffffff.
	    let ncarry = carry >>> 26;
	    let rword = carry & 0x3ffffff;
	    const min = Math.max(0, k - self.length + 1);
	    const max = Math.min(k, num.length - 1);
	    for (let j = min; j <= max; j++) {
	      const i = k - j;
	      const a = self.words[i];
	      const b = num.words[j];
	      const r = a * b + rword;
	      ncarry += r / 0x4000000 | 0;
	      rword = r & 0x3ffffff;
	    }
	    out.words[k] = rword | 0;
	    carry = ncarry | 0;
	  }
	  if (carry !== 0) out.words[k] = carry | 0;else out.length -= 1;
	  return out._strip();
	}
	function bigMulTo(self, num, out) {
	  const len = self.length + num.length;
	  out.negative = self.negative ^ num.negative;
	  out._alloc(len);
	  out.length = len;
	  let carry = 0;
	  let hncarry = 0;
	  let k = 0;
	  for (; k < out.length - 1; k++) {
	    // Sum all words with the same
	    // `i + j = k` and accumulate
	    // `ncarry`, note that ncarry
	    // could be >= 0x3ffffff.
	    let ncarry = hncarry;
	    hncarry = 0;
	    let rword = carry & 0x3ffffff;
	    const min = Math.max(0, k - self.length + 1);
	    const max = Math.min(k, num.length - 1);
	    for (let j = min; j <= max; j++) {
	      const i = k - j;
	      const a = self.words[i];
	      const b = num.words[j];
	      const r = a * b;
	      let lo = r & 0x3ffffff;
	      ncarry = ncarry + (r / 0x4000000 | 0) | 0;
	      lo = lo + rword | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = ncarry + (lo >>> 26) | 0;
	      hncarry += ncarry >>> 26;
	      ncarry &= 0x3ffffff;
	    }
	    out.words[k] = rword;
	    carry = ncarry;
	    ncarry = hncarry;
	  }
	  if (carry !== 0) out.words[k] = carry;else out.length -= 1;
	  return out._strip();
	}
	function jumboMulTo(x, y, out) {
	  // v8 has a 2147483519 bit max (~256mb).
	  if (!HAS_BIGINT || x.length + y.length > 82595519) return bigMulTo(x, y, out);
	  const zero = BigInt(0);
	  const mask = BigInt(0x3ffffff);
	  const shift = BigInt(26);
	  let z = x.toBigInt() * y.toBigInt();
	  const neg = z < zero | 0;
	  if (neg) z = -z;
	  let i = 0;
	  while (z > zero) {
	    out.words[i++] = Number(z & mask);
	    z >>= shift;
	  }
	  if (i === 0) out.words[i++] = 0;
	  out.length = i;
	  out.negative = neg;
	  return out;
	}
	function comb10MulTo(self, num, out) {
	  const a = self.words;
	  const b = num.words;
	  const o = out.words;
	  const a0 = a[0] | 0;
	  const al0 = a0 & 0x1fff;
	  const ah0 = a0 >>> 13;
	  const a1 = a[1] | 0;
	  const al1 = a1 & 0x1fff;
	  const ah1 = a1 >>> 13;
	  const a2 = a[2] | 0;
	  const al2 = a2 & 0x1fff;
	  const ah2 = a2 >>> 13;
	  const a3 = a[3] | 0;
	  const al3 = a3 & 0x1fff;
	  const ah3 = a3 >>> 13;
	  const a4 = a[4] | 0;
	  const al4 = a4 & 0x1fff;
	  const ah4 = a4 >>> 13;
	  const a5 = a[5] | 0;
	  const al5 = a5 & 0x1fff;
	  const ah5 = a5 >>> 13;
	  const a6 = a[6] | 0;
	  const al6 = a6 & 0x1fff;
	  const ah6 = a6 >>> 13;
	  const a7 = a[7] | 0;
	  const al7 = a7 & 0x1fff;
	  const ah7 = a7 >>> 13;
	  const a8 = a[8] | 0;
	  const al8 = a8 & 0x1fff;
	  const ah8 = a8 >>> 13;
	  const a9 = a[9] | 0;
	  const al9 = a9 & 0x1fff;
	  const ah9 = a9 >>> 13;
	  const b0 = b[0] | 0;
	  const bl0 = b0 & 0x1fff;
	  const bh0 = b0 >>> 13;
	  const b1 = b[1] | 0;
	  const bl1 = b1 & 0x1fff;
	  const bh1 = b1 >>> 13;
	  const b2 = b[2] | 0;
	  const bl2 = b2 & 0x1fff;
	  const bh2 = b2 >>> 13;
	  const b3 = b[3] | 0;
	  const bl3 = b3 & 0x1fff;
	  const bh3 = b3 >>> 13;
	  const b4 = b[4] | 0;
	  const bl4 = b4 & 0x1fff;
	  const bh4 = b4 >>> 13;
	  const b5 = b[5] | 0;
	  const bl5 = b5 & 0x1fff;
	  const bh5 = b5 >>> 13;
	  const b6 = b[6] | 0;
	  const bl6 = b6 & 0x1fff;
	  const bh6 = b6 >>> 13;
	  const b7 = b[7] | 0;
	  const bl7 = b7 & 0x1fff;
	  const bh7 = b7 >>> 13;
	  const b8 = b[8] | 0;
	  const bl8 = b8 & 0x1fff;
	  const bh8 = b8 >>> 13;
	  const b9 = b[9] | 0;
	  const bl9 = b9 & 0x1fff;
	  const bh9 = b9 >>> 13;
	  let c = 0;
	  let lo, mid, hi;
	  out.negative = self.negative ^ num.negative;
	  out._alloc(20);
	  out.length = 19;

	  /* k = 0 */
	  lo = Math.imul(al0, bl0);
	  mid = Math.imul(al0, bh0);
	  mid = mid + Math.imul(ah0, bl0) | 0;
	  hi = Math.imul(ah0, bh0);
	  let w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
	  w0 &= 0x3ffffff;

	  /* k = 1 */
	  lo = Math.imul(al1, bl0);
	  mid = Math.imul(al1, bh0);
	  mid = mid + Math.imul(ah1, bl0) | 0;
	  hi = Math.imul(ah1, bh0);
	  lo = lo + Math.imul(al0, bl1) | 0;
	  mid = mid + Math.imul(al0, bh1) | 0;
	  mid = mid + Math.imul(ah0, bl1) | 0;
	  hi = hi + Math.imul(ah0, bh1) | 0;
	  let w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
	  w1 &= 0x3ffffff;

	  /* k = 2 */
	  lo = Math.imul(al2, bl0);
	  mid = Math.imul(al2, bh0);
	  mid = mid + Math.imul(ah2, bl0) | 0;
	  hi = Math.imul(ah2, bh0);
	  lo = lo + Math.imul(al1, bl1) | 0;
	  mid = mid + Math.imul(al1, bh1) | 0;
	  mid = mid + Math.imul(ah1, bl1) | 0;
	  hi = hi + Math.imul(ah1, bh1) | 0;
	  lo = lo + Math.imul(al0, bl2) | 0;
	  mid = mid + Math.imul(al0, bh2) | 0;
	  mid = mid + Math.imul(ah0, bl2) | 0;
	  hi = hi + Math.imul(ah0, bh2) | 0;
	  let w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
	  w2 &= 0x3ffffff;

	  /* k = 3 */
	  lo = Math.imul(al3, bl0);
	  mid = Math.imul(al3, bh0);
	  mid = mid + Math.imul(ah3, bl0) | 0;
	  hi = Math.imul(ah3, bh0);
	  lo = lo + Math.imul(al2, bl1) | 0;
	  mid = mid + Math.imul(al2, bh1) | 0;
	  mid = mid + Math.imul(ah2, bl1) | 0;
	  hi = hi + Math.imul(ah2, bh1) | 0;
	  lo = lo + Math.imul(al1, bl2) | 0;
	  mid = mid + Math.imul(al1, bh2) | 0;
	  mid = mid + Math.imul(ah1, bl2) | 0;
	  hi = hi + Math.imul(ah1, bh2) | 0;
	  lo = lo + Math.imul(al0, bl3) | 0;
	  mid = mid + Math.imul(al0, bh3) | 0;
	  mid = mid + Math.imul(ah0, bl3) | 0;
	  hi = hi + Math.imul(ah0, bh3) | 0;
	  let w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
	  w3 &= 0x3ffffff;

	  /* k = 4 */
	  lo = Math.imul(al4, bl0);
	  mid = Math.imul(al4, bh0);
	  mid = mid + Math.imul(ah4, bl0) | 0;
	  hi = Math.imul(ah4, bh0);
	  lo = lo + Math.imul(al3, bl1) | 0;
	  mid = mid + Math.imul(al3, bh1) | 0;
	  mid = mid + Math.imul(ah3, bl1) | 0;
	  hi = hi + Math.imul(ah3, bh1) | 0;
	  lo = lo + Math.imul(al2, bl2) | 0;
	  mid = mid + Math.imul(al2, bh2) | 0;
	  mid = mid + Math.imul(ah2, bl2) | 0;
	  hi = hi + Math.imul(ah2, bh2) | 0;
	  lo = lo + Math.imul(al1, bl3) | 0;
	  mid = mid + Math.imul(al1, bh3) | 0;
	  mid = mid + Math.imul(ah1, bl3) | 0;
	  hi = hi + Math.imul(ah1, bh3) | 0;
	  lo = lo + Math.imul(al0, bl4) | 0;
	  mid = mid + Math.imul(al0, bh4) | 0;
	  mid = mid + Math.imul(ah0, bl4) | 0;
	  hi = hi + Math.imul(ah0, bh4) | 0;
	  let w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
	  w4 &= 0x3ffffff;

	  /* k = 5 */
	  lo = Math.imul(al5, bl0);
	  mid = Math.imul(al5, bh0);
	  mid = mid + Math.imul(ah5, bl0) | 0;
	  hi = Math.imul(ah5, bh0);
	  lo = lo + Math.imul(al4, bl1) | 0;
	  mid = mid + Math.imul(al4, bh1) | 0;
	  mid = mid + Math.imul(ah4, bl1) | 0;
	  hi = hi + Math.imul(ah4, bh1) | 0;
	  lo = lo + Math.imul(al3, bl2) | 0;
	  mid = mid + Math.imul(al3, bh2) | 0;
	  mid = mid + Math.imul(ah3, bl2) | 0;
	  hi = hi + Math.imul(ah3, bh2) | 0;
	  lo = lo + Math.imul(al2, bl3) | 0;
	  mid = mid + Math.imul(al2, bh3) | 0;
	  mid = mid + Math.imul(ah2, bl3) | 0;
	  hi = hi + Math.imul(ah2, bh3) | 0;
	  lo = lo + Math.imul(al1, bl4) | 0;
	  mid = mid + Math.imul(al1, bh4) | 0;
	  mid = mid + Math.imul(ah1, bl4) | 0;
	  hi = hi + Math.imul(ah1, bh4) | 0;
	  lo = lo + Math.imul(al0, bl5) | 0;
	  mid = mid + Math.imul(al0, bh5) | 0;
	  mid = mid + Math.imul(ah0, bl5) | 0;
	  hi = hi + Math.imul(ah0, bh5) | 0;
	  let w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
	  w5 &= 0x3ffffff;

	  /* k = 6 */
	  lo = Math.imul(al6, bl0);
	  mid = Math.imul(al6, bh0);
	  mid = mid + Math.imul(ah6, bl0) | 0;
	  hi = Math.imul(ah6, bh0);
	  lo = lo + Math.imul(al5, bl1) | 0;
	  mid = mid + Math.imul(al5, bh1) | 0;
	  mid = mid + Math.imul(ah5, bl1) | 0;
	  hi = hi + Math.imul(ah5, bh1) | 0;
	  lo = lo + Math.imul(al4, bl2) | 0;
	  mid = mid + Math.imul(al4, bh2) | 0;
	  mid = mid + Math.imul(ah4, bl2) | 0;
	  hi = hi + Math.imul(ah4, bh2) | 0;
	  lo = lo + Math.imul(al3, bl3) | 0;
	  mid = mid + Math.imul(al3, bh3) | 0;
	  mid = mid + Math.imul(ah3, bl3) | 0;
	  hi = hi + Math.imul(ah3, bh3) | 0;
	  lo = lo + Math.imul(al2, bl4) | 0;
	  mid = mid + Math.imul(al2, bh4) | 0;
	  mid = mid + Math.imul(ah2, bl4) | 0;
	  hi = hi + Math.imul(ah2, bh4) | 0;
	  lo = lo + Math.imul(al1, bl5) | 0;
	  mid = mid + Math.imul(al1, bh5) | 0;
	  mid = mid + Math.imul(ah1, bl5) | 0;
	  hi = hi + Math.imul(ah1, bh5) | 0;
	  lo = lo + Math.imul(al0, bl6) | 0;
	  mid = mid + Math.imul(al0, bh6) | 0;
	  mid = mid + Math.imul(ah0, bl6) | 0;
	  hi = hi + Math.imul(ah0, bh6) | 0;
	  let w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
	  w6 &= 0x3ffffff;

	  /* k = 7 */
	  lo = Math.imul(al7, bl0);
	  mid = Math.imul(al7, bh0);
	  mid = mid + Math.imul(ah7, bl0) | 0;
	  hi = Math.imul(ah7, bh0);
	  lo = lo + Math.imul(al6, bl1) | 0;
	  mid = mid + Math.imul(al6, bh1) | 0;
	  mid = mid + Math.imul(ah6, bl1) | 0;
	  hi = hi + Math.imul(ah6, bh1) | 0;
	  lo = lo + Math.imul(al5, bl2) | 0;
	  mid = mid + Math.imul(al5, bh2) | 0;
	  mid = mid + Math.imul(ah5, bl2) | 0;
	  hi = hi + Math.imul(ah5, bh2) | 0;
	  lo = lo + Math.imul(al4, bl3) | 0;
	  mid = mid + Math.imul(al4, bh3) | 0;
	  mid = mid + Math.imul(ah4, bl3) | 0;
	  hi = hi + Math.imul(ah4, bh3) | 0;
	  lo = lo + Math.imul(al3, bl4) | 0;
	  mid = mid + Math.imul(al3, bh4) | 0;
	  mid = mid + Math.imul(ah3, bl4) | 0;
	  hi = hi + Math.imul(ah3, bh4) | 0;
	  lo = lo + Math.imul(al2, bl5) | 0;
	  mid = mid + Math.imul(al2, bh5) | 0;
	  mid = mid + Math.imul(ah2, bl5) | 0;
	  hi = hi + Math.imul(ah2, bh5) | 0;
	  lo = lo + Math.imul(al1, bl6) | 0;
	  mid = mid + Math.imul(al1, bh6) | 0;
	  mid = mid + Math.imul(ah1, bl6) | 0;
	  hi = hi + Math.imul(ah1, bh6) | 0;
	  lo = lo + Math.imul(al0, bl7) | 0;
	  mid = mid + Math.imul(al0, bh7) | 0;
	  mid = mid + Math.imul(ah0, bl7) | 0;
	  hi = hi + Math.imul(ah0, bh7) | 0;
	  let w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
	  w7 &= 0x3ffffff;

	  /* k = 8 */
	  lo = Math.imul(al8, bl0);
	  mid = Math.imul(al8, bh0);
	  mid = mid + Math.imul(ah8, bl0) | 0;
	  hi = Math.imul(ah8, bh0);
	  lo = lo + Math.imul(al7, bl1) | 0;
	  mid = mid + Math.imul(al7, bh1) | 0;
	  mid = mid + Math.imul(ah7, bl1) | 0;
	  hi = hi + Math.imul(ah7, bh1) | 0;
	  lo = lo + Math.imul(al6, bl2) | 0;
	  mid = mid + Math.imul(al6, bh2) | 0;
	  mid = mid + Math.imul(ah6, bl2) | 0;
	  hi = hi + Math.imul(ah6, bh2) | 0;
	  lo = lo + Math.imul(al5, bl3) | 0;
	  mid = mid + Math.imul(al5, bh3) | 0;
	  mid = mid + Math.imul(ah5, bl3) | 0;
	  hi = hi + Math.imul(ah5, bh3) | 0;
	  lo = lo + Math.imul(al4, bl4) | 0;
	  mid = mid + Math.imul(al4, bh4) | 0;
	  mid = mid + Math.imul(ah4, bl4) | 0;
	  hi = hi + Math.imul(ah4, bh4) | 0;
	  lo = lo + Math.imul(al3, bl5) | 0;
	  mid = mid + Math.imul(al3, bh5) | 0;
	  mid = mid + Math.imul(ah3, bl5) | 0;
	  hi = hi + Math.imul(ah3, bh5) | 0;
	  lo = lo + Math.imul(al2, bl6) | 0;
	  mid = mid + Math.imul(al2, bh6) | 0;
	  mid = mid + Math.imul(ah2, bl6) | 0;
	  hi = hi + Math.imul(ah2, bh6) | 0;
	  lo = lo + Math.imul(al1, bl7) | 0;
	  mid = mid + Math.imul(al1, bh7) | 0;
	  mid = mid + Math.imul(ah1, bl7) | 0;
	  hi = hi + Math.imul(ah1, bh7) | 0;
	  lo = lo + Math.imul(al0, bl8) | 0;
	  mid = mid + Math.imul(al0, bh8) | 0;
	  mid = mid + Math.imul(ah0, bl8) | 0;
	  hi = hi + Math.imul(ah0, bh8) | 0;
	  let w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
	  w8 &= 0x3ffffff;

	  /* k = 9 */
	  lo = Math.imul(al9, bl0);
	  mid = Math.imul(al9, bh0);
	  mid = mid + Math.imul(ah9, bl0) | 0;
	  hi = Math.imul(ah9, bh0);
	  lo = lo + Math.imul(al8, bl1) | 0;
	  mid = mid + Math.imul(al8, bh1) | 0;
	  mid = mid + Math.imul(ah8, bl1) | 0;
	  hi = hi + Math.imul(ah8, bh1) | 0;
	  lo = lo + Math.imul(al7, bl2) | 0;
	  mid = mid + Math.imul(al7, bh2) | 0;
	  mid = mid + Math.imul(ah7, bl2) | 0;
	  hi = hi + Math.imul(ah7, bh2) | 0;
	  lo = lo + Math.imul(al6, bl3) | 0;
	  mid = mid + Math.imul(al6, bh3) | 0;
	  mid = mid + Math.imul(ah6, bl3) | 0;
	  hi = hi + Math.imul(ah6, bh3) | 0;
	  lo = lo + Math.imul(al5, bl4) | 0;
	  mid = mid + Math.imul(al5, bh4) | 0;
	  mid = mid + Math.imul(ah5, bl4) | 0;
	  hi = hi + Math.imul(ah5, bh4) | 0;
	  lo = lo + Math.imul(al4, bl5) | 0;
	  mid = mid + Math.imul(al4, bh5) | 0;
	  mid = mid + Math.imul(ah4, bl5) | 0;
	  hi = hi + Math.imul(ah4, bh5) | 0;
	  lo = lo + Math.imul(al3, bl6) | 0;
	  mid = mid + Math.imul(al3, bh6) | 0;
	  mid = mid + Math.imul(ah3, bl6) | 0;
	  hi = hi + Math.imul(ah3, bh6) | 0;
	  lo = lo + Math.imul(al2, bl7) | 0;
	  mid = mid + Math.imul(al2, bh7) | 0;
	  mid = mid + Math.imul(ah2, bl7) | 0;
	  hi = hi + Math.imul(ah2, bh7) | 0;
	  lo = lo + Math.imul(al1, bl8) | 0;
	  mid = mid + Math.imul(al1, bh8) | 0;
	  mid = mid + Math.imul(ah1, bl8) | 0;
	  hi = hi + Math.imul(ah1, bh8) | 0;
	  lo = lo + Math.imul(al0, bl9) | 0;
	  mid = mid + Math.imul(al0, bh9) | 0;
	  mid = mid + Math.imul(ah0, bl9) | 0;
	  hi = hi + Math.imul(ah0, bh9) | 0;
	  let w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
	  w9 &= 0x3ffffff;

	  /* k = 10 */
	  lo = Math.imul(al9, bl1);
	  mid = Math.imul(al9, bh1);
	  mid = mid + Math.imul(ah9, bl1) | 0;
	  hi = Math.imul(ah9, bh1);
	  lo = lo + Math.imul(al8, bl2) | 0;
	  mid = mid + Math.imul(al8, bh2) | 0;
	  mid = mid + Math.imul(ah8, bl2) | 0;
	  hi = hi + Math.imul(ah8, bh2) | 0;
	  lo = lo + Math.imul(al7, bl3) | 0;
	  mid = mid + Math.imul(al7, bh3) | 0;
	  mid = mid + Math.imul(ah7, bl3) | 0;
	  hi = hi + Math.imul(ah7, bh3) | 0;
	  lo = lo + Math.imul(al6, bl4) | 0;
	  mid = mid + Math.imul(al6, bh4) | 0;
	  mid = mid + Math.imul(ah6, bl4) | 0;
	  hi = hi + Math.imul(ah6, bh4) | 0;
	  lo = lo + Math.imul(al5, bl5) | 0;
	  mid = mid + Math.imul(al5, bh5) | 0;
	  mid = mid + Math.imul(ah5, bl5) | 0;
	  hi = hi + Math.imul(ah5, bh5) | 0;
	  lo = lo + Math.imul(al4, bl6) | 0;
	  mid = mid + Math.imul(al4, bh6) | 0;
	  mid = mid + Math.imul(ah4, bl6) | 0;
	  hi = hi + Math.imul(ah4, bh6) | 0;
	  lo = lo + Math.imul(al3, bl7) | 0;
	  mid = mid + Math.imul(al3, bh7) | 0;
	  mid = mid + Math.imul(ah3, bl7) | 0;
	  hi = hi + Math.imul(ah3, bh7) | 0;
	  lo = lo + Math.imul(al2, bl8) | 0;
	  mid = mid + Math.imul(al2, bh8) | 0;
	  mid = mid + Math.imul(ah2, bl8) | 0;
	  hi = hi + Math.imul(ah2, bh8) | 0;
	  lo = lo + Math.imul(al1, bl9) | 0;
	  mid = mid + Math.imul(al1, bh9) | 0;
	  mid = mid + Math.imul(ah1, bl9) | 0;
	  hi = hi + Math.imul(ah1, bh9) | 0;
	  let w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
	  w10 &= 0x3ffffff;

	  /* k = 11 */
	  lo = Math.imul(al9, bl2);
	  mid = Math.imul(al9, bh2);
	  mid = mid + Math.imul(ah9, bl2) | 0;
	  hi = Math.imul(ah9, bh2);
	  lo = lo + Math.imul(al8, bl3) | 0;
	  mid = mid + Math.imul(al8, bh3) | 0;
	  mid = mid + Math.imul(ah8, bl3) | 0;
	  hi = hi + Math.imul(ah8, bh3) | 0;
	  lo = lo + Math.imul(al7, bl4) | 0;
	  mid = mid + Math.imul(al7, bh4) | 0;
	  mid = mid + Math.imul(ah7, bl4) | 0;
	  hi = hi + Math.imul(ah7, bh4) | 0;
	  lo = lo + Math.imul(al6, bl5) | 0;
	  mid = mid + Math.imul(al6, bh5) | 0;
	  mid = mid + Math.imul(ah6, bl5) | 0;
	  hi = hi + Math.imul(ah6, bh5) | 0;
	  lo = lo + Math.imul(al5, bl6) | 0;
	  mid = mid + Math.imul(al5, bh6) | 0;
	  mid = mid + Math.imul(ah5, bl6) | 0;
	  hi = hi + Math.imul(ah5, bh6) | 0;
	  lo = lo + Math.imul(al4, bl7) | 0;
	  mid = mid + Math.imul(al4, bh7) | 0;
	  mid = mid + Math.imul(ah4, bl7) | 0;
	  hi = hi + Math.imul(ah4, bh7) | 0;
	  lo = lo + Math.imul(al3, bl8) | 0;
	  mid = mid + Math.imul(al3, bh8) | 0;
	  mid = mid + Math.imul(ah3, bl8) | 0;
	  hi = hi + Math.imul(ah3, bh8) | 0;
	  lo = lo + Math.imul(al2, bl9) | 0;
	  mid = mid + Math.imul(al2, bh9) | 0;
	  mid = mid + Math.imul(ah2, bl9) | 0;
	  hi = hi + Math.imul(ah2, bh9) | 0;
	  let w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
	  w11 &= 0x3ffffff;

	  /* k = 12 */
	  lo = Math.imul(al9, bl3);
	  mid = Math.imul(al9, bh3);
	  mid = mid + Math.imul(ah9, bl3) | 0;
	  hi = Math.imul(ah9, bh3);
	  lo = lo + Math.imul(al8, bl4) | 0;
	  mid = mid + Math.imul(al8, bh4) | 0;
	  mid = mid + Math.imul(ah8, bl4) | 0;
	  hi = hi + Math.imul(ah8, bh4) | 0;
	  lo = lo + Math.imul(al7, bl5) | 0;
	  mid = mid + Math.imul(al7, bh5) | 0;
	  mid = mid + Math.imul(ah7, bl5) | 0;
	  hi = hi + Math.imul(ah7, bh5) | 0;
	  lo = lo + Math.imul(al6, bl6) | 0;
	  mid = mid + Math.imul(al6, bh6) | 0;
	  mid = mid + Math.imul(ah6, bl6) | 0;
	  hi = hi + Math.imul(ah6, bh6) | 0;
	  lo = lo + Math.imul(al5, bl7) | 0;
	  mid = mid + Math.imul(al5, bh7) | 0;
	  mid = mid + Math.imul(ah5, bl7) | 0;
	  hi = hi + Math.imul(ah5, bh7) | 0;
	  lo = lo + Math.imul(al4, bl8) | 0;
	  mid = mid + Math.imul(al4, bh8) | 0;
	  mid = mid + Math.imul(ah4, bl8) | 0;
	  hi = hi + Math.imul(ah4, bh8) | 0;
	  lo = lo + Math.imul(al3, bl9) | 0;
	  mid = mid + Math.imul(al3, bh9) | 0;
	  mid = mid + Math.imul(ah3, bl9) | 0;
	  hi = hi + Math.imul(ah3, bh9) | 0;
	  let w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
	  w12 &= 0x3ffffff;

	  /* k = 13 */
	  lo = Math.imul(al9, bl4);
	  mid = Math.imul(al9, bh4);
	  mid = mid + Math.imul(ah9, bl4) | 0;
	  hi = Math.imul(ah9, bh4);
	  lo = lo + Math.imul(al8, bl5) | 0;
	  mid = mid + Math.imul(al8, bh5) | 0;
	  mid = mid + Math.imul(ah8, bl5) | 0;
	  hi = hi + Math.imul(ah8, bh5) | 0;
	  lo = lo + Math.imul(al7, bl6) | 0;
	  mid = mid + Math.imul(al7, bh6) | 0;
	  mid = mid + Math.imul(ah7, bl6) | 0;
	  hi = hi + Math.imul(ah7, bh6) | 0;
	  lo = lo + Math.imul(al6, bl7) | 0;
	  mid = mid + Math.imul(al6, bh7) | 0;
	  mid = mid + Math.imul(ah6, bl7) | 0;
	  hi = hi + Math.imul(ah6, bh7) | 0;
	  lo = lo + Math.imul(al5, bl8) | 0;
	  mid = mid + Math.imul(al5, bh8) | 0;
	  mid = mid + Math.imul(ah5, bl8) | 0;
	  hi = hi + Math.imul(ah5, bh8) | 0;
	  lo = lo + Math.imul(al4, bl9) | 0;
	  mid = mid + Math.imul(al4, bh9) | 0;
	  mid = mid + Math.imul(ah4, bl9) | 0;
	  hi = hi + Math.imul(ah4, bh9) | 0;
	  let w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
	  w13 &= 0x3ffffff;

	  /* k = 14 */
	  lo = Math.imul(al9, bl5);
	  mid = Math.imul(al9, bh5);
	  mid = mid + Math.imul(ah9, bl5) | 0;
	  hi = Math.imul(ah9, bh5);
	  lo = lo + Math.imul(al8, bl6) | 0;
	  mid = mid + Math.imul(al8, bh6) | 0;
	  mid = mid + Math.imul(ah8, bl6) | 0;
	  hi = hi + Math.imul(ah8, bh6) | 0;
	  lo = lo + Math.imul(al7, bl7) | 0;
	  mid = mid + Math.imul(al7, bh7) | 0;
	  mid = mid + Math.imul(ah7, bl7) | 0;
	  hi = hi + Math.imul(ah7, bh7) | 0;
	  lo = lo + Math.imul(al6, bl8) | 0;
	  mid = mid + Math.imul(al6, bh8) | 0;
	  mid = mid + Math.imul(ah6, bl8) | 0;
	  hi = hi + Math.imul(ah6, bh8) | 0;
	  lo = lo + Math.imul(al5, bl9) | 0;
	  mid = mid + Math.imul(al5, bh9) | 0;
	  mid = mid + Math.imul(ah5, bl9) | 0;
	  hi = hi + Math.imul(ah5, bh9) | 0;
	  let w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
	  w14 &= 0x3ffffff;

	  /* k = 15 */
	  lo = Math.imul(al9, bl6);
	  mid = Math.imul(al9, bh6);
	  mid = mid + Math.imul(ah9, bl6) | 0;
	  hi = Math.imul(ah9, bh6);
	  lo = lo + Math.imul(al8, bl7) | 0;
	  mid = mid + Math.imul(al8, bh7) | 0;
	  mid = mid + Math.imul(ah8, bl7) | 0;
	  hi = hi + Math.imul(ah8, bh7) | 0;
	  lo = lo + Math.imul(al7, bl8) | 0;
	  mid = mid + Math.imul(al7, bh8) | 0;
	  mid = mid + Math.imul(ah7, bl8) | 0;
	  hi = hi + Math.imul(ah7, bh8) | 0;
	  lo = lo + Math.imul(al6, bl9) | 0;
	  mid = mid + Math.imul(al6, bh9) | 0;
	  mid = mid + Math.imul(ah6, bl9) | 0;
	  hi = hi + Math.imul(ah6, bh9) | 0;
	  let w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
	  w15 &= 0x3ffffff;

	  /* k = 16 */
	  lo = Math.imul(al9, bl7);
	  mid = Math.imul(al9, bh7);
	  mid = mid + Math.imul(ah9, bl7) | 0;
	  hi = Math.imul(ah9, bh7);
	  lo = lo + Math.imul(al8, bl8) | 0;
	  mid = mid + Math.imul(al8, bh8) | 0;
	  mid = mid + Math.imul(ah8, bl8) | 0;
	  hi = hi + Math.imul(ah8, bh8) | 0;
	  lo = lo + Math.imul(al7, bl9) | 0;
	  mid = mid + Math.imul(al7, bh9) | 0;
	  mid = mid + Math.imul(ah7, bl9) | 0;
	  hi = hi + Math.imul(ah7, bh9) | 0;
	  let w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
	  w16 &= 0x3ffffff;

	  /* k = 17 */
	  lo = Math.imul(al9, bl8);
	  mid = Math.imul(al9, bh8);
	  mid = mid + Math.imul(ah9, bl8) | 0;
	  hi = Math.imul(ah9, bh8);
	  lo = lo + Math.imul(al8, bl9) | 0;
	  mid = mid + Math.imul(al8, bh9) | 0;
	  mid = mid + Math.imul(ah8, bl9) | 0;
	  hi = hi + Math.imul(ah8, bh9) | 0;
	  let w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
	  w17 &= 0x3ffffff;

	  /* k = 18 */
	  lo = Math.imul(al9, bl9);
	  mid = Math.imul(al9, bh9);
	  mid = mid + Math.imul(ah9, bl9) | 0;
	  hi = Math.imul(ah9, bh9);
	  let w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
	  c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
	  w18 &= 0x3ffffff;
	  o[0] = w0;
	  o[1] = w1;
	  o[2] = w2;
	  o[3] = w3;
	  o[4] = w4;
	  o[5] = w5;
	  o[6] = w6;
	  o[7] = w7;
	  o[8] = w8;
	  o[9] = w9;
	  o[10] = w10;
	  o[11] = w11;
	  o[12] = w12;
	  o[13] = w13;
	  o[14] = w14;
	  o[15] = w15;
	  o[16] = w16;
	  o[17] = w17;
	  o[18] = w18;
	  if (c !== 0) {
	    o[19] = c;
	    out.length += 1;
	  }

	  // Note: we shouldn't need to strip here.
	  return out;
	}

	// Polyfill comb.
	if (!Math.imul) comb10MulTo = smallMulTo;

	/*
	 * Expose
	 */

	BN.Red = Red;
	bn = BN;
	return bn;
}

/*!
 * network.js - bitcoin networks for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2019-2020, Jonathan Gonzalez (MIT License).
 * https://github.com/cash-org/cashnode
 */

var hasRequiredNetworks;

function requireNetworks () {
	if (hasRequiredNetworks) return networks;
	hasRequiredNetworks = 1;
	(function (exports) {

		/**
		 * @module protocol/networks
		 */
		const BN = requireBn();
		const network = exports;

		/*
		 * Helpers
		 */

		function b(hash) {
		  return Buffer.from(hash, 'hex');
		}

		/**
		 * Network type list.
		 * @memberof module:protocol/networks
		 * @const {String[]}
		 * @default
		 */

		network.types = ['main', 'testnet', 'regtest', 'simnet'];

		/**
		 * Mainnet
		 * @static
		 * @lends module:protocol/networks
		 * @type {Object}
		 */

		const main = {};

		/**
		 * Symbolic network type.
		 * @const {String}
		 * @default
		 */

		main.type = 'main';

		/**
		 * Default DNS seeds.
		 * @const {String[]}
		 * @default
		 */

		main.seeds = ['seed.flowee.cash', 'seed-bch.bitcoinforks.org', 'btccash-seeder.bitcoinunlimited.info', 'seed.bchd.cash', 'seed.bch.loping.net', 'dnsseed.electroncash.de'];

		/**
		 * Packet magic number.
		 * @const {Number}
		 * @default
		 */

		main.magic = 0xe8f3e1e3;

		/**
		 * Default network port.
		 * @const {Number}
		 * @default
		 */

		main.port = 8333;

		/**
		 * Checkpoint block list.
		 * @const {Object}
		 */

		main.checkpointMap = {
		  11111: b('1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000'),
		  33333: b('a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000'),
		  74000: b('201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000'),
		  105000: b('97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000'),
		  134444: b('feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000'),
		  168000: b('63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000'),
		  193000: b('17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000'),
		  210000: b('2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000'),
		  216116: b('4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000'),
		  225430: b('32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000'),
		  250000: b('14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000'),
		  279000: b('407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000'),
		  295000: b('83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000'),
		  300255: b('b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000'),
		  319400: b('3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000'),
		  343185: b('548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000'),
		  352940: b('ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000'),
		  382320: b('b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000'),
		  401465: b('eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000'),
		  420000: b('a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000'),
		  440000: b('9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000'),
		  450000: b('0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000'),
		  460000: b('8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000'),
		  470000: b('89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000'),
		  // UAHF fork block:
		  478559: b('ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000'),
		  480000: b('f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000'),
		  490000: b('d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000'),
		  500000: b('01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000'),
		  // DAA fork block
		  504031: b('9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000'),
		  510000: b('040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000'),
		  525000: b('c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000'),
		  // Monolith Activation
		  530359: b('0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000'),
		  // Magnetic Anomaly Activation:
		  556767: b('6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000'),
		  // Great Wall Activation:
		  582680: b('18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000'),
		  // Graviton Activation:
		  609136: b('b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000'),
		  // Phonon Activation:
		  635259: b('f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000'),
		  // Axion Activation:
		  661648: b('7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000'),
		  664198: b('60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000'),
		  680140: b('0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000'),
		  // Tachyon Activation
		  686621: b('45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000'),
		  // Selectron Activation
		  713661: b('8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000'),
		  // Gluon activation
		  739536: b('617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000'),
		  // Jefferson activation
		  766195: b('94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000')
		};

		/**
		 * Last checkpoint height.
		 * @const {Number}
		 * @default
		 */

		main.lastCheckpoint = 525000;

		/**
		 * @const {Number}
		 * @default
		 */

		main.halvingInterval = 210000;

		/**
		 * Genesis block header.
		 * @const {Object}
		 */

		main.genesis = {
		  version: 1,
		  hash: b('6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000'),
		  prevBlock: b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot: b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1231006505,
		  bits: 486604799,
		  nonce: 2083236893,
		  height: 0
		};

		/**
		 * The network's genesis block in a hex string.
		 * @const {String}
		 */

		main.genesisBlock = '0100000000000000000000000000000000000000000000000000000000000000000000' + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab' + '5f49ffff001d1dac2b7c01010000000100000000000000000000000000000000000000' + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573' + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66' + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01' + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f' + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f' + 'ac00000000';

		/**
		 * POW-related constants.
		 * @enum {Number}
		 * @default
		 */

		main.pow = {
		  /**
		   * Default target.
		   * @const {BN}
		   */

		  limit: new BN('00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 'hex'),
		  /**
		   * Compact pow limit.
		   * @const {Number}
		   * @default
		   */

		  bits: 486604799,
		  /**
		   * Half Life value used in DAA.
		   * Represents the value of two days in seconds
		   * @const {Number}
		   * @default
		   */

		  halfLife: 172800,
		  /**
		   * Minimum chainwork for best chain.
		   * @const {BN}
		   */

		  chainwork: new BN('0000000000000000000000000000000000000000013c95e14d4d9db91d671020', 'hex'),
		  /**
		   * Desired retarget period in seconds.
		   * @const {Number}
		   * @default
		   */

		  targetTimespan: 14 * 24 * 60 * 60,
		  /**
		   * Average block time.
		   * @const {Number}
		   * @default
		   */

		  targetSpacing: 10 * 60,
		  /**
		   * Retarget interval in blocks.
		   * @const {Number}
		   * @default
		   */

		  retargetInterval: 2016,
		  /**
		   * Whether to reset target if a block
		   * has not been mined recently.
		   * @const {Boolean}
		   * @default
		   */

		  targetReset: false,
		  /**
		   * Do not allow retargetting.
		   * @const {Boolean}
		   * @default
		   */

		  noRetargeting: false
		};

		/**
		 * Block constants.
		 * @enum {Number}
		 * @default
		 */

		main.block = {
		  /**
		   * Height at which bip34 was activated.
		   * Used for avoiding bip30 checks.
		   */

		  bip34height: 227931,
		  /**
		   * Hash of the block that activated bip34.
		   */

		  bip34hash: b('b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000'),
		  /**
		   * Height at which bip65 was activated.
		   */

		  bip65height: 388381,
		  /**
		   * Hash of the block that activated bip65.
		   */

		  bip65hash: b('f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000'),
		  /**
		   * Height at which bip66 was activated.
		   */

		  bip66height: 363725,
		  /**
		   * Hash of the block that activated bip66.
		   */

		  bip66hash: b('3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000'),
		  /**
		   * Height at which UAHF was activated.
		   */

		  uahfHeight: 478558,
		  /**
		   * Hash of the block that activated UAHF.
		   */

		  uahfHash: b('432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000'),
		  /**
		   * Height at which DAA was activated.
		   * November 13, 2017 hard fork
		   */

		  daaHeight: 504031,
		  /**
		   * Hash of the block that activated DAA
		   */

		  daaHash: b('9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000'),
		  /**
		   * Height at which Magnetic Anomaly was activated.
		   * Nov 15, 2018 hard fork
		   */

		  magneticAnomalyHeight: 556767,
		  /**
		   * Hash of the block that activatd Magnetic Anomaly.
		   * November 15, 2018
		   */

		  maaHash: b('6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000'),
		  /**
		   * Height at which Great Wall was activated.
		   * Wed, 15 May 2019 hard fork
		   */

		  greatWallActivationHeight: 582680,
		  /**
		   * Hash of the block that activated Great Wall.
		   * May 15, 2019
		   */

		  gwaHash: b('18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000'),
		  /**
		   * Graviton Hard Fork activation time.
		   * Nov 15, 2019 12:00:00 UTC
		   */

		  gravitonActivationTime: 1573819200,
		  /**
		   * Height at which Graviton was activated.
		   * Friday, 15 November 2019 hard fork
		   */

		  gravitonHeight: 609136,
		  /**
		   * Hash of the block that activated Graviton.
		   * November 15th, 2019
		   */

		  gravitonHash: b('b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000'),
		  /**
		   * Time at which Phonon was activated.
		   * May 15, 2020 12:00:00 UTC
		   */

		  phononActivationTime: 1589544000,
		  /**
		  * Height at which Phonon Activation occured.
		  * May 15, 2020
		  */

		  phononHeight: 635259,
		  /**
		  * Hash of the block that activated Phonon.
		  * May 15th 2020
		  */

		  phononHash: b('f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000'),
		  /**
		   * Time at which Asert3d-2i was activated.
		   * November 15, 2020 12:00:00 UTC
		   */

		  asertActivationTime: 1605441600,
		  /**
		   * Time at which Axion was activated.
		   * November 15, 2020 12:00:00 UTC
		   */

		  axionActivationTime: 1605441600,
		  /**
		  * Height at which Axion Activation occured.
		  * November 15, 2020
		  */

		  axionHeight: 661648,
		  /**
		  * Hash of the block that activated Axion.
		  * November 15th 2020
		  */

		  axionHash: b('7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000'),
		  /**
		   * Time at which Tachyon was activated.
		   * May 15, 2021 12:00:00 UTC
		   */

		  tachyonActivationTime: 1621080000,
		  /**
		  * Height at which Tachyon Activation occured.
		  * May 15, 2021 12:00:00 UTC
		  */

		  tachyonHeight: 686621,
		  /**
		  * Hash of the block that activated Tachyon.
		  * May 15, 2021 12:00:00 UTC
		  */

		  tachyonHash: b('45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000'),
		  /**
		   * Time at which Selectron was activated.
		   * November 15, 2021 12:00:00 UTC
		   */

		  selectronActivationTime: 1636977600,
		  /**
		  * Height at which Selectron Activation occured.
		  *  November 15, 2021 12:00:00 UTC
		  */

		  selectronHeight: 713661,
		  /**
		  * Hash of the block that activated Selectron.
		  * November 15, 2021 12:00:00 UTC
		  */

		  selectronHash: b('8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000'),
		  /**
		   * Time at which Gluon was activated.
		   * May 15, 2022 12:00:00 UTC
		   */

		  gluonActivationTime: 1652572800,
		  /**
		  * Height at which Gluon activation occured.
		  *  May 15, 2022 12:00:00 UTC
		  */

		  gluonHeight: 739536,
		  /**
		  * Hash of the block that activated Gluon.
		  * May 15, 2022 12:00:00 UTC
		  */

		  gluonHash: b('617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000'),
		  /**
		   * Time at which Jefferson was activated.
		   * November 15, 2022 12:00:00 UTC
		   */

		  jeffersonActivationTime: 1668470400,
		  /**
		  * Height at which Gluon activation occured.
		  *  November 15, 2022 12:00:00 UTC
		  */

		  jeffersonHeight: 766195,
		  /**
		  * Hash of the block that activated Gluon.
		  * November 15, 2022 12:00:00 UTC
		  */

		  jeffersonHash: b('94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000'),
		  /**
		   * Time at which Wellington was activated.
		   * May 15, 2023 12:00:00 UTC
		   */

		  wellingtonActivationTime: 1684108800,
		  /**
		   * Safe height to start pruning.
		   */

		  pruneAfterHeight: 1000,
		  /**
		   * Safe number of blocks to keep.
		   */

		  keepBlocks: 288,
		  /**
		   * Age used for the time delta to
		   * determine whether the chain is synced.
		   */

		  maxTipAge: 24 * 60 * 60,
		  /**
		   * Height at which block processing is
		   * slow enough that we can output
		   * logs without spamming.
		   */

		  slowHeight: 325000
		};

		/**
		 * Map of historical blocks which create duplicate transactions hashes.
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
		 * @const {Object}
		 * @default
		 */

		main.bip30 = {
		  91842: b('eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000'),
		  91880: b('21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000')
		};

		/**
		 * For versionbits.
		 * @const {Number}
		 * @default
		 */

		main.activationThreshold = 1916; // 95% of 2016

		/**
		 * Confirmation window for versionbits.
		 * @const {Number}
		 * @default
		 */

		main.minerWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing

		/**
		 * Deployments for versionbits.
		 * @const {Object}
		 * @default
		 */

		main.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 1462060800,
		    // May 1st, 2016
		    timeout: 1493596800,
		    // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601,
		    // January 1, 2008
		    timeout: 1230767999,
		    // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};

		/**
		 * Deployments for versionbits (array form, sorted).
		 * @const {Array}
		 * @default
		 */

		main.deploys = [main.deployments.csv, main.deployments.testdummy];

		/**
		 * Key prefixes.
		 * @enum {Number}
		 * @default
		 */

		main.keyPrefix = {
		  privkey: 0x80,
		  xpubkey: 0x0488b21e,
		  xprivkey: 0x0488ade4,
		  xpubkey58: 'xpub',
		  xprivkey58: 'xprv',
		  coinType: 0
		};

		/**
		 * {@link Address} prefixes.
		 * @enum {Number}
		 */

		main.addressPrefix = {
		  pubkeyhash: 0x00,
		  scripthash: 0x05,
		  cashaddr: 'ecash'
		};

		/**
		 * Default value for whether the mempool
		 * accepts non-standard transactions.
		 * @const {Boolean}
		 * @default
		 */

		main.requireStandard = true;

		/**
		 * Default http port.
		 * @const {Number}
		 * @default
		 */

		main.rpcPort = 8332;

		/**
		 * Default wallet port.
		 * @const {Number}
		 * @default
		 */

		main.walletPort = 8334;

		/**
		 * Default min relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.minRelay = 1000;

		/**
		 * Default normal relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.feeRate = 100000;

		/**
		 * Maximum normal relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.maxFeeRate = 400000;

		/**
		 * Whether to allow self-connection.
		 * @const {Boolean}
		 */

		main.selfConnect = false;

		/**
		 * Whether to request mempool on sync.
		 * @const {Boolean}
		 */

		main.requestMempool = false;

		/*
		 * Testnet (v3)
		 * https://en.bitcoin.it/wiki/Testnet
		 */

		const testnet = {};
		testnet.type = 'testnet';
		testnet.seeds = ['testnet-seed.bitcoinabc.org',
		// Bitcoin ABC seeder
		'testnet-seed-abc.bitcoinforks.org',
		// bitcoinforks seeders
		'testnet-seed.deadalnix.me',
		// Amaury SCHET
		'testnet-seed.bchd.cash'];
		testnet.magic = 0xf4f3e5f4;
		testnet.port = 18333;
		testnet.checkpointMap = {
		  546: b('70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000'),
		  10000: b('02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000'),
		  50000: b('0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000'),
		  90000: b('cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000'),
		  100000: b('1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000'),
		  140000: b('92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000'),
		  170000: b('508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000'),
		  210000: b('32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000'),
		  230000: b('b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000'),
		  270000: b('1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000'),
		  300000: b('a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000'),
		  340000: b('67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000'),
		  350000: b('592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000'),
		  390000: b('f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000'),
		  420000: b('de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000'),
		  460000: b('2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000'),
		  500000: b('06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000'),
		  540000: b('8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000'),
		  570000: b('87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000'),
		  600000: b('169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000'),
		  630000: b('bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000'),
		  670000: b('080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000'),
		  700000: b('c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000'),
		  740000: b('b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000'),
		  780000: b('0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000'),
		  800000: b('03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000'),
		  840000: b('dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000'),
		  880000: b('ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000'),
		  900000: b('9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000'),
		  940000: b('c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000'),
		  980000: b('cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000'),
		  1010000: b('9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000'),
		  1050000: b('d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000'),
		  1090000: b('41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000'),
		  1130000: b('b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000'),
		  // UAHF fork block.
		  1155875: b('38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000'),
		  // DAA fork block.
		  1188697: b('fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000'),
		  // GWA fork block.
		  1303885: b('d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000'),
		  // Graviton fork block
		  1341712: b('5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000'),
		  // Phonon fork block.
		  1378461: b('d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000')
		};
		testnet.lastCheckpoint = 1341712;
		testnet.halvingInterval = 210000;
		testnet.genesis = {
		  version: 1,
		  hash: b('43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000'),
		  prevBlock: b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot: b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1296688602,
		  bits: 486604799,
		  nonce: 414098458,
		  height: 0
		};
		testnet.genesisBlock = '0100000000000000000000000000000000000000000000000000000000000000000000' + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5' + '494dffff001d1aa4ae1801010000000100000000000000000000000000000000000000' + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573' + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66' + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01' + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f' + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f' + 'ac00000000';
		testnet.pow = {
		  limit: new BN('00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 'hex'),
		  bits: 486604799,
		  chainwork: new BN('00000000000000000000000000000000000000000000006956e7298fb096a1cc', 'hex'),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: false
		};
		testnet.block = {
		  bip34height: 21111,
		  bip34hash: b('f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000'),
		  bip65height: 581885,
		  bip65hash: b('b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000'),
		  bip66height: 330776,
		  bip66hash: b('82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000'),
		  uahfHeight: 1155875,
		  uahfHash: b('38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000'),
		  daaHeight: 1188697,
		  daaHash: b('fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000'),
		  magneticAnomalyHeight: 1267996,
		  maaHash: b('244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000'),
		  greatWallActivationHeight: 1303885,
		  gwaHash: b('d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000'),
		  gravitonActivationTime: 1573819200,
		  gravitonHeight: 1341712,
		  gravitonHash: b('5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000'),
		  phononActivationTime: 1589544000,
		  asertActivationTime: 1605441600,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 24 * 60 * 60,
		  slowHeight: 950000
		};
		testnet.bip30 = {};
		testnet.activationThreshold = 1512; // 75% for testchains

		testnet.minerWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing

		testnet.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 1456790400,
		    // March 1st, 2016
		    timeout: 1493596800,
		    // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601,
		    // January 1, 2008
		    timeout: 1230767999,
		    // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};
		testnet.deploys = [testnet.deployments.csv, testnet.deployments.testdummy];
		testnet.keyPrefix = {
		  privkey: 0xef,
		  xpubkey: 0x043587cf,
		  xprivkey: 0x04358394,
		  xpubkey58: 'tpub',
		  xprivkey58: 'tprv',
		  coinType: 1
		};
		testnet.addressPrefix = {
		  pubkeyhash: 0x6f,
		  scripthash: 0xc4,
		  cashaddr: 'xectest'
		};
		testnet.requireStandard = false;
		testnet.rpcPort = 18332;
		testnet.walletPort = 18334;
		testnet.minRelay = 1000;
		testnet.feeRate = 20000;
		testnet.maxFeeRate = 60000;
		testnet.selfConnect = false;
		testnet.requestMempool = false;

		/*
		 * Regtest
		 */

		const regtest = {};
		regtest.type = 'regtest';
		regtest.seeds = ['127.0.0.1'];
		regtest.magic = 0xfabfb5da;
		regtest.port = 48444;
		regtest.checkpointMap = {};
		regtest.lastCheckpoint = 0;
		regtest.halvingInterval = 150;
		regtest.genesis = {
		  version: 1,
		  hash: b('06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f'),
		  prevBlock: b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot: b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1296688602,
		  bits: 545259519,
		  nonce: 2,
		  height: 0
		};
		regtest.genesisBlock = '0100000000000000000000000000000000000000000000000000000000000000000000' + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5' + '494dffff7f200200000001010000000100000000000000000000000000000000000000' + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573' + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66' + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01' + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f' + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f' + 'ac00000000';
		regtest.pow = {
		  limit: new BN('7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 'hex'),
		  bits: 545259519,
		  chainwork: new BN('0000000000000000000000000000000000000000000000000000000000000002', 'hex'),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: true
		};
		regtest.block = {
		  bip34height: 100000000,
		  bip34hash: null,
		  bip65height: 1351,
		  bip65hash: null,
		  bip66height: 1251,
		  bip66hash: null,
		  uahfHeight: 0,
		  uahfHash: null,
		  daaHeight: 0,
		  daaHash: null,
		  magneticAnomalyHeight: 0,
		  maaHash: null,
		  greatWallActivationHeight: 0,
		  gwaHash: null,
		  gravitonHeight: 0,
		  gravitonHash: null,
		  phononActivationTime: 0,
		  asertActivationTime: 0,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 0xffffffff,
		  slowHeight: 0
		};
		regtest.bip30 = {};
		regtest.activationThreshold = 108; // 75% for testchains

		regtest.minerWindow = 144; // Faster than normal for regtest

		regtest.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 0,
		    timeout: 0xffffffff,
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 0,
		    timeout: 0xffffffff,
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};
		regtest.deploys = [regtest.deployments.csv, regtest.deployments.testdummy];
		regtest.keyPrefix = {
		  privkey: 0x5a,
		  xpubkey: 0xeab4fa05,
		  xprivkey: 0xeab404c7,
		  xpubkey58: 'rpub',
		  xprivkey58: 'rprv',
		  coinType: 1
		};
		regtest.addressPrefix = {
		  pubkeyhash: 0x3c,
		  scripthash: 0x26,
		  cashaddr: 'xecreg'
		};
		regtest.requireStandard = false;
		regtest.rpcPort = 48332;
		regtest.walletPort = 48334;
		regtest.minRelay = 1000;
		regtest.feeRate = 20000;
		regtest.maxFeeRate = 60000;
		regtest.selfConnect = true;
		regtest.requestMempool = true;

		/*
		 * Simnet (btcd)
		 */

		const simnet = {};
		simnet.type = 'simnet';
		simnet.seeds = ['127.0.0.1'];
		simnet.magic = 0xf2faede4;
		simnet.port = 18555;
		simnet.checkpointMap = {};
		simnet.lastCheckpoint = 0;
		simnet.halvingInterval = 210000;
		simnet.genesis = {
		  version: 1,
		  hash: b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  prevBlock: b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot: b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1401292357,
		  bits: 545259519,
		  nonce: 2,
		  height: 0
		};
		simnet.genesisBlock = '0100000000000000000000000000000000000000000000000000000000000000000000' + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a4506' + '8653ffff7f200200000001010000000100000000000000000000000000000000000000' + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573' + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66' + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01' + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f' + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f' + 'ac00000000';
		simnet.pow = {
		  limit: new BN(
		  // High target of 0x207fffff (545259519)
		  '7fffff0000000000000000000000000000000000000000000000000000000000', 'hex'),
		  bits: 545259519,
		  chainwork: new BN('0000000000000000000000000000000000000000000000000000000000000002', 'hex'),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: false
		};
		simnet.block = {
		  bip34height: 0,
		  bip34hash: b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  bip65height: 0,
		  bip65hash: b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  bip66height: 0,
		  bip66hash: b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  uahfHeight: 0,
		  uahfHash: null,
		  daaHeight: 0,
		  daaHash: null,
		  magneticAnomalyActivationTime: 1542300000,
		  greatWallActivationTime: 1557921600,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 0xffffffff,
		  slowHeight: 0
		};
		simnet.bip30 = {};
		simnet.activationThreshold = 75; // 75% for testchains

		simnet.minerWindow = 100; // nPowTargetTimespan / nPowTargetSpacing

		simnet.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 0,
		    // March 1st, 2016
		    timeout: 0xffffffff,
		    // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601,
		    // January 1, 2008
		    timeout: 1230767999,
		    // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};
		simnet.deploys = [simnet.deployments.csv, simnet.deployments.testdummy];
		simnet.keyPrefix = {
		  privkey: 0x64,
		  xpubkey: 0x0420bd3a,
		  xprivkey: 0x0420b900,
		  xpubkey58: 'spub',
		  xprivkey58: 'sprv',
		  coinType: 115
		};
		simnet.addressPrefix = {
		  pubkeyhash: 0x3f,
		  scripthash: 0x7b,
		  cashaddr: 'xecsim'
		};
		simnet.requireStandard = false;
		simnet.rpcPort = 18556;
		simnet.walletPort = 18558;
		simnet.minRelay = 1000;
		simnet.feeRate = 20000;
		simnet.maxFeeRate = 60000;
		simnet.selfConnect = false;
		simnet.requestMempool = false;

		/*
		 * Expose
		 */

		network.main = main;
		network.testnet = testnet;
		network.regtest = regtest;
		network.simnet = simnet; 
	} (networks));
	return networks;
}

var consensus = {};

/*!
 * consensus.js - consensus constants and helpers for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredConsensus;

function requireConsensus () {
	if (hasRequiredConsensus) return consensus;
	hasRequiredConsensus = 1;
	(function (exports) {

		/**
		 * @module protocol/consensus
		 */
		const assert = requireAssert$1();
		const BN = requireBn();

		/**
		 * One bitcoin in satoshis.
		 * @const {Amount}
		 * @default
		 */

		exports.COIN = 100000000;

		/**
		 * Maximum amount of money in satoshis:
		 * `21million * 1btc` (consensus).
		 * @const {Amount}
		 * @default
		 */

		exports.MAX_MONEY = 21000000 * exports.COIN;

		/**
		 * Base block subsidy (consensus).
		 * Note to shitcoin implementors: if you
		 * increase this to anything greater than
		 * 33 bits, getReward will have to be
		 * modified to handle the shifts.
		 * @const {Amount}
		 * @default
		 */

		exports.BASE_REWARD = 50 * exports.COIN;

		/**
		 * Half base block subsidy. Required to
		 * calculate the reward properly (with
		 * only 32 bit shifts available).
		 * @const {Amount}
		 * @default
		 */

		exports.HALF_REWARD = Math.floor(exports.BASE_REWARD / 2);

		/**
		 * Maximum block base size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIZE = 1000000;

		/**
		 * Maximum block base size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_FORK_BLOCK_SIZE = 32000000;

		/**
		 * Maximum transaction version (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_VERSION = 2;

		/**
		 * Maximum transaction size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIZE = 1000000;

		/**
		 * Maximum sigcheck operations per transaction.
		 * @const {Number
		 * @default
		 */

		exports.MAX_TX_SIGCHECKS = 3000;

		/**
		 * Ratio between the allowable block-size / sigchecks during sigcheck
		 * operations in a block. (Network rule)
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGCHECKS_RATIO = 141;

		/**
		 * Minimum transaction size (consensus)
		 * @const {Number}
		 * @see https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/
		 * @default
		 */

		exports.MIN_TX_SIZE = 100;

		/**
		 * Maximum block serialization size (protocol).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_RAW_BLOCK_SIZE = 32000000;

		/**
		 * Maximum block sigops per mb (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGOPS_PER_MB = 20000;

		/**
		 * Maximum transaction sigops
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIGOPS = 20000;

		/**
		 * Maximum block sigops cost (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGOPS_COST = 80000;

		/**
		 * Maximum size for coinbase script sig
		 * @const {Number}
		 * @default
		 */
		exports.MAX_COINBASE_SCRIPTSIG_SIZE = 100;

		/**
		 * Address for Coinbase Rule (8% of block reward+fees goes to this address)
		 * @const {String}
		 * @default
		 */
		exports.COINBASE_RULE_ADDR = ['ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j', 'ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07'];

		/**
		 * Size of set to pick median time from.
		 * @const {Number}
		 * @default
		 */

		exports.MEDIAN_TIMESPAN = 11;

		/**
		 * What bits to set in version
		 * for versionbits blocks.
		 * @const {Number}
		 * @default
		 */

		exports.VERSION_TOP_BITS = 0x20000000;

		/**
		 * What bitmask determines whether
		 * versionbits is in use.
		 * @const {Number}
		 * @default
		 */

		exports.VERSION_TOP_MASK = 0xe0000000;

		/**
		 * Number of blocks before a coinbase
		 * spend can occur (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.COINBASE_MATURITY = 100;

		/**
		 * nLockTime threshold for differentiating
		 * between height and time (consensus).
		 * Tue Nov 5 00:53:20 1985 UTC
		 * @const {Number}
		 * @default
		 */

		exports.LOCKTIME_THRESHOLD = 500000000;

		/**
		 * Highest nSequence bit -- disables
		 * sequence locktimes (consensus).
		 * @const {Number}
		 */

		exports.SEQUENCE_DISABLE_FLAG = 1 << 31 >>> 0;

		/**
		 * Sequence time: height or time (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_TYPE_FLAG = 1 << 22;

		/**
		 * Sequence granularity for time (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_GRANULARITY = 9;

		/**
		 * Sequence mask (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_MASK = 0x0000ffff;

		/**
		 * Max serialized script size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_SIZE = 10000;

		/**
		 * Max stack size during execution (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_STACK = 1000;

		/**
		 * Max script element size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_PUSH = 520;

		/**
		 * Max opcodes executed (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_OPS = 201;

		/**
		 * Max `n` value for multisig (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_MULTISIG_PUBKEYS = 20;

		/**
		 * The date bip16 (p2sh) was activated (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.BIP16_TIME = 1333238400;

		/**
		 * A hash of all zeroes.
		 * @const {Buffer}
		 * @default
		 */

		exports.ZERO_HASH = Buffer.alloc(32, 0x00);

		/**
		 * A hash of all zeroes.
		 * @const {String}
		 * @default
		 */

		exports.NULL_HASH = '0000000000000000000000000000000000000000000000000000000000000000';

		/**
		 * Anti replay commitment.
		 * @const {String}
		 * @default
		 */

		exports.ANTI_REPLAY_COMMITMENT = 'Bitcoin: A Peer-to-Peer Electronic Cash System';

		/**
		 * Convert a compact number to a big number.
		 * Used for `block.bits` -> `target` conversion.
		 * @param {Number} compact
		 * @returns {BN}
		 */

		exports.fromCompact = function fromCompact(compact) {
		  if (compact === 0) return new BN(0);
		  const exponent = compact >>> 24;
		  const negative = compact >>> 23 & 1;
		  let mantissa = compact & 0x7fffff;
		  let num;
		  if (exponent <= 3) {
		    mantissa >>>= 8 * (3 - exponent);
		    num = new BN(mantissa);
		  } else {
		    num = new BN(mantissa);
		    num.iushln(8 * (exponent - 3));
		  }
		  if (negative) num.ineg();
		  return num;
		};

		/**
		 * Convert a big number to a compact number.
		 * Used for `target` -> `block.bits` conversion.
		 * @param {BN} num
		 * @returns {Number}
		 */

		exports.toCompact = function toCompact(num) {
		  if (num.isZero()) return 0;
		  let exponent = num.byteLength();
		  let mantissa;
		  if (exponent <= 3) {
		    mantissa = num.toNumber();
		    mantissa <<= 8 * (3 - exponent);
		  } else {
		    mantissa = num.ushrn(8 * (exponent - 3)).toNumber();
		  }
		  if (mantissa & 0x800000) {
		    mantissa >>= 8;
		    exponent++;
		  }
		  let compact = exponent << 24 | mantissa;
		  if (num.isNeg()) compact |= 0x800000;
		  compact >>>= 0;
		  return compact;
		};

		/**
		 * Verify proof-of-work.
		 * @param {Hash} hash
		 * @param {Number} bits
		 * @returns {Boolean}
		 */

		exports.verifyPOW = function verifyPOW(hash, bits) {
		  const target = exports.fromCompact(bits);
		  if (target.isNeg() || target.isZero()) return false;
		  if (target.bitLength() > 256) return false;
		  const num = new BN(hash, 'le');
		  if (num.gt(target)) return false;
		  return true;
		};

		/**
		 * Calculate block subsidy.
		 * @param {Number} height - Reward era by height.
		 * @returns {Amount}
		 */

		exports.getReward = function getReward(height, interval) {
		  assert(height >= 0, 'Bad height for reward.');
		  const halvings = Math.floor(height / interval);

		  // BIP 42 (well, our own version of it,
		  // since we can only handle 32 bit shifts).
		  // https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki
		  if (halvings >= 33) return 0;

		  // We need to shift right by `halvings`,
		  // but 50 btc is a 33 bit number, so we
		  // cheat. We only start halving once the
		  // halvings are at least 1.
		  if (halvings === 0) return exports.BASE_REWARD;
		  return exports.HALF_REWARD >>> halvings - 1;
		};

		/**
		 * Test version bit.
		 * @param {Number} version
		 * @param {Number} bit
		 * @returns {Boolean}
		 */

		exports.hasBit = function hasBit(version, bit) {
		  const TOP_MASK = exports.VERSION_TOP_MASK;
		  const TOP_BITS = exports.VERSION_TOP_BITS;
		  const bits = (version & TOP_MASK) >>> 0;
		  const mask = 1 << bit;
		  return bits === TOP_BITS && (version & mask) !== 0;
		};

		/**
		 * Calculate max block sigops.
		 * @param {Number} size
		 * @returns {Number}
		 */

		exports.maxBlockSigops = function maxBlockSigops(size) {
		  const mb = 1 + ((size - 1) / 1e6 | 0);
		  return mb * exports.MAX_BLOCK_SIGOPS_PER_MB;
		};

		/**
		 * Calculate maximum block sigchecks.
		 * @param {Number} size 
		 * @returns {Number}
		 */

		exports.maxBlockSigchecks = function maxBlockSigchecks(size) {
		  return size / exports.MAX_BLOCK_SIGCHECKS_RATIO;
		}; 
	} (consensus));
	return consensus;
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var _polyfillNode_events = /*#__PURE__*/Object.freeze({
	__proto__: null,
	EventEmitter: EventEmitter,
	default: EventEmitter
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

var util = {};

/*!
 * util.js - utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {

		const assert = requireAssert$1();

		/**
		 * @exports utils/util
		 */

		const util = exports;

		/**
		 * Return hrtime (shim for browser).
		 * @param {Array} time
		 * @returns {Array} [seconds, nanoseconds]
		 */

		util.bench = function bench(time) {
		  if (!process.hrtime) {
		    const now = Date.now();
		    if (time) {
		      const [hi, lo] = time;
		      const start = hi * 1000 + lo / 1e6;
		      return now - start;
		    }
		    const ms = now % 1000;

		    // Seconds
		    const hi = (now - ms) / 1000;

		    // Nanoseconds
		    const lo = ms * 1e6;
		    return [hi, lo];
		  }
		  if (time) {
		    const [hi, lo] = process.hrtime(time);
		    return hi * 1000 + lo / 1e6;
		  }
		  return process.hrtime();
		};

		/**
		 * Get current time in unix time (seconds).
		 * @returns {Number}
		 */

		util.now = function now() {
		  return Math.floor(Date.now() / 1000);
		};

		/**
		 * Get current time in unix time (milliseconds).
		 * @returns {Number}
		 */

		util.ms = function ms() {
		  return Date.now();
		};

		/**
		 * Create a Date ISO string from time in unix time (seconds).
		 * @param {Number?} time - Seconds in unix time.
		 * @returns {String}
		 */

		util.date = function date(time) {
		  if (time == null) time = util.now();
		  return new Date(time * 1000).toISOString().slice(0, -5) + 'Z';
		};

		/**
		 * Get unix seconds from a Date string.
		 * @param {String?} date - Date ISO String.
		 * @returns {Number}
		 */

		util.time = function time(date) {
		  if (date == null) return util.now();
		  return new Date(date) / 1000 | 0;
		};

		/**
		 * Reverse a hex-string.
		 * @param {Buffer}
		 * @returns {String} Reversed hex string.
		 */

		util.revHex = function revHex(buf) {
		  assert(Buffer.isBuffer(buf));
		  return Buffer.from(buf).reverse().toString('hex');
		};
		util.fromRev = function fromRev(str) {
		  assert(typeof str === 'string');
		  assert((str.length & 1) === 0);
		  return Buffer.from(str, 'hex').reverse();
		}; 
	} (util));
	return util;
}

/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var timedata;
var hasRequiredTimedata;

function requireTimedata () {
	if (hasRequiredTimedata) return timedata;
	hasRequiredTimedata = 1;

	const EventEmitter = require$$0$2;
	const util = requireUtil();
	const binary = requireBinary();

	/**
	 * Time Data
	 * An object which handles "adjusted time". This may not
	 * look it, but this is actually a semi-consensus-critical
	 * piece of code. It handles version packets from peers
	 * and calculates what to offset our system clock's time by.
	 * @alias module:protocol.TimeData
	 * @extends EventEmitter
	 * @property {Array} samples
	 * @property {Object} known
	 * @property {Number} limit
	 * @property {Number} offset
	 */

	class TimeData extends EventEmitter {
	  /**
	   * Create time data.
	   * @constructor
	   * @param {Number} [limit=200]
	   */

	  constructor(limit) {
	    super();
	    if (limit == null) limit = 200;
	    this.samples = [];
	    this.known = new Map();
	    this.limit = limit;
	    this.offset = 0;
	    this.checked = false;
	  }

	  /**
	   * Add time data.
	   * @param {String} id
	   * @param {Number} time
	   */

	  add(id, time) {
	    if (this.samples.length >= this.limit) return;
	    if (this.known.has(id)) return;
	    const sample = time - util.now();
	    this.known.set(id, sample);
	    binary.insert(this.samples, sample, compare);
	    this.emit('sample', sample, this.samples.length);
	    if (this.samples.length >= 5 && this.samples.length % 2 === 1) {
	      let median = this.samples[this.samples.length >>> 1];
	      if (Math.abs(median) >= 70 * 60) {
	        if (!this.checked) {
	          let match = false;
	          for (const offset of this.samples) {
	            if (offset !== 0 && Math.abs(offset) < 5 * 60) {
	              match = true;
	              break;
	            }
	          }
	          if (!match) {
	            this.checked = true;
	            this.emit('mismatch');
	          }
	        }
	        median = 0;
	      }
	      this.offset = median;
	      this.emit('offset', this.offset);
	    }
	  }

	  /**
	   * Get the current adjusted time.
	   * @returns {Number} Adjusted Time.
	   */

	  now() {
	    return util.now() + this.offset;
	  }

	  /**
	   * Adjust a timestamp.
	   * @param {Number} time
	   * @returns {Number} Adjusted Time.
	   */

	  adjust(time) {
	    return time + this.offset;
	  }

	  /**
	   * Unadjust a timestamp.
	   * @param {Number} time
	   * @returns {Number} Local Time.
	   */

	  local(time) {
	    return time - this.offset;
	  }

	  /**
	   * Get the current adjusted time in milliseconds.
	   * @returns {Number} Adjusted Time.
	   */

	  ms() {
	    return Date.now() + this.offset * 1000;
	  }
	}

	/*
	 * Helpers
	 */

	function compare(a, b) {
	  return a - b;
	}

	/*
	 * Expose
	 */

	timedata = TimeData;
	return timedata;
}

/*!
 * network.js - network object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var network;
var hasRequiredNetwork;

function requireNetwork () {
	if (hasRequiredNetwork) return network;
	hasRequiredNetwork = 1;

	const assert = requireAssert$1();
	const binary = requireBinary();
	const networks = requireNetworks();
	const consensus = requireConsensus();
	const TimeData = requireTimedata();

	/**
	 * Network
	 * Represents a network.
	 * @alias module:protocol.Network
	 */

	class Network {
	  /**
	   * Create a network.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    assert(!Network[options.type], 'Cannot create two networks.');
	    this.type = options.type;
	    this.seeds = options.seeds;
	    this.magic = options.magic;
	    this.port = options.port;
	    this.checkpointMap = options.checkpointMap;
	    this.lastCheckpoint = options.lastCheckpoint;
	    this.checkpoints = [];
	    this.halvingInterval = options.halvingInterval;
	    this.genesis = options.genesis;
	    this.genesisBlock = options.genesisBlock;
	    this.pow = options.pow;
	    this.block = options.block;
	    this.bip30 = options.bip30;
	    this.activationThreshold = options.activationThreshold;
	    this.minerWindow = options.minerWindow;
	    this.deployments = options.deployments;
	    this.deploys = options.deploys;
	    this.unknownBits = ~consensus.VERSION_TOP_MASK;
	    this.keyPrefix = options.keyPrefix;
	    this.addressPrefix = options.addressPrefix;
	    this.requireStandard = options.requireStandard;
	    this.rpcPort = options.rpcPort;
	    this.walletPort = options.walletPort;
	    this.minRelay = options.minRelay;
	    this.feeRate = options.feeRate;
	    this.maxFeeRate = options.maxFeeRate;
	    this.selfConnect = options.selfConnect;
	    this.requestMempool = options.requestMempool;
	    this.time = new TimeData();
	    this.init();
	  }

	  /**
	   * Get a deployment by bit index.
	   * @param {Number} bit
	   * @returns {Object}
	   */

	  init() {
	    let bits = 0;
	    for (const deployment of this.deploys) bits |= 1 << deployment.bit;
	    bits |= consensus.VERSION_TOP_MASK;
	    this.unknownBits = ~bits >>> 0;
	    for (const key of Object.keys(this.checkpointMap)) {
	      const hash = this.checkpointMap[key];
	      const height = Number(key);
	      this.checkpoints.push({
	        hash,
	        height
	      });
	    }
	    this.checkpoints.sort(cmpNode);
	  }

	  /**
	   * Get a deployment by bit index.
	   * @param {Number} bit
	   * @returns {Object}
	   */

	  byBit(bit) {
	    const index = binary.search(this.deploys, bit, cmpBit);
	    if (index === -1) return null;
	    return this.deploys[index];
	  }

	  /**
	   * Get network adjusted time.
	   * @returns {Number}
	   */

	  now() {
	    return this.time.now();
	  }

	  /**
	   * Get network adjusted time in milliseconds.
	   * @returns {Number}
	   */

	  ms() {
	    return this.time.ms();
	  }

	  /**
	   * Create a network. Get existing network if possible.
	   * @param {NetworkType|Object} options
	   * @returns {Network}
	   */

	  static create(options) {
	    if (typeof options === 'string') options = networks[options];
	    assert(options, 'Unknown network.');
	    if (Network[options.type]) return Network[options.type];
	    const network = new Network(options);
	    Network[network.type] = network;
	    if (!Network.primary) Network.primary = network;
	    return network;
	  }

	  /**
	   * Set the default network. This network will be used
	   * if nothing is passed as the `network` option for
	   * certain objects.
	   * @param {NetworkType} type - Network type.
	   * @returns {Network}
	   */

	  static set(type) {
	    assert(typeof type === 'string', 'Bad network.');
	    Network.primary = Network.get(type);
	    Network.type = type;
	    return Network.primary;
	  }

	  /**
	   * Get a network with a string or a Network object.
	   * @param {NetworkType|Network} type - Network type.
	   * @returns {Network}
	   */

	  static get(type) {
	    if (!type) {
	      assert(Network.primary, 'No default network.');
	      return Network.primary;
	    }
	    if (type instanceof Network) return type;
	    if (typeof type === 'string') return Network.create(type);
	    throw new Error('Unknown network.');
	  }

	  /**
	   * Get a network with a string or a Network object.
	   * @param {NetworkType|Network} type - Network type.
	   * @returns {Network}
	   */

	  static ensure(type) {
	    if (!type) {
	      assert(Network.primary, 'No default network.');
	      return Network.primary;
	    }
	    if (type instanceof Network) return type;
	    if (typeof type === 'string') {
	      if (networks[type]) return Network.create(type);
	    }
	    assert(Network.primary, 'No default network.');
	    return Network.primary;
	  }

	  /**
	   * Get a network by an associated comparator.
	   * @private
	   * @param {Object} value
	   * @param {Function} compare
	   * @param {Network|null} network
	   * @param {String} name
	   * @returns {Network}
	   */

	  static by(value, compare, network, name) {
	    if (network) {
	      network = Network.get(network);
	      if (compare(network, value)) return network;
	      throw new Error(`Network mismatch for ${name}.`);
	    }
	    for (const type of networks.types) {
	      network = networks[type];
	      if (compare(network, value)) return Network.get(type);
	    }
	    throw new Error(`Network not found for ${name}.`);
	  }

	  /**
	   * Get a network by its magic number.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromMagic(value, network) {
	    return Network.by(value, cmpMagic, network, 'magic number');
	  }

	  /**
	   * Get a network by its WIF prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromWIF(prefix, network) {
	    return Network.by(prefix, cmpWIF, network, 'WIF');
	  }

	  /**
	   * Get a network by its xpubkey prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPublic(prefix, network) {
	    return Network.by(prefix, cmpPub, network, 'xpubkey');
	  }

	  /**
	   * Get a network by its xprivkey prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPrivate(prefix, network) {
	    return Network.by(prefix, cmpPriv, network, 'xprivkey');
	  }

	  /**
	   * Get a network by its xpubkey base58 prefix.
	   * @param {String} prefix
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPublic58(prefix, network) {
	    return Network.by(prefix, cmpPub58, network, 'xpubkey');
	  }

	  /**
	   * Get a network by its xprivkey base58 prefix.
	   * @param {String} prefix
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPrivate58(prefix, network) {
	    return Network.by(prefix, cmpPriv58, network, 'xprivkey');
	  }

	  /**
	   * Get a network by its base58 address prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromAddress(prefix, network) {
	    return Network.by(prefix, cmpAddress, network, 'base58 address');
	  }

	  /**
	   * Get a network by its cashaddr address prefix.
	   * @param {String} hrp
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromCashAddr(prefix, network) {
	    return Network.by(prefix, cmpCashAddr, network, 'cashaddr address');
	  }

	  /**
	   * Convert the network to a string.
	   * @returns {String}
	   */

	  toString() {
	    return this.type;
	  }

	  /**
	   * Inspect the network.
	   * @returns {String}
	   */

	  inspect() {
	    return `<Network: ${this.type}>`;
	  }

	  /**
	   * Test an object to see if it is a Network.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isNetwork(obj) {
	    return obj instanceof Network;
	  }
	}

	/**
	 * Default network.
	 * @type {Network}
	 */

	Network.primary = null;

	/**
	 * Default network type.
	 * @type {String}
	 */

	Network.type = null;

	/*
	 * Networks (to avoid hash table mode).
	 */

	Network.main = null;
	Network.testnet = null;
	Network.regtest = null;
	Network.segnet4 = null;
	Network.simnet = null;

	/*
	 * Set initial network.
	 */

	Network.set(process.env.BCASH_NETWORK || 'main');

	/*
	 * Helpers
	 */

	function cmpBit(a, b) {
	  return a.bit - b;
	}
	function cmpNode(a, b) {
	  return a.height - b.height;
	}
	function cmpMagic(network, magic) {
	  return network.magic === magic;
	}
	function cmpWIF(network, prefix) {
	  return network.keyPrefix.privkey === prefix;
	}
	function cmpPub(network, prefix) {
	  return network.keyPrefix.xpubkey === prefix;
	}
	function cmpPriv(network, prefix) {
	  return network.keyPrefix.xprivkey === prefix;
	}
	function cmpPub58(network, prefix) {
	  return network.keyPrefix.xpubkey58 === prefix;
	}
	function cmpPriv58(network, prefix) {
	  return network.keyPrefix.xprivkey58 === prefix;
	}
	function cmpAddress(network, prefix) {
	  const prefixes = network.addressPrefix;
	  switch (prefix) {
	    case prefixes.pubkeyhash:
	    case prefixes.scripthash:
	      return true;
	  }
	  return false;
	}
	function cmpCashAddr(network, prefix) {
	  return network.addressPrefix.cashaddr === prefix;
	}

	/*
	 * Expose
	 */

	network = Network;
	return network;
}

var utils = {};

var message = {};

var random = {};

/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */

var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return random;
	hasRequiredRandom = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	const HAS_CRYPTO = crypto && typeof crypto.getRandomValues === 'function';
	const randomValues = HAS_CRYPTO ? crypto.getRandomValues.bind(crypto) : null;
	const pool = new Uint32Array(16);
	const MAX_BYTES = 65536;
	let poolPos = 0;

	/**
	 * Generate pseudo-random bytes.
	 * @param {Number} size
	 * @returns {Buffer}
	 */

	function randomBytes(size) {
	  assert(size >>> 0 === size);
	  const data = Buffer.alloc(size);
	  randomFillSync(data, 0, size);
	  return data;
	}

	/**
	 * Generate pseudo-random bytes.
	 * @param {Buffer} data
	 * @param {Number} [off=0]
	 * @param {Number} [size=data.length-off]
	 * @returns {Buffer}
	 */

	function randomFill(data, off, size) {
	  assert(Buffer.isBuffer(data));
	  if (off == null) off = 0;
	  assert(off >>> 0 === off);
	  if (size == null) size = data.length - off;
	  assert(size >>> 0 === size);
	  assert(off + size <= data.length);
	  randomFillSync(data, off, size);
	  return data;
	}

	/**
	 * Generate a random uint32.
	 * @returns {Number}
	 */

	function randomInt() {
	  if ((poolPos & 15) === 0) {
	    getRandomValues(pool);
	    poolPos = 0;
	  }
	  return pool[poolPos++];
	}

	/**
	 * Generate a random uint32 within a range.
	 * @param {Number} min - Inclusive.
	 * @param {Number} max - Exclusive.
	 * @returns {Number}
	 */

	function randomRange(min, max) {
	  assert(min >>> 0 === min);
	  assert(max >>> 0 === max);
	  assert(max >= min);
	  const space = max - min;
	  if (space === 0) return min;
	  const top = -space >>> 0;
	  let x, r;
	  do {
	    x = randomInt();
	    r = x % space;
	  } while (x - r > top);
	  return r + min;
	}

	/*
	 * Helpers
	 */

	function getRandomValues(array) {
	  if (!HAS_CRYPTO) throw new Error('Entropy source not available.');
	  return randomValues(array);
	}
	function randomFillSync(data, off, size) {
	  assert(Buffer.isBuffer(data));
	  assert(data.buffer instanceof ArrayBuffer);
	  assert(data.byteOffset >>> 0 === data.byteOffset);
	  assert(data.byteLength >>> 0 === data.byteLength);
	  assert(off >>> 0 === off);
	  assert(size >>> 0 === size);
	  assert(off + size <= data.byteLength);
	  if (size > 2 ** 31 - 1) throw new RangeError('The value "size" is out of range.');
	  const offset = data.byteOffset + off;
	  const array = new Uint8Array(data.buffer, offset, size);
	  if (array.length > MAX_BYTES) {
	    for (let i = 0; i < array.length; i += MAX_BYTES) {
	      let j = i + MAX_BYTES;
	      if (j > array.length) j = array.length;
	      getRandomValues(array.subarray(i, j));
	    }
	  } else {
	    if (array.length > 0) getRandomValues(array);
	  }
	}

	/*
	 * Expose
	 */

	random.native = 0;
	random.randomBytes = randomBytes;
	random.randomFill = randomFill;
	random.randomInt = randomInt;
	random.randomRange = randomRange;
	return random;
}

var asn1 = {};

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = (function () {
    return function foo() {}.name === 'foo';
  }());
}
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

function assert(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}

// assert.AssertionError instanceof Error
inherits(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
}

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
}

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
}

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert.throws = throws;
function throws(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
}

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
}

assert.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AssertionError: AssertionError,
	assert: ok,
	deepEqual: deepEqual,
	deepStrictEqual: deepStrictEqual,
	default: assert,
	doesNotThrow: doesNotThrow,
	equal: equal,
	fail: fail,
	ifError: ifError,
	notDeepEqual: notDeepEqual,
	notDeepStrictEqual: notDeepStrictEqual,
	notEqual: notEqual,
	notStrictEqual: notStrictEqual,
	ok: ok,
	strictEqual: strictEqual,
	throws: throws
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredAsn1;

function requireAsn1 () {
	if (hasRequiredAsn1) return asn1;
	hasRequiredAsn1 = 1;

	const assert = require$$0$1;
	const BN = requireBn();

	/*
	 * ASN1
	 */

	function readSize(data, pos, strict) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert(typeof strict === 'boolean');
	  if (pos >= data.length) throw new Error('Invalid size.');
	  const field = data[pos];
	  const bytes = field & 0x7f;
	  pos += 1;

	  // Definite form.
	  if ((field & 0x80) === 0) {
	    // Short form.
	    return [bytes, pos];
	  }

	  // Indefinite form.
	  if (strict && bytes === 0) throw new Error('Indefinite length.');

	  // Long form.
	  let size = 0;
	  for (let i = 0; i < bytes; i++) {
	    assert(pos < data.length);
	    const ch = data[pos];
	    pos += 1;
	    if (size >= 1 << 24) throw new Error('Length too large.');
	    size *= 0x100;
	    size += ch;
	    if (strict && size === 0) throw new Error('Unexpected leading zeroes.');
	  }
	  if (strict && size < 0x80) throw new Error('Non-minimal length.');
	  return [size, pos];
	}
	function readSeq(data, pos, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert(typeof strict === 'boolean');
	  if (pos >= data.length || data[pos] !== 0x30) throw new Error('Invalid sequence tag.');
	  pos += 1;
	  let size;
	  [size, pos] = readSize(data, pos, strict);
	  if (strict && pos + size !== data.length) throw new Error('Trailing bytes.');
	  return pos;
	}
	function readInt(data, pos, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert(typeof strict === 'boolean');
	  if (pos >= data.length || data[pos] !== 0x02) throw new Error('Invalid integer tag.');
	  pos += 1;
	  let size;
	  [size, pos] = readSize(data, pos, strict);
	  if (pos + size > data.length) throw new Error('Integer body out of bounds.');
	  if (strict) {
	    // Zero length integer.
	    if (size === 0) throw new Error('Zero length integer.');

	    // No negatives.
	    if (data[pos] & 0x80) throw new Error('Integers must be positive.');

	    // Allow zero only if it prefixes a high bit.
	    if (size > 1) {
	      if (data[pos] === 0x00 && (data[pos + 1] & 0x80) === 0x00) throw new Error('Unexpected leading zeroes.');
	    }
	  }

	  // Eat leading zeroes.
	  while (size > 0 && data[pos] === 0x00) {
	    pos += 1;
	    size -= 1;
	  }

	  // No reason to have an integer larger than this.
	  if (size > 2048) throw new Error('Invalid integer size.');
	  const num = BN.decode(data.slice(pos, pos + size));
	  pos += size;
	  return [num, pos];
	}
	function readVersion(data, pos, version, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert((version & 0xff) === version);
	  assert(typeof strict === 'boolean');
	  let num;
	  [num, pos] = readInt(data, pos, strict);
	  if (num.cmpn(version) !== 0) throw new Error('Invalid version.');
	  return pos;
	}
	function sizeSize(size) {
	  assert(size >>> 0 === size);
	  if (size <= 0x7f)
	    // [size]
	    return 1;
	  if (size <= 0xff)
	    // 0x81 [size]
	    return 2;
	  assert(size <= 0xffff);
	  return 3; // 0x82 [size-hi] [size-lo]
	}
	function sizeSeq(size) {
	  return 1 + sizeSize(size) + size;
	}
	function sizeInt(num) {
	  assert(num instanceof BN);

	  // 0x02 [size] [0x00?] [int]
	  const bits = num.bitLength();
	  let size = bits + 7 >>> 3;
	  if (bits > 0 && (bits & 7) === 0) size += num.testn(bits - 1);
	  if (bits === 0) size = 1;
	  return 1 + sizeSize(size) + size;
	}
	function sizeVersion(version) {
	  assert((version & 0xff) === version);
	  return 3;
	}
	function writeSize(data, pos, size) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert(size >>> 0 === size);
	  if (size <= 0x7f) {
	    // [size]
	    data[pos++] = size;
	  } else if (size <= 0xff) {
	    // 0x81 [size]
	    data[pos++] = 0x81;
	    data[pos++] = size;
	  } else {
	    // 0x82 [size-hi] [size-lo]
	    assert(size <= 0xffff);
	    data[pos++] = 0x82;
	    data[pos++] = size >> 8;
	    data[pos++] = size & 0xff;
	  }
	  assert(pos <= data.length);
	  return pos;
	}
	function writeSeq(data, pos, size) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  data[pos++] = 0x30;
	  return writeSize(data, pos, size);
	}
	function writeInt(data, pos, num) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert(num instanceof BN);

	  // 0x02 [size] [0x00?] [int]
	  const bits = num.bitLength();
	  let size = bits + 7 >>> 3;
	  let pad = 0;
	  if (bits > 0 && (bits & 7) === 0) pad = num.testn(bits - 1);
	  if (bits === 0) size = 1;
	  data[pos++] = 0x02;
	  pos = writeSize(data, pos, pad + size);
	  if (pad) data[pos++] = 0x00;
	  if (bits !== 0) num.encode().copy(data, pos);else data[pos] = 0x00;
	  pos += size;
	  assert(pos <= data.length);
	  return pos;
	}
	function writeVersion(data, pos, version) {
	  assert(Buffer.isBuffer(data));
	  assert(pos >>> 0 === pos);
	  assert((version & 0xff) === version);
	  assert(pos + 3 <= data.length);
	  data[pos++] = 0x02;
	  data[pos++] = 0x01;
	  data[pos++] = version;
	  return pos;
	}

	/*
	 * Expose
	 */

	asn1.readSize = readSize;
	asn1.readSeq = readSeq;
	asn1.readInt = readInt;
	asn1.readVersion = readVersion;
	asn1.sizeSize = sizeSize;
	asn1.sizeSeq = sizeSeq;
	asn1.sizeInt = sizeInt;
	asn1.sizeVersion = sizeVersion;
	asn1.writeSize = writeSize;
	asn1.writeSeq = writeSeq;
	asn1.writeInt = writeInt;
	asn1.writeVersion = writeVersion;
	return asn1;
}

/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */

var chacha20;
var hasRequiredChacha20;

function requireChacha20 () {
	if (hasRequiredChacha20) return chacha20;
	hasRequiredChacha20 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

	/**
	 * ChaCha20
	 */

	class ChaCha20 {
	  /**
	   * Create a ChaCha20 context.
	   * @constructor
	   */

	  constructor() {
	    this.state = new Uint32Array(16);
	    this.stream = new Uint32Array(16);
	    this.bytes = new Uint8Array(this.stream.buffer);
	    this.pos = -1;
	    if (BIG_ENDIAN) this.bytes = Buffer.alloc(64);
	  }

	  /**
	   * Initialize chacha20 with a key, nonce, and counter.
	   * @param {Buffer} key
	   * @param {Buffer} nonce
	   * @param {Number} counter
	   */

	  init(key, nonce, counter) {
	    if (counter == null) counter = 0;
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(nonce));
	    assert(Number.isSafeInteger(counter));
	    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');
	    if (nonce.length >= 24) {
	      key = ChaCha20.derive(key, nonce.slice(0, 16));
	      nonce = nonce.slice(16);
	    }
	    this.state[0] = 0x61707865;
	    this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
	    this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
	    this.state[3] = 0x6b206574;
	    this.state[4] = readU32(key, 0);
	    this.state[5] = readU32(key, 4);
	    this.state[6] = readU32(key, 8);
	    this.state[7] = readU32(key, 12);
	    this.state[8] = readU32(key, 16 % key.length);
	    this.state[9] = readU32(key, 20 % key.length);
	    this.state[10] = readU32(key, 24 % key.length);
	    this.state[11] = readU32(key, 28 % key.length);
	    this.state[12] = counter >>> 0;
	    if (nonce.length === 8) {
	      this.state[13] = counter / 0x100000000 >>> 0;
	      this.state[14] = readU32(nonce, 0);
	      this.state[15] = readU32(nonce, 4);
	    } else if (nonce.length === 12) {
	      this.state[13] = readU32(nonce, 0);
	      this.state[14] = readU32(nonce, 4);
	      this.state[15] = readU32(nonce, 8);
	    } else if (nonce.length === 16) {
	      this.state[12] = readU32(nonce, 0);
	      this.state[13] = readU32(nonce, 4);
	      this.state[14] = readU32(nonce, 8);
	      this.state[15] = readU32(nonce, 12);
	    } else {
	      throw new RangeError('Invalid nonce size.');
	    }
	    this.pos = 0;
	    return this;
	  }

	  /**
	   * Encrypt/decrypt data.
	   * @param {Buffer} data - Will be mutated.
	   * @returns {Buffer}
	   */

	  encrypt(data) {
	    assert(Buffer.isBuffer(data));
	    if (this.pos === -1) throw new Error('Context is not initialized.');
	    for (let i = 0; i < data.length; i++) {
	      if ((this.pos & 63) === 0) {
	        this._block();
	        this.pos = 0;
	      }
	      data[i] ^= this.bytes[this.pos++];
	    }
	    return data;
	  }

	  /**
	   * Stir the stream.
	   */

	  _block() {
	    for (let i = 0; i < 16; i++) this.stream[i] = this.state[i];
	    for (let i = 0; i < 10; i++) {
	      qround(this.stream, 0, 4, 8, 12);
	      qround(this.stream, 1, 5, 9, 13);
	      qround(this.stream, 2, 6, 10, 14);
	      qround(this.stream, 3, 7, 11, 15);
	      qround(this.stream, 0, 5, 10, 15);
	      qround(this.stream, 1, 6, 11, 12);
	      qround(this.stream, 2, 7, 8, 13);
	      qround(this.stream, 3, 4, 9, 14);
	    }
	    for (let i = 0; i < 16; i++) this.stream[i] += this.state[i];
	    if (BIG_ENDIAN) {
	      for (let i = 0; i < 16; i++) writeU32(this.bytes, this.stream[i], i * 4);
	    }
	    this.state[12] += 1;
	    if (this.state[12] === 0) this.state[13] += 1;
	  }

	  /**
	   * Destroy context.
	   */

	  destroy() {
	    for (let i = 0; i < 16; i++) {
	      this.state[i] = 0;
	      this.stream[i] = 0;
	    }
	    if (BIG_ENDIAN) {
	      for (let i = 0; i < 64; i++) this.bytes[i] = 0;
	    }
	    this.pos = -1;
	    return this;
	  }

	  /**
	   * Derive key with XChaCha20.
	   * @param {Buffer} key
	   * @param {Buffer} nonce
	   * @returns {Buffer}
	   */

	  static derive(key, nonce) {
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(nonce));
	    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');
	    if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');
	    const state = new Uint32Array(16);
	    state[0] = 0x61707865;
	    state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
	    state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
	    state[3] = 0x6b206574;
	    state[4] = readU32(key, 0);
	    state[5] = readU32(key, 4);
	    state[6] = readU32(key, 8);
	    state[7] = readU32(key, 12);
	    state[8] = readU32(key, 16 % key.length);
	    state[9] = readU32(key, 20 % key.length);
	    state[10] = readU32(key, 24 % key.length);
	    state[11] = readU32(key, 28 % key.length);
	    state[12] = readU32(nonce, 0);
	    state[13] = readU32(nonce, 4);
	    state[14] = readU32(nonce, 8);
	    state[15] = readU32(nonce, 12);
	    for (let i = 0; i < 10; i++) {
	      qround(state, 0, 4, 8, 12);
	      qround(state, 1, 5, 9, 13);
	      qround(state, 2, 6, 10, 14);
	      qround(state, 3, 7, 11, 15);
	      qround(state, 0, 5, 10, 15);
	      qround(state, 1, 6, 11, 12);
	      qround(state, 2, 7, 8, 13);
	      qround(state, 3, 4, 9, 14);
	    }
	    const out = Buffer.alloc(32);
	    writeU32(out, state[0], 0);
	    writeU32(out, state[1], 4);
	    writeU32(out, state[2], 8);
	    writeU32(out, state[3], 12);
	    writeU32(out, state[12], 16);
	    writeU32(out, state[13], 20);
	    writeU32(out, state[14], 24);
	    writeU32(out, state[15], 28);
	    return out;
	  }
	}

	/*
	 * Static
	 */

	ChaCha20.native = 0;

	/*
	 * Helpers
	 */

	function qround(x, a, b, c, d) {
	  x[a] += x[b];
	  x[d] = rotl32(x[d] ^ x[a], 16);
	  x[c] += x[d];
	  x[b] = rotl32(x[b] ^ x[c], 12);
	  x[a] += x[b];
	  x[d] = rotl32(x[d] ^ x[a], 8);
	  x[c] += x[d];
	  x[b] = rotl32(x[b] ^ x[c], 7);
	}
	function rotl32(w, b) {
	  return w << b | w >>> 32 - b;
	}
	function readU32(data, off) {
	  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
	}
	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	chacha20 = ChaCha20;
	return chacha20;
}

/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */

var batchRng;
var hasRequiredBatchRng;

function requireBatchRng () {
	if (hasRequiredBatchRng) return batchRng;
	hasRequiredBatchRng = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const ChaCha20 = requireChacha20();
	const SHA256 = requireSha256();

	/**
	 * BatchRNG
	 */

	class BatchRNG {
	  constructor(curve, encode = key => key) {
	    this.curve = curve;
	    this.encode = encode;
	    this.hash = new SHA256();
	    this.chacha = new ChaCha20();
	    this.key = Buffer.alloc(32, 0x00);
	    this.iv = Buffer.alloc(8, 0x00);
	    this.cache = [new BN(1), new BN(1)];
	  }
	  init(batch) {
	    assert(Array.isArray(batch));
	    this.hash.init();
	    for (const [msg, sig, key] of batch) {
	      this.hash.update(SHA256.digest(msg));
	      this.hash.update(sig);
	      this.hash.update(this.encode(key));
	    }
	    this.key = this.hash.final();
	    this.cache[0] = new BN(1);
	    this.cache[1] = new BN(1);
	    return this;
	  }
	  encrypt(counter) {
	    const size = this.curve.scalarSize * 2;
	    const data = Buffer.alloc(size, 0x00);
	    const left = data.slice(0, this.curve.scalarSize);
	    const right = data.slice(this.curve.scalarSize);
	    this.chacha.init(this.key, this.iv, counter);
	    this.chacha.encrypt(data);
	    return [this.curve.decodeScalar(left), this.curve.decodeScalar(right)];
	  }
	  refresh(counter) {
	    let overflow = 0;
	    for (;;) {
	      // First word is always zero.
	      this.iv[4] = overflow;
	      this.iv[5] = overflow >>> 8;
	      this.iv[6] = overflow >>> 16;
	      this.iv[7] = overflow >>> 24;
	      overflow += 1;
	      const [s1, s2] = this.encrypt(counter);
	      if (s1.isZero() || s1.cmp(this.curve.n) >= 0) continue;
	      if (s2.isZero() || s2.cmp(this.curve.n) >= 0) continue;
	      this.cache[0] = s1;
	      this.cache[1] = s2;
	      break;
	    }
	  }
	  generate(index) {
	    assert(index >>> 0 === index);
	    if (index & 1) this.refresh(index >>> 1);
	    return this.cache[index & 1];
	  }
	}

	/*
	 * Expose
	 */

	batchRng = BatchRNG;
	return batchRng;
}

/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */

var schnorrLegacy;
var hasRequiredSchnorrLegacy;

function requireSchnorrLegacy () {
	if (hasRequiredSchnorrLegacy) return schnorrLegacy;
	hasRequiredSchnorrLegacy = 1;

	const assert = requireAssert();
	const BatchRNG = requireBatchRng();
	const BN = requireBn();

	/**
	 * Schnorr
	 */

	class Schnorr {
	  constructor(curve, hash) {
	    this.curve = curve;
	    this.hash = hash;
	    this.rng = new BatchRNG(this.curve, this.encode.bind(this));
	  }
	  check() {
	    // [SCHNORR] "Footnotes".
	    // Must be congruent to 3 mod 4.
	    if (this.curve.p.andln(3) !== 3) throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
	  }
	  encode(key) {
	    // Extra speedy key reserialization.
	    assert(Buffer.isBuffer(key));
	    const {
	      fieldSize
	    } = this.curve;
	    if (key.length === 1 + fieldSize) return key;
	    if (key.length !== 1 + fieldSize * 2) throw new Error('Invalid point.');
	    const out = Buffer.alloc(1 + fieldSize);
	    out[0] = 0x02 | key[key.length - 1] & 1;
	    key.copy(out, 1, 1, 1 + fieldSize);
	    return out;
	  }
	  hashInt(...items) {
	    // [SCHNORR] "Specification".
	    // eslint-disable-next-line
	    const h = new this.hash();
	    h.init();
	    for (const item of items) h.update(item);
	    let hash = h.final(this.curve.scalarSize);
	    if (hash.length > this.curve.scalarSize) hash = hash.slice(0, this.curve.scalarSize);
	    const num = BN.decode(hash, this.curve.endian);
	    num.iumaskn(this.curve.scalarBits);
	    return num.imod(this.curve.n);
	  }
	  hashNonce(a, m) {
	    return this.hashInt(a, m);
	  }
	  hashChallenge(R, A, m) {
	    return this.hashInt(R, this.encode(A), m);
	  }
	  sign(msg, key) {
	    assert(Buffer.isBuffer(msg));
	    this.check();
	    return this._sign(msg, key);
	  }
	  _sign(msg, key) {
	    // Schnorr Signing.
	    //
	    // [SCHNORR] "Signing".
	    // [CASH] "Recommended practices for secure signature generation".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `a` be a secret non-zero scalar.
	    //   - k != 0.
	    //
	    // Computation:
	    //
	    //   A = G * a
	    //   k = H(a, m) mod n
	    //   R = G * k
	    //   k = -k mod n, if y(R) is not square
	    //   r = x(R)
	    //   e = H(r, A, m) mod n
	    //   s = (k + e * a) mod n
	    //   S = (r, s)
	    //
	    // Note that `k` must remain secret,
	    // otherwise an attacker can compute:
	    //
	    //   a = (s - k) / e mod n
	    const {
	      n
	    } = this.curve;
	    const G = this.curve.g;
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');
	    const A = G.mulBlind(a);
	    const k = this.hashNonce(key, msg);
	    if (k.isZero()) throw new Error('Signing failed (k\' = 0).');
	    const R = G.mulBlind(k);
	    if (!R.isSquare()) k.ineg().imod(n);
	    const Rraw = R.encodeX();
	    const Araw = A.encode();
	    const e = this.hashChallenge(Rraw, Araw, msg);
	    const s = k.add(e.mul(a)).imod(n);
	    return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);
	  }
	  verify(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));
	    this.check();
	    if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;
	    try {
	      return this._verify(msg, sig, key);
	    } catch (e) {
	      return false;
	    }
	  }
	  _verify(msg, sig, key) {
	    // Schnorr Verification.
	    //
	    // [SCHNORR] "Verification".
	    // [CASH] "Signature verification algorithm".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - r^3 + a * r + b is square in F(p).
	    //   - sqrt(r^3 + a * r + b) is square in F(p).
	    //   - r < p, s < n.
	    //   - R != O.
	    //
	    // Computation:
	    //
	    //   R = (r, sqrt(r^3 + a * r + b))
	    //   e = H(r, A, m) mod n
	    //   R == G * s - A * e
	    //
	    // We can skip a square root with:
	    //
	    //   e = H(r, A, m) mod n
	    //   R = G * s - A * e
	    //   y(R) is square
	    //   x(R) == r
	    //
	    // We can also avoid affinization by
	    // replacing the two assertions with:
	    //
	    //   (y(R) * z(R) mod p) is square
	    //   x(R) == r * z(R)^2 mod p
	    //
	    // Furthermore, squareness can be calculated
	    // with a variable time Jacobi symbol algorithm.
	    const {
	      p,
	      n
	    } = this.curve;
	    const G = this.curve.g;
	    const Rraw = sig.slice(0, this.curve.fieldSize);
	    const sraw = sig.slice(this.curve.fieldSize);
	    const r = this.curve.decodeField(Rraw);
	    const s = this.curve.decodeScalar(sraw);
	    const A = this.curve.decodePoint(key);
	    if (r.cmp(p) >= 0 || s.cmp(n) >= 0) return false;
	    const e = this.hashChallenge(Rraw, key, msg);
	    const R = G.jmulAdd(s, A, e.ineg().imod(n));
	    if (!R.isSquare()) return false;
	    if (!R.eqX(r)) return false;
	    return true;
	  }
	  verifyBatch(batch) {
	    assert(Array.isArray(batch));
	    this.check();
	    for (const item of batch) {
	      assert(Array.isArray(item) && item.length === 3);
	      const [msg, sig, key] = item;
	      assert(Buffer.isBuffer(msg));
	      assert(Buffer.isBuffer(sig));
	      assert(Buffer.isBuffer(key));
	      if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;
	    }
	    try {
	      return this._verifyBatch(batch);
	    } catch (e) {
	      return false;
	    }
	  }
	  _verifyBatch(batch) {
	    // Schnorr Batch Verification.
	    //
	    // [SCHNORR] "Batch Verification".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - Let `i` be the batch item index.
	    //   - r^3 + a * r + b is square in F(p).
	    //   - sqrt(r^3 + a * r + b) is square in F(p).
	    //   - r < p, s < n.
	    //   - a1 = 1 mod n.
	    //
	    // Computation:
	    //
	    //   Ri = (ri, sqrt(ri^3 + a * ri + b))
	    //   ei = H(ri, Ai, mi) mod n
	    //   ai = random integer in [1,n-1]
	    //   lhs = si * ai + ... mod n
	    //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...
	    //   G * -lhs + rhs == O
	    const {
	      n
	    } = this.curve;
	    const G = this.curve.g;
	    const points = new Array(1 + batch.length * 2);
	    const coeffs = new Array(1 + batch.length * 2);
	    const sum = new BN(0);
	    this.rng.init(batch);
	    points[0] = G;
	    coeffs[0] = sum;
	    for (let i = 0; i < batch.length; i++) {
	      const [msg, sig, key] = batch[i];
	      const Rraw = sig.slice(0, this.curve.fieldSize);
	      const sraw = sig.slice(this.curve.fieldSize);
	      const R = this.curve.decodeSquare(Rraw);
	      const s = this.curve.decodeScalar(sraw);
	      const A = this.curve.decodePoint(key);
	      if (s.cmp(n) >= 0) return false;
	      const e = this.hashChallenge(Rraw, key, msg);
	      const a = this.rng.generate(i);
	      const ea = e.mul(a).imod(n);
	      sum.iadd(s.mul(a)).imod(n);
	      points[1 + i * 2 + 0] = R;
	      coeffs[1 + i * 2 + 0] = a;
	      points[1 + i * 2 + 1] = A;
	      coeffs[1 + i * 2 + 1] = ea;
	    }
	    sum.ineg().imod(n);
	    return this.curve.jmulAll(points, coeffs).isInfinity();
	  }
	}

	/*
	 * Expose
	 */

	schnorrLegacy = Schnorr;
	return schnorrLegacy;
}

/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */

var hmacDrbg;
var hasRequiredHmacDrbg;

function requireHmacDrbg () {
	if (hasRequiredHmacDrbg) return hmacDrbg;
	hasRequiredHmacDrbg = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const RESEED_INTERVAL = 0x1000000000000;
	const ZERO = Buffer.from([0x00]);
	const ONE = Buffer.from([0x01]);

	/**
	 * HmacDRBG
	 */

	class HmacDRBG {
	  constructor(hash, entropy, nonce, pers) {
	    assert(hash && typeof hash.id === 'string');
	    this.hash = hash;
	    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;
	    this.K = Buffer.alloc(hash.size);
	    this.V = Buffer.alloc(hash.size);
	    this.rounds = 0;
	    if (entropy) this.init(entropy, nonce, pers);
	  }
	  init(entropy, nonce, pers) {
	    if (nonce == null) nonce = Buffer.alloc(0);
	    if (pers == null) pers = Buffer.alloc(0);
	    assert(Buffer.isBuffer(entropy));
	    assert(Buffer.isBuffer(nonce));
	    assert(Buffer.isBuffer(pers));
	    for (let i = 0; i < this.V.length; i++) {
	      this.K[i] = 0x00;
	      this.V[i] = 0x01;
	    }
	    const seed = Buffer.concat([entropy, nonce, pers]);
	    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
	    this.update(seed);
	    this.rounds = 1;
	    return this;
	  }
	  reseed(entropy, add) {
	    if (add == null) add = Buffer.alloc(0);
	    assert(Buffer.isBuffer(entropy));
	    assert(Buffer.isBuffer(add));
	    if (this.rounds === 0) throw new Error('DRBG not initialized.');
	    const seed = Buffer.concat([entropy, add]);
	    if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
	    this.update(seed);
	    this.rounds = 1;
	    return this;
	  }
	  generate(len, add) {
	    assert(len >>> 0 === len);
	    assert(add == null || Buffer.isBuffer(add));
	    if (this.rounds === 0) throw new Error('DRBG not initialized.');
	    if (this.rounds > RESEED_INTERVAL) throw new Error('Reseed is required.');
	    if (add && add.length > 0) this.update(add);
	    const blocks = Math.ceil(len / this.hash.size);
	    const out = Buffer.alloc(blocks * this.hash.size);
	    for (let i = 0; i < blocks; i++) {
	      this.V = this.mac(this.V);
	      this.V.copy(out, i * this.hash.size);
	    }
	    this.update(add);
	    this.rounds += 1;
	    return out.slice(0, len);
	  }
	  randomBytes(size) {
	    return this.generate(size);
	  }

	  /*
	   * Helpers
	   */

	  mac(data) {
	    return this.hash.mac(data, this.K);
	  }
	  hmac() {
	    return this.hash.hmac().init(this.K);
	  }
	  update(seed) {
	    assert(seed == null || Buffer.isBuffer(seed));
	    const kmac = this.hmac();
	    kmac.update(this.V);
	    kmac.update(ZERO);
	    if (seed) kmac.update(seed);
	    this.K = kmac.final();
	    this.V = this.mac(this.V);
	    if (seed && seed.length > 0) {
	      const kmac = this.hmac();
	      kmac.update(this.V);
	      kmac.update(ONE);
	      kmac.update(seed);
	      this.K = kmac.final();
	      this.V = this.mac(this.V);
	    }
	    return this;
	  }
	}

	/*
	 * Static
	 */

	HmacDRBG.native = 0;

	/*
	 * Expose
	 */

	hmacDrbg = HmacDRBG;
	return hmacDrbg;
}

var elliptic = {};

/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */

var hasRequiredElliptic;

function requireElliptic () {
	if (hasRequiredElliptic) return elliptic;
	hasRequiredElliptic = 1;

	const {
	  custom
	} = requireCustom$1();
	const BN = requireBn();

	/*
	 * Constants
	 */

	const types = {
	  AFFINE: 0,
	  JACOBIAN: 1,
	  PROJECTIVE: 2,
	  EXTENDED: 3
	};
	const jsfIndex = [-3,
	// -1 -1
	-1,
	// -1 0
	-5,
	// -1 1
	-7,
	// 0 -1
	0,
	// 0 0
	7,
	// 0 1
	5,
	// 1 -1
	1,
	// 1 0
	3 // 1 1
	];
	let uid = 0;

	/**
	 * Curve
	 */

	class Curve {
	  constructor(Point, type, conf) {
	    this.Point = null;
	    this.id = null;
	    this.uid = uid++;
	    this.ossl = null;
	    this.type = 'base';
	    this.endian = 'be';
	    this.hash = null;
	    this.prefix = null;
	    this.context = false;
	    this.prime = null;
	    this.p = null;
	    this.red = null;
	    this.fieldSize = 0;
	    this.fieldBits = 0;
	    this.adjustedSize = 0;
	    this.signBit = 0;
	    this.mask = 0;
	    this.n = null;
	    this.h = null;
	    this.q = null;
	    this.z = null;
	    this.g = null;
	    this.nh = null;
	    this.scalarSize = 0;
	    this.scalarBits = 0;
	    this.zero = null;
	    this.one = null;
	    this.two = null;
	    this.three = null;
	    this.four = null;
	    this.i2 = null;
	    this.i3 = null;
	    this.i4 = null;
	    this.i6 = null;
	    this.torsion = null;
	    this.endo = null;
	    this.hi = null;
	    this._init(Point, type, conf);
	  }
	  _init(Point, type, conf) {
	    assert(typeof Point === 'function');
	    assert(typeof type === 'string');
	    assert(conf && typeof conf === 'object');
	    assert(conf.red == null || conf.red instanceof BN.Red);
	    assert(conf.p != null, 'Must pass a prime.');
	    assert(conf.id == null || typeof conf.id === 'string');
	    assert(conf.ossl == null || typeof conf.ossl === 'string');
	    assert(conf.endian == null || typeof conf.endian === 'string');
	    assert(conf.hash == null || typeof conf.hash === 'string');
	    assert(conf.prefix == null || typeof conf.prefix === 'string');
	    assert(conf.context == null || typeof conf.context === 'boolean');
	    assert(conf.prime == null || typeof conf.prime === 'string');
	    assert(conf.torsion == null || Array.isArray(conf.torsion));

	    // Point class.
	    this.Point = Point;

	    // Meta.
	    this.id = conf.id || null;
	    this.ossl = conf.ossl || null;
	    this.type = type;
	    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');
	    this.hash = conf.hash || null;
	    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;
	    this.context = conf.context || false;
	    this.prime = conf.prime || null;

	    // Prime.
	    this.p = BN.fromJSON(conf.p);

	    // Reduction.
	    if (conf.red) {
	      this.red = conf.red;
	    } else {
	      // Use Montgomery when there is no fast reduction for the prime.
	      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
	      this.red.precompute();
	    }

	    // Precalculate encoding length.
	    this.fieldSize = this.p.byteLength();
	    this.fieldBits = this.p.bitLength();
	    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);
	    this.signBit = this.adjustedSize * 8 - 1;
	    this.mask = 0xff;
	    if ((this.fieldBits & 7) !== 0) this.mask = (1 << (this.fieldBits & 7)) - 1;

	    // Curve configuration, optional.
	    this.n = BN.fromJSON(conf.n || '0');
	    this.h = BN.fromJSON(conf.h || '1');
	    this.q = this.n.mul(this.h);
	    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);
	    this.g = null;
	    this.nh = this.n.ushrn(1);
	    this.scalarSize = this.n.byteLength();
	    this.scalarBits = this.n.bitLength();

	    // Useful for many curves.
	    this.zero = new BN(0).toRed(this.red);
	    this.one = new BN(1).toRed(this.red);
	    this.two = new BN(2).toRed(this.red);
	    this.three = new BN(3).toRed(this.red);
	    this.four = new BN(4).toRed(this.red);

	    // Inverses.
	    this.i2 = this.two.redInvert();
	    this.i3 = this.three.redInvert();
	    this.i4 = this.i2.redSqr();
	    this.i6 = this.i2.redMul(this.i3);

	    // Torsion.
	    this.torsion = new Array(this.h.word(0));
	    for (let i = 0; i < this.torsion.length; i++) this.torsion[i] = this.point();

	    // Endomorphism.
	    this.endo = null;

	    // Cache.
	    this.hi = null;

	    // Memoize.
	    this._scale = memoize(this._scale, this);
	    this.isIsomorphic = memoize(this.isIsomorphic, this);
	    this.isIsogenous = memoize(this.isIsogenous, this);

	    // Sanity checks.
	    assert(this.p.sign() > 0 && this.p.isOdd());
	    assert(this.n.sign() >= 0);
	    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);
	    assert(this.endian === 'be' || this.endian === 'le');
	    return this;
	  }
	  _finalize(conf) {
	    assert(conf && typeof conf === 'object');

	    // Create base point.
	    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();

	    // Parse small order points.
	    if (conf.torsion) {
	      assert(conf.torsion.length === this.torsion.length);
	      for (let i = 0; i < this.torsion.length; i++) this.torsion[i] = this.pointFromJSON(conf.torsion[i]);
	    }
	    return this;
	  }
	  _findTorsion() {
	    // Find all torsion points by grinding.
	    assert(!this.n.isZero());
	    const h = this.h.word(0);
	    const x = this.one.redNeg();
	    const out = [this.point()];
	    const set = new Set();
	    let len = h;
	    while (out.length < len) {
	      let p;
	      x.redIAdd(this.one);
	      try {
	        p = this.pointFromX(x.clone());
	      } catch (e) {
	        continue;
	      }
	      try {
	        p = p.mul(this.n);
	      } catch (e) {
	        len = 2;
	        continue;
	      }
	      if (p.isInfinity()) continue;
	      p.normalize();
	      for (const point of [p, p.neg()]) {
	        const key = point.key();
	        if (!set.has(key)) {
	          out.push(point);
	          set.add(key);
	        }
	      }
	    }
	    out.sort((a, b) => a.cmp(b));
	    while (out.length < h) out.push(this.point());
	    return out;
	  }
	  _fixedMul(p, k) {
	    // Fixed-base method for point multiplication.
	    //
	    // [ECPM] "Windowed method".
	    // [GECC] Page 95, Section 3.3.
	    //
	    // Windows are appropriately shifted to avoid any
	    // doublings. This reduces a 256 bit multiplication
	    // down to 64 additions with a window size of 4.
	    assert(p instanceof Point);
	    assert(k instanceof BN);
	    assert(p.pre && p.pre.windows);

	    // Get precomputed windows.
	    const {
	      width,
	      points
	    } = p._getWindows(0, 0);

	    // Recompute window size.
	    const size = 1 << width;

	    // Recompute steps.
	    const bits = k.bitLength();
	    const steps = (bits + width - 1) / width >>> 0;

	    // Multiply.
	    let acc = this.jpoint();
	    for (let i = 0; i < steps; i++) {
	      const bits = k.bits(i * width, width);
	      acc = acc.add(points[i * size + bits]);
	    }

	    // Adjust sign.
	    if (k.isNeg()) acc = acc.neg();
	    return acc;
	  }
	  _fixedNafMul(p, k) {
	    // Fixed-base NAF windowing method for point multiplication.
	    //
	    // [GECC] Algorithm 3.42, Page 105, Section 3.3.
	    assert(p instanceof Point);
	    assert(k instanceof BN);
	    assert(p.pre && p.pre.doubles);

	    // Get precomputed doubles.
	    const {
	      step,
	      points
	    } = p._getDoubles(0, 0);

	    // Get fixed NAF (in a more windowed form).
	    const naf = getFixedNAF(k, 2, k.bitLength() + 1, step);

	    // Compute steps.
	    const I = ((1 << step + 1) - (step % 2 === 0 ? 2 : 1)) / 3;

	    // Multiply.
	    let a = this.jpoint();
	    let b = this.jpoint();
	    for (let i = I; i > 0; i--) {
	      for (let j = 0; j < naf.length; j++) {
	        const nafW = naf[j];
	        if (nafW === i) b = b.add(points[j]);else if (nafW === -i) b = b.sub(points[j]);
	      }
	      a = a.add(b);
	    }
	    return a;
	  }
	  _wnafMul(w, p, k) {
	    // Window NAF method for point multiplication.
	    //
	    // [GECC] Algorithm 3.36, Page 100, Section 3.3.
	    assert(p instanceof Point);
	    assert(k instanceof BN);

	    // Precompute window.
	    const {
	      width,
	      points
	    } = p._safeNAF(w);

	    // Get NAF form.
	    const naf = getNAF(k, width, k.bitLength() + 1);

	    // Add `this`*(N+1) for every w-NAF index.
	    let acc = this.jpoint();
	    for (let i = naf.length - 1; i >= 0; i--) {
	      const z = naf[i];
	      if (i !== naf.length - 1) acc = acc.dbl();
	      if (z > 0) acc = acc.add(points[z - 1 >> 1]);else if (z < 0) acc = acc.sub(points[-z - 1 >> 1]);
	    }
	    return acc;
	  }
	  _wnafMulAdd(w, points, coeffs) {
	    // Multiple point multiplication, also known
	    // as "Shamir's trick" (with interleaved NAFs).
	    //
	    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.
	    //        Algorithm 3.51, Page 112, Section 3.3.
	    //
	    // This is particularly useful for signature
	    // verifications and mutiplications after an
	    // endomorphism split.
	    assert(w >>> 0 === w);
	    assert(Array.isArray(points));
	    assert(Array.isArray(coeffs));
	    assert(points.length === coeffs.length);
	    const length = points.length;
	    const wnd = new Array(length);
	    const naf = new Array(length);

	    // Check arrays and calculate size.
	    let max = 0;
	    for (let i = 0; i < length; i++) {
	      const point = points[i];
	      const coeff = coeffs[i];
	      assert(point instanceof Point);
	      assert(coeff instanceof BN);
	      if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.');

	      // Avoid sparse arrays.
	      wnd[i] = null;
	      naf[i] = null;

	      // Compute max scalar size.
	      max = Math.max(max, coeff.bitLength() + 1);
	    }

	    // Compute NAFs.
	    let ppoint = null;
	    let pcoeff = null;
	    let len = 0;
	    for (let i = 0; i < length; i++) {
	      const point = points[i];
	      const coeff = coeffs[i];
	      const pre = point._getNAF(0);

	      // Use precomputation if available.
	      if (pre) {
	        wnd[len] = pre.points;
	        naf[len] = getNAF(coeff, pre.width, max);
	        len += 1;
	        continue;
	      }

	      // Save last non-precomputed point.
	      if (!ppoint) {
	        ppoint = point;
	        pcoeff = coeff;
	        continue;
	      }

	      // Compute JSF in NAF form.
	      wnd[len] = ppoint._getJNAF(point);
	      naf[len] = getJNAF(pcoeff, coeff, max);
	      ppoint = null;
	      pcoeff = null;
	      len += 1;
	    }

	    // Regular NAF for odd points.
	    if (ppoint) {
	      const nafw = ppoint._safeNAF(w);
	      wnd[len] = nafw.points;
	      naf[len] = getNAF(pcoeff, nafw.width, max);
	      len += 1;
	    }

	    // Multiply and add.
	    let acc = this.jpoint();
	    for (let i = max - 1; i >= 0; i--) {
	      if (i !== max - 1) acc = acc.dbl();
	      for (let j = 0; j < len; j++) {
	        const z = naf[j][i];
	        if (z > 0) acc = acc.add(wnd[j][z - 1 >> 1]);else if (z < 0) acc = acc.sub(wnd[j][-z - 1 >> 1]);
	      }
	    }
	    return acc;
	  }
	  _endoWnafMulAdd(points, coeffs) {
	    throw new Error('Not implemented.');
	  }
	  _scale(curve, invert) {
	    assert(curve instanceof Curve);
	    assert(curve.p.eq(this.p));
	    switch (curve.type) {
	      case 'short':
	        return this._scaleShort(curve, invert);
	      case 'mont':
	        return this._scaleMont(curve, invert);
	      case 'edwards':
	        return this._scaleEdwards(curve, invert);
	      default:
	        throw new Error('Not implemented.');
	    }
	  }
	  _scaleShort(curve, invert) {
	    throw new Error('Not implemented.');
	  }
	  _scaleMont(curve, invert) {
	    throw new Error('Not implemented.');
	  }
	  _scaleEdwards(curve, invert) {
	    throw new Error('Not implemented.');
	  }
	  isElliptic() {
	    throw new Error('Not implemented.');
	  }
	  jinv() {
	    throw new Error('Not implemented.');
	  }
	  isComplete() {
	    return false;
	  }
	  precompute(rng) {
	    assert(!this.g.isInfinity(), 'Must have base point.');
	    assert(!this.n.isZero(), 'Must have order.');
	    this.g.precompute(this.n.bitLength(), rng);
	    return this;
	  }
	  scalar(num, base, endian) {
	    const k = new BN(num, base, endian);
	    assert(!k.red);
	    if (this.n.isZero()) return k;
	    return k.imod(this.n);
	  }
	  field(num, base, endian) {
	    const x = BN.cast(num, base, endian);
	    if (x.red) return x.forceRed(this.red);
	    return x.toRed(this.red);
	  }
	  point(x, y) {
	    throw new Error('Not implemented.');
	  }
	  jpoint(x, y, z) {
	    throw new Error('Not implemented.');
	  }
	  xpoint(x, z) {
	    throw new Error('Not implemented.');
	  }
	  cpoint(xx, xz, yy, yz) {
	    assert(xx instanceof BN);
	    assert(xz instanceof BN);
	    assert(yy instanceof BN);
	    assert(yz instanceof BN);
	    if (xz.isZero() || yz.isZero()) return this.point();
	    const z = xz.redMul(yz).redInvert();
	    const x = xx.redMul(yz).redMul(z);
	    const y = yy.redMul(xz).redMul(z);
	    return this.point(x, y);
	  }
	  solveX2(y) {
	    throw new Error('Not implemented.');
	  }
	  solveX(y) {
	    return this.solveX2(y).redSqrt();
	  }
	  solveY2(x) {
	    throw new Error('Not implemented.');
	  }
	  solveY(x) {
	    return this.solveY2(x).redSqrt();
	  }
	  validate(point) {
	    throw new Error('Not implemented.');
	  }
	  pointFromX(x, sign) {
	    throw new Error('Not implemented.');
	  }
	  pointFromY(y, sign) {
	    throw new Error('Not implemented.');
	  }
	  isIsomorphic(curve) {
	    throw new Error('Not implemented.');
	  }
	  isIsogenous(curve) {
	    throw new Error('Not implemented.');
	  }
	  pointFromShort(point) {
	    throw new Error('Not implemented.');
	  }
	  pointFromMont(point, sign) {
	    throw new Error('Not implemented.');
	  }
	  pointFromEdwards(point) {
	    throw new Error('Not implemented.');
	  }
	  pointFromUniform(u) {
	    throw new Error('Not implemented.');
	  }
	  pointToUniform(p) {
	    throw new Error('Not implemented.');
	  }
	  pointFromHash(bytes, pake = false) {
	    // [H2EC] "Roadmap".
	    assert(Buffer.isBuffer(bytes));
	    assert(typeof pake === 'boolean');
	    if (bytes.length !== this.fieldSize * 2) throw new Error('Invalid hash size.');

	    // Random oracle encoding.
	    // Ensure a proper distribution.
	    const s1 = bytes.slice(0, this.fieldSize);
	    const s2 = bytes.slice(this.fieldSize);
	    const u1 = this.decodeUniform(s1);
	    const u2 = this.decodeUniform(s2);
	    const p1 = this.pointFromUniform(u1);
	    const p2 = this.pointFromUniform(u2);
	    const p3 = p1.add(p2);
	    return pake ? p3.mulH() : p3;
	  }
	  pointToHash(p, subgroup, rng) {
	    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
	    assert(p instanceof this.Point);
	    assert(subgroup >>> 0 === subgroup);

	    // Add a random torsion component.
	    const i = subgroup % this.torsion.length;
	    const p0 = p.add(this.torsion[i]);

	    // Average Cost (R = sqrt):
	    //
	    //   SSWU (~4 iterations) => 8I + 16R
	    //   SVDW (~4 iterations) => 12I + 28R
	    //   Elligator 1 (~2 iterations) => 6I + 10R
	    //   Elligator 2 (~2 iterations) => 4I + 6R
	    //   Ristretto (~1 iteration) => 1I + 2R + h*1R
	    for (;;) {
	      const u1 = this.randomField(rng);
	      const p1 = this.pointFromUniform(u1);

	      // Avoid 2-torsion points:
	      //   Short Weierstrass: ((A / 3) / B, 0)
	      //   Montgomery: (0, 0)
	      //   Twisted Edwards: (0, -1)
	      if (p1.neg().eq(p1)) continue;
	      const p2 = p0.sub(p1);
	      const hint = randomInt(rng);
	      let u2;
	      try {
	        u2 = this.pointToUniform(p2, hint & 15);
	      } catch (e) {
	        if (e.message === 'Invalid point.') continue;
	        throw e;
	      }
	      const s1 = this.encodeUniform(u1, hint >>> 8);
	      const s2 = this.encodeUniform(u2, hint >>> 16);
	      return Buffer.concat([s1, s2]);
	    }
	  }
	  randomScalar(rng) {
	    const max = this.n.isZero() ? this.p : this.n;
	    return BN.random(rng, 1, max);
	  }
	  randomField(rng) {
	    return BN.random(rng, 1, this.p).toRed(this.red);
	  }
	  randomPoint(rng) {
	    let p;
	    for (;;) {
	      const x = this.randomField(rng);
	      const sign = (randomInt(rng) & 1) !== 0;
	      try {
	        p = this.pointFromX(x, sign);
	      } catch (e) {
	        continue;
	      }
	      assert(p.validate());
	      return p.mulH();
	    }
	  }
	  mulAll(points, coeffs) {
	    return this.jmulAll(points, coeffs);
	  }
	  jmulAll(points, coeffs) {
	    assert(Array.isArray(points));
	    assert(points.length === 0 || points[0] instanceof Point);

	    // Multiply with endomorphism if we're using affine points.
	    if (this.endo && points.length > 0 && points[0].type === types.AFFINE) return this._endoWnafMulAdd(points, coeffs);

	    // Otherwise, a regular Shamir's trick.
	    return this._wnafMulAdd(5, points, coeffs);
	  }
	  mulH(k) {
	    assert(k instanceof BN);
	    return this.imulH(k.clone());
	  }
	  imulH(k) {
	    assert(k instanceof BN);
	    assert(!k.red);
	    const word = this.h.word(0);

	    // Optimize for powers of two.
	    if ((word & word - 1) === 0) {
	      const bits = this.h.bitLength();
	      return k.iushln(bits - 1).imod(this.n);
	    }
	    return k.imuln(word).imod(this.n);
	  }
	  normalizeAll(points) {
	    assert(Array.isArray(points));
	    const len = points.length;
	    const z = new Array(len);
	    for (let i = 0; i < len; i++) {
	      const p = points[i];
	      assert(p instanceof Point);
	      assert(p.curve === this);
	      if (p.type === types.AFFINE) {
	        z[i] = this.one;
	        continue;
	      }
	      z[i] = p.z;
	    }
	    const zi = this.red.invertAll(z);
	    const out = new Array(len);
	    for (let i = 0; i < len; i++) out[i] = points[i].scale(zi[i]);
	    return out;
	  }
	  affinizeAll(points) {
	    return this.normalizeAll(points);
	  }
	  clamp(scalar) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    assert(Buffer.isBuffer(scalar));
	    assert(scalar.length === this.scalarSize);
	    assert(this.scalarSize <= this.fieldSize);
	    let top = this.fieldBits & 7 || 8;
	    let lsb = 0;
	    let msb = this.scalarSize - 1;

	    // Swap endianness.
	    if (this.endian === 'be') [lsb, msb] = [msb, lsb];

	    // Adjust for low order.
	    if (this.scalarSize < this.fieldSize) top = 8;

	    // Ensure a multiple of the cofactor.
	    scalar[lsb] &= -this.h.word(0) & 0xff;

	    // Clamp to the prime.
	    scalar[msb] &= (1 << top) - 1;

	    // Set the high bit.
	    scalar[msb] |= 1 << top - 1;
	    return scalar;
	  }
	  splitHash(bytes) {
	    // [RFC8032] Section 5.1.6 & 5.2.6.
	    assert(Buffer.isBuffer(bytes));
	    assert(bytes.length === this.adjustedSize * 2);
	    assert(this.scalarSize <= this.adjustedSize);
	    let off = 0;
	    if (this.endian === 'be') off = this.adjustedSize - this.scalarSize;
	    const scalar = bytes.slice(off, off + this.scalarSize);
	    const prefix = bytes.slice(this.adjustedSize);
	    this.clamp(scalar);
	    return [scalar, prefix];
	  }
	  encodeField(x) {
	    // [SEC1] Page 12, Section 2.3.5.
	    assert(x instanceof BN);
	    assert(!x.red);
	    return x.encode(this.endian, this.fieldSize);
	  }
	  decodeField(bytes) {
	    // [SEC1] Page 13, Section 2.3.6.
	    assert(Buffer.isBuffer(bytes));
	    if (bytes.length !== this.fieldSize) throw new Error('Invalid field element size.');
	    return BN.decode(bytes, this.endian);
	  }
	  encodeAdjusted(x) {
	    assert(x instanceof BN);
	    assert(!x.red);
	    return x.encode(this.endian, this.adjustedSize);
	  }
	  decodeAdjusted(bytes) {
	    assert(Buffer.isBuffer(bytes));
	    if (bytes.length !== this.adjustedSize) throw new Error('Invalid field element size.');
	    return BN.decode(bytes, this.endian);
	  }
	  encodeScalar(k) {
	    // [SEC1] Page 13, Section 2.3.7.
	    assert(k instanceof BN);
	    assert(!k.red);
	    return k.encode(this.endian, this.scalarSize);
	  }
	  decodeScalar(bytes) {
	    // [SEC1] Page 14, Section 2.3.8.
	    assert(Buffer.isBuffer(bytes));
	    if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');
	    return BN.decode(bytes, this.endian);
	  }
	  encodeClamped(k) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    return this.clamp(this.encodeScalar(k));
	  }
	  decodeClamped(bytes) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    assert(Buffer.isBuffer(bytes));
	    if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');
	    const clamped = this.clamp(Buffer.from(bytes));
	    return BN.decode(clamped, this.endian);
	  }
	  encodeUniform(x, bits) {
	    assert(x instanceof BN);
	    assert(bits >>> 0 === bits);
	    const msb = this.endian === 'le' ? this.fieldSize - 1 : 0;
	    const bytes = x.fromRed().encode(this.endian, this.fieldSize);
	    bytes[msb] |= bits & ~this.mask & 0xff;
	    return bytes;
	  }
	  decodeUniform(bytes) {
	    assert(Buffer.isBuffer(bytes));
	    if (bytes.length !== this.fieldSize) throw new Error('Invalid field size.');
	    const x = BN.decode(bytes, this.endian);
	    x.iumaskn(this.fieldBits);
	    return x.toRed(this.red);
	  }
	  encodePoint(point, compact) {
	    assert(point instanceof Point);
	    return point.encode(compact);
	  }
	  decodePoint(bytes) {
	    throw new Error('Not implemented.');
	  }
	  encodeX(point) {
	    throw new Error('Not implemented.');
	  }
	  decodeX(bytes) {
	    throw new Error('Not implemented.');
	  }
	  decodeEven(bytes) {
	    throw new Error('Not implemented.');
	  }
	  decodeSquare(bytes) {
	    throw new Error('Not implemented.');
	  }
	  toShort() {
	    throw new Error('Not implemented.');
	  }
	  toMont(b0) {
	    throw new Error('Not implemented.');
	  }
	  toEdwards(a0) {
	    throw new Error('Not implemented.');
	  }
	  pointToJSON(point, pre) {
	    assert(point instanceof Point);
	    return point.toJSON(pre);
	  }
	  pointFromJSON(json) {
	    throw new Error('Not implemented.');
	  }
	  toJSON(pre) {
	    let prefix, context;
	    let n, z, endo;
	    if (this.type === 'edwards') {
	      prefix = this.prefix ? this.prefix.toString() : null;
	      context = this.context;
	    }
	    if (!this.n.isZero()) n = this.n.toJSON();
	    if (!this.z.isZero()) {
	      z = this.z.fromRed();
	      if (this.z.redIsHigh()) z.isub(this.p);
	      z = z.toString(16);
	    }
	    if (this.endo) endo = this.endo.toJSON();
	    return {
	      id: this.id,
	      ossl: this.ossl,
	      type: this.type,
	      endian: this.endian,
	      hash: this.hash,
	      prefix,
	      context,
	      prime: this.prime,
	      p: this.p.toJSON(),
	      a: undefined,
	      b: undefined,
	      d: undefined,
	      n,
	      h: this.h.toString(16),
	      s: undefined,
	      z,
	      c: undefined,
	      g: this.g.toJSON(pre),
	      endo
	    };
	  }
	  static fromJSON(json) {
	    return new this(json);
	  }
	}

	/**
	 * Point
	 */

	class Point {
	  constructor(curve, type) {
	    assert(curve instanceof Curve);
	    assert(type >>> 0 === type);
	    this.curve = curve;
	    this.type = type;
	    this.pre = null;
	  }
	  _init() {
	    throw new Error('Not implemented.');
	  }
	  _safeNAF(width) {
	    assert(width >>> 0 === width);
	    if (this.pre && this.pre.naf) return this.pre.naf;
	    if (width === 0) return null;
	    const size = 1 << width - 2;
	    const points = new Array(size);
	    const p = this.toJ();
	    const dbl = size === 1 ? null : p.dbl();
	    points[0] = p;
	    for (let i = 1; i < size; i++) points[i] = points[i - 1].add(dbl);
	    return new NAF(width, points);
	  }
	  _getNAF(width) {
	    assert(width >>> 0 === width);
	    if (this.pre && this.pre.naf) return this.pre.naf;
	    if (width === 0) return null;
	    const odds = this._safeNAF(width).points;
	    const points = this.curve.affinizeAll(odds);
	    return new NAF(width, points);
	  }
	  _getWindows(width, bits) {
	    assert(width >>> 0 === width);
	    assert(bits >>> 0 === bits);
	    if (this.pre && this.pre.windows) return this.pre.windows;
	    if (width === 0) return null;
	    const size = 1 << width;
	    const steps = (bits + width - 1) / width >>> 0;
	    const wnds = new Array(steps * size);
	    let g = this.toJ();
	    for (let i = 0; i < steps; i++) {
	      wnds[i * size] = this.curve.jpoint();
	      for (let j = 1; j < size; j++) wnds[i * size + j] = wnds[i * size + j - 1].add(g);
	      g = g.dblp(width);
	    }
	    const points = this.curve.affinizeAll(wnds);
	    return new Windows(width, bits, points);
	  }
	  _getDoubles(step, power) {
	    assert(step >>> 0 === step);
	    assert(power >>> 0 === power);
	    if (this.pre && this.pre.doubles) return this.pre.doubles;
	    if (step === 0) return null;
	    const len = Math.ceil(power / step) + 1;
	    const dbls = new Array(len);
	    let acc = this.toJ();
	    let k = 0;
	    dbls[k++] = acc;
	    for (let i = 0; i < power; i += step) {
	      for (let j = 0; j < step; j++) acc = acc.dbl();
	      dbls[k++] = acc;
	    }
	    assert(k === len);
	    const points = this.curve.affinizeAll(dbls);
	    return new Doubles(step, points);
	  }
	  _getBeta() {
	    return null;
	  }
	  _getBlinding(rng) {
	    if (this.pre && this.pre.blinding) return this.pre.blinding;
	    if (!rng) return null;
	    if (this.curve.n.isZero()) return null;

	    // Pregenerate a random blinding value:
	    //
	    //   blind = random integer in [1,n-1]
	    //   unblind = G * blind
	    //
	    // We intend to subtract the blinding value
	    // from scalars before multiplication. We
	    // can add the unblinding point once the
	    // multiplication is complete.
	    const blind = this.curve.randomScalar(rng);
	    const unblind = this.mul(blind);
	    return new Blinding(blind, unblind);
	  }
	  _hasWindows(k) {
	    assert(k instanceof BN);
	    if (!this.pre || !this.pre.windows) return false;
	    const {
	      width,
	      bits
	    } = this.pre.windows;
	    const steps = (bits + width - 1) / width >>> 0;
	    return k.bitLength() <= steps * width;
	  }
	  _hasDoubles(k) {
	    assert(k instanceof BN);
	    if (!this.pre || !this.pre.doubles) return false;
	    const {
	      step,
	      points
	    } = this.pre.doubles;
	    const power = k.bitLength() + 1;
	    return points.length >= Math.ceil(power / step) + 1;
	  }
	  _getJNAF(point) {
	    assert(point instanceof Point);
	    assert(point.type === this.type);

	    // Create comb for JSF.
	    return [this,
	    // 1
	    this.add(point),
	    // 3
	    this.sub(point),
	    // 5
	    point // 7
	    ];
	  }
	  _blind(k, rng) {
	    // [SIDE1] Page 5, Section 4.
	    // [BLIND] Page 20, Section 7.
	    assert(k instanceof BN);
	    assert(!k.red);

	    // Scalar splitting (requires precomputation).
	    //
	    // Blind a multiplication by first subtracting
	    // a blinding value from the scalar. Example:
	    //
	    //   b = random integer in [1,n-1]
	    //   B = P * b (precomputed)
	    //   Q = P * (k - b) + B
	    //
	    // Note that Joye describes a different method
	    // (multiplier randomization) which computes:
	    //
	    //   B = random point in E
	    //   Q = (P + B) * k - B * k
	    //
	    // Our method is more similar to the "scalar
	    // splitting" technique described in the
	    // second source above.
	    //
	    // The blinding value and its corresponding
	    // point are randomly generated and computed
	    // on boot. As long as an attacker is not
	    // able to observe the boot, this should give
	    // a decent bit of protection against various
	    // channel attacks.
	    if (this.pre && this.pre.blinding) {
	      const {
	        blind,
	        unblind
	      } = this.pre.blinding;
	      const t = k.sub(blind);
	      return [this, t, unblind];
	    }

	    // Randomization is not possible without
	    // an RNG. Do a normal multiplication.
	    if (!rng) return [this, k, null];

	    // If we have no precomputed blinding
	    // factor, there are two possibilities
	    // for randomization:
	    //
	    // 1. Randomize the multiplier by adding
	    //    a random multiple of `n`.
	    //
	    // 2. Re-scale the point itself by a
	    //    random factor.
	    //
	    // The first option can be accomplished
	    // with some like:
	    //
	    //   a = random integer in [1,n-1]
	    //   r = a * n
	    //   Q = P * (k + r)
	    //
	    // The second is accomplished with:
	    //
	    //   a = random element in F(p)
	    //   R = (x * a^2, y * a^3, z * a)
	    //   Q = R * k
	    //
	    // If we have precomputed doubles / naf
	    // points, we opt for the first method
	    // to avoid randomizing everything.
	    if (this.pre) {
	      if (this.curve.n.isZero()) return [this, k, null];
	      const a = this.curve.randomScalar(rng);
	      const r = a.mul(this.curve.n);
	      const t = r.iadd(k);
	      return [this, t, null];
	    }

	    // If there is no precomputation _at all_,
	    // we opt for the second method.
	    const p = this.randomize(rng);
	    return [p, k, null];
	  }
	  clone() {
	    throw new Error('Not implemented.');
	  }
	  precompute(bits, rng) {
	    assert(bits >>> 0 === bits);
	    if (!this.pre) this.pre = new Precomp();
	    if (!this.pre.naf) this.pre.naf = this._getNAF(9);
	    if (!this.pre.doubles) this.pre.doubles = this._getDoubles(4, bits + 1);
	    if (!this.pre.beta) this.pre.beta = this._getBeta();
	    if (!this.pre.blinding) this.pre.blinding = this._getBlinding(rng);
	    return this;
	  }
	  validate() {
	    return this.curve.validate(this);
	  }
	  normalize() {
	    return this;
	  }
	  scale(a) {
	    throw new Error('Not implemented.');
	  }
	  randomize(rng) {
	    const z = this.curve.randomField(rng);
	    return this.scale(z);
	  }
	  neg() {
	    throw new Error('Not implemented.');
	  }
	  add(point) {
	    throw new Error('Not implemented.');
	  }
	  sub(point) {
	    assert(point instanceof Point);
	    return this.add(point.neg());
	  }
	  dbl() {
	    throw new Error('Not implemented.');
	  }
	  dblp(pow) {
	    // Repeated doubling. This can
	    // be optimized by child classes.
	    assert(pow >>> 0 === pow);
	    let r = this;
	    for (let i = 0; i < pow; i++) r = r.dbl();
	    return r;
	  }
	  diffAddDbl(p, q) {
	    throw new Error('Not implemented.');
	  }
	  getX() {
	    throw new Error('Not implemented.');
	  }
	  getY() {
	    throw new Error('Not implemented.');
	  }
	  eq(point) {
	    throw new Error('Not implemented.');
	  }
	  cmp(point) {
	    throw new Error('Not implemented.');
	  }
	  isInfinity() {
	    throw new Error('Not implemented.');
	  }
	  isOrder2() {
	    throw new Error('Not implemented.');
	  }
	  isOdd() {
	    throw new Error('Not implemented.');
	  }
	  isEven() {
	    throw new Error('Not implemented.');
	  }
	  isSquare() {
	    throw new Error('Not implemented.');
	  }
	  eqX(x) {
	    throw new Error('Not implemented.');
	  }
	  eqR(x) {
	    throw new Error('Not implemented.');
	  }
	  isSmall() {
	    // Test whether the point is of small order.
	    if (this.isInfinity()) return false;

	    // P * h = O
	    return this.jmulH().isInfinity();
	  }
	  hasTorsion() {
	    // Test whether the point is in another subgroup.
	    if (this.isInfinity()) return false;

	    // P * n != O
	    return !this.jmul(this.curve.n).isInfinity();
	  }
	  order() {
	    // Calculate point order.
	    const {
	      h,
	      n
	    } = this.curve;
	    let p = this.toJ();
	    let q = new BN(1);
	    while (!p.isInfinity()) {
	      q.iaddn(1);
	      if (q.cmp(h) > 0) {
	        q = n.clone();
	        break;
	      }
	      p = p.add(this);
	    }
	    return q;
	  }
	  mul(k) {
	    return this.jmul(k);
	  }
	  muln(k) {
	    return this.jmuln(k);
	  }
	  mulBlind(k, rng) {
	    return this.jmulBlind(k, rng);
	  }
	  mulAdd(k1, p2, k2) {
	    return this.jmulAdd(k1, p2, k2);
	  }
	  mulH() {
	    return this.jmulH();
	  }
	  div(k) {
	    return this.jdiv(k);
	  }
	  divn(k) {
	    return this.jdivn(k);
	  }
	  divH() {
	    return this.jdivH();
	  }
	  jmul(k) {
	    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
	    if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this], [k]);
	    return this.curve._wnafMul(5, this, k);
	  }
	  jmuln(k) {
	    assert((k | 0) === k);
	    return this.jmul(new BN(k));
	  }
	  jmulBlind(k, rng = null) {
	    const [p, t, unblind] = this._blind(k, rng);
	    const q = p.jmul(t);
	    if (unblind) return q.add(unblind);
	    return q;
	  }
	  jmulAdd(k1, p2, k2) {
	    if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);
	    return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);
	  }
	  jmulH() {
	    const word = this.curve.h.word(0);

	    // Optimize for powers of two.
	    if ((word & word - 1) === 0) {
	      const bits = this.curve.h.bitLength();
	      return this.toJ().dblp(bits - 1);
	    }
	    return this.jmul(this.curve.h);
	  }
	  jdiv(k) {
	    assert(k instanceof BN);
	    assert(!k.red);
	    return this.jmul(k.invert(this.curve.n));
	  }
	  jdivn(k) {
	    assert(!this.curve.n.isZero());
	    if (this.curve.h.cmpn(k) === 0) return this.jdivH();
	    return this.jdiv(new BN(k));
	  }
	  jdivH() {
	    if (this.curve.n.isZero()) return this.toJ();
	    if (this.curve.h.cmpn(1) === 0) return this.toJ();
	    if (this.curve.hi === null) this.curve.hi = this.curve.h.invert(this.curve.n);
	    return this.jmul(this.curve.hi);
	  }
	  toP() {
	    return this.normalize();
	  }
	  toJ() {
	    return this;
	  }
	  toX() {
	    return this;
	  }
	  key() {
	    if (this.isInfinity()) return `${this.curve.uid}:oo`;
	    this.normalize();
	    const x = this.getX().toString(16);
	    const y = this.getY().toString(16);
	    return `${this.curve.uid}:${x},${y}`;
	  }
	  encode(compact) {
	    throw new Error('Not implemented.');
	  }
	  static decode(curve, bytes) {
	    throw new Error('Not implemented.');
	  }
	  encodeX() {
	    throw new Error('Not implemented.');
	  }
	  static decodeX(curve, bytes) {
	    throw new Error('Not implemented.');
	  }
	  static decodeEven(curve, bytes) {
	    throw new Error('Not implemented.');
	  }
	  static decodeSquare(curve, bytes) {
	    throw new Error('Not implemented.');
	  }
	  toJSON(pre) {
	    throw new Error('Not implemented.');
	  }
	  static fromJSON(curve, json) {
	    throw new Error('Not implemented.');
	  }
	  [custom]() {
	    return '<Point>';
	  }
	}

	/**
	 * ShortCurve
	 */

	class ShortCurve extends Curve {
	  constructor(conf) {
	    super(ShortPoint, 'short', conf);
	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.b = BN.fromJSON(conf.b).toRed(this.red);
	    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);
	    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();
	    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();
	    this.zeroA = this.a.isZero();
	    this.threeA = this.a.eq(this.three.redNeg());
	    this.redN = this.n.toRed(this.red);
	    this.pmodn = this.p.clone();
	    this.highOrder = this.n.cmp(this.p) >= 0;
	    this.smallGap = false;
	    this._finalize(conf);
	  }
	  _finalize(conf) {
	    super._finalize(conf);

	    // Precalculate endomorphism.
	    if (conf.endo != null) this.endo = Endo.fromJSON(this, conf.endo);else this.endo = this._getEndomorphism();
	    if (!this.n.isZero()) {
	      this.pmodn = this.p.mod(this.n);

	      // Check for Maxwell's trick (see eqR).
	      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;
	    }
	    return this;
	  }
	  static _isomorphism(curveA, curveB, custom, odd) {
	    // Short Weierstrass Isomorphism.
	    //
	    // [GECC] Page 84, Section 3.1.5.
	    // [ARITH1] Page 274, Section 13.1.5.
	    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
	    //
	    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.
	    //
	    // Transformation:
	    //
	    //   u4 = a' / a
	    //   u2 = +-sqrt(u4)
	    //   u6 = u4 * u2
	    //   a' = a * u4
	    //   b' = b * u6
	    //
	    // Where `u2` is any root that is square.
	    //
	    // If a = 0, we can do:
	    //
	    //   a' = 0
	    //   b' = b'
	    //
	    // Where (b' / b)^(1 / 3) is square.
	    //
	    // If b = 0, we can do:
	    //
	    //   a' = a'
	    //   b' = 0
	    //
	    // Where sqrt(a' / a) is square.
	    assert(curveA instanceof BN);
	    assert(curveB instanceof BN);
	    assert(custom instanceof BN);
	    assert(odd == null || typeof odd === 'boolean');
	    assert(!curveA.isZero() || !curveB.isZero());
	    if (custom.isZero()) throw new Error('Invalid coefficient.');
	    if (curveA.isZero()) {
	      const customB = custom;
	      const u6 = customB.redDiv(curveB);
	      // Todo: allow index flag.
	      const u2 = uncube(u6);

	      // Already checked in uncube().
	      assert(u2.redJacobi() === 1);
	      return [curveA.clone(), customB.clone()];
	    }
	    if (curveB.isZero()) {
	      const customA = custom;
	      const u4 = customA.redDiv(curveA);
	      const u2 = u4.redSqrt();

	      // Todo: allow odd flag.
	      if (u2.redJacobi() !== 1) u2.redINeg();
	      if (u2.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
	      return [customA.clone(), curveB.clone()];
	    }
	    const customA = custom;
	    const u4 = customA.redDiv(curveA);
	    const u2 = u4.redSqrt();
	    if (odd != null) {
	      if (u2.redIsOdd() !== odd) u2.redINeg();
	    } else {
	      if (u2.redJacobi() !== 1) u2.redINeg();
	    }
	    if (u2.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
	    const u6 = u4.redMul(u2);
	    const a = curveA.redMul(u4);
	    const b = curveB.redMul(u6);
	    assert(a.eq(customA));
	    return [a, b];
	  }
	  _short(a0, odd) {
	    return ShortCurve._isomorphism(this.a, this.b, a0, odd);
	  }
	  _mont(b0, odd) {
	    // Short Weierstrass->Montgomery Equivalence.
	    //
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    // [SAFE] "Ladders".
	    //
	    // Transformation:
	    //
	    //   r = A / (3 * B)
	    //   s = +-sqrt(3 * r^2 + a)
	    //   A = 3 * r / s
	    //   B = 1 / s
	    const [r, s] = this._findRS(odd);
	    const b = s.redInvert();
	    const a = r.redMuln(3).redMul(b);
	    if (b0 != null) return MontCurve._isomorphism(a, b, b0);
	    return [a, b];
	  }
	  _edwards(a0, odd) {
	    // Short Weierstrass->Twisted Edwards Equivalence.
	    //
	    // [TWISTEQ] Section 1.
	    //
	    // Transformation:
	    //
	    //   r = (a' + d') / 6
	    //   s = +-sqrt(3 * r^2 + a)
	    //   a' = 3 * r + 2 * s
	    //   d' = 3 * r - 2 * s
	    const [r, s] = this._findRS(odd);
	    const r3 = r.redMuln(3);
	    const s2 = s.redMuln(2);
	    const a = r3.redAdd(s2);
	    const d = r3.redSub(s2);
	    if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);
	    return [a, d];
	  }
	  _findRS(sign) {
	    // Find `r` and `s` for equivalence.
	    //
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    // [SAFE] "Ladders".
	    //
	    // Computation:
	    //
	    //   r = solve(r^3 + a * r + b == 0, r)
	    //   s = +-sqrt(3 * r^2 + a)
	    //
	    // Computing `r` is non-trivial. We need
	    // to solve `r^3 + a * r + b = 0`, but we
	    // don't have a polynomial solver, so we
	    // loop over random points until we find
	    // one with 2-torsion. Multiplying by the
	    // subgroup order should yield a point of
	    // ((A / 3) / B, 0) which is a solution.
	    assert(sign == null || typeof sign === 'boolean');
	    assert(this.h.word(0) >= 4);
	    assert(!this.n.isZero());
	    const x = this.one.redNeg();
	    let p;
	    for (;;) {
	      x.redIAdd(this.one);
	      try {
	        p = this.pointFromX(x.clone());
	      } catch (e) {
	        continue;
	      }
	      p = p.mul(this.n);
	      if (p.isInfinity()) continue;
	      if (!p.y.isZero()) continue;
	      break;
	    }
	    const r = p.x;
	    const r2 = r.redSqr();
	    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();
	    if (sign != null) {
	      if (s.redIsOdd() !== sign) s.redINeg();
	    }
	    return [r, s];
	  }
	  _scale0(a, b) {
	    // We can extract the isomorphism factors with:
	    //
	    //   u4 = a' / a
	    //   u6 = b' / b
	    //   u2 = +-sqrt(u4)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // `u2` should be picked such that `u4 * u2 = u6`.
	    //
	    // If a = 0, we can do:
	    //
	    //   u6 = b' / b
	    //   u2 = u6^(1 / 3)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // Where `u2` is any root that is square.
	    //
	    // If b = 0, we can do:
	    //
	    //   u4 = a' / a
	    //   u2 = +-sqrt(u4)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // Where `u2` is any root that is square.
	    assert(this.a.isZero() === a.isZero());
	    assert(this.b.isZero() === b.isZero());
	    if (this.a.isZero()) {
	      const u6 = this.b.redDiv(this.field(b));
	      // Todo: figure out how to check index.
	      const u2 = uncube(u6);
	      const u = u2.redSqrt();
	      const u3 = u2.redMul(u);
	      assert(u3.redSqr().eq(u6));
	      assert(!u.isZero());
	      return [u2, u3];
	    }
	    if (this.b.isZero()) {
	      const u4 = this.a.redDiv(this.field(a));
	      const u2 = u4.redSqrt();

	      // Todo: figure out how to check oddness.
	      if (u2.redJacobi() !== 1) u2.redINeg();
	      const u = u2.redSqrt();
	      const u3 = u2.redMul(u);
	      assert(u3.redMul(u).eq(u4));
	      assert(!u.isZero());
	      return [u2, u3];
	    }
	    const u4 = this.a.redDiv(this.field(a));
	    const u6 = this.b.redDiv(this.field(b));
	    const u2 = u4.redSqrt();
	    if (!u4.redMul(u2).eq(u6)) u2.redINeg();
	    assert(u4.redMul(u2).eq(u6));
	    const u = u2.redSqrt();
	    const u3 = u2.redMul(u);
	    assert(!u.isZero());
	    return [u2, u3];
	  }
	  _scale1(x, y) {
	    // If base points are available, it is much
	    // easier, with:
	    //
	    //   u2 = x' / x
	    //   u3 = y' / y
	    //   u = +-sqrt(u2)
	    //
	    // `u` should be picked such that `u2 * u = u3`.
	    const u2 = this.g.x.redDiv(this.field(x));
	    const u3 = this.g.y.redDiv(this.field(y));
	    const u = u2.redSqrt();
	    if (!u2.redMul(u).eq(u3)) u.redINeg();
	    assert(u2.redMul(u).eq(u3));
	    assert(!u.isZero());
	    return [u2, u3];
	  }
	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);
	    if (this.g.isInfinity() || curve.g.isInfinity()) return this._scale0(curve.a, curve.b);
	    return this._scale1(curve.g.x, curve.g.y);
	  }
	  _scaleMont(curve) {
	    assert(curve instanceof MontCurve);
	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a, b] = curve._short();
	      return this._scale0(a, b);
	    }
	    const {
	      x,
	      y
	    } = curve.g;
	    const nx = x.redAdd(curve.a3).redMul(curve.bi);
	    const ny = y.redMul(curve.bi);
	    return this._scale1(nx, ny);
	  }
	  _scaleEdwards(curve) {
	    assert(curve instanceof EdwardsCurve);
	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a, b] = curve._short();
	      return this._scale0(a, b);
	    }
	    const {
	      x,
	      y,
	      z
	    } = curve.g;
	    const a5 = curve.a.redMuln(5);
	    const d5 = curve.d.redMuln(5);
	    const dma = curve.d.redSub(curve.a);
	    const d5a = d5.redSub(curve.a);
	    const da5 = curve.d.redSub(a5);
	    const ypz = y.redAdd(z);
	    const ymz = y.redSub(z);
	    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
	    const xz = ymz.redMuln(12);
	    const yy = dma.redMul(ypz).redMul(z);
	    const yz = ymz.redMul(x).redIMuln(4);
	    const zi = xz.redMul(yz).redInvert();
	    const nx = xx.redMul(yz).redMul(zi);
	    const ny = yy.redMul(xz).redMul(zi);
	    return this._scale1(nx, ny);
	  }
	  _getEndomorphism(index = 0) {
	    // Compute endomorphism.
	    //
	    // [GECC] Example 3.76, Page 128, Section 3.5.

	    // No curve params.
	    if (this.n.isZero() || this.g.isInfinity()) return null;

	    // No efficient endomorphism.
	    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1) return null;

	    // Solve beta^3 mod p = 1.
	    const [b1, b2] = this._getEndoRoots(this.p);

	    // Choose the smallest beta by default.
	    const beta = [b1, b2][index & 1].toRed(this.red);

	    // Solve lambda^3 mod n = 1.
	    const [l1, l2] = this._getEndoRoots(this.n);

	    // Choose the lambda matching selected beta.
	    // Note that P * lambda = (x * beta, y).
	    const p = this.point(this.g.x.redMul(beta), this.g.y);
	    let lambda;
	    if (this.g.mul(l1).eq(p)) {
	      lambda = l1;
	    } else {
	      assert(this.g.mul(l2).eq(p));
	      lambda = l2;
	    }

	    // Get basis vectors.
	    const basis = this._getEndoBasis(lambda);

	    // Precompute `g1` and `g2`.
	    const pre = this._getEndoPrecomp(basis);
	    return new Endo(beta, lambda, basis, pre);
	  }
	  _getEndoRoots(num) {
	    // Find roots for x^2 + x + 1 in F.
	    //
	    // [GECC] Example 3.76, Page 128, Section 3.5.
	    // [GLV] Page 192, Section 2 (Endomorphisms).
	    //
	    // The above document doesn't fully explain how
	    // to derive these and only "hints" at it, as
	    // mentioned by Hal Finney[1], but we're basically
	    // computing two possible cube roots of 1 here.
	    //
	    // Note that we could also compute[2]:
	    //
	    //   beta = 2^((p - 1) / 3) mod p
	    //   lambda = 3^((n - 1) / 3) mod n
	    //
	    // As an extension of Fermat's little theorem:
	    //
	    //   g^(p - 1) mod p == 1
	    //
	    // It is suspected[3] this is how Hal Finney[4]
	    // computed his original endomorphism roots.
	    //
	    // @indutny's method for computing cube roots
	    // of unity[5] appears to be the method described
	    // on wikipedia[6][7].
	    //
	    // Sage produces the same solution:
	    //
	    //   sage: solve(x^2 + x + 1 == 0, x)
	    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]
	    //
	    // This can be reduced to:
	    //
	    //   x = (+-sqrt(-3) - 1) / 2
	    //
	    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565
	    // [2] https://crypto.stackexchange.com/a/22739
	    // [3] https://bitcoin.stackexchange.com/a/35872
	    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5
	    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity
	    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example
	    // [7] http://mathworld.wolfram.com/SplittingField.html
	    const red = num === this.p ? this.red : BN.mont(num);
	    const two = new BN(2).toRed(red);
	    const three = new BN(3).toRed(red);
	    const i2 = two.redInvert();

	    // S1 = sqrt(-3) / 2
	    const s1 = three.redNeg().redSqrt().redMul(i2);

	    // S2 = -S1
	    const s2 = s1.redNeg();

	    // R1 = S1 - 1 / 2
	    const r1 = s1.redSub(i2).fromRed();

	    // R2 = S2 - 1 / 2
	    const r2 = s2.redSub(i2).fromRed();
	    return [r1, r2].sort(BN.cmp);
	  }
	  _getEndoBasis(lambda) {
	    // Compute endomorphic basis.
	    //
	    // This essentially computes Cornacchia's algorithm
	    // for solving x^2 + d * y^2 = m (d = lambda, m = order).
	    //
	    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm
	    //
	    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
	    // [GLV] Page 196, Section 4 (Decomposing K).
	    //
	    // Balanced length-two representation of a multiplier.
	    //
	    // 1. Run the extended euclidean algorithm with inputs n
	    //    and lambda. The algorithm produces a sequence of
	    //    equations si*n + ti*lam = ri where s0=1, t0=0,
	    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri
	    //    and are non-negative and strictly decreasing. Let
	    //    l be the greatest index for which rl >= sqrt(n).
	    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);

	    // 2. Set (a1, b1) <- (rl+1, -tl+1).
	    const a1 = rl1;
	    const b1 = tl1.neg();

	    // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)
	    //    then set (a2, b2) <- (rl, -tl).
	    //    else set (a2, b2) <- (rl+2, -tl+2).
	    const lhs = rl.sqr().iadd(tl.sqr());
	    const rhs = rl2.sqr().iadd(tl2.sqr());
	    let a2, b2;
	    if (lhs.cmp(rhs) <= 0) {
	      a2 = rl;
	      b2 = tl.neg();
	    } else {
	      a2 = rl2;
	      b2 = tl2.neg();
	    }
	    return [new Vector(a1, b1), new Vector(a2, b2)];
	  }
	  _egcdSqrt(lambda) {
	    // Extended Euclidean algorithm for integers.
	    //
	    // [GECC] Algorithm 2.19, Page 40, Section 2.2.
	    // [GLV] Page 196, Section 4 (Decomposing K).
	    assert(lambda instanceof BN);
	    assert(!lambda.red);
	    assert(lambda.sign() > 0);
	    assert(this.n.sign() > 0);

	    // Note that we insert the approximate square
	    // root checks as described in algorithm 3.74.
	    //
	    // Algorithm 2.19 is defined as:
	    //
	    // 1. u <- a
	    //    v <- b
	    //
	    // 2. x1 <- 1
	    //    y1 <- 0
	    //    x2 <- 0
	    //    y2 <- 1
	    //
	    // 3. while u != 0 do
	    //
	    // 3.1. q <- floor(v / u)
	    //      r <- v - q * u
	    //      x <- x2 - q * x1
	    //      y <- y2 - q * y1
	    //
	    // 3.2. v <- u
	    //      u <- r
	    //      x2 <- x1
	    //      x1 <- x
	    //      y2 <- y1
	    //      y1 <- y
	    //
	    // 4. d <- v
	    //    x <- x2
	    //    y <- y2
	    //
	    // 5. Return (d, x, y).

	    // Start with an approximate square root of n.
	    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);
	    let u = lambda; // r1
	    let v = this.n.clone(); // r0
	    let x1 = new BN(1); // t1
	    let y1 = new BN(0); // t0
	    let x2 = new BN(0); // s1
	    let y2 = new BN(1); // s0

	    // All vectors are roots of: a + b * lambda = 0 (mod n).
	    let rl, tl;

	    // First vector.
	    let rl1, tl1;

	    // Inner.
	    let i = 0;
	    let j = 0;
	    let p;

	    // Compute EGCD.
	    while (!u.isZero() && i < 2) {
	      const q = v.quo(u);
	      const r = v.sub(q.mul(u));
	      const x = x2.sub(q.mul(x1));
	      const y = y2.sub(q.mul(y1));

	      // Check for r < sqrt(n).
	      if (j === 0 && r.cmp(sqrtn) < 0) {
	        rl = p;
	        tl = x1;
	        rl1 = r;
	        tl1 = x;
	        j = 1; // 1 more round.
	      }
	      p = r;
	      v = u;
	      u = r;
	      x2 = x1;
	      x1 = x;
	      y2 = y1;
	      y1 = y;
	      i += j;
	    }

	    // Should never happen.
	    assert(j !== 0, 'Could not find r < sqrt(n).');

	    // Second vector.
	    const rl2 = x2;
	    const tl2 = x1;
	    return [rl, tl, rl1, tl1, rl2, tl2];
	  }
	  _getEndoPrecomp(basis) {
	    // Precompute `g1` and `g2` to avoid round division.
	    //
	    // [JCEN12] Page 5, Section 4.3.
	    //
	    // Computation:
	    //
	    //   d = a1 * b2 - b1 * a2
	    //   t = ceil(log2(d+1)) + p
	    //   g1 = round((2^t * b2) / d)
	    //   g2 = round((2^t * b1) / d)
	    //
	    // Where:
	    //
	    //   `p` is the number of precision bits.
	    //   `d` is equal to `n` (the curve order).
	    //
	    // The paper above uses 2 as the value of `p`,
	    // whereas libsecp256k1 uses 128 (total=384).
	    //
	    // We pick precision for `g1` and `g2` such that:
	    //
	    //   abs(g1) < n
	    //   abs(g2) < n
	    //
	    // This ensures maximum precision for the constants
	    // while also ensuring they fit into a fixed number
	    // of scalar limbs in more optimized implementations.
	    //
	    // Furthermore, we attempt to align to a limb width
	    // of 64 bits. This allows us to optimize the shift,
	    // a la libsecp256k1[1].
	    //
	    // [1] https://github.com/bitcoin-core/secp256k1/pull/822
	    assert(Array.isArray(basis));
	    assert(basis.length === 2);
	    assert(basis[0] instanceof Vector);
	    assert(basis[1] instanceof Vector);
	    const [v1, v2] = basis;
	    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));
	    const bits = d.bitLength();
	    const align = bits >= 160;
	    assert(d.eq(this.n));

	    // Start with a rough estimate.
	    let shift = bits + Math.ceil(bits / 2) + 1;
	    let g1, g2;
	    if (align) shift -= shift & 63;
	    while (shift > bits) {
	      g1 = v2.b.ushln(shift).divRound(d);
	      g2 = v1.b.ushln(shift).divRound(d);
	      if (g1.ucmp(d) < 0 && g2.ucmp(d) < 0) break;
	      if (align) shift -= 64;else shift -= 1;
	    }
	    if (shift <= bits) throw new Error('Could not calculate g1 and g2.');
	    return [shift, g1, g2];
	  }
	  _endoSplit(k) {
	    // Balanced length-two representation of a multiplier.
	    //
	    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
	    //
	    // Also note that it is possible to precompute[1]
	    // values in order to avoid the division[2][3][4].
	    //
	    // This involves precomputing `g1` and `g2 (see
	    // above). `c1` and `c2` can then be computed as
	    // follows:
	    //
	    //   t = ceil(log2(n+1)) + p
	    //   c1 = (k * g1) >> t
	    //   c2 = -((k * g2) >> t)
	    //
	    // Where `>>` is an _unsigned_ right shift. Also
	    // note that the last bit discarded in the shift
	    // must be stored. If it is 1, then add 1 to the
	    // scalar (absolute addition).
	    //
	    // It's worth noting that libsecp256k1 uses a
	    // different calculation along the lines of:
	    //
	    //   t = ceil(log2(n+1)) + p
	    //   c1 = ((k * g1) >> t) * -b1
	    //   c2 = ((k * -g2) >> t) * -b2
	    //   k2 = c1 + c2
	    //   k1 = k2 * -lambda + k
	    //
	    // So, in the future, we can consider changing
	    // step 4 to:
	    //
	    //   4. Compute c1 = (k * g1) >> t
	    //          and c2 = -((k * g2) >> t).
	    //
	    //   const [shift, g1, g2] = this.endo.pre;
	    //   const c1 = k.mulShift(g1, shift);
	    //   const c2 = k.mulShift(g2, shift).ineg();
	    //
	    // Once we're brave enough, that is.
	    //
	    // [1] [JCEN12] Page 5, Section 4.3.
	    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259
	    // [3] https://github.com/bitcoin-core/secp256k1/pull/21
	    // [4] https://github.com/bitcoin-core/secp256k1/pull/127
	    assert(k instanceof BN);
	    assert(!k.red);
	    assert(!this.n.isZero());
	    const [v1, v2] = this.endo.basis;

	    // 4. Compute c1 = round(b2 * k / n)
	    //        and c2 = round(-b1 * k / n).
	    const c1 = v2.b.mul(k).divRound(this.n);
	    const c2 = v1.b.neg().mul(k).divRound(this.n);

	    // 5. Compute k1 = k - c1 * a1 - c2 * a2
	    //        and k2 = -c1 * b1 - c2 * b2.
	    const p1 = c1.mul(v1.a);
	    const p2 = c2.mul(v2.a);
	    const q1 = c1.ineg().mul(v1.b);
	    const q2 = c2.mul(v2.b);

	    // Calculate answer.
	    const k1 = k.sub(p1).isub(p2);
	    const k2 = q1.isub(q2);

	    // 6. Return (k1, k2).
	    return [k1, k2];
	  }
	  _endoBeta(point) {
	    assert(point instanceof ShortPoint);
	    return [point, point._getBeta()];
	  }
	  _endoWnafMulAdd(points, coeffs) {
	    // Point multiplication with efficiently computable endomorphisms.
	    //
	    // [GECC] Algorithm 3.77, Page 129, Section 3.5.
	    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).
	    //
	    // Note it may be possible to do this 4-dimensionally [4GLV].
	    assert(Array.isArray(points));
	    assert(Array.isArray(coeffs));
	    assert(points.length === coeffs.length);
	    assert(this.endo != null);
	    const len = points.length;
	    const npoints = new Array(len * 2);
	    const ncoeffs = new Array(len * 2);
	    for (let i = 0; i < len; i++) {
	      const [p1, p2] = this._endoBeta(points[i]);
	      const [k1, k2] = this._endoSplit(coeffs[i]);
	      npoints[i * 2 + 0] = p1;
	      ncoeffs[i * 2 + 0] = k1;
	      npoints[i * 2 + 1] = p2;
	      ncoeffs[i * 2 + 1] = k2;
	    }
	    return this._wnafMulAdd(5, npoints, ncoeffs);
	  }
	  _sswu(u) {
	    // Simplified Shallue-Woestijne-Ulas Method.
	    //
	    // Distribution: 3/8.
	    //
	    // [SSWU1] Page 15-16, Section 7. Appendix G.
	    // [SSWU2] Page 5, Theorem 2.3.
	    // [H2EC] "Simplified Shallue-van de Woestijne-Ulas Method".
	    //
	    // Assumptions:
	    //
	    //   - a != 0, b != 0.
	    //   - Let z be a non-square in F(p).
	    //   - z != -1.
	    //   - The polynomial g(x) - z is irreducible over F(p).
	    //   - g(b / (z * a)) is square in F(p).
	    //   - u != 0, u != +-sqrt(-1 / z).
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + a * x + b
	    //   t1 = 1 / (z^2 * u^4 + z * u^2)
	    //   x1 = (-b / a) * (1 + t1)
	    //   x1 = b / (z * a), if t1 = 0
	    //   x2 = z * u^2 * x1
	    //   x = x1, if g(x1) is square
	    //     = x2, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const {
	      b,
	      z,
	      ai,
	      zi,
	      one
	    } = this;
	    const z2 = z.redSqr();
	    const ba = b.redNeg().redMul(ai);
	    const bza = b.redMul(zi).redMul(ai);
	    const u2 = u.redSqr();
	    const u4 = u2.redSqr();
	    const t0 = z2.redMul(u4).redIAdd(z.redMul(u2));
	    const t1 = t0.isZero() ? t0 : t0.redInvert();
	    const x1 = t1.isZero() ? bza : ba.redMul(one.redAdd(t1));
	    const x2 = z.redMul(u2).redMul(x1);
	    const y1 = this.solveY2(x1);
	    const y2 = this.solveY2(x2);
	    const alpha = y1.redIsSquare() | 0;
	    const x = [x1, x2][alpha ^ 1];
	    const y = [y1, y2][alpha ^ 1].redSqrt();
	    if (y.redIsOdd() !== u.redIsOdd()) y.redINeg();
	    return this.point(x, y);
	  }
	  _sswui(p, hint) {
	    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).
	    //
	    // Assumptions:
	    //
	    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).
	    //   - If r < 3 then x != -b / a.
	    //
	    // Unlike SVDW, the preimages here are evenly
	    // distributed (more or less). SSWU covers ~3/8
	    // of the curve points. Each preimage has a 1/2
	    // chance of mapping to either x1 or x2.
	    //
	    // Assuming the point is within that set, each
	    // point has a 1/4 chance of inverting to any
	    // of the preimages. This means we can simply
	    // randomly select a preimage if one exists.
	    //
	    // However, the [SVDW2] sampling method seems
	    // slighly faster in practice for [SQUARED].
	    //
	    // Map:
	    //
	    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)
	    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)
	    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)
	    //   u3 = -(a * x + b - c) / (2 * b * z)
	    //   u4 = -(a * x + b + c) / (2 * b * z)
	    //   r = random integer in [1,4]
	    //   u = sign(y) * abs(sqrt(ur))
	    const {
	      a,
	      b,
	      z
	    } = this;
	    const {
	      x,
	      y
	    } = p;
	    const r = hint & 3;
	    const a2x2 = a.redSqr().redMul(x.redSqr());
	    const abx2 = a.redMul(b).redMul(x).redIMuln(2);
	    const b23 = b.redSqr().redMuln(3);
	    const axb = a.redMul(x).redIAdd(b);
	    const c = a2x2.redISub(abx2).redISub(b23).redSqrt();
	    const n0 = axb.redSub(c).redINeg();
	    const n1 = axb.redAdd(c).redINeg();
	    const d0 = axb.redMul(z).redIMuln(2);
	    const d1 = b.redMul(z).redIMuln(2);
	    const n = [n0, n1][r & 1]; // r = 1 or 3
	    const d = [d0, d1][r >>> 1]; // r = 2 or 3
	    const u = n.redDivSqrt(d);
	    if (u.redIsOdd() !== y.redIsOdd()) u.redINeg();
	    return u;
	  }
	  _svdwf(u) {
	    // Shallue-van de Woestijne Method.
	    //
	    // Distribution: 9/16.
	    //
	    // [SVDW1] Section 5.
	    // [SVDW2] Page 8, Section 3.
	    //         Page 15, Section 6, Algorithm 1.
	    // [H2EC] "Shallue-van de Woestijne Method".
	    //
	    // Assumptions:
	    //
	    //   - p = 1 (mod 3).
	    //   - a = 0, b != 0.
	    //   - Let z be a unique element in F(p).
	    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).
	    //   - u != 0, u != +-sqrt(-g(z)).
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + b
	    //   c = sqrt(-3 * z^2)
	    //   t1 = u^2 + g(z)
	    //   t2 = 1 / (u^2 * t1)
	    //   t3 = u^4 * t2 * c
	    //   x1 = (c - z) / 2 - t3
	    //   x2 = t3 - (c + z) / 2
	    //   x3 = z - t1^3 * t2 / (3 * z^2)
	    //   x = x1, if g(x1) is square
	    //     = x2, if g(x2) is square
	    //     = x3, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const {
	      c,
	      z,
	      zi,
	      i2,
	      i3
	    } = this;
	    const gz = this.solveY2(z);
	    const z3 = i3.redMul(zi.redSqr());
	    const u2 = u.redSqr();
	    const u4 = u2.redSqr();
	    const t1 = u2.redAdd(gz);
	    const u2t1 = u2.redMul(t1);
	    const t2 = u2t1.isZero() ? u2t1 : u2t1.redInvert();
	    const t3 = u4.redMul(t2).redMul(c);
	    const t4 = t1.redSqr().redMul(t1);
	    const x1 = c.redSub(z).redMul(i2).redISub(t3);
	    const x2 = t3.redSub(c.redAdd(z).redMul(i2));
	    const x3 = z.redSub(t4.redMul(t2).redMul(z3));
	    const y1 = this.solveY2(x1);
	    const y2 = this.solveY2(x2);
	    const y3 = this.solveY2(x3);
	    const alpha = y1.redJacobi() | 1;
	    const beta = y2.redJacobi() | 1;
	    const i = mod((alpha - 1) * beta, 3);
	    const x = [x1, x2, x3][i];
	    const y = [y1, y2, y3][i];
	    return [x, y];
	  }
	  _svdw(u) {
	    const [x, yy] = this._svdwf(u);
	    const y = yy.redSqrt();
	    if (y.redIsOdd() !== u.redIsOdd()) y.redINeg();
	    return this.point(x, y);
	  }
	  _svdwi(p, hint) {
	    // Inverting the Map (Shallue-van de Woestijne).
	    //
	    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
	    // [SVDW2] Page 12, Section 5.
	    // [SVDW3] "Inverting the map".
	    //
	    // Assumptions:
	    //
	    //   - If r = 1 then x != -(c + z) / 2.
	    //   - If r = 2 then x != (c - z) / 2.
	    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).
	    //   - f(f^-1(x)) = x where f is the map function.
	    //
	    // We use the sampling method from [SVDW2],
	    // _not_ [SQUARED]. This seems to have a
	    // better distribution in practice.
	    //
	    // Note that [SVDW3] also appears to be
	    // incorrect in terms of distribution.
	    //
	    // The distribution of f(u), assuming u is
	    // random, is (1/2, 1/4, 1/4).
	    //
	    // To mirror this, f^-1(x) should simply
	    // pick (1/2, 1/4, 1/8, 1/8).
	    //
	    // To anyone running the forward map, our
	    // strings will appear to be random.
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + b
	    //   c = sqrt(-3 * z^2)
	    //   t0 = 9 * (x^2 * z^2 + z^4)
	    //   t1 = 18 * x * z^3
	    //   t2 = 12 * g(z) * (x - z)
	    //   t3 = sqrt(t0 - t1 + t2)
	    //   t4 = t3 * z
	    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)
	    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)
	    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2
	    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2
	    //   r = random integer in [1,4]
	    //   u = sign(y) * abs(sqrt(ur))
	    const {
	      b,
	      c,
	      z,
	      zero,
	      two
	    } = this;
	    const {
	      x,
	      y
	    } = p;
	    const r = hint & 3;
	    const z2 = z.redSqr();
	    const z3 = z2.redMul(z);
	    const z4 = z2.redSqr();
	    const gz = z3.redAdd(b);
	    const gz2 = gz.redMuln(2);
	    const xx = x.redSqr();
	    const x2z = x.redMuln(2).redIAdd(z);
	    const xz2 = x.redMul(z2);
	    const c0 = c.redSub(x2z);
	    const c1 = c.redAdd(x2z);
	    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);
	    const t1 = x.redMul(z3).redIMuln(18);
	    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);
	    const t3 = r >= 2 ? t0.redISub(t1).redIAdd(t2).redSqrt() : zero;
	    const t4 = t3.redMul(z);
	    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);
	    const n0 = gz.redMul(c0);
	    const n1 = gz.redMul(c1);
	    const n2 = t5.redAdd(t4);
	    const n3 = t5.redSub(t4);
	    const d2 = two;
	    const n = [n0, n1, n2, n3][r];
	    const d = [c1, c0, d2, d2][r];
	    const u = n.redDivSqrt(d);
	    const [x0] = this._svdwf(u);
	    if (!x0.eq(x)) throw new Error('Invalid point.');
	    if (u.redIsOdd() !== y.redIsOdd()) u.redINeg();
	    return u;
	  }
	  isElliptic() {
	    const {
	      a,
	      b
	    } = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const d = b2.redMuln(27).redIAdd(a3.redMuln(4));

	    // 4 * a^3 + 27 * b^2 != 0
	    return !d.isZero();
	  }
	  jinv() {
	    // [ARITH1] Page 71, Section 4.4.
	    // http://mathworld.wolfram.com/j-Invariant.html
	    const {
	      a,
	      b
	    } = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const t0 = a3.redMuln(4);
	    const lhs = t0.redMuln(1728);
	    const rhs = b2.redMuln(27).redIAdd(t0);
	    if (rhs.isZero()) throw new Error('Curve is not elliptic.');

	    // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)
	    return lhs.redDiv(rhs).fromRed();
	  }
	  point(x, y) {
	    return new ShortPoint(this, x, y);
	  }
	  jpoint(x, y, z) {
	    return new JPoint(this, x, y, z);
	  }
	  solveX(y) {
	    assert(y instanceof BN);
	    if (!this.a.isZero()) throw new Error('Not implemented.');

	    // x^3 = y^2 - b
	    const y2 = y.redSqr();
	    const x3 = y2.redSub(this.b);
	    return cubeRoots(x3);
	  }
	  solveY2(x) {
	    // [GECC] Page 89, Section 3.2.2.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html
	    assert(x instanceof BN);

	    // y^2 = x^3 + a * x + b
	    const x3 = x.redSqr().redMul(x);
	    const y2 = x3.redIAdd(this.b);
	    if (!this.zeroA) {
	      // Save some cycles for a = -3.
	      if (this.threeA) y2.redIAdd(x.redMuln(-3));else y2.redIAdd(this.a.redMul(x));
	    }
	    return y2;
	  }
	  validate(point) {
	    assert(point instanceof ShortPoint);
	    if (point.inf) return true;
	    const {
	      x,
	      y
	    } = point;
	    const y2 = this.solveY2(x);
	    return y.redSqr().eq(y2);
	  }
	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');
	    if (!x.red) x = x.toRed(this.red);
	    const y = this.solveY(x);
	    if (sign != null) {
	      if (this.h.cmpn(1) > 0) {
	        if (y.isZero() && sign) throw new Error('Invalid point.');
	      }
	      if (y.redIsOdd() !== sign) y.redINeg();
	    }
	    return this.point(x, y);
	  }
	  pointFromY(y, index = 0) {
	    assert(y instanceof BN);
	    assert(index >>> 0 === index);
	    if (!y.red) y = y.toRed(this.red);
	    const coords = this.solveX(y);
	    if (index >= coords.length) throw new Error('Invalid X coordinate index.');
	    const x = coords[index];
	    return this.point(x, y);
	  }
	  isIsomorphic(curve) {
	    // [GECC] Page 84, Section 3.1.5.
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    assert(curve instanceof Curve);
	    if (!curve.p.eq(this.p)) return false;
	    let u2, u3;
	    try {
	      [u2, u3] = this._scale(curve);
	    } catch (e) {
	      return false;
	    }

	    // E(a,b) <-> E(au^4,bu^6)
	    if (curve.type === 'short') {
	      // a' = a * u^4, b' = b * u^6
	      const a = this.field(curve.a).redMul(u2.redSqr());
	      const b = this.field(curve.b).redMul(u3.redSqr());
	      return this.a.eq(a) && this.b.eq(b);
	    }

	    // E(a,b) <-> M(A,B)
	    if (curve.type === 'mont') {
	      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0
	      const {
	        a3,
	        bi
	      } = curve;
	      const x = this.field(a3.redMul(bi)).redMul(u2);
	      const y2 = this.solveY2(x);
	      return y2.isZero();
	    }

	    // E(a,b) <-> E(a,d)
	    if (curve.type === 'edwards') {
	      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0
	      const x = this.field(curve.ad6).redMul(u2);
	      const y2 = this.solveY2(x);
	      return y2.isZero();
	    }
	    return false;
	  }
	  isIsogenous(curve) {
	    assert(curve instanceof Curve);
	    return false;
	  }
	  pointFromShort(point) {
	    // [GECC] Page 84, Section 3.1.5.
	    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
	    assert(point instanceof ShortPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):
	      //
	      //   x' = x * u^2
	      //   y' = y * u^3
	      //
	      // Where a * u^4 = a' and b * u^6 = b'.
	      if (point.isInfinity()) return this.point();
	      const [u2, u3] = this._scale(point.curve);
	      const x = this.field(point.x);
	      const y = this.field(point.y);
	      const nx = x.redMul(u2);
	      const ny = y.redMul(u3);
	      return this.point(nx, ny);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromMont(point) {
	    // [ALT] Appendix E.2 (Switching between Alternative Representations).
	    // [MONT2] "Equivalence with Weierstrass curves"
	    assert(point instanceof MontPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for M(A,B)->E(a,b):
	      //
	      //   x = (u + A / 3) / B
	      //   y = v / B
	      //
	      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
	      if (point.isInfinity()) return this.point();
	      const {
	        a3,
	        bi
	      } = point.curve;
	      const [u2, u3] = this._scale(point.curve);
	      const nx = point.x.redAdd(a3).redMul(bi);
	      const ny = point.y.redMul(bi);
	      return this.point(this.field(nx).redMul(u2), this.field(ny).redMul(u3));
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromEdwards(point) {
	    // [TWISTEQ] Section 2.
	    assert(point instanceof EdwardsPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,d)->E(a',b'):
	      //
	      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))
	      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> ((a + d) / 6, 0)
	      //
	      // Unexceptional Cases:
	      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))
	      const {
	        a,
	        d,
	        ad6
	      } = point.curve;
	      const [u2, u3] = this._scale(point.curve);
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) {
	        const x = this.field(ad6).redMul(u2);
	        return this.point(x, this.zero);
	      }
	      const {
	        x,
	        y,
	        z
	      } = point;
	      const a5 = a.redMuln(5);
	      const d5 = d.redMuln(5);
	      const dma = d.redSub(a);
	      const d5a = d5.redSub(a);
	      const da5 = d.redSub(a5);
	      const ypz = y.redAdd(z);
	      const ymz = y.redSub(z);
	      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
	      const xz = ymz.redMuln(12);
	      const yy = dma.redMul(ypz).redMul(z);
	      const yz = ymz.redMul(x).redIMuln(4);
	      return this.cpoint(this.field(xx).redMul(u2), this.field(xz), this.field(yy).redMul(u3), this.field(yz));
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromUniform(u) {
	    assert(u instanceof BN);

	    // z = 0 or b = 0
	    if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.');

	    // a != 0, b != 0
	    if (!this.a.isZero()) return this._sswu(u);

	    // p = 1 mod 3, a = 0, b != 0
	    if (!this.c.isZero()) return this._svdw(u);
	    throw new Error('Not implemented.');
	  }
	  pointToUniform(p, hint) {
	    // Convert a short weierstrass point to a field
	    // element by inverting either the SSWU or SVDW
	    // map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof ShortPoint);
	    assert(hint >>> 0 === hint);

	    // z = 0 or b = 0
	    if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.');

	    // P = O
	    if (p.isInfinity()) throw new Error('Invalid point.');

	    // Add a random torsion component.
	    const i = (hint >>> 4 & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);
	    return wrapErrors(() => {
	      // a != 0, b != 0
	      if (!this.a.isZero()) return this._sswui(q, hint);

	      // p = 1 mod 3, a = 0, b != 0
	      if (!this.c.isZero()) return this._svdwi(q, hint);
	      throw new Error('Not implemented.');
	    });
	  }
	  mulAll(points, coeffs) {
	    return super.mulAll(points, coeffs).toP();
	  }
	  affinizeAll(points) {
	    const out = this.normalizeAll(points);
	    for (let i = 0; i < out.length; i++) out[i] = out[i].toP();
	    return out;
	  }
	  decodePoint(bytes) {
	    return ShortPoint.decode(this, bytes);
	  }
	  encodeX(point) {
	    assert(point instanceof Point);
	    return point.encodeX();
	  }
	  decodeEven(bytes) {
	    return ShortPoint.decodeEven(this, bytes);
	  }
	  decodeSquare(bytes) {
	    return ShortPoint.decodeSquare(this, bytes);
	  }
	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);
	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });
	    if (sign != null) {
	      const [, u3] = curve._scale(this);
	      if (u3.redIsOdd() !== sign) u3.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
	    return curve;
	  }
	  toMont(b0, odd, sign = null) {
	    const [a, b] = this._mont(b0, odd);
	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });
	    if (sign != null) {
	      const [, u3] = this._scale(curve);
	      if (u3.redIsOdd() !== sign) u3.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
	    return curve;
	  }
	  toEdwards(a0, odd, sign = null) {
	    const [a, d] = this._edwards(a0, odd);
	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h
	    });
	    if (sign != null) {
	      const [, u3] = this._scale(curve);
	      if (u3.redIsOdd() !== sign) u3.redINeg();
	    }
	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromShort(this.g);
	      curve.g.normalize();
	    }
	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }
	    return curve;
	  }
	  pointFromJSON(json) {
	    return ShortPoint.fromJSON(this, json);
	  }
	  toJSON(pre) {
	    const json = super.toJSON(pre);
	    json.a = this.a.fromRed().toJSON();
	    json.b = this.b.fromRed().toJSON();
	    if (!this.c.isZero()) json.c = this.c.fromRed().toJSON();
	    return json;
	  }
	}

	/**
	 * ShortPoint
	 */

	class ShortPoint extends Point {
	  constructor(curve, x, y) {
	    assert(curve instanceof ShortCurve);
	    super(curve, types.AFFINE);
	    this.x = this.curve.zero;
	    this.y = this.curve.zero;
	    this.inf = true;
	    if (x != null) this._init(x, y);
	  }
	  _init(x, y) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    this.x = x;
	    this.y = y;
	    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	  _getBeta() {
	    if (!this.curve.endo) return null;
	    if (this.pre && this.pre.beta) return this.pre.beta;

	    // Augment the point with our beta value.
	    // This is the counterpart to `k2` after
	    // the endomorphism split of `k`.
	    //
	    // Note that if we have precomputation,
	    // we have to clone and update all of the
	    // precomputed points below.
	    const xb = this.x.redMul(this.curve.endo.beta);
	    const beta = this.curve.point(xb, this.y);
	    if (this.pre) {
	      beta.pre = this.pre.map(point => {
	        const xb = point.x.redMul(this.curve.endo.beta);
	        return this.curve.point(xb, point.y);
	      });
	      this.pre.beta = beta;
	    }
	    return beta;
	  }
	  _getJNAF(point) {
	    assert(point instanceof ShortPoint);
	    if (this.inf || point.inf) return super._getJNAF(point);

	    // Create comb for JSF.
	    const comb = [this,
	    // 1
	    null,
	    // 3
	    null,
	    // 5
	    point // 7
	    ];

	    // Try to avoid Jacobian points, if possible.
	    if (this.y.eq(point.y)) {
	      comb[1] = this.add(point);
	      comb[2] = this.toJ().sub(point);
	    } else if (this.y.eq(point.y.redNeg())) {
	      comb[1] = this.toJ().add(point);
	      comb[2] = this.sub(point);
	    } else {
	      comb[1] = this.toJ().add(point);
	      comb[2] = this.toJ().sub(point);
	    }
	    return comb;
	  }
	  clone() {
	    if (this.inf) return this.curve.point();
	    return this.curve.point(this.x, this.y);
	  }
	  scale(a) {
	    return this.toJ().scale(a);
	  }
	  neg() {
	    // P = O
	    if (this.inf) return this;

	    // -(X1, Y1) = (X1, -Y1)
	    return this.curve.point(this.x, this.y.redNeg());
	  }
	  add(p) {
	    // [GECC] Page 80, Section 3.1.2.
	    //
	    // Addition Law:
	    //
	    //   l = (y1 - y2) / (x1 - x2)
	    //   x3 = l^2 - x1 - x2
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 1S + 6A
	    assert(p instanceof ShortPoint);

	    // O + P = P
	    if (this.inf) return p;

	    // P + O = P
	    if (p.inf) return this;

	    // P + P, P + -P
	    if (this.x.eq(p.x)) {
	      // P + -P = O
	      if (!this.y.eq(p.y)) return this.curve.point();

	      // P + P = 2P
	      return this.dbl();
	    }

	    // X1 != X2, Y1 = Y2
	    if (this.y.eq(p.y)) {
	      // X3 = -X1 - X2
	      const nx = this.x.redNeg().redISub(p.x);

	      // Y3 = -Y1
	      const ny = this.y.redNeg();

	      // Skip the inverse.
	      return this.curve.point(nx, ny);
	    }

	    // H = X1 - X2
	    const h = this.x.redSub(p.x);

	    // R = Y1 - Y2
	    const r = this.y.redSub(p.y);

	    // L = R / H
	    const l = r.redDiv(h);

	    // X3 = L^2 - X1 - X2
	    const nx = l.redSqr().redISub(this.x).redISub(p.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
	    return this.curve.point(nx, ny);
	  }
	  dbl() {
	    // [GECC] Page 80, Section 3.1.2.
	    //
	    // Addition Law (doubling):
	    //
	    //   l = (3 * x1^2 + a) / (2 * y1)
	    //   x3 = l^2 - 2 * x1
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 2S + 3A + 2*2 + 1*3

	    // P = O
	    if (this.inf) return this;

	    // Y1 = 0
	    if (this.y.isZero()) return this.curve.point();

	    // XX = X1^2
	    const xx = this.x.redSqr();

	    // M = 3 * XX + a
	    const m = xx.redIMuln(3).redIAdd(this.curve.a);

	    // Z = 2 * Y1
	    const z = this.y.redMuln(2);

	    // L = M / Z
	    const l = m.redDiv(z);

	    // X3 = L^2 - 2 * X1
	    const nx = l.redSqr().redISub(this.x).redISub(this.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
	    return this.curve.point(nx, ny);
	  }
	  dblp(pow) {
	    return this.toJ().dblp(pow).toP();
	  }
	  getX() {
	    if (this.inf) throw new Error('Invalid point.');
	    return this.x.fromRed();
	  }
	  getY() {
	    if (this.inf) throw new Error('Invalid point.');
	    return this.y.fromRed();
	  }
	  eq(p) {
	    assert(p instanceof ShortPoint);

	    // P = Q
	    if (this === p) return true;

	    // P = O
	    if (this.inf) return p.inf;

	    // Q = O
	    if (p.inf) return false;

	    // X1 = X2, Y1 = Y2
	    return this.x.eq(p.x) && this.y.eq(p.y);
	  }
	  cmp(point) {
	    assert(point instanceof ShortPoint);
	    if (this.inf && !point.inf) return -1;
	    if (!this.inf && point.inf) return 1;
	    if (this.inf && point.inf) return 0;
	    return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
	  }
	  isInfinity() {
	    // Infinity cannot be represented in
	    // the affine space, except by a flag.
	    return this.inf;
	  }
	  isOrder2() {
	    if (this.inf) return false;
	    return this.y.isZero();
	  }
	  isOdd() {
	    if (this.inf) return false;
	    return this.y.redIsOdd();
	  }
	  isEven() {
	    if (this.inf) return false;
	    return this.y.redIsEven();
	  }
	  isSquare() {
	    if (this.inf) return false;
	    return this.y.redJacobi() !== -1;
	  }
	  eqX(x) {
	    assert(x instanceof BN);
	    assert(!x.red);
	    if (this.inf) return false;
	    return this.getX().eq(x);
	  }
	  eqR(x) {
	    assert(x instanceof BN);
	    assert(!x.red);
	    assert(!this.curve.n.isZero());
	    if (this.inf) return false;
	    return this.getX().imod(this.curve.n).eq(x);
	  }
	  mul(k) {
	    return super.mul(k).toP();
	  }
	  muln(k) {
	    return super.muln(k).toP();
	  }
	  mulBlind(k, rng) {
	    return super.mulBlind(k, rng).toP();
	  }
	  mulAdd(k1, p2, k2) {
	    return super.mulAdd(k1, p2, k2).toP();
	  }
	  mulH() {
	    return super.mulH().toP();
	  }
	  div(k) {
	    return super.div(k).toP();
	  }
	  divn(k) {
	    return super.divn(k).toP();
	  }
	  divH() {
	    return super.divH().toP();
	  }
	  toP() {
	    return this;
	  }
	  toJ() {
	    // (X3, Y3, Z3) = (1, 1, 0)
	    if (this.inf) return this.curve.jpoint();

	    // (X3, Y3, Z3) = (X1, Y1, 1)
	    return this.curve.jpoint(this.x, this.y, this.curve.one);
	  }
	  encode(compact) {
	    // [SEC1] Page 10, Section 2.3.3.
	    if (compact == null) compact = true;
	    assert(typeof compact === 'boolean');
	    const {
	      fieldSize
	    } = this.curve;

	    // We do not serialize points at infinity.
	    if (this.inf) throw new Error('Invalid point.');

	    // Compressed form (0x02 = even, 0x03 = odd).
	    if (compact) {
	      const p = Buffer.alloc(1 + fieldSize);
	      const x = this.curve.encodeField(this.getX());
	      p[0] = 0x02 | this.y.redIsOdd();
	      x.copy(p, 1);
	      return p;
	    }

	    // Uncompressed form (0x04).
	    const p = Buffer.alloc(1 + fieldSize * 2);
	    const x = this.curve.encodeField(this.getX());
	    const y = this.curve.encodeField(this.getY());
	    p[0] = 0x04;
	    x.copy(p, 1);
	    y.copy(p, 1 + fieldSize);
	    return p;
	  }
	  static decode(curve, bytes) {
	    // [SEC1] Page 11, Section 2.3.4.
	    assert(curve instanceof ShortCurve);
	    assert(Buffer.isBuffer(bytes));
	    const len = curve.fieldSize;
	    if (bytes.length < 1 + len) throw new Error('Not a point.');

	    // Point forms:
	    //
	    //   0x00 -> Infinity (openssl, unsupported)
	    //   0x02 -> Compressed Even
	    //   0x03 -> Compressed Odd
	    //   0x04 -> Uncompressed
	    //   0x06 -> Hybrid Even (openssl)
	    //   0x07 -> Hybrid Odd (openssl)
	    //
	    // Note that openssl supports serializing points
	    // at infinity as {0}. We choose not to support it
	    // because it's strange and not terribly useful.
	    const form = bytes[0];
	    switch (form) {
	      case 0x02:
	      case 0x03:
	        {
	          if (bytes.length !== 1 + len) throw new Error('Invalid point size for compressed.');
	          const x = curve.decodeField(bytes.slice(1, 1 + len));
	          if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
	          const p = curve.pointFromX(x, form === 0x03);
	          assert(!p.isInfinity());
	          return p;
	        }
	      case 0x04:
	      case 0x06:
	      case 0x07:
	        {
	          if (bytes.length !== 1 + len * 2) throw new Error('Invalid point size for uncompressed.');
	          const x = curve.decodeField(bytes.slice(1, 1 + len));
	          const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len));

	          // [GECC] Algorithm 4.3, Page 180, Section 4.
	          if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0) throw new Error('Invalid point.');

	          // OpenSSL hybrid encoding.
	          if (form !== 0x04 && form !== (0x06 | y.isOdd())) throw new Error('Invalid hybrid encoding.');
	          const p = curve.point(x, y);
	          if (!p.validate()) throw new Error('Invalid point.');
	          assert(!p.isInfinity());
	          return p;
	        }
	      default:
	        {
	          throw new Error('Unknown point format.');
	        }
	    }
	  }
	  encodeX() {
	    // [SCHNORR] "Specification".
	    // [BIP340] "Specification".
	    return this.curve.encodeField(this.getX());
	  }
	  static decodeEven(curve, bytes) {
	    // [BIP340] "Specification".
	    assert(curve instanceof ShortCurve);
	    const x = curve.decodeField(bytes);
	    if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
	    return curve.pointFromX(x, false);
	  }
	  static decodeSquare(curve, bytes) {
	    // [SCHNORR] "Specification".
	    assert(curve instanceof ShortCurve);
	    const x = curve.decodeField(bytes);
	    if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
	    return curve.pointFromX(x);
	  }
	  toJSON(pre) {
	    if (this.inf) return [];
	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();
	    if (pre === true && this.pre) return [x, y, this.pre.toJSON()];
	    return [x, y];
	  }
	  toPretty() {
	    if (this.inf) return [];
	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);
	    return [x, y];
	  }
	  static fromJSON(curve, json) {
	    assert(curve instanceof ShortCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0 || json.length === 2 || json.length === 3);
	    if (json.length === 0) return curve.point();
	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);
	    const point = curve.point(x, y);
	    if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);
	    return point;
	  }
	  [custom]() {
	    if (this.inf) return '<ShortPoint: Infinity>';
	    return '<ShortPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';
	  }
	}

	/**
	 * JPoint
	 */

	class JPoint extends Point {
	  constructor(curve, x, y, z) {
	    assert(curve instanceof ShortCurve);
	    super(curve, types.JACOBIAN);
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = this.curve.zero;
	    this.zOne = false;
	    if (x != null) this._init(x, y, z);
	  }
	  _init(x, y, z) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    assert(z == null || z instanceof BN);
	    this.x = x;
	    this.y = y;
	    this.z = z || this.curve.one;
	    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
	    this.zOne = this.z.eq(this.curve.one);
	  }
	  clone() {
	    return this.curve.jpoint(this.x, this.y, this.z);
	  }
	  validate() {
	    // [GECC] Example 3.20, Page 88, Section 3.
	    const {
	      a,
	      b
	    } = this.curve;

	    // P = O
	    if (this.isInfinity()) return true;

	    // Z1 = 1
	    if (this.zOne) return this.curve.validate(this.toP());

	    // y^2 = x^3 + a * x * z^4 + b * z^6
	    const lhs = this.y.redSqr();
	    const x3 = this.x.redSqr().redMul(this.x);
	    const z2 = this.z.redSqr();
	    const z4 = z2.redSqr();
	    const z6 = z4.redMul(z2);
	    const rhs = x3.redIAdd(b.redMul(z6));
	    if (!this.curve.zeroA) {
	      // Save some cycles for a = -3.
	      if (this.curve.threeA) rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));else rhs.redIAdd(a.redMul(z4).redMul(this.x));
	    }
	    return lhs.eq(rhs);
	  }
	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z
	    // 1I + 3M + 1S

	    // Z = 1
	    if (this.zOne) return this;

	    // P = O
	    if (this.isInfinity()) return this;

	    // A = 1 / Z1
	    const a = this.z.redInvert();

	    // AA = A^2
	    const aa = a.redSqr();

	    // X3 = X1 * AA
	    this.x = this.x.redMul(aa);

	    // Y3 = Y1 * AA * A
	    this.y = this.y.redMul(aa).redMul(a);

	    // Z3 = 1
	    this.z = this.curve.one;
	    this.zOne = true;
	    return this;
	  }
	  scale(a) {
	    assert(a instanceof BN);

	    // P = O
	    if (this.isInfinity()) return this.curve.jpoint();

	    // AA = A^2
	    const aa = a.redSqr();

	    // X3 = X1 * AA
	    const nx = this.x.redMul(aa);

	    // Y3 = Y1 * AA * A
	    const ny = this.y.redMul(aa).redMul(a);

	    // Z3 = Z1 * A
	    const nz = this.z.redMul(a);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  neg() {
	    // -(X1, Y1, Z1) = (X1, -Y1, Z1)
	    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	  }
	  add(p) {
	    assert(p instanceof Point);
	    if (p.type === types.AFFINE) return this._mixedAdd(p);
	    return this._add(p);
	  }
	  _add(p) {
	    assert(p instanceof JPoint);

	    // O + P = P
	    if (this.isInfinity()) return p;

	    // P + O = P
	    if (p.isInfinity()) return this;

	    // Z1 = 1
	    if (this.zOne) return p._addJA(this);

	    // Z2 = 1
	    if (p.zOne) return this._addJA(p);
	    return this._addJJ(p);
	  }
	  _mixedAdd(p) {
	    assert(p instanceof ShortPoint);

	    // O + P = P
	    if (this.isInfinity()) return p.toJ();

	    // P + O = P
	    if (p.isInfinity()) return this;
	    return this._addJA(p);
	  }
	  _addJJ(p) {
	    // No assumptions.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2
	    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)

	    // Z1Z1 = Z1^2
	    const z1z1 = this.z.redSqr();

	    // Z2Z2 = Z2^2
	    const z2z2 = p.z.redSqr();

	    // U1 = X1 * Z2Z2
	    const u1 = this.x.redMul(z2z2);

	    // U2 = X2 * Z1Z1
	    const u2 = p.x.redMul(z1z1);

	    // S1 = Y1 * Z2 * Z2Z2
	    const s1 = this.y.redMul(p.z).redMul(z2z2);

	    // S2 = Y2 * Z1 * Z1Z1
	    const s2 = p.y.redMul(this.z).redMul(z1z1);

	    // H = U2 - U1
	    const h = u2.redISub(u1);

	    // r = S2 - S1
	    const r = s2.redISub(s1);

	    // H = 0
	    if (h.isZero()) {
	      if (!r.isZero()) return this.curve.jpoint();
	      return this.dbl();
	    }

	    // HH = H^2
	    const hh = h.redSqr();

	    // HHH = H * HH
	    const hhh = h.redMul(hh);

	    // V = U1 * HH
	    const v = u1.redMul(hh);

	    // X3 = r^2 - HHH - 2 * V
	    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);

	    // Y3 = r * (V - X3) - S1 * HHH
	    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));

	    // Z3 = Z1 * Z2 * H
	    const nz = this.z.redMul(p.z).redMul(h);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  _addJA(p) {
	    // Assumes Z2 = 1.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd
	    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)

	    // Z1Z1 = Z1^2
	    const z1z1 = this.z.redSqr();

	    // U2 = X2 * Z1Z1
	    const u2 = p.x.redMul(z1z1);

	    // S2 = Y2 * Z1 * Z1Z1
	    const s2 = p.y.redMul(this.z).redMul(z1z1);

	    // H = U2 - X1
	    const h = u2.redISub(this.x);

	    // r = 2 * (S2 - Y1)
	    const r = s2.redISub(this.y).redIMuln(2);

	    // H = 0
	    if (h.isZero()) {
	      if (!r.isZero()) return this.curve.jpoint();
	      return this.dbl();
	    }

	    // I = (2 * H)^2
	    const i = h.redMuln(2).redSqr();

	    // J = H * I
	    const j = h.redMul(i);

	    // V = X1 * I
	    const v = this.x.redMul(i);

	    // X3 = r^2 - J - 2 * V
	    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);

	    // Y3 = r * (V - X3) - 2 * Y1 * J
	    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));

	    // Z3 = 2 * Z1 * H
	    const nz = this.z.redMul(h).redIMuln(2);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  dbl() {
	    // P = O
	    if (this.isInfinity()) return this;

	    // Y1 = 0
	    if (this.y.isZero()) return this.curve.jpoint();

	    // a = 0
	    if (this.curve.zeroA) return this._dbl0();

	    // a = -3
	    if (this.curve.threeA) return this._dbl3();
	    return this._dblJ();
	  }
	  _dblJ() {
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2
	    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8
	    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)

	    // XX = X1^2
	    const xx = this.x.redSqr();

	    // YY = Y1^2
	    const yy = this.y.redSqr();

	    // ZZ = Z1^2
	    const zz = this.z.redSqr();

	    // S = 4 * X1 * YY
	    const s = this.x.redMul(yy).redIMuln(4);

	    // M = 3 * XX + a * ZZ^2
	    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));

	    // T = M^2 - 2 * S
	    const t = m.redSqr().redISub(s).redISub(s);

	    // X3 = T
	    const nx = t;

	    // Y3 = M * (S - T) - 8 * YY^2
	    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));

	    // Z3 = 2 * Y1 * Z1
	    const nz = this.y.redMul(this.z).redIMuln(2);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  _dbl0() {
	    // Assumes a = 0.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
	    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8
	    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)

	    // A = X1^2
	    const a = this.x.redSqr();

	    // B = Y1^2
	    const b = this.y.redSqr();

	    // C = B^2
	    const c = b.redSqr();

	    // + XB2 = (X1 + B)^2
	    const xb2 = b.redIAdd(this.x).redSqr();

	    // D = 2 * ((X1 + B)^2 - A - C)
	    const d = xb2.redISub(a).redISub(c).redIMuln(2);

	    // E = 3 * A
	    const e = a.redIMuln(3);

	    // F = E^2
	    const f = e.redSqr();

	    // X3 = F - 2 * D
	    const nx = f.redISub(d).redISub(d);

	    // Y3 = E * (D - X3) - 8 * C
	    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));

	    // Z3 = 2 * Y1 * Z1
	    const nz = this.y.redMul(this.z).redIMuln(2);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  _dbl3() {
	    // Assumes a = -3.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8
	    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)

	    // delta = Z1^2
	    const delta = this.z.redSqr();

	    // gamma = Y1^2
	    const gamma = this.y.redSqr();

	    // beta = X1 * gamma
	    const beta = this.x.redMul(gamma);

	    // + xmdelta = X1 - delta
	    const xmdelta = this.x.redSub(delta);

	    // + xpdelta = X1 + delta
	    const xpdelta = this.x.redAdd(delta);

	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    const alpha = xmdelta.redMul(xpdelta).redIMuln(3);

	    // + beta4 = 4 * beta
	    const beta4 = beta.redIMuln(4);

	    // + beta8 = 2 * beta4
	    const beta8 = beta4.redMuln(2);

	    // + gamma28 = 8 * gamma^2
	    const gamma28 = gamma.redSqr().redIMuln(8);

	    // X3 = alpha^2 - 8 * beta
	    const nx = alpha.redSqr().redISub(beta8);

	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);

	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);
	    return this.curve.jpoint(nx, ny, nz);
	  }
	  getX() {
	    if (this.isInfinity()) throw new Error('Invalid point.');
	    this.normalize();
	    return this.x.fromRed();
	  }
	  getY() {
	    if (this.isInfinity()) throw new Error('Invalid point.');
	    this.normalize();
	    return this.y.fromRed();
	  }
	  eq(p) {
	    assert(p instanceof JPoint);

	    // P = Q
	    if (this === p) return true;

	    // P = O
	    if (this.isInfinity()) return p.isInfinity();

	    // Q = O
	    if (p.isInfinity()) return false;

	    // Z1 = Z2
	    if (this.z.eq(p.z)) {
	      return this.x.eq(p.x) && this.y.eq(p.y);
	    }

	    // X1 * Z2^2 = X2 * Z1^2
	    const zz1 = this.z.redSqr();
	    const zz2 = p.z.redSqr();
	    const x1 = this.x.redMul(zz2);
	    const x2 = p.x.redMul(zz1);
	    if (!x1.eq(x2)) return false;

	    // Y1 * Z2^3 = Y2 * Z1^3
	    const zzz1 = zz1.redMul(this.z);
	    const zzz2 = zz2.redMul(p.z);
	    const y1 = this.y.redMul(zzz2);
	    const y2 = p.y.redMul(zzz1);
	    return y1.eq(y2);
	  }
	  cmp(point) {
	    assert(point instanceof JPoint);
	    const inf1 = this.isInfinity();
	    const inf2 = point.isInfinity();
	    if (inf1 && !inf2) return -1;
	    if (!inf1 && inf2) return 1;
	    if (inf1 && inf2) return 0;
	    return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
	  }
	  isInfinity() {
	    // Z1 = 0
	    return this.z.isZero();
	  }
	  isOrder2() {
	    if (this.isInfinity()) return false;
	    return this.y.isZero();
	  }
	  isOdd() {
	    if (this.isInfinity()) return false;
	    this.normalize();
	    return this.y.redIsOdd();
	  }
	  isEven() {
	    if (this.isInfinity()) return false;
	    this.normalize();
	    return this.y.redIsEven();
	  }
	  isSquare() {
	    if (this.isInfinity()) return false;
	    return this.y.redMul(this.z).redJacobi() !== -1;
	  }
	  eqX(x) {
	    // Verify that integer `x` is equal to field
	    // element `x` by scaling it by our z coordinate.
	    // This optimization is mentioned in and used for
	    // bip-schnorr[1]. This avoids having to affinize
	    // the resulting point during verification.
	    //
	    // [1] [SCHNORR] "Optimizations".
	    assert(x instanceof BN);
	    assert(!x.red);
	    if (this.isInfinity()) return false;
	    const zz = this.z.redSqr();
	    const rx = x.toRed(this.curve.red).redMul(zz);
	    return this.x.eq(rx);
	  }
	  eqR(x) {
	    // Similar to the optimization above, this
	    // optimization, suggested by Maxwell[1],
	    // compares an integer to an X coordinate
	    // by scaling it.
	    //
	    // Since a signature's R value is modulo N
	    // in ECDSA, we may be dealing with an R
	    // value greater than N in actuality.
	    //
	    // If the equality check fails, we can
	    // scale N itself by Z and add it to the
	    // X field element.
	    //
	    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f
	    assert(x instanceof BN);
	    assert(!x.red);
	    if (!this.curve.smallGap) return this.toP().eqR(x);
	    if (this.isInfinity()) return false;
	    if (x.cmp(this.curve.p) >= 0) return false;
	    const zz = this.z.redSqr();
	    const rx = x.toRed(this.curve.red).redMul(zz);
	    if (this.x.eq(rx)) return true;
	    if (this.curve.highOrder) return false;
	    if (x.cmp(this.curve.pmodn) >= 0) return false;
	    const rn = this.curve.redN.redMul(zz);
	    rx.redIAdd(rn);
	    return this.x.eq(rx);
	  }
	  toP() {
	    // P = O
	    if (this.isInfinity()) return this.curve.point();
	    this.normalize();

	    // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)
	    return this.curve.point(this.x, this.y);
	  }
	  toJ() {
	    return this;
	  }
	  encode(compact) {
	    return this.toP().encode(compact);
	  }
	  static decode(curve, bytes) {
	    return ShortPoint.decode(curve, bytes).toJ();
	  }
	  encodeX() {
	    return this.toP().encodeX();
	  }
	  static decodeEven(curve, bytes) {
	    return ShortPoint.decodeEven(curve, bytes).toJ();
	  }
	  static decodeSquare(curve, bytes) {
	    return ShortPoint.decodeSquare(curve, bytes).toJ();
	  }
	  toJSON(pre) {
	    return this.toP().toJSON(pre);
	  }
	  toPretty() {
	    return this.toP().toPretty();
	  }
	  static fromJSON(curve, json) {
	    return ShortPoint.fromJSON(curve, json).toJ();
	  }
	  [custom]() {
	    if (this.isInfinity()) return '<JPoint: Infinity>';
	    return '<JPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
	  }
	}

	/**
	 * MontCurve
	 */

	class MontCurve extends Curve {
	  constructor(conf) {
	    super(MontPoint, 'mont', conf);
	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.b = BN.fromJSON(conf.b).toRed(this.red);
	    this.bi = this.b.redInvert();
	    this.a2 = this.a.redAdd(this.two);
	    this.a24 = this.a2.redMul(this.i4);
	    this.a3 = this.a.redMul(this.i3);
	    this.a0 = this.a.redMul(this.bi);
	    this.b0 = this.bi.redSqr();
	    this._finalize(conf);
	  }
	  static _isomorphism(curveA, curveB, customB) {
	    // Montgomery Isomorphism.
	    //
	    // [MONT3] Page 3, Section 2.1.
	    //
	    // Transformation:
	    //
	    //   A' = A
	    //   B' = B'
	    //
	    // Where (B / B') is square.
	    assert(curveA instanceof BN);
	    assert(curveB instanceof BN);
	    assert(customB instanceof BN);
	    const a = curveA.clone();
	    const b = customB.clone();
	    const c = curveB.redDiv(customB);
	    if (c.redJacobi() !== 1) throw new Error('Invalid `b` coefficient.');
	    return [a, b];
	  }
	  _short(a0, odd) {
	    // Montgomery->Short Weierstrass Equivalence.
	    //
	    // [MONT2] "Equivalence with Weierstrass curves".
	    //
	    // Transformation:
	    //
	    //   a = (3 - A^2) / (3 * B^2)
	    //   b = (2 * A^3 - 9 * A) / (27 * B^3)
	    const {
	      a,
	      b,
	      three
	    } = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const b3 = b2.redMul(b);
	    const n0 = three.redSub(a2);
	    const d0 = b2.redMuln(3);
	    const n1 = a3.redMuln(2).redISub(a.redMuln(9));
	    const d1 = b3.redMuln(27);
	    const wa = n0.redDiv(d0);
	    const wb = n1.redDiv(d1);
	    if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);
	    return [wa, wb];
	  }
	  _mont(b0) {
	    return MontCurve._isomorphism(this.a, this.b, b0);
	  }
	  _edwards(a0, invert = false) {
	    // Montgomery->Twisted Edwards Transformation.
	    //
	    // [MONT1] Page 11, Section 4.3.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //
	    // Equivalence:
	    //
	    //   a = (A + 2) / B
	    //   d = (A - 2) / B
	    //
	    // Isomorphism:
	    //
	    //   a = a'
	    //   d = a' * (A - 2) / (A + 2)
	    //
	    // Where ((A + 2) / (B * a')) is square.
	    //
	    // If `d` is square, we can usually find
	    // a complete curve by using the `invert`
	    // option. This will create an isomorphism
	    // chain of: M(A,B)->E(a,d)->E(d,a).
	    //
	    // The equivalence between E(a,d) and
	    // E(d,a) is:
	    //
	    //   (x, y) = (x, 1 / y)
	    //
	    // Meaning our map to E(d,a) is:
	    //
	    //   x = u / v
	    //   y = 1 / ((u - 1) / (u + 1))
	    //     = (u + 1) / (u - 1)
	    assert(typeof invert === 'boolean');
	    const {
	      two,
	      bi
	    } = this;
	    const a = this.a.redAdd(two).redMul(bi);
	    const d = this.a.redSub(two).redMul(bi);
	    if (invert) a.swap(d);
	    if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);
	    return [a, d];
	  }
	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);
	    const [u2, u3] = curve._scale(this);
	    return [this.field(u2.redInvert()), this.field(u3.redInvert())];
	  }
	  _scaleMont(curve) {
	    // We can extract the isomorphism factor with:
	    //
	    //   c = +-sqrt(B / B')
	    //
	    // If base points are available, we can do:
	    //
	    //   c = v' / v
	    assert(curve instanceof MontCurve);
	    if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.b).redDivSqrt(this.b);
	    return this.g.y.redDiv(this.field(curve.g.y));
	  }
	  _scaleEdwards(curve, invert) {
	    // We _could_ do something like:
	    //
	    //   B = 4 / (a - d)
	    //   c = +-sqrt(B / B')
	    //
	    // Which can be reduced to:
	    //
	    //   c = +-sqrt(4 / ((a - d) * B'))
	    //
	    // If base points are available:
	    //
	    //   v = u' / x
	    //   c = v' / v
	    //
	    // Which can be reduced to:
	    //
	    //   c = v' * x / u'
	    //
	    // However, the way our maps are
	    // written, we can re-use the Edwards
	    // isomorphism factor when going the
	    // other direction.
	    assert(curve instanceof EdwardsCurve);
	    const c = curve._scale(this, invert);
	    return this.field(c);
	  }
	  _solveY0(x) {
	    assert(x instanceof BN);

	    // y^2 = x^3 + A * x^2 + B * x
	    const a = this.a0;
	    const b = this.b0;
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));
	    return y2;
	  }
	  _elligator2(u) {
	    // Elligator 2.
	    //
	    // Distribution: 1/2.
	    //
	    // [ELL2] Page 11, Section 5.2.
	    // [H2EC] "Elligator 2 Method".
	    //        "Mappings for Montgomery curves".
	    // [SAFE] "Indistinguishability from uniform random strings".
	    //
	    // Assumptions:
	    //
	    //   - y^2 = x^3 + A * x^2 + B * x.
	    //   - A != 0, B != 0.
	    //   - A^2 - 4 * B is non-zero and non-square in F(p).
	    //   - Let z be a non-square in F(p).
	    //   - u != +-sqrt(-1 / z).
	    //
	    // Note that Elligator 2 is defined over the form:
	    //
	    //   y'^2 = x'^3 + A' * x'^2 + B' * x'
	    //
	    // Instead of:
	    //
	    //   B * y^2 = x^3 + A * x^2 + x
	    //
	    // Where:
	    //
	    //   A' = A / B
	    //   B' = 1 / B^2
	    //   x' = x / B
	    //   y' = y / B
	    //
	    // And:
	    //
	    //   x = B * x'
	    //   y = B * y'
	    //
	    // This is presumably the result of Elligator 2
	    // being designed in long Weierstrass form. If
	    // we want to support B != 1, we need to do the
	    // conversion.
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + A * x^2 + B * x
	    //   x1 = -A / (1 + z * u^2)
	    //   x1 = -A, if x1 = 0
	    //   x2 = -x1 - A
	    //   x = x1, if g(x1) is square
	    //     = x2, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const lhs = this.a0.redNeg();
	    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));
	    if (rhs.isZero()) rhs.inject(this.one);
	    const x1 = lhs.redMul(rhs.redInvert());
	    const x2 = x1.redNeg().redISub(this.a0);
	    const y1 = this._solveY0(x1);
	    const y2 = this._solveY0(x2);
	    const alpha = y1.redIsSquare() | 0;
	    const x0 = [x1, x2][alpha ^ 1];
	    const y0 = [y1, y2][alpha ^ 1].redSqrt();
	    if (y0.redIsOdd() !== u.redIsOdd()) y0.redINeg();
	    const x = this.b.redMul(x0);
	    const y = this.b.redMul(y0);
	    return this.point(x, y);
	  }
	  _invert2(p, hint) {
	    // Inverting the Map (Elligator 2).
	    //
	    // [ELL2] Page 12, Section 5.3.
	    //
	    // Assumptions:
	    //
	    //   - -z * x * (x + A) is square in F(p).
	    //   - If r = 1 then x != 0.
	    //   - If r = 2 then x != -A.
	    //
	    // Map:
	    //
	    //   u1 = -(x + A) / (x * z)
	    //   u2 = -x / ((x + A) * z)
	    //   r = random integer in [1,2]
	    //   u = sign(y) * abs(sqrt(ur))
	    //
	    // Note that `0 / 0` can only occur if A = 0
	    // (this violates the assumptions of Elligator 2).
	    const {
	      x,
	      y
	    } = p;
	    const r = hint & 1;
	    const x0 = x.redMul(this.bi);
	    const y0 = y.redMul(this.bi);
	    const n = x0.redAdd(this.a0);
	    const d = x0;
	    const lhs = [n, d][r].redINeg();
	    const rhs = [d, n][r].redMul(this.z);
	    const u = lhs.redDivSqrt(rhs);
	    if (u.redIsOdd() !== y0.redIsOdd()) u.redINeg();
	    return u;
	  }
	  isElliptic() {
	    const a2 = this.a.redSqr();
	    const d = this.b.redMul(a2.redSub(this.four));

	    // B * (A^2 - 4) != 0
	    return !d.isZero();
	  }
	  jinv() {
	    // [MONT3] Page 3, Section 2.
	    const {
	      a,
	      three,
	      four
	    } = this;
	    const a2 = a.redSqr();
	    const t0 = a2.redSub(three);
	    const lhs = t0.redPown(3).redIMuln(256);
	    const rhs = a2.redSub(four);
	    if (rhs.isZero()) throw new Error('Curve is not elliptic.');

	    // (256 * (A^2 - 3)^3) / (A^2 - 4)
	    return lhs.redDiv(rhs).fromRed();
	  }
	  point(x, y) {
	    return new MontPoint(this, x, y);
	  }
	  jpoint(x, y, z) {
	    assert(x == null && y == null && z == null);
	    return this.point();
	  }
	  xpoint(x, z) {
	    return new XPoint(this, x, z);
	  }
	  solveY2(x) {
	    // [MONT3] Page 3, Section 2.
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html
	    assert(x instanceof BN);

	    // B * y^2 = x^3 + A * x^2 + x
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);
	    const y2 = by2.redMul(this.bi);
	    return y2;
	  }
	  validate(point) {
	    assert(point instanceof MontPoint);
	    if (point.isInfinity()) return true;
	    const {
	      x,
	      y
	    } = point;
	    const y2 = this.solveY2(x);
	    return y.redSqr().eq(y2);
	  }
	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');
	    if (!x.red) x = x.toRed(this.red);
	    const y = this.solveY(x);
	    if (sign != null) {
	      if (y.isZero() && sign) throw new Error('Invalid point.');
	      if (y.redIsOdd() !== sign) y.redINeg();
	    }
	    return this.point(x, y);
	  }
	  isIsomorphic(curve, invert) {
	    // [MONT3] Page 3, Section 2.1.
	    assert(curve instanceof Curve);
	    if (!curve.p.eq(this.p)) return false;

	    // M(A,B) <-> M(A,B')
	    if (curve.type === 'mont') {
	      const a = this.field(curve.a);
	      const b = this.field(curve.b);

	      // A' = A
	      if (!this.a.eq(a)) return false;

	      // B' != 0
	      if (this.b.isZero()) return false;

	      // jacobi(B / B') = 1
	      const c = b.redDiv(this.b);
	      return c.redJacobi() === 1;
	    }
	    return curve.isIsomorphic(this, invert);
	  }
	  isIsogenous(curve) {
	    assert(curve instanceof Curve);
	    if (curve.type === 'mont') return false;
	    return curve.isIsogenous(this);
	  }
	  pointFromShort(point) {
	    // [ALT] Appendix E.2 (Switching between Alternative Representations).
	    // [MONT2] "Equivalence with Weierstrass curves"
	    assert(point instanceof ShortPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,b)->M(A,B):
	      //
	      //   u = B * x - A / 3
	      //   v = B * y
	      //
	      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
	      if (point.isInfinity()) return this.point();
	      const {
	        a3,
	        b
	      } = this;
	      const [u2, u3] = this._scale(point.curve);
	      const x = this.field(point.x).redMul(u2);
	      const y = this.field(point.y).redMul(u3);
	      const u = b.redMul(x).redISub(a3);
	      const v = b.redMul(y);
	      return this.point(u, v);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromMont(point) {
	    // [MONT3] Page 3, Section 2.1.
	    assert(point instanceof MontPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for M(A,B)<->M(A,B'):
	      //
	      //   u' = u
	      //   v' = +-sqrt(B / B') * v
	      //
	      // Undefined if (B / B') is not square.
	      if (point.isInfinity()) return this.point();
	      const c = this._scale(point.curve);
	      const u = this.field(point.x);
	      const v = this.field(point.y);
	      const nu = u;
	      const nv = c.redMul(v);
	      return this.point(nu, nv);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromEdwards(point) {
	    // [RFC7748] Section 4.1 & 4.2.
	    // [MONT3] Page 6, Section 2.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    assert(point instanceof EdwardsPoint);
	    assert(point.curve.p.eq(this.p));

	    // Edwards `x`, `y`, `z`.
	    const x = this.field(point.x);
	    const y = this.field(point.y);
	    const z = this.field(point.z);
	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for E(1,d)->M(2-4d,1):
	      //
	      //   u = y^2 / x^2
	      //   v = (2 - x^2 - y^2) * y / x^3
	      //
	      // Undefined for x = 0.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-1, 0) -> (0, 0)
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point(this.zero, this.zero);
	      const c = z.redSqr().redIMuln(2);
	      const uu = y.redSqr();
	      const uz = x.redSqr();
	      const vv = c.redISub(uz).redISub(uu).redMul(y);
	      const vz = uz.redMul(x);
	      return this.cpoint(uu, uz, vv, vz);
	    }
	    if (this.isIsomorphic(point.curve, true)) {
	      // Isomorphic maps for E(d,a)->M(A,B):
	      //
	      //   u = (y + 1) / (y - 1)
	      //   v = +-sqrt((A - 2) / (B * a)) * u / x
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point(this.zero, this.zero);
	      const c = this._scale(point.curve, true);
	      const uu = y.redAdd(z);
	      const uz = y.redSub(z);
	      const vv = c.redMul(z).redMul(uu);
	      const vz = x.redMul(uz);
	      return this.cpoint(uu, uz, vv, vz);
	    }
	    if (this.isIsomorphic(point.curve, false)) {
	      // Isomorphic maps for E(a,d)->M(A,B):
	      //
	      //   u = (1 + y) / (1 - y)
	      //   v = +-sqrt((A + 2) / (B * a)) * u / x
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point(this.zero, this.zero);
	      const c = this._scale(point.curve, false);
	      const uu = z.redAdd(y);
	      const uz = z.redSub(y);
	      const vv = c.redMul(z).redMul(uu);
	      const vz = x.redMul(uz);
	      return this.cpoint(uu, uz, vv, vz);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromUniform(u) {
	    assert(u instanceof BN);

	    // z = 0 or A = 0
	    if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.');
	    return this._elligator2(u);
	  }
	  pointToUniform(p, hint) {
	    // Convert a montgomery point to a field
	    // element by inverting the elligator2 map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof MontPoint);
	    assert(hint >>> 0 === hint);

	    // z = 0 or A = 0
	    if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.');

	    // P = O
	    if (p.isInfinity()) throw new Error('Invalid point.');

	    // Add a random torsion component.
	    const i = (hint >>> 4 & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);
	    return wrapErrors(() => {
	      return this._invert2(q, hint);
	    });
	  }
	  decodePoint(bytes, sign) {
	    return MontPoint.decode(this, bytes, sign);
	  }
	  encodeX(point) {
	    assert(point instanceof XPoint);
	    return point.encode();
	  }
	  decodeX(bytes) {
	    return XPoint.decode(this, bytes);
	  }
	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);
	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });
	    if (sign != null) {
	      const [, u3] = curve._scale(this);
	      if (u3.redIsOdd() !== sign) u3.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
	    return curve;
	  }
	  toMont(b0, sign = null) {
	    const [a, b] = this._mont(b0);
	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });
	    if (sign != null) {
	      const c = curve._scale(this);
	      if (c.redIsOdd() !== sign) c.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
	    return curve;
	  }
	  toEdwards(a0, invert, sign = null) {
	    const [a, d] = this._edwards(a0, invert);
	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });
	    if (sign != null) {
	      const c = curve._scale(this, invert);
	      if (c.redIsOdd() !== sign) c.redINeg();
	    }
	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromMont(this.g);
	      curve.g.normalize();
	    }
	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }
	    return curve;
	  }
	  pointFromJSON(json) {
	    return MontPoint.fromJSON(this, json);
	  }
	  toJSON(pre) {
	    const json = super.toJSON(pre);
	    json.a = this.a.fromRed().toJSON();
	    json.b = this.b.fromRed().toJSON();
	    return json;
	  }
	}

	/**
	 * MontPoint
	 */

	class MontPoint extends Point {
	  constructor(curve, x, y) {
	    assert(curve instanceof MontCurve);
	    super(curve, types.AFFINE);
	    this.x = this.curve.zero;
	    this.y = this.curve.zero;
	    this.inf = true;
	    if (x != null) this._init(x, y);
	  }
	  _init(x, y) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    this.x = x;
	    this.y = y;
	    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	  clone() {
	    if (this.inf) return this.curve.point();
	    return this.curve.point(this.x, this.y);
	  }
	  scale(a) {
	    return this.clone();
	  }
	  randomize(rng) {
	    return this.clone();
	  }
	  neg() {
	    // P = O
	    if (this.inf) return this;

	    // -(X1, Y1) = (X1, -Y1)
	    return this.curve.point(this.x, this.y.redNeg());
	  }
	  add(p) {
	    // [MONT1] Page 8, Section 4.3.2.
	    //
	    // Addition Law:
	    //
	    //   l = (y2 - y1) / (x2 - x1)
	    //   x3 = b * l^2 - a - x1 - x2
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 1S + 7A + 1*b
	    assert(p instanceof MontPoint);

	    // O + P = P
	    if (this.inf) return p;

	    // P + O = P
	    if (p.inf) return this;

	    // P + P, P + -P
	    if (this.x.eq(p.x)) {
	      // P + -P = O
	      if (!this.y.eq(p.y)) return this.curve.point();

	      // P + P = 2P
	      return this.dbl();
	    }

	    // H = X2 - X1
	    const h = p.x.redSub(this.x);

	    // R = Y2 - Y1
	    const r = p.y.redSub(this.y);

	    // L = R / H
	    const l = r.redDiv(h);

	    // K = b * L^2
	    const k = this.curve.b.redMul(l.redSqr());

	    // X3 = K - a - X1 - X2
	    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
	    return this.curve.point(nx, ny);
	  }
	  dbl() {
	    // [MONT1] Page 8, Section 4.3.2.
	    //
	    // Addition Law (doubling):
	    //
	    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)
	    //   x3 = b * l^2 - a - 2 * x1
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3

	    // P = O
	    if (this.inf) return this;

	    // Y1 = 0
	    if (this.y.isZero()) return this.curve.point();

	    // M1 = 3 * X1^2
	    const m1 = this.x.redSqr().redIMuln(3);

	    // M2 = 2 * a * X1
	    const m2 = this.curve.a.redMul(this.x).redIMuln(2);

	    // M = M1 + M2 + 1
	    const m = m1.redIAdd(m2).redIAdd(this.curve.one);

	    // Z = 2 * b * Y1
	    const z = this.curve.b.redMul(this.y).redIMuln(2);

	    // L = M / Z
	    const l = m.redDiv(z);

	    // K = b * L^2
	    const k = this.curve.b.redMul(l.redSqr());

	    // X3 = K - a - 2 * X1
	    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
	    return this.curve.point(nx, ny);
	  }
	  getX() {
	    if (this.inf) throw new Error('Invalid point.');
	    return this.x.fromRed();
	  }
	  getY() {
	    if (this.inf) throw new Error('Invalid point.');
	    return this.y.fromRed();
	  }
	  eq(p) {
	    assert(p instanceof MontPoint);

	    // P = Q
	    if (this === p) return true;

	    // P = O
	    if (this.inf) return p.inf;

	    // Q = O
	    if (p.inf) return false;

	    // X1 = X2, Y1 = Y2
	    return this.x.eq(p.x) && this.y.eq(p.y);
	  }
	  cmp(point) {
	    assert(point instanceof MontPoint);
	    if (this.inf && !point.inf) return -1;
	    if (!this.inf && point.inf) return 1;
	    if (this.inf && point.inf) return 0;
	    return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
	  }
	  isInfinity() {
	    // Infinity cannot be represented in
	    // the affine space, except by a flag.
	    return this.inf;
	  }
	  isOrder2() {
	    if (this.inf) return false;
	    return this.y.isZero();
	  }
	  isOdd() {
	    if (this.inf) return false;
	    return this.y.redIsOdd();
	  }
	  isEven() {
	    if (this.inf) return false;
	    return this.y.redIsEven();
	  }
	  toP() {
	    return this;
	  }
	  toJ() {
	    return this;
	  }
	  toX() {
	    // (X3, Z3) = (1, 0)
	    if (this.inf) return this.curve.xpoint();

	    // (X3, Z3) = (X1, 1)
	    return this.curve.xpoint(this.x, this.curve.one);
	  }
	  encode() {
	    return this.toX().encode();
	  }
	  static decode(curve, bytes, sign) {
	    assert(curve instanceof MontCurve);
	    return curve.decodeX(bytes).toP(sign);
	  }
	  toJSON(pre) {
	    if (this.inf) return [];
	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();
	    return [x, y];
	  }
	  toPretty() {
	    if (this.inf) return [];
	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);
	    return [x, y];
	  }
	  static fromJSON(curve, json) {
	    assert(curve instanceof MontCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0 || json.length === 2 || json.length === 3);
	    if (json.length === 0) return curve.point();
	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);
	    return curve.point(x, y);
	  }
	  [custom]() {
	    if (this.inf) return '<MontPoint: Infinity>';
	    return '<MontPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';
	  }
	}

	/**
	 * XPoint
	 */

	class XPoint extends Point {
	  constructor(curve, x, z) {
	    assert(curve instanceof MontCurve);
	    super(curve, types.PROJECTIVE);
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	    if (x != null) this._init(x, z);
	  }
	  _init(x, z) {
	    assert(x instanceof BN);
	    assert(z == null || z instanceof BN);
	    this.x = x;
	    this.z = z || this.curve.one;
	    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
	  }
	  clone() {
	    return this.curve.xpoint(this.x, this.z);
	  }
	  precompute(power, rng) {
	    // No-op.
	    return this;
	  }
	  validate() {
	    if (this.isInfinity()) return true;

	    // B * y^2 * z = x^3 + A * x^2 * z + x * z^2
	    const {
	      x,
	      z
	    } = this;
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const z2 = z.redSqr();
	    const ax2 = this.curve.a.redMul(x2).redMul(z);
	    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));
	    const y2 = by2.redMul(this.curve.bi);

	    // sqrt(y^2 * z^4) = y * z^2
	    return y2.redMul(z).redJacobi() !== -1;
	  }
	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale
	    // 1I + 1M

	    // P = O
	    if (this.isInfinity()) return this;

	    // Z1 = 1
	    if (this.z.eq(this.curve.one)) return this;

	    // X3 = X1 / Z1
	    this.x = this.x.redDiv(this.z);

	    // Z3 = 1
	    this.z = this.curve.one;
	    return this;
	  }
	  scale(a) {
	    assert(a instanceof BN);

	    // P = O
	    if (this.isInfinity()) return this.curve.xpoint();

	    // X3 = X1 * A
	    const nx = this.x.redMul(a);

	    // Y3 = Y1 * A
	    const nz = this.z.redMul(a);
	    return this.curve.xpoint(nx, nz);
	  }
	  neg() {
	    // -(X1, Z1) = (X1, Z1)
	    return this;
	  }
	  dbl() {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	    // 2M + 2S + 4A + 1*a24

	    // A = X1 + Z1
	    const a = this.x.redAdd(this.z);

	    // AA = A^2
	    const aa = a.redSqr();

	    // B = X1 - Z1
	    const b = this.x.redSub(this.z);

	    // BB = B^2
	    const bb = b.redSqr();

	    // C = AA - BB
	    const c = aa.redSub(bb);

	    // X3 = AA * BB
	    const nx = aa.redMul(bb);

	    // Z3 = C * (BB + a24 * C)
	    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));
	    return this.curve.xpoint(nx, nz);
	  }
	  diffAddDbl(p2, p3) {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3
	    // 6M + 4S + 8A + 1*a24
	    assert(p2 instanceof XPoint);
	    assert(p3 instanceof XPoint);

	    // A = X2 + Z2
	    const a = p2.x.redAdd(p2.z);

	    // AA = A^2
	    const aa = a.redSqr();

	    // B = X2 - Z2
	    const b = p2.x.redSub(p2.z);

	    // BB = B^2
	    const bb = b.redSqr();

	    // E = AA - BB
	    const e = aa.redSub(bb);

	    // C = X3 + Z3
	    const c = p3.x.redAdd(p3.z);

	    // D = X3 - Z3
	    const d = p3.x.redSub(p3.z);

	    // DA = D * A
	    const da = d.redMul(a);

	    // CB = C * B
	    const cb = c.redMul(b);

	    // X5 = Z1 * (DA + CB)^2
	    const x5 = this.z.redMul(da.redAdd(cb).redSqr());

	    // Z5 = X1 * (DA - CB)^2
	    const z5 = this.x.redMul(da.redISub(cb).redSqr());

	    // X4 = AA * BB
	    const x4 = aa.redMul(bb);

	    // Z4 = E * (BB + a24 * E)
	    const z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));
	    return [this.curve.xpoint(x4, z4), this.curve.xpoint(x5, z5)];
	  }
	  getX() {
	    if (this.isInfinity()) throw new Error('Invalid point.');
	    this.normalize();
	    return this.x.fromRed();
	  }
	  getY(sign) {
	    return this.toP(sign).getY();
	  }
	  eq(p) {
	    assert(p instanceof XPoint);

	    // P = Q
	    if (this === p) return true;

	    // P = O
	    if (this.isInfinity()) return p.isInfinity();

	    // Q = O
	    if (p.isInfinity()) return false;

	    // Z1 = Z2
	    if (this.z.eq(p.z)) return this.x.eq(p.x);

	    // X1 * Z2 = X2 * Z1
	    const x1 = this.x.redMul(p.z);
	    const x2 = p.x.redMul(this.z);
	    return x1.eq(x2);
	  }
	  cmp(point) {
	    assert(point instanceof XPoint);
	    const inf1 = this.isInfinity();
	    const inf2 = point.isInfinity();
	    if (inf1 && !inf2) return -1;
	    if (!inf1 && inf2) return 1;
	    if (inf1 && inf2) return 0;
	    return this.order().cmp(point.order()) || this.getX().cmp(point.getX());
	  }
	  isInfinity() {
	    // Z1 = 0
	    return this.z.isZero();
	  }
	  isOrder2() {
	    if (this.isInfinity()) return false;
	    return this.x.isZero();
	  }
	  isOdd() {
	    return false;
	  }
	  isEven() {
	    return false;
	  }
	  hasTorsion() {
	    if (this.isInfinity()) return false;

	    // X1 = 0, Z1 != 0 (edge case)
	    if (this.x.isZero()) return true;
	    return super.hasTorsion();
	  }
	  order() {
	    try {
	      return this.toP().order();
	    } catch (e) {
	      return new BN(1);
	    }
	  }
	  jmul(k) {
	    // Multiply with the Montgomery Ladder.
	    //
	    // [MONT3] Algorithm 4, Page 12, Section 4.2.
	    //
	    // Note that any clamping is meant to
	    // be done _outside_ of this function.
	    assert(k instanceof BN);
	    assert(!k.red);
	    const bits = k.bitLength();
	    let a = this.curve.xpoint();
	    let b = this;
	    for (let i = bits - 1; i >= 0; i--) {
	      const bit = k.bit(i);
	      if (bit === 0) [a, b] = this.diffAddDbl(a, b);else [b, a] = this.diffAddDbl(b, a);
	    }
	    return a;
	  }
	  jmulBlind(k, rng) {
	    if (!rng) return this.jmul(k);

	    // Randomize if available.
	    return this.randomize(rng).jmul(k);
	  }
	  jmulAdd(k1, p2, k2) {
	    throw new Error('Not implemented.');
	  }
	  toP(sign = null) {
	    assert(sign == null || typeof sign === 'boolean');
	    if (this.isInfinity()) return this.curve.point();
	    this.normalize();
	    return this.curve.pointFromX(this.x, sign);
	  }
	  toJ() {
	    return this;
	  }
	  toX() {
	    return this;
	  }
	  key() {
	    if (this.isInfinity()) return `${this.curve.uid}:oo`;
	    this.normalize();
	    const x = this.getX().toString(16);
	    return `${this.curve.uid}:${x}`;
	  }
	  encode() {
	    // [RFC7748] Section 5.
	    return this.curve.encodeField(this.getX());
	  }
	  static decode(curve, bytes) {
	    assert(curve instanceof MontCurve);

	    // [RFC7748] Section 5.
	    const x = curve.decodeField(bytes);

	    // We're supposed to ignore the hi bit
	    // on montgomery points... I think. If
	    // we don't, the X25519 test vectors
	    // break, which is pretty convincing
	    // evidence. This is a no-op for X448.
	    x.iumaskn(curve.fieldBits);

	    // Note: montgomery points are meant to be
	    // reduced by the prime and do not have to
	    // be explicitly validated in order to do
	    // the montgomery ladder.
	    const p = curve.xpoint(x, curve.one);
	    assert(!p.isInfinity());
	    return p;
	  }
	  toJSON(pre) {
	    return this.toP().toJSON(pre);
	  }
	  toPretty() {
	    return this.toP().toPretty();
	  }
	  static fromJSON(curve, json) {
	    return MontPoint.fromJSON(curve, json).toX();
	  }
	  [custom]() {
	    if (this.isInfinity()) return '<XPoint: Infinity>';
	    return '<XPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
	  }
	}

	/**
	 * EdwardsCurve
	 */

	class EdwardsCurve extends Curve {
	  constructor(conf) {
	    super(EdwardsPoint, 'edwards', conf);
	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.d = BN.fromJSON(conf.d).toRed(this.red);
	    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);
	    this.si = this.s.isZero() ? this.zero : this.s.redInvert();
	    this.k = this.d.redMuln(2);
	    this.smi = -this.d.redNeg().word(0);
	    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);
	    this.twisted = !this.a.eq(this.one);
	    this.oneA = this.a.eq(this.one);
	    this.mOneA = this.a.eq(this.one.redNeg());
	    this.smallD = this.prime != null && this.d.redNeg().length === 1;
	    this.alt = null;
	    this._finalize(conf);
	  }
	  static _isomorphism(curveA, curveD, customA) {
	    // Twisted Edwards Isomorphism.
	    //
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    //
	    // Transformation:
	    //
	    //   a' = a'
	    //   d' = a' * d / a
	    //
	    // Where (a / a') is square.
	    assert(curveA instanceof BN);
	    assert(curveD instanceof BN);
	    assert(customA instanceof BN);
	    const a = customA.clone();
	    const d = customA.redMul(curveD).redDiv(curveA);
	    const c = curveA.redDiv(customA);
	    if (c.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
	    return [a, d];
	  }
	  _short(a0, odd) {
	    // Twisted Edwards->Short Weierstrass Equivalence.
	    //
	    // [TWISTEQ] Section 2.
	    //
	    // Transformation:
	    //
	    //   a' = -(a^2 + 14 * a * d + d^2) / 48
	    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864
	    const {
	      a,
	      d
	    } = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const d2 = d.redSqr();
	    const d3 = d2.redMul(d);
	    const ad14 = a.redMul(d).redIMuln(14);
	    const a2d = a2.redMul(d);
	    const ad2 = a.redMul(d2);
	    const t0 = a2d.redIAdd(ad2).redIMuln(33);
	    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);
	    const wb = t0.redISub(a3).redISub(d3).redDivn(864);
	    if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);
	    return [wa, wb];
	  }
	  _mont(b0, invert = false) {
	    // Twisted Edwards->Montgomery Transformation.
	    //
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //
	    // Equivalence:
	    //
	    //   A = 2 * (a + d) / (a - d)
	    //   B = 4 / (a - d)
	    //
	    // Isomorphism:
	    //
	    //   A = 2 * (a + d) / (a - d)
	    //   B = B'
	    //
	    // Where ((4 / (a - d)) / B') is square.
	    //
	    // If `4 / (a - d)` is non-square, we can
	    // usually force B=1 by using the `invert`
	    // option. This will create an isomorphism
	    // chain of: E(a,d)->E(d,a)->M(-A,-B).
	    //
	    // The equivalence between E(a,d) and E(d,a)
	    // is:
	    //
	    //   (x, y) = (x, 1 / y)
	    //
	    // Meaning our map to M(-A,-B) is:
	    //
	    //   u = (1 + 1 / y) / (1 - 1 / y)
	    //     = (y + 1) / (y - 1)
	    //   v = u / x
	    assert(typeof invert === 'boolean');
	    let apd, amd;
	    if (invert) {
	      apd = this.d.redAdd(this.a);
	      amd = this.d.redSub(this.a);
	    } else {
	      apd = this.a.redAdd(this.d);
	      amd = this.a.redSub(this.d);
	    }
	    const z = amd.redInvert();
	    const a = apd.redMuln(2).redMul(z);
	    const b = z.redMuln(4);
	    if (b0 != null) return MontCurve._isomorphism(a, b, b0);
	    return [a, b];
	  }
	  _edwards(a0) {
	    return EdwardsCurve._isomorphism(this.a, this.d, a0);
	  }
	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);
	    const [u2, u3] = curve._scale(this);
	    return [this.field(u2.redInvert()), this.field(u3.redInvert())];
	  }
	  _scaleMont(curve, invert = false) {
	    // Calculate isomorphism factor between
	    // Twisted Edwards and Montgomery with:
	    //
	    //   a = (A + 2) / B
	    //   c = +-sqrt(a / a')
	    //
	    // Which can be reduced to:
	    //
	    //   c = +-sqrt((A + 2) / (B * a'))
	    //
	    // If base points are available, we can do:
	    //
	    //   x = u / v
	    //   c = x' / x
	    //
	    // Which can be reduced to:
	    //
	    //   c = v * x' / u
	    //
	    // We can now calculate the Edwards `x` with:
	    //
	    //   x' = c * u / v
	    //
	    // And likewise, the Montgomery `v`:
	    //
	    //   v = c * u / x'
	    assert(curve instanceof MontCurve);
	    assert(typeof invert === 'boolean');
	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a] = curve._edwards(null, invert);
	      return this.field(a).redDivSqrt(this.a);
	    }
	    const x = curve.g.x.redDiv(curve.g.y);
	    return this.g.x.redDiv(this.field(x));
	  }
	  _scaleEdwards(curve) {
	    // We can extract the isomorphism factor with:
	    //
	    //   c = +-sqrt(a / a')
	    //
	    // If base points are available, we can do:
	    //
	    //   c = x' / x
	    assert(curve instanceof EdwardsCurve);
	    if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.a).redDivSqrt(this.a);
	    return this.g.x.redDiv(this.field(curve.g.x));
	  }
	  _mulA(num) {
	    assert(num instanceof BN);

	    // n * a = n
	    if (this.oneA) return num.clone();

	    // n * a = -n
	    if (this.mOneA) return num.redNeg();
	    return this.a.redMul(num);
	  }
	  _mulD(num) {
	    assert(num instanceof BN);

	    // -d < 0x4000000
	    if (this.smallD) return num.redMuln(this.smi);
	    return this.d.redMul(num);
	  }
	  _elligator1(t) {
	    // Elligator 1.
	    //
	    // Distribution: 1/2.
	    //
	    // [ELL1] Page 6, Section 3.
	    //        Page 15, Appendix A.
	    // [ELL2] Page 7, Section 3.2.
	    //
	    // Assumptions:
	    //
	    //   - Let p be a prime power congruent to 3 mod 4.
	    //   - Let s be a nonzero element of F(p).
	    //   - Let c = 2 / s^2.
	    //   - Let r = c + 1 / c.
	    //   - Let d = -(c + 1)^2 / (c - 1)^2.
	    //   - (s^2 - 2) * (s^2 + 2) != 0.
	    //   - c * (c - 1) * (c + 1) != 0.
	    //   - r != 0.
	    //   - d is not square.
	    //   - x^2 + y^2 = 1 + d * x^2 * y^2.
	    //   - u * v * X * Y * x * (Y + 1) != 0.
	    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.
	    //
	    // Elligator 1, as devised by Fouque et al,
	    // takes place on the hyperelliptic curve of:
	    //
	    //   y^2 = x^5 + (r^2 - 2) * x^3 + x
	    //
	    // Not only must our Edwards curve be complete,
	    // with a prime congruent to 3 mod 4, and a = 1,
	    // our curve must be isomorphic to a hyperelliptic
	    // curve of the above form. Roughly one half of
	    // all Edwards curves are isomorphic to a curve
	    // of said form.
	    //
	    // We can derive the isomorphism with:
	    //
	    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)
	    //   s = +-sqrt(2 / c)
	    //   r = c + 1 / c
	    //
	    // Note that even if your curve is an Elligator 1
	    // curve, Elligator 2 is probably still preferable,
	    // as it has nearly the same properties (i.e. the
	    // same distribution), and is much less complex.
	    //
	    // Map:
	    //
	    //   f(a) = a^((p - 1) / 2)
	    //   u = (1 - t) / (1 + t)
	    //   v = u^5 + (r^2 - 2) * u^3 + u
	    //   X = f(v) * u
	    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)
	    //   Y = 1, if u = 0
	    //   x = (c - 1) * s * X * (1 + X) / Y
	    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)
	    //
	    // When t = +-1, we create the hyperelliptic
	    // 2-torsion point of (0, 0). This needs to be
	    // mapped to (0, -1) in Edwards form, but the x
	    // denominator becomes zero. As far as I can
	    // tell, this is the only exceptional case.
	    //
	    // The only other exceptional case initially
	    // appears to be when the y denominator sums to
	    // zero (when t = sqrt(4 / r + 1)), however, the
	    // hyperelliptic `X` is negated by the sign of
	    // `v`, making this impossible.
	    const {
	      s,
	      si,
	      i2,
	      one,
	      two
	    } = this;
	    const c = si.redSqr().redIMuln(2);
	    const ci = s.redSqr().redMul(i2);
	    const ci2 = ci.redSqr();
	    const r = c.redAdd(ci);
	    const r2 = r.redSqr().redISub(two);
	    const cm1 = c.redSub(one);
	    const uu = one.redSub(t);
	    const uz = one.redAdd(t);
	    const u = uz.isZero() ? uz : uu.redDiv(uz);
	    const u2 = u.redSqr();
	    const u3 = u2.redMul(u);
	    const u5 = u3.redMul(u2);
	    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);
	    const f0 = this.field(v.redJacobi());
	    const f1 = this.field(u2.redAdd(ci2).redJacobi());
	    const f2 = f0.redMul(f1);
	    const X = f0.redMul(u);
	    const Y = f0.redMul(v).redSqrt().redMul(f2);
	    const X1 = one.redAdd(X);
	    const rX = r.redMul(X);
	    const X12 = X1.redSqr();
	    const xx = cm1.redMul(s).redMul(X).redMul(X1);
	    const xz = u.isZero() ? this.one : Y;
	    const yy = rX.redSub(X12);
	    const yz = rX.redAdd(X12);
	    return this.cpoint(xx, xz, yy, yz);
	  }
	  _invert1(p, hint) {
	    // Inverting the Map (Elligator 1).
	    //
	    // [ELL1] Page 6, Section 3.
	    //        Page 15, Appendix A.
	    // [ELL2] Page 7, Section 3.3.
	    //
	    // Assumptions:
	    //
	    //   - y + 1 != 0.
	    //   - (1 + n * r)^2 - 1 is square in F(p).
	    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.
	    //   - Y = (c - 1) * s * X * (1 + X) / x.
	    //
	    // Map:
	    //
	    //   f(a) = a^((p - 1) / 2)
	    //   n = (y - 1) / (2 * (y + 1))
	    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)
	    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))
	    //   u = z * X
	    //   t = (1 - u) / (1 + u)
	    const {
	      s,
	      si,
	      i2,
	      one
	    } = this;
	    const {
	      x,
	      y,
	      z
	    } = p;
	    const sign = hint & 1;
	    const c = si.redSqr().redIMuln(2);
	    const ci = s.redSqr().redMul(i2);
	    const ci2 = ci.redSqr();
	    const r = c.redAdd(ci);
	    const cm1 = c.redSub(one);
	    const nn = y.redSub(z);
	    const nz = y.redAdd(z).redIMuln(2);
	    const n = nz.isZero() ? nz : nn.redDiv(nz);
	    const nr1 = one.redAdd(n.redMul(r));
	    const w2 = nr1.redSqr().redISub(one);
	    const w = w2.redSqrt();
	    const X = w.redSub(nr1);
	    const X1 = one.redAdd(X);
	    const YY = cm1.redMul(s).redMul(X).redMul(X1);
	    const Y = YY.redMul(x.redMul(z));
	    const X2 = X.redSqr().redIAdd(ci2);
	    const Z = this.field(Y.redMul(X2).redJacobi());
	    const u = Z.redMul(X);
	    const tt = one.redSub(u);
	    const tz = one.redAdd(u);
	    const t = tz.isZero() ? tz : tt.redDiv(tz);
	    if (t.redIsOdd() !== Boolean(sign)) t.redINeg();
	    return t;
	  }
	  _alt() {
	    if (!this.alt) this.alt = this.toMont();
	    return this.alt;
	  }
	  isElliptic() {
	    const ad = this.a.redMul(this.d);
	    const amd = this.a.redSub(this.d);

	    // a * d * (a - d) != 0
	    return !ad.redMul(amd).isZero();
	  }
	  jinv() {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    const {
	      a,
	      d
	    } = this;
	    const ad = a.redMul(d);
	    const amd4 = a.redSub(d).redPown(4);
	    const a2 = a.redSqr();
	    const d2 = d.redSqr();
	    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);
	    const lhs = t0.redPown(3).redIMuln(16);
	    const rhs = ad.redMul(amd4);
	    if (rhs.isZero()) throw new Error('Curve is not elliptic.');

	    // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)
	    return lhs.redDiv(rhs).fromRed();
	  }
	  isComplete() {
	    return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
	  }
	  point(x, y, z, t) {
	    return new EdwardsPoint(this, x, y, z, t);
	  }
	  jpoint(x, y, z) {
	    assert(x == null && y == null && z == null);
	    return this.point();
	  }
	  cpoint(xx, xz, yy, yz) {
	    assert(xx instanceof BN);
	    assert(xz instanceof BN);
	    assert(yy instanceof BN);
	    assert(yz instanceof BN);
	    const x = xx.redMul(yz);
	    const y = yy.redMul(xz);
	    const z = xz.redMul(yz);
	    const t = xx.redMul(yy);
	    return this.point(x, y, z, t);
	  }
	  solveX2(y) {
	    // [RFC8032] Section 5.1.3 & 5.2.3.
	    assert(y instanceof BN);

	    // x^2 = (y^2 - 1) / (d * y^2 - a)
	    const y2 = y.redSqr();
	    const rhs = this._mulD(y2).redISub(this.a);
	    const lhs = y2.redISub(this.one);
	    const x2 = lhs.redDiv(rhs);
	    return x2;
	  }
	  solveX(y) {
	    // Optimize with inverse square root trick.
	    //
	    // Note that `0 / 0` can only occur if
	    // `a == d` (i.e. the curve is singular).
	    const y2 = y.redSqr();
	    const rhs = this._mulD(y2).redISub(this.a);
	    const lhs = y2.redISub(this.one);
	    return lhs.redDivSqrt(rhs);
	  }
	  solveY2(x) {
	    assert(x instanceof BN);

	    // y^2 = (a * x^2 - 1) / (d * x^2 - 1)
	    const x2 = x.redSqr();
	    const lhs = this._mulA(x2).redISub(this.one);
	    const rhs = this._mulD(x2).redISub(this.one);
	    const y2 = lhs.redDiv(rhs);
	    return y2;
	  }
	  solveY(x) {
	    // Optimize with inverse square root trick.
	    //
	    // Note that `0 / 0` can only occur if
	    // `a == d` (i.e. the curve is singular).
	    const x2 = x.redSqr();
	    const lhs = this._mulA(x2).redISub(this.one);
	    const rhs = this._mulD(x2).redISub(this.one);
	    return lhs.redDivSqrt(rhs);
	  }
	  validate(point) {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    //           Page 11, Section 6.
	    assert(point instanceof EdwardsPoint);

	    // Z1 = 1
	    if (point.zOne) {
	      // a * x^2 + y^2 = 1 + d * x^2 * y^2
	      const x2 = point.x.redSqr();
	      const y2 = point.y.redSqr();
	      const dxy = this._mulD(x2).redMul(y2);
	      const lhs = this._mulA(x2).redIAdd(y2);
	      const rhs = this.one.redAdd(dxy);
	      const tz = point.t;
	      const xy = point.x.redMul(point.y);
	      return lhs.eq(rhs) && tz.eq(xy);
	    }

	    // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2
	    const x2 = point.x.redSqr();
	    const y2 = point.y.redSqr();
	    const z2 = point.z.redSqr();
	    const z4 = z2.redSqr();
	    const dxy = this._mulD(x2).redMul(y2);
	    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);
	    const rhs = z4.redIAdd(dxy);
	    const tz = point.t.redMul(point.z);
	    const xy = point.x.redMul(point.y);
	    return lhs.eq(rhs) && tz.eq(xy);
	  }
	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');
	    if (!x.red) x = x.toRed(this.red);
	    const y = this.solveY(x);
	    if (sign != null) {
	      if (y.isZero() && sign) throw new Error('Invalid point.');
	      if (y.redIsOdd() !== sign) y.redINeg();
	    }
	    return this.point(x, y);
	  }
	  pointFromY(y, sign = null) {
	    assert(y instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');
	    if (!y.red) y = y.toRed(this.red);
	    const x = this.solveX(y);
	    if (sign != null) {
	      if (x.isZero() && sign) throw new Error('Invalid point.');
	      if (x.redIsOdd() !== sign) x.redINeg();
	    }
	    return this.point(x, y);
	  }
	  isIsomorphic(curve, invert = false) {
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //           Definition 2.1, Page 3, Section 2.
	    assert(curve instanceof Curve);
	    assert(typeof invert === 'boolean');
	    if (!curve.p.eq(this.p)) return false;

	    // E(a,d) <-> E(a,b)
	    if (curve.type === 'short') return curve.isIsomorphic(this);

	    // E(a,d) <-> M(A,B)
	    // E(a,d) <-> M(-A,-B)
	    if (curve.type === 'mont') {
	      // A * (a - d) = 2 * (a + d)
	      const a = this.field(curve.a);
	      let apd, amd;
	      if (invert) {
	        apd = this.d.redAdd(this.a);
	        amd = this.d.redSub(this.a);
	      } else {
	        apd = this.a.redAdd(this.d);
	        amd = this.a.redSub(this.d);
	      }
	      return a.redMul(amd).eq(apd.redIMuln(2));
	    }

	    // E(a,d) <-> E(a',a'd/a)
	    if (curve.type === 'edwards') {
	      // a' * d = a * d'
	      const a = this.field(curve.a);
	      const d = this.field(curve.d);
	      return this.a.redMul(d).eq(a.redMul(this.d));
	    }
	    return false;
	  }
	  isIsogenous(curve) {
	    // Check for the 4-isogenies described by Hamburg:
	    // https://moderncrypto.org/mail-archive/curves/2016/000806.html
	    assert(curve instanceof Curve);
	    if (!curve.p.eq(this.p)) return false;

	    // E(1,d) <-> M(2-4d,1)
	    if (curve.type === 'mont') {
	      if (!this.a.eq(this.one)) return false;
	      const a = this.field(curve.a);
	      const b = this.field(curve.b);
	      const d24 = this.two.redSub(this.d.redMuln(4));
	      return a.eq(d24) && b.eq(this.one);
	    }

	    // E(a,d) <-> E(-a,d-a)
	    if (curve.type === 'edwards') {
	      const a = this.field(curve.a);
	      const d = this.field(curve.d);
	      return a.eq(this.a.redNeg()) && d.eq(this.d.redSub(this.a));
	    }
	    return false;
	  }
	  pointFromShort(point) {
	    // [TWISTEQ] Section 1.
	    assert(point instanceof ShortPoint);
	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,b)->E(a',d'):
	      //
	      //   x' = (6 * x - a' - d') / (6 * y)
	      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')
	      //
	      // Undefined for x = (5 * d' - a') / 12 or y = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - ((a' + d') / 6, 0) -> (0, -1)
	      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)
	      //
	      // Unexceptional Cases:
	      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)
	      if (point.isInfinity()) return this.point();
	      if (point.y.isZero()) return this.point(this.zero, this.one.redNeg());
	      const {
	        a,
	        d
	      } = this;
	      const [u2, u3] = this._scale(point.curve);
	      const a5 = a.redMuln(5);
	      const d5 = d.redMuln(5);
	      const x = this.field(point.x).redMul(u2);
	      const y = this.field(point.y).redMul(u3);
	      const x6 = x.redMuln(6);
	      const x12 = x.redMuln(12);
	      const xx = x6.redSub(a).redISub(d);
	      const xz = y.redMuln(6);
	      const yy = x12.redSub(a5).redIAdd(d);
	      const yz = x12.redAdd(a).redISub(d5);
	      return this.cpoint(xx, xz, yy, yz);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromMont(point) {
	    // [RFC7748] Section 4.1 & 4.2.
	    // [MONT3] Page 6, Section 2.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    assert(point instanceof MontPoint);
	    assert(point.curve.p.eq(this.p));

	    // Montgomery `u`, `v`.
	    const u = this.field(point.x);
	    const v = this.field(point.y);
	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for M(2-4d,1)->E(1,d):
	      //
	      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)
	      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /
	      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)
	      //
	      // Undefined for u = 0 and v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, 1)
	      //
	      // Unexceptional Cases:
	      //   - (-1, +-sqrt(A - 2)) -> (0, 1)
	      //   - (1, +-sqrt(A + 2)) -> (0, -1)
	      //
	      // The point (1, v) is invalid on Curve448.
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point();
	      const u2 = u.redSqr();
	      const u3 = u2.redMul(u);
	      const u4 = u3.redMul(u);
	      const u5 = u4.redMul(u);
	      const v2 = v.redSqr();
	      const a = v.redMuln(4);
	      const b = u2.redSub(this.one);
	      const c = u2.redMuln(2);
	      const d = v2.redMuln(4);
	      const e = u3.redIMuln(2);
	      const f = u.redMul(v2).redIMuln(4);
	      const g = u2.redMul(v2).redIMuln(2);
	      const h = v2.redIMuln(2);
	      const xx = a.redMul(b);
	      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);
	      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();
	      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);
	      return this.cpoint(xx, xz, yy, yz).divn(4);
	    }
	    if (this.isIsomorphic(point.curve, true)) {
	      // Isomorphic maps for M(-A,-B)->E(a,d):
	      //
	      //   x = +-sqrt((A - 2) / (B * a)) * u / v
	      //   y = (u + 1) / (u - 1)
	      //
	      // Undefined for u = 1 or v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, -1)
	      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)
	      //
	      // Unexceptional Cases:
	      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)
	      //
	      // The point (1, v) is invalid on Curve448.
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());
	      const c = this._scale(point.curve, true);
	      const xx = c.redMul(u);
	      const xz = v;
	      const yy = u.redAdd(this.one);
	      const yz = u.redSub(this.one);
	      return this.cpoint(xx, xz, yy, yz);
	    }
	    if (this.isIsomorphic(point.curve, false)) {
	      // Isomorphic maps for M(A,B)->E(a,d):
	      //
	      //   x = +-sqrt((A + 2) / (B * a)) * u / v
	      //   y = (u - 1) / (u + 1)
	      //
	      // Undefined for u = -1 or v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, -1)
	      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)
	      //
	      // Unexceptional Cases:
	      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)
	      //
	      // The point (-1, v) is invalid on Curve25519.
	      if (point.isInfinity()) return this.point();
	      if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());
	      const c = this._scale(point.curve, false);
	      const xx = c.redMul(u);
	      const xz = v;
	      const yy = u.redSub(this.one);
	      const yz = u.redAdd(this.one);
	      return this.cpoint(xx, xz, yy, yz);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromEdwards(point) {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    // [ISOGENY] Page 2, Section 2.
	    assert(point instanceof EdwardsPoint);
	    assert(point.curve.p.eq(this.p));

	    // Edwards `x`, `y`, `z`, `t`.
	    const a = this.field(point.curve.a);
	    const x = this.field(point.x);
	    const y = this.field(point.y);
	    const z = this.field(point.z);
	    const t = this.field(point.t);
	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for E(a,d)<->E(-a,d-a):
	      //
	      //   x' = (2 * x * y) / (y^2 - a * x^2)
	      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)
	      //
	      // Undefined for y^2 - a * x^2 = 0
	      //            or y^2 + a * x^2 = 2.
	      const xy = x.redMul(y);
	      const x2 = x.redSqr();
	      const y2 = y.redSqr();
	      const z2 = z.redSqr();
	      const ax2 = a.redMul(x2);
	      const xx = xy.redIMuln(2);
	      const xz = y2.redSub(ax2);
	      const yy = y2.redAdd(ax2);
	      const yz = z2.redIMuln(2).redISub(yy);
	      const p = this.cpoint(xx, xz, yy, yz);
	      return !this.twisted ? p.divn(4) : p;
	    }
	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for E(a,d)<->E(a',a'd/a):
	      //
	      //   x' = +-sqrt(a / a') * x
	      //   y' = y
	      //
	      // Undefined when (a / a') is not square.
	      const c = this._scale(point.curve);
	      const nx = c.redMul(x);
	      const ny = y;
	      const nz = z;
	      const nt = c.redMul(t);
	      return this.point(nx, ny, nz, nt);
	    }
	    throw new Error('Not implemented.');
	  }
	  pointFromUniform(u, curve = null) {
	    assert(u instanceof BN);
	    assert(u.red === this.red);
	    assert(curve == null || curve instanceof MontCurve);
	    if (!curve) curve = this._alt();
	    const u0 = curve.field(u);
	    const p0 = curve.pointFromUniform(u0);
	    return this.pointFromMont(p0);
	  }
	  pointToUniform(p, hint, curve = null) {
	    // Convert an edwards point to a field
	    // element by inverting the elligator2 map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof EdwardsPoint);
	    assert(hint >>> 0 === hint);
	    assert(curve == null || curve instanceof MontCurve);
	    if (!curve) curve = this._alt();

	    // Add a random torsion component.
	    const i = (hint >> 4 & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    // Convert and invert.
	    const p0 = curve.pointFromEdwards(q);
	    const u0 = curve.pointToUniform(p0, hint & 15);
	    return this.field(u0);
	  }
	  pointFromHash(bytes, pake, curve = null) {
	    assert(curve == null || curve instanceof MontCurve);
	    if (!curve) curve = this._alt();
	    const p0 = curve.pointFromHash(bytes, pake);
	    return this.pointFromMont(p0);
	  }
	  pointToHash(p, subgroup, rng, curve = null) {
	    assert(p instanceof EdwardsPoint);
	    assert(subgroup >>> 0 === subgroup);
	    assert(curve == null || curve instanceof MontCurve);
	    if (!curve) curve = this._alt();

	    // Add a random torsion component.
	    const i = subgroup % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    // Convert and invert.
	    const p0 = curve.pointFromEdwards(q);
	    return curve.pointToHash(p0, 0, rng);
	  }
	  decodePoint(bytes) {
	    return EdwardsPoint.decode(this, bytes);
	  }
	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);
	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });
	    if (sign != null) {
	      const [, u3] = curve._scale(this);
	      if (u3.redIsOdd() !== sign) u3.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
	    return curve;
	  }
	  toMont(b0, invert, sign = null) {
	    const [a, b] = this._mont(b0, invert);
	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });
	    if (sign != null) {
	      const c = this._scale(curve, invert);
	      if (c.redIsOdd() !== sign) c.redINeg();
	    }
	    if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);
	    for (let i = 0; i < this.h.word(0); i++) curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
	    return curve;
	  }
	  toEdwards(a0, sign = null) {
	    const [a, d] = this._edwards(a0);
	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });
	    if (sign != null) {
	      const c = curve._scale(this);
	      if (c.redIsOdd() !== sign) c.redINeg();
	    }
	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromEdwards(this.g);
	      curve.g.normalize();
	    }
	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }
	    return curve;
	  }
	  pointFromJSON(json) {
	    return EdwardsPoint.fromJSON(this, json);
	  }
	  toJSON(pre) {
	    const json = super.toJSON(pre);
	    json.a = this.a.fromRed().toJSON();
	    json.d = this.d.fromRed().toJSON();
	    if (!this.s.isZero()) json.s = this.s.fromRed().toJSON();
	    return json;
	  }
	}

	/**
	 * EdwardsPoint
	 */

	class EdwardsPoint extends Point {
	  constructor(curve, x, y, z, t) {
	    assert(curve instanceof EdwardsCurve);
	    super(curve, types.EXTENDED);
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	    if (x != null) this._init(x, y, z, t);
	  }
	  _init(x, y, z, t) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    assert(z == null || z instanceof BN);
	    assert(t == null || t instanceof BN);
	    this.x = x;
	    this.y = y;
	    this.z = z || this.curve.one;
	    this.t = t || null;
	    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z.eq(this.curve.one);
	    this._check();
	    if (!this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne) this.t = this.t.redDiv(this.z);
	    }
	  }
	  _check() {
	    // In order to achieve complete
	    // addition formulas, `a` must
	    // be a square (always the case
	    // for a=1), and `d` must be a
	    // non-square.
	    //
	    // If this is not the case, the
	    // addition formulas may have
	    // exceptional cases where Z3=0.
	    //
	    // In particular, this can occur
	    // when: Q*h = -P*h and Q != -P.
	    //
	    // This is assuming 4-torsion is
	    // involved (the 4-torsion point
	    // is _not_ representable when
	    // `d` is square).
	    if (this.z.isZero()) throw new Error('Invalid point.');
	  }
	  clone() {
	    return this.curve.point(this.x, this.y, this.z, this.t);
	  }
	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z
	    // 1I + 2M (+ 1M if extended)

	    // Z1 = 1
	    if (this.zOne) return this;

	    // A = 1 / Z1
	    const a = this.z.redInvert();

	    // X3 = X1 * A
	    this.x = this.x.redMul(a);

	    // Y3 = Y1 * A
	    this.y = this.y.redMul(a);

	    // T3 = T1 * A
	    this.t = this.t.redMul(a);

	    // Z3 = 1
	    this.z = this.curve.one;
	    this.zOne = true;
	    return this;
	  }
	  scale(a) {
	    assert(a instanceof BN);

	    // X3 = X1 * A
	    const nx = this.x.redMul(a);

	    // Y3 = Y1 * A
	    const ny = this.y.redMul(a);

	    // Z3 = Z1 * A
	    const nz = this.z.redMul(a);

	    // T3 = T1 * A
	    const nt = this.t.redMul(a);
	    return this.curve.point(nx, ny, nz, nt);
	  }
	  neg() {
	    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)
	    const nx = this.x.redNeg();
	    const ny = this.y;
	    const nz = this.z;
	    const nt = this.t.redNeg();
	    return this.curve.point(nx, ny, nz, nt);
	  }
	  add(p) {
	    assert(p instanceof EdwardsPoint);

	    // P = O
	    if (this.isInfinity()) return p;

	    // Q = O
	    if (p.isInfinity()) return this;

	    // Z1 = 1
	    if (this.zOne) return p._add(this);
	    return this._add(p);
	  }
	  _add(p) {
	    // a = -1
	    if (this.curve.mOneA) return this._addM1(p);
	    return this._addA(p);
	  }
	  _addM1(p) {
	    // Assumes a = -1.
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
	    // 8M + 8A + 1*k + 1*2
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3
	    // 7M + 8A + 1*k + 1*2

	    // A = (Y1 - X1) * (Y2 - X2)
	    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));

	    // B = (Y1 + X1) * (Y2 + X2)
	    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));

	    // C = T1 * k * T2
	    const c = this.t.redMul(this.curve.k).redMul(p.t);

	    // D = Z1 * 2 * Z2
	    const d = p.zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);

	    // E = B - A
	    const e = b.redSub(a);

	    // F = D - C
	    const f = d.redSub(c);

	    // G = D + C
	    const g = d.redIAdd(c);

	    // H = B + A
	    const h = b.redIAdd(a);

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);
	    return this.curve.point(nx, ny, nz, nt);
	  }
	  _addA(p) {
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
	    // 9M + 7A + 1*a + 1*d
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd
	    // 8M + 7A + 1*a + 1*d

	    // A = X1 * X2
	    const a = this.x.redMul(p.x);

	    // B = Y1 * Y2
	    const b = this.y.redMul(p.y);

	    // C = T1 * d * T2
	    const c = this.curve._mulD(this.t).redMul(p.t);

	    // D = Z1 * Z2
	    const d = p.zOne ? this.z.clone() : this.z.redMul(p.z);

	    // + XYXY = (X1 + Y1) * (X2 + Y2)
	    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));

	    // E = (X1 + Y1) * (X2 + Y2) - A - B
	    const e = xyxy.redISub(a).redISub(b);

	    // F = D - C
	    const f = d.redSub(c);

	    // G = D + C
	    const g = d.redIAdd(c);

	    // H = B - a * A
	    const h = b.redISub(this.curve._mulA(a));

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);
	    return this.curve.point(nx, ny, nz, nt);
	  }
	  dbl() {
	    // P = O
	    if (this.isInfinity()) return this;
	    return this._dbl();
	  }
	  _dbl() {
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
	    // 4M + 4S + 6A + 1*a + 1*2
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd
	    // 3M + 4S + 7A + 1*a + 1*2

	    // A = X1^2
	    const a = this.x.redSqr();

	    // B = Y1^2
	    const b = this.y.redSqr();

	    // C = 2 * Z1^2
	    const c = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2);

	    // D = a * A
	    const d = this.curve._mulA(a);

	    // E = (X1 + Y1)^2 - A - B
	    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);

	    // G = D + B
	    const g = d.redAdd(b);

	    // F = G - C
	    const f = g.redSub(c);

	    // H = D - B
	    const h = d.redISub(b);

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);
	    return this.curve.point(nx, ny, nz, nt);
	  }
	  getX() {
	    this.normalize();
	    return this.x.fromRed();
	  }
	  getY() {
	    this.normalize();
	    return this.y.fromRed();
	  }
	  eq(p) {
	    assert(p instanceof EdwardsPoint);
	    assert(!this.z.isZero());
	    assert(!p.z.isZero());

	    // P = Q
	    if (this === p) return true;

	    // Z1 = Z2
	    if (this.z.eq(p.z)) {
	      return this.x.eq(p.x) && this.y.eq(p.y);
	    }

	    // X1 * Z2 = X2 * Z1
	    const x1 = this.x.redMul(p.z);
	    const x2 = p.x.redMul(this.z);
	    if (!x1.eq(x2)) return false;
	    const y1 = this.y.redMul(p.z);
	    const y2 = p.y.redMul(this.z);
	    return y1.eq(y2);
	  }
	  cmp(point) {
	    assert(point instanceof EdwardsPoint);
	    return this.order().cmp(point.order()) || this.getY().cmp(point.getY()) || this.getX().cmp(point.getX());
	  }
	  isInfinity() {
	    assert(!this.z.isZero());

	    // X1 = 0
	    if (!this.x.isZero()) return false;

	    // Y1 = Z1
	    return this.y.eq(this.z);
	  }
	  isOrder2() {
	    if (this.isInfinity()) return false;
	    return this.x.isZero();
	  }
	  isOdd() {
	    this.normalize();
	    return this.x.redIsOdd();
	  }
	  isEven() {
	    this.normalize();
	    return this.x.redIsEven();
	  }
	  toP() {
	    return this.normalize();
	  }
	  toJ() {
	    return this;
	  }
	  encode() {
	    // [RFC8032] Section 5.1.2.
	    const y = this.getY();

	    // Note: `x` normalized from `getY()` call.
	    y.setn(this.curve.signBit, this.x.redIsOdd());
	    return this.curve.encodeAdjusted(y);
	  }
	  static decode(curve, bytes) {
	    // [RFC8032] Section 5.1.3.
	    assert(curve instanceof EdwardsCurve);
	    const y = curve.decodeAdjusted(bytes);
	    const sign = y.testn(curve.signBit) !== 0;
	    y.setn(curve.signBit, 0);
	    if (y.cmp(curve.p) >= 0) throw new Error('Invalid point.');
	    return curve.pointFromY(y, sign);
	  }
	  toJSON(pre) {
	    if (this.isInfinity()) return [];
	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();
	    if (pre === true && this.pre) return [x, y, this.pre.toJSON()];
	    return [x, y];
	  }
	  toPretty() {
	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);
	    return [x, y];
	  }
	  static fromJSON(curve, json) {
	    assert(curve instanceof EdwardsCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0 || json.length === 2 || json.length === 3);
	    if (json.length === 0) return curve.point();
	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);
	    const point = curve.point(x, y);
	    if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);
	    return point;
	  }
	  [custom]() {
	    if (this.isInfinity()) return '<EdwardsPoint: Infinity>';
	    return '<EdwardsPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
	  }
	}

	/**
	 * Precomp
	 */

	class Precomp {
	  constructor() {
	    this.naf = null;
	    this.windows = null;
	    this.doubles = null;
	    this.blinding = null;
	    this.beta = null;
	  }
	  map(func) {
	    assert(typeof func === 'function');
	    const out = new this.constructor();
	    if (this.naf) out.naf = this.naf.map(func);
	    if (this.doubles) out.doubles = this.doubles.map(func);
	    return out;
	  }
	  toJSON() {
	    return {
	      naf: this.naf ? this.naf.toJSON() : null,
	      windows: this.windows ? this.windows.toJSON() : null,
	      doubles: this.doubles ? this.doubles.toJSON() : null,
	      blinding: this.blinding ? this.blinding.toJSON() : undefined
	    };
	  }
	  fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    if (json.naf != null) this.naf = NAF.fromJSON(point, json.naf);
	    if (json.windows != null) this.windows = Windows.fromJSON(point, json.windows);
	    if (json.doubles != null) this.doubles = Doubles.fromJSON(point, json.doubles);
	    if (json.blinding != null) this.blinding = Blinding.fromJSON(point, json.blinding);
	    return this;
	  }
	  static fromJSON(point, json) {
	    return new this().fromJSON(point, json);
	  }
	}

	/**
	 * NAF
	 */

	class NAF {
	  constructor(width, points) {
	    this.width = width;
	    this.points = points;
	  }
	  map(func) {
	    assert(typeof func === 'function');
	    const {
	      width
	    } = this;
	    const points = [];
	    for (const point of this.points) points.push(func(point));
	    return new this.constructor(width, points);
	  }
	  toJSON() {
	    return {
	      width: this.width,
	      points: this.points.slice(1).map(point => {
	        return point.toJSON();
	      })
	    };
	  }
	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert(json.width >>> 0 === json.width);
	    assert(Array.isArray(json.points));
	    const {
	      curve
	    } = point;
	    const {
	      width
	    } = json;
	    const points = [point];
	    for (const item of json.points) points.push(curve.pointFromJSON(item));
	    return new this(width, points);
	  }
	}

	/**
	 * Windows
	 */

	class Windows {
	  constructor(width, bits, points) {
	    this.width = width;
	    this.bits = bits;
	    this.points = points;
	  }
	  toJSON() {
	    return {
	      width: this.width,
	      bits: this.bits,
	      points: this.points.slice(1).map(point => {
	        return point.toJSON();
	      })
	    };
	  }
	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert(json.width >>> 0 === json.width);
	    assert(json.bits >>> 0 === json.bits);
	    assert(Array.isArray(json.points));
	    const {
	      curve
	    } = point;
	    const {
	      width,
	      bits
	    } = json;
	    const points = [point];
	    for (const item of json.points) points.push(curve.pointFromJSON(item));
	    return new this(width, bits, points);
	  }
	}

	/**
	 * Doubles
	 */

	class Doubles {
	  constructor(step, points) {
	    this.step = step;
	    this.points = points;
	  }
	  map(func) {
	    assert(typeof func === 'function');
	    const {
	      step
	    } = this;
	    const points = [];
	    for (const point of this.points) points.push(func(point));
	    return new this.constructor(step, points);
	  }
	  toJSON() {
	    return {
	      step: this.step,
	      points: this.points.slice(1).map(point => {
	        return point.toJSON();
	      })
	    };
	  }
	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert(json.step >>> 0 === json.step);
	    assert(Array.isArray(json.points));
	    const {
	      curve
	    } = point;
	    const {
	      step
	    } = json;
	    const points = [point];
	    for (const item of json.points) points.push(curve.pointFromJSON(item));
	    return new this(step, points);
	  }
	}

	/**
	 * Blinding
	 */

	class Blinding {
	  constructor(blind, unblind) {
	    this.blind = blind;
	    this.unblind = unblind;
	  }
	  toJSON() {
	    return {
	      blind: this.blind.toJSON(),
	      unblind: this.unblind.toJSON()
	    };
	  }
	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    const {
	      curve
	    } = point;
	    const blind = BN.fromJSON(json.blind);
	    const unblind = curve.pointFromJSON(json.unblind);
	    return new this(blind, unblind);
	  }
	}

	/**
	 * Endo
	 */

	class Endo {
	  constructor(beta, lambda, basis, pre) {
	    this.beta = beta;
	    this.lambda = lambda;
	    this.basis = basis;
	    this.pre = pre;
	  }
	  toJSON() {
	    return {
	      beta: this.beta.fromRed().toJSON(),
	      lambda: this.lambda.toJSON(),
	      basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],
	      pre: [this.pre[0], this.pre[1].toJSON(), this.pre[2].toJSON()]
	    };
	  }
	  static fromJSON(curve, json) {
	    assert(curve instanceof Curve);
	    assert(json && typeof json === 'object');
	    assert(Array.isArray(json.basis));
	    assert(Array.isArray(json.pre));
	    assert(json.basis.length === 2);
	    assert(json.pre.length === 3);
	    assert(json.pre[0] >>> 0 === json.pre[0]);
	    const beta = BN.fromJSON(json.beta).toRed(curve.red);
	    const lambda = BN.fromJSON(json.lambda);
	    const basis = [Vector.fromJSON(json.basis[0]), Vector.fromJSON(json.basis[1])];
	    const pre = [json.pre[0], BN.fromJSON(json.pre[1]), BN.fromJSON(json.pre[2])];
	    return new this(beta, lambda, basis, pre);
	  }
	}

	/**
	 * Vector
	 */

	class Vector {
	  constructor(a, b) {
	    this.a = a;
	    this.b = b;
	  }
	  toJSON() {
	    return {
	      a: this.a.toJSON(),
	      b: this.b.toJSON()
	    };
	  }
	  static fromJSON(json) {
	    assert(json && typeof json === 'object');
	    const a = BN.fromJSON(json.a);
	    const b = BN.fromJSON(json.b);
	    return new this(a, b);
	  }
	}

	/**
	 * P192
	 * https://tinyurl.com/fips-186-2 (page 29)
	 * https://tinyurl.com/fips-186-3 (page 88)
	 */

	class P192 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P192',
	      ossl: 'prime192v1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'p192',
	      // 2^192 - 2^64 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff fffffffc'],
	      b: ['64210519 e59c80e7 0fa7e9ab 72243049', 'feb8deec c146b9b1'],
	      n: ['ffffffff ffffffff ffffffff 99def836', '146bc9b1 b4d22831'],
	      h: '1',
	      // Icart
	      z: '-5',
	      g: [['188da80e b03090f6 7cbf20eb 43a18800', 'f4ff0afd 82ff1012'], ['07192b95 ffc8da78 631011ed 6b24cdd5', '73f977a1 1e794811'], pre]
	    });
	  }
	}

	/**
	 * P224
	 * https://tinyurl.com/fips-186-2 (page 30)
	 * https://tinyurl.com/fips-186-3 (page 88)
	 */

	class P224 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P224',
	      ossl: 'secp224r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'p224',
	      // 2^224 - 2^96 + 1 (1 mod 16)
	      p: ['ffffffff ffffffff ffffffff ffffffff', '00000000 00000000 00000001'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff fffffffe'],
	      b: ['b4050a85 0c04b3ab f5413256 5044b0b7', 'd7bfd8ba 270b3943 2355ffb4'],
	      n: ['ffffffff ffffffff ffffffff ffff16a2', 'e0b8f03e 13dd2945 5c5c2a3d'],
	      h: '1',
	      // SSWU
	      z: '1f',
	      g: [['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3', '56c21122 343280d6 115c1d21'], ['bd376388 b5f723fb 4c22dfe6 cd4375a0', '5a074764 44d58199 85007e34'], pre]
	    });
	  }
	}

	/**
	 * P256
	 * https://tinyurl.com/fips-186-2 (page 31)
	 * https://tinyurl.com/fips-186-3 (page 89)
	 */

	class P256 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P256',
	      ossl: 'prime256v1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: null,
	      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
	      p: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff ffffffff'],
	      // -3 mod p
	      a: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff fffffffc'],
	      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc', '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],
	      n: ['ffffffff 00000000 ffffffff ffffffff', 'bce6faad a7179e84 f3b9cac2 fc632551'],
	      h: '1',
	      // SSWU
	      z: '-a',
	      g: [['6b17d1f2 e12c4247 f8bce6e5 63a440f2', '77037d81 2deb33a0 f4a13945 d898c296'], ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16', '2bce3357 6b315ece cbb64068 37bf51f5'], pre]
	    });
	  }
	}

	/**
	 * P384
	 * https://tinyurl.com/fips-186-2 (page 32)
	 * https://tinyurl.com/fips-186-3 (page 89)
	 */

	class P384 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P384',
	      ossl: 'secp384r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA384',
	      prime: null,
	      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 ffffffff'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 fffffffc'],
	      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19', '181d9c6e fe814112 0314088f 5013875a', 'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],
	      n: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff c7634d81 f4372ddf', '581a0db2 48b0a77a ecec196a ccc52973'],
	      h: '1',
	      // Icart
	      z: '-c',
	      g: [['aa87ca22 be8b0537 8eb1c71e f320ad74', '6e1d3b62 8ba79b98 59f741e0 82542a38', '5502f25d bf55296c 3a545e38 72760ab7'], ['3617de4a 96262c6f 5d9e98bf 9292dc29', 'f8f41dbd 289a147c e9da3113 b5f0b8c0', '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'], pre]
	    });
	  }
	}

	/**
	 * P521
	 * https://tinyurl.com/fips-186-2 (page 33)
	 * https://tinyurl.com/fips-186-3 (page 90)
	 */

	class P521 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P521',
	      ossl: 'secp521r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA512',
	      prime: 'p521',
	      // 2^521 - 1 (= 3 mod 4)
	      p: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff'],
	      // -3 mod p
	      a: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffc'],
	      b: ['00000051 953eb961 8e1c9a1f 929a21a0', 'b68540ee a2da725b 99b315f3 b8b48991', '8ef109e1 56193951 ec7e937b 1652c0bd', '3bb1bf07 3573df88 3d2c34f1 ef451fd4', '6b503f00'],
	      n: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffa 51868783 bf2f966b 7fcc0148', 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e', '91386409'],
	      h: '1',
	      // SSWU
	      z: '-4',
	      g: [['000000c6 858e06b7 0404e9cd 9e3ecb66', '2395b442 9c648139 053fb521 f828af60', '6b4d3dba a14b5e77 efe75928 fe1dc127', 'a2ffa8de 3348b3c1 856a429b f97e7e31', 'c2e5bd66'], ['00000118 39296a78 9a3bc004 5c8a5fb4', '2c7d1bd9 98f54449 579b4468 17afbd17', '273e662c 97ee7299 5ef42640 c550b901', '3fad0761 353c7086 a272c240 88be9476', '9fd16650'], pre]
	    });
	  }
	}

	/**
	 * SECP256K1
	 * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)
	 * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)
	 */

	class SECP256K1 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'SECP256K1',
	      ossl: 'secp256k1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'k256',
	      // 2^256 - 2^32 - 977 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe fffffc2f'],
	      a: '0',
	      b: '7',
	      n: ['ffffffff ffffffff ffffffff fffffffe', 'baaedce6 af48a03b bfd25e8c d0364141'],
	      h: '1',
	      // SVDW
	      z: '1',
	      // sqrt(-3)
	      c: ['0a2d2ba9 3507f1df 233770c2 a797962c', 'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],
	      g: [['79be667e f9dcbbac 55a06295 ce870b07', '029bfcdb 2dce28d9 59f2815b 16f81798'], ['483ada77 26a3c465 5da4fbfc 0e1108a8', 'fd17b448 a6855419 9c47d08f fb10d4b8'], pre],
	      // Precomputed endomorphism.
	      endo: {
	        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9', '9cf04975 12f58995 c1396c28 719501ee'],
	        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a', '122e22ea 20816678 df02967c 1b23bd72'],
	        basis: [{
	          a: '3086d221a7d46bcde86c90e49284eb15',
	          b: '-e4437ed6010e88286f547fa90abfe4c3'
	        }, {
	          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	          b: '3086d221a7d46bcde86c90e49284eb15'
	        }],
	        pre: [384, ['3086d221 a7d46bcd e86c90e4 9284eb15', '3daa8a14 71e8ca7f e893209a 45dbb031'], ['-', 'e4437ed6 010e8828 6f547fa9 0abfe4c4', '221208ac 9df506c6 1571b4ae 8ac47f71']]
	      }
	    });
	  }
	}

	/**
	 * BRAINPOOLP256
	 * https://tools.ietf.org/html/rfc5639#section-3.4
	 */

	class BRAINPOOLP256 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP256',
	      ossl: 'brainpoolP256r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72', '6e3bf623 d5262028 2013481d 1f6e5377'],
	      a: ['7d5a0975 fc2c3057 eef67530 417affe7', 'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],
	      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf', '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],
	      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71', '8c397aa3 b561a6f7 901e0e82 974856a7'],
	      h: '1',
	      // Icart
	      z: '-2',
	      g: [['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af', 'b9de27e1 e3bd23c2 3a4453bd 9ace3262'], ['547ef835 c3dac4fd 97f8461a 14611dc9', 'c2774513 2ded8e54 5c1d54c7 2f046997'], pre]
	    });
	  }
	}

	/**
	 * BRAINPOOLP384
	 * https://tools.ietf.org/html/rfc5639#section-3.6
	 */

	class BRAINPOOLP384 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP384',
	      ossl: 'brainpoolP384r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA384',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b4 12b1da19 7fb71123', 'acd3a729 901d1a71 87470013 3107ec53'],
	      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0', 'c2bea28e 4fb22787 139165ef ba91f90f', '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],
	      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c', '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5', '7cb43902 95dbc994 3ab78696 fa504c11'],
	      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b3 1f166e6c ac0425a7', 'cf3ab6af 6b7fc310 3b883202 e9046565'],
	      h: '1',
	      // SSWU
	      z: '-5',
	      g: [['1d1c64f0 68cf45ff a2a63a81 b7c13f6b', '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8', 'e826e034 36d646aa ef87b2e2 47d4af1e'], ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552', '62b70b29 feec5864 e19c054f f9912928', '0e464621 77918111 42820341 263c5315'], pre]
	    });
	  }
	}

	/**
	 * BRAINPOOLP512
	 * https://tools.ietf.org/html/rfc5639#section-3.7
	 */

	class BRAINPOOLP512 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP512',
	      ossl: 'brainpoolP512r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA512',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330871', '7d4d9b00 9bc66842 aecda12a e6a380e6', '2881ff2f 2d82c685 28aa6056 583a48f3'],
	      a: ['7830a331 8b603b89 e2327145 ac234cc5', '94cbdd8d 3df91610 a83441ca ea9863bc', '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5', '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],
	      b: ['3df91610 a83441ca ea9863bc 2ded5d5a', 'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7', '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67', '984050b7 5ebae5dd 2809bd63 8016f723'],
	      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330870', '553e5c41 4ca92619 41866119 7fac1047', '1db1d381 085ddadd b5879682 9ca90069'],
	      h: '1',
	      // Icart
	      z: '7',
	      g: [['81aee4bd d82ed964 5a21322e 9c4c6a93', '85ed9f70 b5d916c1 b43b62ee f4d0098e', 'ff3b1f78 e2d0d48d 50d1687b 93b97d5f', '7c6d5047 406a5e68 8b352209 bcb9f822'], ['7dde385d 566332ec c0eabfa9 cf7822fd', 'f209f700 24a57b1a a000c55b 881f8111', 'b2dcde49 4a5f485e 5bca4bd8 8a2763ae', 'd1ca2b2f a8f05406 78cd1e0f 3ad80892'], pre]
	    });
	  }
	}

	/**
	 * X25519
	 * https://tools.ietf.org/html/rfc7748#section-4.1
	 */

	class X25519 extends MontCurve {
	  constructor() {
	    super({
	      id: 'X25519',
	      ossl: 'X25519',
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHA512',
	      prime: 'p25519',
	      // 2^255 - 19 (= 5 mod 8)
	      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
	      // 486662
	      a: '76d06',
	      b: '1',
	      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
	      h: '8',
	      // Elligator 2
	      z: '2',
	      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000009'],
	      // See: https://www.rfc-editor.org/errata/eid4730
	      ['5f51e65e 475f794b 1fe122d3 88b72eb3', '6dc2b281 92839e4d d6163a5d 81312c14']],
	      torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'], ['6be4f497 f9a9c2af c21fa77a d7f4a6ef', '635a11c7 284a9363 e9a248ef 9c884415']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'], ['141b0b68 06563d50 3de05885 280b5910', '9ca5ee38 d7b56c9c 165db710 6377bbd8']], [['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'], ['68c59389 3d458e64 31c6ca00 45fb5015', '20a44346 8eaa68dd 0f103842 048065b7']], [['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'], ['173a6c76 c2ba719b ce3935ff ba04afea', 'df5bbcb9 71559722 f0efc7bd fb7f9a36']], [['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'], ['3931c129 569e83a5 29482c14 e628b457', '933bfc29 ed801b4d 68871483 92507b1a']], [['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'], ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8', '6cc403d6 127fe4b2 9778eb7c 6daf84d3']]]
	    });
	  }
	}

	/**
	 * X448
	 * https://tools.ietf.org/html/rfc7748#section-4.2
	 */

	class X448 extends MontCurve {
	  constructor() {
	    super({
	      id: 'X448',
	      ossl: 'X448',
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
	      // 156326
	      a: '262a6',
	      b: '1',
	      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000005'], ['7d235d12 95f5b1f6 6c98ab6e 58326fce', 'cbae5d34 f55545d0 60f75dc2 8df3f6ed', 'b8027e23 46430d21 1312c4b1 50677af7', '6fd7223d 457b5b1a']],
	      torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['ba4d3a08 29b6112f 8812e51b a0bb2abe', 'bc1cb08e b48e5569 36ba50fd d2e7d68a', 'f8cb3216 0522425b 3f990812 abbe635a', 'd37a21e1 7551b193']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['45b2c5f7 d649eed0 77ed1ae4 5f44d541', '43e34f71 4b71aa96 c945af01 2d182975', '0734cde9 faddbda4 c066f7ed 54419ca5', '2c85de1e 8aae4e6c']]]
	    });
	  }
	}

	/**
	 * MONT448
	 * Isomorphic to Ed448-Goldilocks.
	 */

	class MONT448 extends MontCurve {
	  constructor() {
	    super({
	      id: 'MONT448',
	      ossl: null,
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
	      // -78160 / -39082 mod p
	      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5', '5d93f8d2 22746997 60ccffc6 49961ed6', 'c5b05fca c24864ed 6fb59697 931b78da', '84ddecd8 ca2b5cfb'],
	      b: '1',
	      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [['ac0d24cc c6c75cb0 eb71f81e 7a6edf51', '48e88aee 009a2a24 e795687e c28e125a', '3e6730a6 0d46367b aa7fe99d 152128dc', '41321bc7 7817f059'], ['5a4437f6 80c0d0db 9b061276 d5d0ffcc', 'e786ff33 b6a53d30 98746425 82e66f09', '4433dae7 7244a6e2 6b11e905 7228f483', '556c41a5 913f55fe']],
	      torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['bec92fd0 6da2acf2 b4e261e8 7cef0d34', '22e75c18 3c589857 b71924e5 73c2f9ce', 'e18da5f2 466e2f39 3c2eedf0 f105a60a', 'b40c717d 4f1e1fd7']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['4136d02f 925d530d 4b1d9e17 8310f2cb', 'dd18a3e7 c3a767a8 48e6db19 8c3d0631', '1e725a0d b991d0c6 c3d1120f 0efa59f5', '4bf38e82 b0e1e028']]]
	    });
	  }
	}

	/**
	 * ED25519
	 * https://tools.ietf.org/html/rfc8032#section-5.1
	 */

	class ED25519 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ED25519',
	      ossl: 'ED25519',
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHA512',
	      prefix: 'SigEd25519 no Ed25519 collisions',
	      context: false,
	      prime: 'p25519',
	      // 2^255 - 19 (= 5 mod 8)
	      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
	      a: '-1',
	      // -121665 / 121666 mod p
	      d: ['52036cee 2b6ffe73 8cc74079 7779e898', '00700a4d 4141d8ab 75eb4dca 135978a3'],
	      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
	      h: '8',
	      // Elligator 2
	      z: '2',
	      g: [['216936d3 cd6e53fe c0a4e231 fdd6dc5c', '692cc760 9525a7b2 c9562d60 8f25d51a'],
	      // 4/5
	      ['66666666 66666666 66666666 66666666', '66666666 66666666 66666666 66666658'], pre],
	      torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffec']], [['2b832480 4fc1df0b 2b4d0099 3dfbd7a7', '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['547cdb7f b03e20f4 d4b2ff66 c2042858', 'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'], ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']], [['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'], ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']], [['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'], ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']], [['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'], ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']]]
	    });
	  }
	}

	/**
	 * ISO448
	 * https://tools.ietf.org/html/rfc7748#section-4.2
	 * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658
	 */

	class ISO448 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ISO448',
	      ossl: null,
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prefix: 'SigEd448',
	      context: true,
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
	      a: '1',
	      // 39082 / 39081 mod p
	      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc', 'ad461572 42a50f37 809b1da3 412a12e7', '9ccc9c81 264cfe9a d0809970 58fb61c4', '243cc32d baa156b9'],
	      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [['79a70b2b 70400553 ae7c9df4 16c792c6', '1128751a c9296924 0c25a07d 728bdc93', 'e21f7787 ed697224 9de732f3 8496cd11', '69871309 3e9c04fc'],
	      // Note: the RFC has this wrong.
	      ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 80000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], pre],
	      torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']]]
	    });
	  }
	}

	/**
	 * ED448
	 * https://tools.ietf.org/html/rfc8032#section-5.2
	 */

	class ED448 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ED448',
	      ossl: 'ED448',
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prefix: 'SigEd448',
	      context: true,
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
	      a: '1',
	      // -39081 mod p
	      d: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffff6756'],
	      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [['4f1970c6 6bed0ded 221d15a6 22bf36da', '9e146570 470f1767 ea6de324 a3d3a464', '12ae1af7 2ab66511 433b80e1 8b00938e', '2626a82b c70cc05e'], ['693f4671 6eb6bc24 88762037 56c9c762', '4bea7373 6ca39840 87789c1e 05a0c2d7', '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad', '9808795b f230fa14'], pre],
	      torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']]]
	    });
	  }
	}

	/*
	 * Curve Registry
	 */

	const curves = {
	  __proto__: null,
	  P192,
	  P224,
	  P256,
	  P384,
	  P521,
	  SECP256K1,
	  BRAINPOOLP256,
	  BRAINPOOLP384,
	  BRAINPOOLP512,
	  X25519,
	  X448,
	  MONT448,
	  ED25519,
	  ISO448,
	  ED448
	};
	const cache = {
	  __proto__: null,
	  P192: null,
	  P224: null,
	  P256: null,
	  P384: null,
	  P521: null,
	  SECP256K1: null,
	  BRAINPOOLP256: null,
	  BRAINPOOLP384: null,
	  BRAINPOOLP512: null,
	  X25519: null,
	  X448: null,
	  MONT448: null,
	  ED25519: null,
	  ISO448: null,
	  ED448: null
	};
	function curve(name, ...args) {
	  assert(typeof name === 'string');
	  const key = name.toUpperCase();
	  let curve = cache[key];
	  if (!curve) {
	    const Curve = curves[key];
	    if (!Curve) throw new Error(`Curve not found: "${name}".`);
	    curve = new Curve(...args);
	    cache[key] = curve;
	  }
	  return curve;
	}
	function register(name, Curve) {
	  assert(typeof name === 'string');
	  assert(typeof Curve === 'function');
	  const key = name.toUpperCase();
	  if (curves[key]) throw new Error(`Curve already registered: "${name}".`);
	  curves[key] = Curve;
	  cache[key] = null;
	}

	/*
	 * Scalar Recoding
	 */

	function getNAF(k, width, max) {
	  // Computing the width-w NAF of a positive integer.
	  //
	  // [GECC] Algorithm 3.35, Page 100, Section 3.3.
	  //
	  // The above document describes a rather abstract
	  // method of recoding. The more optimal method
	  // below was ported from libsecp256k1.
	  assert(k instanceof BN);
	  assert(!k.red);
	  assert(width >>> 0 === width);
	  assert(max >>> 0 === max);
	  const naf = new Array(max);
	  const bits = k.bitLength() + 1;
	  const sign = k.sign() | 1;
	  assert(bits <= max);
	  for (let i = 0; i < max; i++) naf[i] = 0;
	  let i = 0;
	  let carry = 0;
	  let word;
	  while (i < bits) {
	    if (k.bit(i) === carry) {
	      i += 1;
	      continue;
	    }
	    word = k.bits(i, width) + carry;
	    carry = word >> width - 1 & 1;
	    word -= carry << width;
	    naf[i] = sign * word;
	    i += width;
	  }
	  assert(carry === 0);
	  return naf;
	}
	function getFixedNAF(k, width, max, step) {
	  assert(step >>> 0 === step);

	  // Recode to NAF.
	  const naf = getNAF(k, width, max);

	  // Translate into more windowed form.
	  const len = Math.ceil(naf.length / step);
	  const repr = new Array(len);
	  let i = 0;
	  for (let j = 0; j < naf.length; j += step) {
	    let nafW = 0;
	    for (let k = j + step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k];
	    repr[i++] = nafW;
	  }
	  assert(i === len);
	  return repr;
	}
	function getJSF(k1, k2, max) {
	  // Joint sparse form.
	  //
	  // [GECC] Algorithm 3.50, Page 111, Section 3.3.
	  assert(k1 instanceof BN);
	  assert(k2 instanceof BN);
	  assert(!k1.red);
	  assert(!k2.red);
	  assert(max >>> 0 === max);
	  const jsf = [new Array(max), new Array(max)];
	  const bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;
	  const s1 = k1.sign() | 1;
	  const s2 = k2.sign() | 1;
	  assert(bits <= max);
	  let d1 = 0;
	  let d2 = 0;
	  for (let i = 0; i < bits; i++) {
	    const b1 = k1.bits(i, 3);
	    const b2 = k2.bits(i, 3);

	    // First phase.
	    let m14 = (b1 & 3) + d1 & 3;
	    let m24 = (b2 & 3) + d2 & 3;
	    let u1 = 0;
	    let u2 = 0;
	    if (m14 === 3) m14 = -1;
	    if (m24 === 3) m24 = -1;
	    if (m14 & 1) {
	      const m8 = (b1 & 7) + d1 & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
	    }
	    if (m24 & 1) {
	      const m8 = (b2 & 7) + d2 & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
	    }
	    jsf[0][i] = u1 * s1;
	    jsf[1][i] = u2 * s2;

	    // Second phase.
	    if (2 * d1 === 1 + u1) d1 = 1 - d1;
	    if (2 * d2 === 1 + u2) d2 = 1 - d2;
	  }
	  for (let i = bits; i < max; i++) {
	    jsf[0][i] = 0;
	    jsf[1][i] = 0;
	  }
	  return jsf;
	}
	function getJNAF(c1, c2, max) {
	  const jsf = getJSF(c1, c2, max);
	  const naf = new Array(max);

	  // JSF -> NAF conversion.
	  for (let i = 0; i < max; i++) {
	    const ja = jsf[0][i];
	    const jb = jsf[1][i];
	    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
	  }
	  return naf;
	}

	/*
	 * Helpers
	 */

	function assert(val, msg) {
	  if (!val) {
	    const err = new Error(msg || 'Assertion failed');
	    if (Error.captureStackTrace) Error.captureStackTrace(err, assert);
	    throw err;
	  }
	}
	function wrapErrors(fn) {
	  assert(typeof fn === 'function');
	  try {
	    return fn();
	  } catch (e) {
	    if (e.message === 'X is not a square mod P.' || e.message === 'Not invertible.') {
	      throw new Error('Invalid point.');
	    }
	    throw e;
	  }
	}
	function mod(x, y) {
	  // Euclidean modulo.
	  let r = x % y;
	  if (r < 0) {
	    r += y;
	  }
	  return r;
	}
	function cubeRoot(x) {
	  assert(x instanceof BN);
	  assert(x.red);
	  const p = x.red.m;
	  if (p.cmpn(3) <= 0) return x.clone();

	  // p = 2 mod 3
	  if (p.modrn(3) === 2) {
	    // e = (2 * p - 1) / 3
	    const e = p.ushln(1).isubn(1).idivn(3);
	    return x.redPow(e);
	  }
	  const mod9 = p.modrn(9);

	  // p = 4 mod 9
	  if (mod9 === 4) {
	    // e = (2 * p + 1) / 9
	    const e = p.ushln(1).iaddn(1).idivn(9);
	    const r = x.redPow(e);
	    const c = r.redSqr().redMul(r);
	    if (!c.eq(x)) throw new Error('X is not a cube mod P.');
	    return r;
	  }

	  // p = 7 mod 9
	  if (mod9 === 7) {
	    // e = (p + 2) / 9
	    const e = p.addn(2).idivn(9);
	    const r = x.redPow(e);
	    const c = r.redSqr().redMul(r);
	    if (!c.eq(x)) throw new Error('X is not a cube mod P.');
	    return r;
	  }
	  throw new Error('Not implemented.');
	}
	function cubeRoots(x) {
	  const r0 = cubeRoot(x);

	  // p = 1 mod 3
	  if (x.red.m.modrn(3) === 1) {
	    // Multiply by roots of unity to find other roots.
	    const two = new BN(2).toRed(x.red);
	    const three = new BN(3).toRed(x.red);
	    const i2 = two.redInvert();
	    const s1 = three.redNeg().redSqrt().redMul(i2);
	    const s2 = s1.redNeg();
	    const u1 = s1.redSub(i2);
	    const u2 = s2.redSub(i2);
	    const r1 = r0.redMul(u1);
	    const r2 = r0.redMul(u2);
	    return [r0, r1, r2];
	  }

	  // p = 2 mod 3 guarantees 1 cube root per element.
	  return [r0];
	}
	function uncube(x) {
	  // Find a cube root which is also a quadratic residue.
	  for (const root of cubeRoots(x)) {
	    if (root.redJacobi() >= 0) return root;
	  }
	  throw new Error('X^(1/3) is not a square mod P.');
	}
	function randomInt(rng) {
	  return BN.randomBits(rng, 32).toNumber();
	}
	function memoize(method, self) {
	  const cache = new WeakMap();
	  return function memoized(curve, invert) {
	    const i = invert & 1;
	    const item = cache.get(curve);
	    if (item && item[i] !== null) return item[i];
	    const result = method.call(self, curve, invert);
	    if (!cache.has(curve)) cache.set(curve, [null, null]);
	    cache.get(curve)[i] = result;
	    return result;
	  };
	}
	function toPretty(x, size) {
	  assert(x instanceof BN);
	  assert(size >>> 0 === size);
	  if (size & 7) size += 8 - (size & 7);
	  const str = x.toString(16, size);
	  const chunks = [];
	  const out = [];
	  assert((str.length & 7) === 0);
	  for (let i = 0; i < str.length; i += 8) chunks.push(str.slice(i, i + 8));
	  for (let i = 0; i < chunks.length; i += 4) out.push(chunks.slice(i, i + 4).join(' '));
	  return out;
	}

	/*
	 * Expose
	 */

	elliptic.Curve = Curve;
	elliptic.Point = Point;
	elliptic.ShortCurve = ShortCurve;
	elliptic.ShortPoint = ShortPoint;
	elliptic.JPoint = JPoint;
	elliptic.MontCurve = MontCurve;
	elliptic.MontPoint = MontPoint;
	elliptic.XPoint = XPoint;
	elliptic.EdwardsCurve = EdwardsCurve;
	elliptic.EdwardsPoint = EdwardsPoint;
	elliptic.curves = curves;
	elliptic.curve = curve;
	elliptic.register = register;
	return elliptic;
}

/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */

var ecdsa;
var hasRequiredEcdsa;

function requireEcdsa () {
	if (hasRequiredEcdsa) return ecdsa;
	hasRequiredEcdsa = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const rng = requireRandom();
	const asn1 = requireAsn1();
	const Schnorr = requireSchnorrLegacy();
	const HmacDRBG = requireHmacDrbg();
	const elliptic = requireElliptic();

	/**
	 * ECDSA
	 */

	class ECDSA {
	  constructor(name, hash, xof, pre) {
	    assert(typeof name === 'string');
	    assert(hash);
	    assert(xof);
	    this.id = name;
	    this.type = 'ecdsa';
	    this.hash = hash;
	    this.xof = xof;
	    this.native = 0;
	    this._pre = pre || null;
	    this._curve = null;
	    this._schnorr = null;
	  }
	  get curve() {
	    if (!this._curve) {
	      this._curve = elliptic.curve(this.id, this._pre);
	      this._curve.precompute(rng);
	      this._pre = null;
	    }
	    return this._curve;
	  }
	  get schnorr() {
	    if (!this._schnorr) this._schnorr = new Schnorr(this.curve, this.xof);
	    return this._schnorr;
	  }
	  get size() {
	    return this.curve.fieldSize;
	  }
	  get bits() {
	    return this.curve.fieldBits;
	  }
	  privateKeyGenerate() {
	    const a = this.curve.randomScalar(rng);
	    return this.curve.encodeScalar(a);
	  }
	  privateKeyVerify(key) {
	    assert(Buffer.isBuffer(key));
	    let a;
	    try {
	      a = this.curve.decodeScalar(key);
	    } catch (e) {
	      return false;
	    }
	    return !a.isZero() && a.cmp(this.curve.n) < 0;
	  }
	  privateKeyExport(key) {
	    const pub = this.publicKeyCreate(key, false);
	    const {
	      x,
	      y
	    } = this.publicKeyExport(pub);
	    return {
	      d: Buffer.from(key),
	      x,
	      y
	    };
	  }
	  privateKeyImport(json) {
	    assert(json && typeof json === 'object');
	    const a = BN.decode(json.d, this.curve.endian);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    return this.curve.encodeScalar(a);
	  }
	  privateKeyTweakAdd(key, tweak) {
	    const t = this.curve.decodeScalar(tweak);
	    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    const k = a.add(t).imod(this.curve.n);
	    if (k.isZero()) throw new Error('Invalid private key.');
	    return this.curve.encodeScalar(k);
	  }
	  privateKeyTweakMul(key, tweak) {
	    const t = this.curve.decodeScalar(tweak);
	    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    const k = a.mul(t).imod(this.curve.n);
	    if (k.isZero()) throw new Error('Invalid private key.');
	    return this.curve.encodeScalar(k);
	  }
	  privateKeyNegate(key) {
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    const k = a.neg().imod(this.curve.n);
	    return this.curve.encodeScalar(k);
	  }
	  privateKeyInvert(key) {
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    const k = a.invert(this.curve.n);
	    return this.curve.encodeScalar(k);
	  }
	  publicKeyCreate(key, compress) {
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    const A = this.curve.g.mulBlind(a);
	    return A.encode(compress);
	  }
	  publicKeyConvert(key, compress) {
	    const A = this.curve.decodePoint(key);
	    return A.encode(compress);
	  }
	  publicKeyFromUniform(bytes, compress) {
	    const u = this.curve.decodeUniform(bytes);
	    const A = this.curve.pointFromUniform(u);
	    return A.encode(compress);
	  }
	  publicKeyToUniform(key, hint = rng.randomInt()) {
	    const A = this.curve.decodePoint(key);
	    const u = this.curve.pointToUniform(A, hint);
	    return this.curve.encodeUniform(u, hint >>> 8);
	  }
	  publicKeyFromHash(bytes, compress) {
	    const A = this.curve.pointFromHash(bytes);
	    return A.encode(compress);
	  }
	  publicKeyToHash(key) {
	    const A = this.curve.decodePoint(key);
	    return this.curve.pointToHash(A, 0, rng);
	  }
	  publicKeyVerify(key) {
	    assert(Buffer.isBuffer(key));
	    try {
	      this.curve.decodePoint(key);
	    } catch (e) {
	      return false;
	    }
	    return true;
	  }
	  publicKeyExport(key) {
	    const {
	      x,
	      y
	    } = this.curve.decodePoint(key);
	    return {
	      x: this.curve.encodeField(x.fromRed()),
	      y: this.curve.encodeField(y.fromRed())
	    };
	  }
	  publicKeyImport(json, compress) {
	    assert(json && typeof json === 'object');
	    const x = BN.decode(json.x, this.curve.endian);
	    if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');
	    if (json.y != null) {
	      const y = BN.decode(json.y, this.curve.endian);
	      if (y.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');
	      const A = this.curve.point(x, y);
	      if (!A.validate()) throw new Error('Invalid point.');
	      return A.encode(compress);
	    }
	    const A = this.curve.pointFromX(x, json.sign);
	    return A.encode(compress);
	  }
	  publicKeyTweakAdd(key, tweak, compress) {
	    const t = this.curve.decodeScalar(tweak);
	    if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
	    const A = this.curve.decodePoint(key);
	    const T = this.curve.g.jmul(t);
	    const P = T.add(A);
	    return P.encode(compress);
	  }
	  publicKeyTweakMul(key, tweak, compress) {
	    const t = this.curve.decodeScalar(tweak);
	    if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
	    const A = this.curve.decodePoint(key);
	    const P = A.mul(t);
	    return P.encode(compress);
	  }
	  publicKeyCombine(keys, compress) {
	    assert(Array.isArray(keys));
	    let P = this.curve.jpoint();
	    for (const key of keys) {
	      const A = this.curve.decodePoint(key);
	      P = P.add(A);
	    }
	    return P.encode(compress);
	  }
	  publicKeyNegate(key, compress) {
	    const A = this.curve.decodePoint(key);
	    const P = A.neg();
	    return P.encode(compress);
	  }
	  signatureNormalize(sig) {
	    const [r, s] = this._decodeCompact(sig);
	    if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);
	    return this._encodeCompact(r, s);
	  }
	  signatureNormalizeDER(sig) {
	    const [r, s] = this._decodeDER(sig, false);
	    if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);
	    return this._encodeDER(r, s);
	  }
	  signatureExport(sig) {
	    const [r, s] = this._decodeCompact(sig);
	    return this._encodeDER(r, s);
	  }
	  signatureImport(sig) {
	    const [r, s] = this._decodeDER(sig, false);
	    return this._encodeCompact(r, s);
	  }
	  isLowS(sig) {
	    assert(Buffer.isBuffer(sig));
	    let s;
	    try {
	      [, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return false;
	    }
	    return s.cmp(this.curve.nh) <= 0;
	  }
	  isLowDER(sig) {
	    assert(Buffer.isBuffer(sig));
	    let s;
	    try {
	      [, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return false;
	    }
	    return s.cmp(this.curve.nh) <= 0;
	  }
	  sign(msg, key) {
	    const [r, s] = this._sign(msg, key);
	    return this._encodeCompact(r, s);
	  }
	  signRecoverable(msg, key) {
	    const [r, s, param] = this._sign(msg, key);
	    return [this._encodeCompact(r, s), param];
	  }
	  signDER(msg, key) {
	    const [r, s] = this._sign(msg, key);
	    return this._encodeDER(r, s);
	  }
	  signRecoverableDER(msg, key) {
	    const [r, s, param] = this._sign(msg, key);
	    return [this._encodeDER(r, s), param];
	  }
	  _sign(msg, key) {
	    // ECDSA Signing.
	    //
	    // [SEC1] Page 44, Section 4.1.3.
	    // [GECC] Algorithm 4.29, Page 184, Section 4.4.1.
	    // [RFC6979] Page 9, Section 2.4.
	    // [RFC6979] Page 10, Section 3.2.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `a` be a secret non-zero scalar.
	    //   - Let `k` be a random non-zero scalar.
	    //   - R != O, r != 0, s != 0.
	    //
	    // Computation:
	    //
	    //   k = random integer in [1,n-1]
	    //   R = G * k
	    //   r = x(R) mod n
	    //   s = (r * a + m) / k mod n
	    //   s = -s mod n, if s > n / 2
	    //   S = (r, s)
	    //
	    // We can blind the scalar arithmetic
	    // with a random integer `b` like so:
	    //
	    //   b = random integer in [1,n-1]
	    //   s = (r * (a * b) + m * b) / (k * b) mod n
	    //
	    // Note that `k` must remain secret,
	    // otherwise an attacker can compute:
	    //
	    //   a = (s * k - m) / r mod n
	    //
	    // This means that if two signatures
	    // share the same `r` value, an attacker
	    // can compute:
	    //
	    //   k = (m1 - m2) / (+-s1 - +-s2) mod n
	    //   a = (s1 * k - m1) / r mod n
	    //
	    // Assuming:
	    //
	    //   s1 = (r * a + m1) / k mod n
	    //   s2 = (r * a + m2) / k mod n
	    //
	    // To mitigate this, `k` can be generated
	    // deterministically using the HMAC-DRBG
	    // construction described in [RFC6979].
	    const {
	      n,
	      nh
	    } = this.curve;
	    const G = this.curve.g;
	    const a = this.curve.decodeScalar(key);
	    if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');
	    const m = this._reduce(msg);
	    const nonce = this.curve.encodeScalar(m);
	    const drbg = new HmacDRBG(this.hash, key, nonce);
	    for (;;) {
	      const bytes = drbg.generate(this.curve.scalarSize);
	      const k = this._truncate(bytes);
	      if (k.isZero() || k.cmp(n) >= 0) continue;
	      const R = G.mulBlind(k);
	      if (R.isInfinity()) continue;
	      const x = R.getX();
	      const r = x.mod(n);
	      if (r.isZero()) continue;
	      const b = this.curve.randomScalar(rng);
	      const ki = k.mul(b).fermat(n);
	      const ba = a.mul(b).imod(n);
	      const bm = m.mul(b).imod(n);
	      const sk = r.mul(ba).iadd(bm).imod(n);
	      const s = sk.mul(ki).imod(n);
	      if (s.isZero()) continue;
	      let param = R.isOdd() | !x.eq(r) << 1;
	      if (s.cmp(nh) > 0) {
	        s.ineg().imod(n);
	        param ^= 1;
	      }
	      return [r, s, param];
	    }
	  }
	  verify(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));
	    let r, s;
	    try {
	      [r, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return false;
	    }
	    try {
	      return this._verify(msg, r, s, key);
	    } catch (e) {
	      return false;
	    }
	  }
	  verifyDER(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));
	    let r, s;
	    try {
	      [r, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return false;
	    }
	    try {
	      return this._verify(msg, r, s, key);
	    } catch (e) {
	      return false;
	    }
	  }
	  _verify(msg, r, s, key) {
	    // ECDSA Verification.
	    //
	    // [SEC1] Page 46, Section 4.1.4.
	    // [GECC] Algorithm 4.30, Page 184, Section 4.4.1.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - r != 0, r < n.
	    //   - s != 0, s < n.
	    //   - R != O.
	    //
	    // Computation:
	    //
	    //   u1 = m / s mod n
	    //   u2 = r / s mod n
	    //   R = G * u1 + A * u2
	    //   r == x(R) mod n
	    //
	    // Note that the signer can verify their
	    // own signatures more efficiently with:
	    //
	    //   R = G * ((u1 + u2 * a) mod n)
	    //
	    // Furthermore, we can avoid affinization
	    // of `R` by scaling `r` by `z^2` and
	    // repeatedly adding `n * z^2` to it up
	    // to a certain threshold.
	    const {
	      n
	    } = this.curve;
	    const G = this.curve.g;
	    const m = this._reduce(msg);
	    const A = this.curve.decodePoint(key);
	    if (r.isZero() || r.cmp(n) >= 0) return false;
	    if (s.isZero() || s.cmp(n) >= 0) return false;
	    const si = s.invert(n);
	    const u1 = m.mul(si).imod(n);
	    const u2 = r.mul(si).imod(n);
	    const R = G.jmulAdd(u1, A, u2);
	    return R.eqR(r);
	  }
	  recover(msg, sig, param, compress) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(param >>> 0 === param);
	    assert((param & 3) === param, 'The recovery param is more than two bits.');
	    let r, s;
	    try {
	      [r, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return null;
	    }
	    let A;
	    try {
	      A = this._recover(msg, r, s, param);
	    } catch (e) {
	      return null;
	    }
	    return A.encode(compress);
	  }
	  recoverDER(msg, sig, param, compress) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(param >>> 0 === param);
	    assert((param & 3) === param, 'The recovery param is more than two bits.');
	    let r, s;
	    try {
	      [r, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return null;
	    }
	    let A;
	    try {
	      A = this._recover(msg, r, s, param);
	    } catch (e) {
	      return null;
	    }
	    return A.encode(compress);
	  }
	  _recover(msg, r, s, param) {
	    // ECDSA Public Key Recovery.
	    //
	    // [SEC1] Page 47, Section 4.1.6.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `i` be an integer in [0,3].
	    //   - x^3 + a * x + b is square in F(p).
	    //   - If i > 1 then r < (p mod n).
	    //   - r != 0, r < n.
	    //   - s != 0, s < n.
	    //   - A != O.
	    //
	    // Computation:
	    //
	    //   x = r + n, if i > 1
	    //     = r, otherwise
	    //   R' = (x, sqrt(x^3 + a * x + b))
	    //   R = -R', if i mod 2 == 1
	    //     = +R', otherwise
	    //   s1 = m / r mod n
	    //   s2 = s / r mod n
	    //   A = R * s2 - G * s1
	    //
	    // Note that this implementation will have
	    // trouble on curves where `p / n > 1`.
	    const {
	      n,
	      pmodn
	    } = this.curve;
	    const G = this.curve.g;
	    const m = this._reduce(msg);
	    if (r.isZero() || r.cmp(n) >= 0) throw new Error('Invalid R value.');
	    if (s.isZero() || s.cmp(n) >= 0) throw new Error('Invalid S value.');
	    const sign = (param & 1) !== 0;
	    const high = param >>> 1;
	    let x = r;
	    if (high) {
	      if (this.curve.highOrder) throw new Error('Invalid high bit.');
	      if (x.cmp(pmodn) >= 0) throw new Error('Invalid R value.');
	      x = x.add(n);
	    }
	    const R = this.curve.pointFromX(x, sign);
	    const ri = r.invert(n);
	    const s1 = m.mul(ri).ineg().imod(n);
	    const s2 = s.mul(ri).imod(n);
	    const A = G.mulAdd(s1, R, s2);
	    if (A.isInfinity()) throw new Error('Invalid point.');
	    return A;
	  }
	  derive(pub, priv, compress) {
	    const A = this.curve.decodePoint(pub);
	    const a = this.curve.decodeScalar(priv);
	    if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
	    if (this.curve.h.cmpn(1) > 0) {
	      if (A.isSmall()) throw new Error('Invalid point.');
	    }
	    const P = A.mulBlind(a, rng);
	    return P.encode(compress);
	  }

	  /*
	   * Schnorr
	   */

	  schnorrSign(msg, key) {
	    return this.schnorr.sign(msg, key);
	  }
	  schnorrVerify(msg, sig, key) {
	    return this.schnorr.verify(msg, sig, key);
	  }
	  schnorrVerifyBatch(batch) {
	    return this.schnorr.verifyBatch(batch);
	  }

	  /*
	   * Helpers
	   */

	  _encodeCompact(r, s) {
	    return Buffer.concat([this.curve.encodeScalar(r), this.curve.encodeScalar(s)]);
	  }
	  _decodeCompact(sig) {
	    assert(Buffer.isBuffer(sig));
	    const {
	      n
	    } = this.curve;
	    const size = this.curve.scalarSize;
	    if (sig.length !== size * 2) throw new Error('Invalid signature size.');
	    const Rraw = sig.slice(0, size);
	    const Sraw = sig.slice(size, size * 2);
	    const r = this.curve.decodeScalar(Rraw);
	    const s = this.curve.decodeScalar(Sraw);
	    if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');
	    return [r, s];
	  }
	  _encodeDER(r, s) {
	    const size = asn1.sizeInt(r) + asn1.sizeInt(s);
	    const out = Buffer.alloc(asn1.sizeSeq(size));
	    let pos = 0;
	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeInt(out, pos, r);
	    pos = asn1.writeInt(out, pos, s);
	    assert(pos === out.length);
	    return out;
	  }
	  _decodeDER(sig, strict) {
	    assert(Buffer.isBuffer(sig));
	    assert(typeof strict === 'boolean');
	    const {
	      n
	    } = this.curve;
	    let pos = 0;
	    let r, s;
	    pos = asn1.readSeq(sig, pos, strict);
	    [r, pos] = asn1.readInt(sig, pos, strict);
	    [s, pos] = asn1.readInt(sig, pos, strict);
	    if (strict && pos !== sig.length) throw new Error('Trailing bytes.');
	    if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');
	    return [r, s];
	  }
	  _truncate(msg) {
	    // Byte array to integer conversion.
	    //
	    // [SEC1] Step 5, Page 45, Section 4.1.3.
	    // [FIPS186] Page 25, Section B.2.
	    //
	    // The two sources above disagree on this.
	    //
	    // FIPS186 simply modulos the entire byte
	    // array by the order, whereas SEC1 takes
	    // the left-most ceil(log2(n+1)) bits modulo
	    // the order (and maybe does other stuff).
	    //
	    // Instead of trying to decipher all of
	    // this nonsense, we simply replicate the
	    // OpenSSL behavior (which, in actuality,
	    // is more similar to the SEC1 behavior).
	    assert(Buffer.isBuffer(msg));
	    const bits = this.curve.n.bitLength();
	    const bytes = bits + 7 >>> 3;
	    if (msg.length > bytes) msg = msg.slice(0, bytes);
	    const m = BN.decode(msg, this.curve.endian);
	    const d = msg.length * 8 - bits;
	    if (d > 0) m.iushrn(d);
	    return m;
	  }
	  _reduce(msg) {
	    return this._truncate(msg).imod(this.curve.n);
	  }
	}

	/*
	 * Expose
	 */

	ecdsa = ECDSA;
	return ecdsa;
}

var naf = {
	width: 9,
	points: [
		[
			"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
			"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
		],
		[
			"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
			"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
		],
		[
			"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
			"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
		],
		[
			"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
			"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
		],
		[
			"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
			"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
		],
		[
			"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
			"0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
		],
		[
			"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
			"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
		],
		[
			"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
			"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
		],
		[
			"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
			"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
		],
		[
			"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
			"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
		],
		[
			"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
			"02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
		],
		[
			"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
			"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
		],
		[
			"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
			"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
		],
		[
			"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
			"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
		],
		[
			"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
			"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
		],
		[
			"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
			"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
		],
		[
			"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
			"02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
		],
		[
			"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
			"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
		],
		[
			"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
			"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
		],
		[
			"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
			"0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
		],
		[
			"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
			"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
		],
		[
			"049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
			"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
		],
		[
			"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
			"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
		],
		[
			"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
			"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
		],
		[
			"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
			"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
		],
		[
			"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
			"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
		],
		[
			"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
			"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
		],
		[
			"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
			"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
		],
		[
			"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
			"091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
		],
		[
			"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
			"0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
		],
		[
			"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
			"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
		],
		[
			"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
			"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
		],
		[
			"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
			"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
		],
		[
			"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
			"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
		],
		[
			"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
			"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
		],
		[
			"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
			"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
		],
		[
			"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
			"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
		],
		[
			"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
			"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
		],
		[
			"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
			"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
		],
		[
			"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
			"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
		],
		[
			"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
			"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
		],
		[
			"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
			"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
		],
		[
			"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
			"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
		],
		[
			"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
			"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
		],
		[
			"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
			"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
		],
		[
			"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
			"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
		],
		[
			"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
			"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
		],
		[
			"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
			"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
		],
		[
			"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
			"0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
		],
		[
			"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
			"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
		],
		[
			"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
			"09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
		],
		[
			"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
			"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
		],
		[
			"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
			"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
		],
		[
			"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
			"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
		],
		[
			"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
			"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
		],
		[
			"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
			"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
		],
		[
			"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
			"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
		],
		[
			"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
			"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
		],
		[
			"078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
			"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
		],
		[
			"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
			"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
		],
		[
			"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
			"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
		],
		[
			"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
			"04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
		],
		[
			"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
			"073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
		],
		[
			"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
			"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
		],
		[
			"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
			"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
		],
		[
			"0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
			"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
		],
		[
			"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
			"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
		],
		[
			"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
			"060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
		],
		[
			"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
			"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
		],
		[
			"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
			"0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
		],
		[
			"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
			"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
		],
		[
			"04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
			"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
		],
		[
			"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
			"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
		],
		[
			"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
			"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
		],
		[
			"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
			"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
		],
		[
			"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
			"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
		],
		[
			"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
			"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
		],
		[
			"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
			"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
		],
		[
			"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
			"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
		],
		[
			"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
			"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
		],
		[
			"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
			"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
		],
		[
			"0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
			"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
		],
		[
			"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
			"021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
		],
		[
			"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
			"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
		],
		[
			"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
			"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
		],
		[
			"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
			"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
		],
		[
			"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
			"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
		],
		[
			"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
			"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
		],
		[
			"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
			"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
		],
		[
			"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
			"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
		],
		[
			"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
			"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
		],
		[
			"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
			"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
		],
		[
			"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
			"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
		],
		[
			"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
			"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
		],
		[
			"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
			"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
		],
		[
			"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
			"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
		],
		[
			"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
			"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
		],
		[
			"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
			"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
		],
		[
			"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
			"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
		],
		[
			"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
			"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
		],
		[
			"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
			"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
		],
		[
			"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
			"0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
		],
		[
			"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
			"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
		],
		[
			"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
			"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
		],
		[
			"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
			"09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
		],
		[
			"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
			"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
		],
		[
			"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
			"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
		],
		[
			"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
			"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
		],
		[
			"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
			"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
		],
		[
			"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
			"0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
		],
		[
			"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
			"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
		],
		[
			"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
			"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
		],
		[
			"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
			"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
		],
		[
			"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
			"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
		],
		[
			"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
			"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
		],
		[
			"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
			"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
		],
		[
			"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
			"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
		],
		[
			"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
			"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
		],
		[
			"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
			"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
		],
		[
			"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
			"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
		],
		[
			"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
			"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
		],
		[
			"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
			"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
		],
		[
			"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
			"0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
		],
		[
			"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
			"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
		],
		[
			"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
			"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
		],
		[
			"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
			"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
		],
		[
			"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
			"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
		]
	]
};
var doubles = {
	step: 4,
	points: [
		[
			"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
			"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
		],
		[
			"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
			"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
		],
		[
			"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
			"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
		],
		[
			"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
			"04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
		],
		[
			"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
			"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
		],
		[
			"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
			"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
		],
		[
			"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
			"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
		],
		[
			"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
			"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
		],
		[
			"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
			"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
		],
		[
			"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
			"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
		],
		[
			"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
			"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
		],
		[
			"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
			"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
		],
		[
			"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
			"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
		],
		[
			"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
			"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
		],
		[
			"06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
			"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
		],
		[
			"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
			"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
		],
		[
			"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
			"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
		],
		[
			"0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
			"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
		],
		[
			"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
			"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
		],
		[
			"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
			"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
		],
		[
			"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
			"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
		],
		[
			"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
			"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
		],
		[
			"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
			"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
		],
		[
			"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
			"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
		],
		[
			"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
			"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
		],
		[
			"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
			"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
		],
		[
			"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
			"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
		],
		[
			"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
			"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
		],
		[
			"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
			"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
		],
		[
			"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
			"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
		],
		[
			"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
			"0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
		],
		[
			"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
			"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
		],
		[
			"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
			"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
		],
		[
			"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
			"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
		],
		[
			"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
			"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
		],
		[
			"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
			"067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
		],
		[
			"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
			"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
		],
		[
			"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
			"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
		],
		[
			"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
			"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
		],
		[
			"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
			"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
		],
		[
			"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
			"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
		],
		[
			"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
			"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
		],
		[
			"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
			"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
		],
		[
			"0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
			"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
		],
		[
			"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
			"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
		],
		[
			"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
			"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
		],
		[
			"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
			"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
		],
		[
			"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
			"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
		],
		[
			"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
			"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
		],
		[
			"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
			"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
		],
		[
			"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
			"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
		],
		[
			"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
			"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
		],
		[
			"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
			"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
		],
		[
			"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
			"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
		],
		[
			"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
			"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
		],
		[
			"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
			"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
		],
		[
			"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
			"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
		],
		[
			"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
			"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
		],
		[
			"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
			"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
		],
		[
			"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
			"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
		],
		[
			"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
			"0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
		],
		[
			"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
			"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
		],
		[
			"08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
			"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
		],
		[
			"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
			"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
		],
		[
			"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
			"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
		]
	]
};
var require$$2 = {
	naf: naf,
	doubles: doubles
};

/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var secp256k1;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1;
	hasRequiredSecp256k1 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();
	const pre = require$$2;

	/*
	 * Expose
	 */

	secp256k1 = new ECDSA('SECP256K1', SHA256, SHA256, pre);
	return secp256k1;
}

/*!
 * message.js - message signing utilities.
 * Copyright (c) 2019, The Bcoin Developers (MIT License).
 */

var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1;
	(function (exports) {

		const assert = requireAssert$1();
		const bufio = requireBufio();
		const hash256 = requireHash256();
		const secp256k1 = requireSecp256k1();

		/**
		 * @exports utils/message
		 */

		const message = exports;

		/**
		 * Bitcoin signing magic string.
		 * @const {String}
		 * @default
		 */

		message.MAGIC_STRING = 'eCash Signed Message:\n';

		/**
		 * Hash message with magic string.
		 * @param {String} message
		 * @param {String} [prefix = message.MAGIC_STRING]
		 * @returns {Hash}
		 */

		message.magicHash = (msg, prefix = message.MAGIC_STRING) => {
		  assert(typeof prefix === 'string', 'prefix must be a string.');
		  assert(typeof msg === 'string', 'message must be a string');
		  const bw = bufio.write();
		  bw.writeVarString(prefix);
		  bw.writeVarString(msg, 'utf8');
		  return hash256.digest(bw.render());
		};

		/**
		 * Sign message with key.
		 * @param {String} msg
		 * @param {KeyRing} ring
		 * @param {String} [prefix = message.MAGIC_STRING]
		 * @returns {Buffer}
		 */

		message.sign = (msg, ring, prefix) => {
		  assert(ring.getPrivateKey(), 'Cannot sign without private key.');
		  const hash = message.magicHash(msg, prefix);
		  const compress = 0x04 !== ring.getPublicKey().readInt8(0);
		  const [signature, recovery] = secp256k1.signRecoverable(hash, ring.getPrivateKey());
		  const bw = bufio.write();
		  bw.writeI8(recovery + 27 + (compress ? 4 : 0));
		  bw.writeBytes(signature);
		  return bw.render();
		};

		/**
		 * Recover raw public key from message and signature.
		 * @param {String} msg
		 * @param {Buffer} signature
		 * @param {String} [prefix = MAGIC_STRING]
		 */

		message.recover = (msg, signature, prefix) => {
		  assert(typeof msg === 'string', 'msg must be a string');
		  assert(Buffer.isBuffer(signature), 'sig must be a buffer');
		  const hash = message.magicHash(msg, prefix);
		  assert.strictEqual(signature.length, 65, 'Invalid signature length');
		  const flagByte = signature.readUInt8(0) - 27;
		  assert(flagByte < 8, 'Invalid signature parameter');
		  const compressed = Boolean(flagByte & 4);
		  const recovery = flagByte & 3;
		  return secp256k1.recover(hash, signature.slice(1), recovery, compressed);
		};

		/**
		 * Verify signature for message.
		 * @param {String} msg
		 * @param {Buffer} signature
		 * @param {Buffer} publicKey
		 * @param {String} [prefix = message.MAGIC_STRING]
		 */

		message.verify = (msg, signature, publicKey, prefix) => {
		  const recoveredKey = message.recover(msg, signature);
		  assert(Buffer.isBuffer(publicKey), 'publicKey must be a buffer');
		  if (Buffer.compare(publicKey, recoveredKey) !== 0) return false;
		  return secp256k1.verify(message.magicHash(msg, prefix), signature.slice(1), publicKey);
		}; 
	} (message));
	return message;
}

/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	/**
	 * @module utils
	 */
	utils.binary = requireBinary();
	utils.fixed = requireFixed();
	utils.util = requireUtil();
	utils.message = requireMessage();
	const {
	  inspect: {
	    custom
	  }
	} = require$$0$4;
	utils.inspectSymbol = custom || 'inspect';
	return utils;
}

/*!
 * address.js - address object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var address;
var hasRequiredAddress;

function requireAddress () {
	if (hasRequiredAddress) return address;
	hasRequiredAddress = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  base58,
	  cashaddr
	} = requireBstring();
	const ecashaddr = requireCashaddr();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const {
	  inspectSymbol
	} = requireUtils();

	/*
	 * Constants
	 */

	const ZERO_HASH160 = Buffer.alloc(20, 0x00);

	/**
	 * Address
	 * Represents an address.
	 * @alias module:primitives.Address
	 * @property {Buffer} hash
	 * @property {AddressPrefix} type
	 */

	class Address {
	  /**
	   * Create an address.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options, network) {
	    this.type = Address.types.PUBKEYHASH;
	    this.hash = ZERO_HASH160;
	    if (options) this.fromOptions(options, network);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options, network) {
	    if (typeof options === 'string') return this.fromString(options, network);
	    assert(options);
	    const {
	      hash,
	      type
	    } = options;
	    return this.fromHash(hash, type);
	  }

	  /**
	   * Insantiate address from options.
	   * @param {Object} options
	   * @returns {Address}
	   */

	  static fromOptions(options, network) {
	    return new this().fromOptions(options, network);
	  }

	  /**
	   * Get the address hash.
	   * @param {String?} enc - Can be `"hex"` or `null`.
	   * @returns {Hash|Buffer}
	   */

	  getHash(enc) {
	    if (enc === 'hex') return this.hash.toString('hex');
	    return this.hash;
	  }

	  /**
	   * Test whether the address is null.
	   * @returns {Boolean}
	   */

	  isNull() {
	    if (this.hash.length === 20) return this.hash.equals(ZERO_HASH160);
	    if (this.hash.length === 32) return this.hash.equals(consensus.ZERO_HASH);
	    for (let i = 0; i < this.hash.length; i++) {
	      if (this.hash[i] !== 0) return false;
	    }
	    return true;
	  }

	  /**
	   * Test equality against another address.
	   * @param {Address} addr
	   * @returns {Boolean}
	   */

	  equals(addr) {
	    assert(addr instanceof Address);
	    return this.type === addr.type && this.hash.equals(addr.hash);
	  }

	  /**
	   * Get the address type as a string.
	   * @returns {String}
	   */

	  getType() {
	    return Address.typesByVal[this.type].toLowerCase();
	  }

	  /**
	   * Get a network address prefix for the address.
	   * @param {Network?} network
	   * @returns {Number}
	   */

	  getPrefix(network) {
	    network = Network.get(network);
	    const prefixes = network.addressPrefix;
	    switch (this.type) {
	      case Address.types.PUBKEYHASH:
	        return prefixes.pubkeyhash;
	      case Address.types.SCRIPTHASH:
	        return prefixes.scripthash;
	    }
	    return -1;
	  }

	  /**
	   * Calculate size of serialized address.
	   * @returns {Number}
	   */

	  getSize() {
	    return 5 + this.hash.length;
	  }

	  /**
	   * Compile the address object to its raw serialization.
	   * @param {{NetworkType|Network)?} network
	   * @returns {Buffer}
	   * @throws Error on bad hash/prefix.
	   */

	  toRaw(network) {
	    const size = this.getSize();
	    const bw = bio.write(size);
	    const prefix = this.getPrefix(network);
	    assert(prefix !== -1, 'Not a valid address prefix.');
	    bw.writeU8(prefix);
	    bw.writeBytes(this.hash);
	    bw.writeChecksum(hash256.digest);
	    return bw.render();
	  }

	  /**
	   * Compile the address object to a base58 address.
	   * @param {{NetworkType|Network)?} network
	   * @returns {AddressString}
	   * @throws Error on bad hash/prefix.
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Compile the address object to a cashaddr address.
	   * @param {{NetworkType|Network)?} network
	   * @returns {String}
	   * @throws Error on bad hash/prefix.
	   */

	  toCashAddr(network) {
	    const type = this.type;
	    const hash = this.hash;
	    network = Network.get(network);
	    const prefix = network.addressPrefix.cashaddr;
	    return cashaddr.encode(prefix, type, hash);
	  }

	  /**
	   * Inject properties from string.
	   * @private
	   * @param {String} addr
	   * @param {(Network|NetworkType)?} network
	   * @returns {Address}
	   */

	  fromString(addr, network) {
	    assert(typeof addr === 'string');
	    assert(addr.length > 0);
	    assert(addr.length <= 100);

	    // If the address is mixed case,
	    // it can only ever be base58.
	    if (isMixedCase(addr)) return this.fromBase58(addr, network);

	    // Otherwise, it's most likely cashaddr.
	    try {
	      return this.fromCashAddr(addr, network);
	    } catch (e) {
	      return this.fromBase58(addr, network);
	    }
	  }

	  /**
	   * Instantiate address from string.
	   * @param {String} addr
	   * @param {(Network|NetworkType)?} network
	   * @returns {Address}
	   */

	  static fromString(addr, network) {
	    return new this().fromString(addr, network);
	  }

	  /**
	   * Return cashaddr by default
	   * @param {(Network|NetworkType)?} network
	   * @returns {AddressString}
	   */

	  toString(network) {
	    return this.toCashAddr(network);
	  }

	  /**
	   * Inspect the Address.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return '<Address:' + ` type=${this.getType()}` + ` str=${this.toString()}` + '>';
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @throws Parse error
	   */

	  fromRaw(data, network) {
	    const br = bio.read(data, true);
	    const prefix = br.readU8();
	    network = Network.fromAddress(prefix, network);
	    const type = Address.getType(prefix, network);
	    if (data.length !== 25) throw new Error('Address is too long.');
	    const hash = br.readBytes(br.left() - 4);
	    br.verifyChecksum(hash256.digest);
	    return this.fromHash(hash, type);
	  }

	  /**
	   * Create an address object from a serialized address.
	   * @param {Buffer} data
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Inject properties from base58 address.
	   * @private
	   * @param {AddressString} data
	   * @param {Network?} network
	   * @throws Parse error
	   */

	  fromBase58(data, network) {
	    assert(typeof data === 'string');
	    if (data.length > 55) throw new Error('Address is too long.');
	    return this.fromRaw(base58.decode(data), network);
	  }

	  /**
	   * Create an address object from a base58 address.
	   * @param {AddressString} data
	   * @param {Network?} network
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromBase58(data, network) {
	    return new this().fromBase58(data, network);
	  }

	  /**
	   * Inject properties from cashaddr address.
	   * @private
	   * @param {String} data
	   * @param {Network?} network
	   * @throws Parse error
	   */

	  fromCashAddr(data, network) {
	    assert(typeof data === 'string');
	    network = Network.get(network);
	    network.addressPrefix.cashaddr;
	    const addr = ecashaddr.decode(data);
	    addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';
	    Network.fromCashAddr(addr.prefix, network);
	    return this.fromHash(Buffer.from(addr.hash), addr.type);
	  }

	  /**
	   * Create an address object from a cashaddr address.
	   * @param {String} data
	   * @param {Network?} network
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromCashAddr(data, network) {
	    return new this().fromCashAddr(data, network);
	  }

	  /**
	   * Inject properties from output script.
	   * @private
	   * @param {Script} script
	   */

	  fromScript(script) {
	    const pk = script.getPubkey();
	    if (pk) {
	      this.hash = hash160.digest(pk);
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }
	    const pkh = script.getPubkeyhash();
	    if (pkh) {
	      this.hash = pkh;
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }
	    const sh = script.getScripthash();
	    if (sh) {
	      this.hash = sh;
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }

	    // Put this last: it's the slowest to check.
	    if (script.isMultisig()) {
	      this.hash = script.hash160();
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }
	    return null;
	  }

	  /**
	   * Inject properties from input script.
	   * @private
	   * @param {Script} script
	   */

	  fromInputScript(script) {
	    const [, pk] = script.getPubkeyhashInput();
	    if (pk) {
	      this.hash = hash160.digest(pk);
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }
	    const redeem = script.getScripthashInput();
	    if (redeem) {
	      this.hash = hash160.digest(redeem);
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }
	    return null;
	  }

	  /**
	   * Create an Address from an input script.
	   * Attempt to extract address
	   * properties from an input script.
	   * @param {Script}
	   * @returns {Address|null}
	   */

	  static fromInputScript(script) {
	    return new this().fromInputScript(script);
	  }

	  /**
	   * Create an Address from an output script.
	   * Parse an output script and extract address
	   * properties. Converts pubkey and multisig
	   * scripts to pubkeyhash and scripthash addresses.
	   * @param {Script}
	   * @returns {Address|null}
	   */

	  static fromScript(script) {
	    return new this().fromScript(script);
	  }

	  /**
	   * Inject properties from a hash.
	   * @private
	   * @param {Buffer|Hash} hash
	   * @param {AddressPrefix} type
	   * @throws on bad hash size
	   */

	  fromHash(hash, type) {
	    if (typeof type === 'string') {
	      type = Address.types[type.toUpperCase()];
	      assert(type != null, 'Not a valid address type.');
	    }
	    if (type == null) type = Address.types.PUBKEYHASH;
	    assert(Buffer.isBuffer(hash));
	    assert(type >>> 0 === type);
	    assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH, 'Not a valid address type.');
	    assert(hash.length === 20, 'Hash is the wrong size.');
	    this.hash = hash;
	    this.type = type;
	    return this;
	  }

	  /**
	   * Create a naked address from hash/type.
	   * @param {Hash} hash
	   * @param {AddressPrefix} type
	   * @returns {Address}
	   * @throws on bad hash size
	   */

	  static fromHash(hash, type) {
	    return new this().fromHash(hash, type);
	  }

	  /**
	   * Inject properties from pubkeyhash.
	   * @private
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  fromPubkeyhash(hash) {
	    const type = Address.types.PUBKEYHASH;
	    assert(hash.length === 20, 'P2PKH must be 20 bytes.');
	    return this.fromHash(hash, type, -1);
	  }

	  /**
	   * Instantiate address from pubkeyhash.
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  static fromPubkeyhash(hash) {
	    return new this().fromPubkeyhash(hash);
	  }

	  /**
	   * Inject properties from scripthash.
	   * @private
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  fromScripthash(hash) {
	    const type = Address.types.SCRIPTHASH;
	    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');
	    return this.fromHash(hash, type, -1);
	  }

	  /**
	   * Instantiate address from scripthash.
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  static fromScripthash(hash) {
	    return new this().fromScripthash(hash);
	  }

	  /**
	   * Test whether the address is pubkeyhash.
	   * @returns {Boolean}
	   */

	  isPubkeyhash() {
	    return this.type === Address.types.PUBKEYHASH;
	  }

	  /**
	   * Test whether the address is scripthash.
	   * @returns {Boolean}
	   */

	  isScripthash() {
	    return this.type === Address.types.SCRIPTHASH;
	  }

	  /**
	   * Get the hash of a base58 address or address-related object.
	   * @param {Address|Hash} data
	   * @param {String?} enc - Can be `"hex"` or `null`.
	   * @returns {Hash}
	   */

	  static getHash(data, enc) {
	    if (!data) throw new Error('Object is not an address.');
	    let hash;
	    if (Buffer.isBuffer(data)) {
	      if (data.length !== 20) throw new Error('Object is not an address.');
	      hash = data;
	    } else if (data instanceof Address) {
	      hash = data.hash;
	    } else {
	      throw new Error('Object is not an address.');
	    }
	    if (enc === 'hex') return hash.toString('hex');
	    return hash;
	  }

	  /**
	   * Get an address type for a specified network address prefix.
	   * @param {Number} prefix
	   * @param {Network} network
	   * @returns {AddressType}
	   */

	  static getType(prefix, network) {
	    const prefixes = network.addressPrefix;
	    switch (prefix) {
	      case prefixes.pubkeyhash:
	        return Address.types.PUBKEYHASH;
	      case prefixes.scripthash:
	        return Address.types.SCRIPTHASH;
	      default:
	        throw new Error('Unknown address prefix.');
	    }
	  }
	}

	/**
	 * Address types.
	 * @enum {Number}
	 */

	Address.types = {
	  PUBKEYHASH: 0,
	  SCRIPTHASH: 1
	};

	/**
	 * Address types by value.
	 * @const {Object}
	 */

	Address.typesByVal = ['PUBKEYHASH', 'SCRIPTHASH'];

	/*
	 * Helpers
	 */

	function isMixedCase(str) {
	  let lower = false;
	  let upper = false;
	  for (let i = 0; i < str.length; i++) {
	    const ch = str.charCodeAt(i);
	    if (ch >= 0x30 && ch <= 0x39) continue;

	    // skip :
	    if (ch === 0x3a) continue;
	    if (ch & 32) {
	      assert(ch >= 0x61 && ch <= 0x7a);
	      lower = true;
	    } else {
	      assert(ch >= 0x41 && ch <= 0x5a);
	      upper = true;
	    }
	    if (lower && upper) return true;
	  }
	  return false;
	}

	/*
	 * Expose
	 */

	address = Address;
	return address;
}

/**
 * uri.js - bitcoin uri parsing for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	const assert = requireAssert$1();
	const Address = requireAddress();
	const Amount = requireAmount();

	/**
	 * URI
	 * Represents a bitcoin URI.
	 * @alias module:btc.URI
	 * @property {Address} address
	 * @property {Amount} amount
	 * @property {String|null} label
	 * @property {String|null} message
	 * @property {String|null} request
	 */

	class URI {
	  /**
	   * Create a bitcoin URI.
	   * @alias module:btc.URI
	   * @constructor
	   * @param {Object|String} options
	   */

	  constructor(options) {
	    this.address = new Address();
	    this.amount = -1;
	    this.label = null;
	    this.message = null;
	    this.request = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object|String} options
	   * @returns {URI}
	   */

	  fromOptions(options) {
	    if (typeof options === 'string') return this.fromString(options);
	    if (options.address) this.address.fromOptions(options.address);
	    if (options.amount != null) {
	      assert(Number.isSafeInteger(options.amount) && options.amount >= 0, 'Amount must be a uint64.');
	      this.amount = options.amount;
	    }
	    if (options.label) {
	      assert(typeof options.label === 'string', 'Label must be a string.');
	      this.label = options.label;
	    }
	    if (options.message) {
	      assert(typeof options.message === 'string', 'Message must be a string.');
	      this.message = options.message;
	    }
	    if (options.request) {
	      assert(typeof options.request === 'string', 'Request must be a string.');
	      this.request = options.request;
	    }
	    return this;
	  }

	  /**
	   * Instantiate URI from options.
	   * @param {Object|String} options
	   * @returns {URI}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Parse and inject properties from string.
	   * @private
	   * @param {String} str
	   * @param {Network?} network
	   * @returns {URI}
	   */

	  fromString(str, network) {
	    assert(typeof str === 'string');
	    assert(str.length > 8, 'Not a bitcoin URI.');
	    const prefix = str.substring(0, 8);
	    assert(prefix === 'bitcoin:', 'Not a bitcoin URI.');
	    str = str.substring(8);
	    const index = str.indexOf('?');
	    let addr, qs;
	    if (index === -1) {
	      addr = str;
	    } else {
	      addr = str.substring(0, index);
	      qs = str.substring(index + 1);
	    }
	    this.address.fromString(addr, network);
	    if (!qs) return this;
	    const query = parsePairs(qs);
	    if (query.amount) {
	      assert(query.amount.length > 0, 'Value is empty.');
	      assert(query.amount[0] !== '-', 'Value is negative.');
	      this.amount = Amount.value(query.amount);
	    }
	    if (query.label) this.label = query.label;
	    if (query.message) this.message = query.message;
	    if (query.r) this.request = query.r;
	    return this;
	  }

	  /**
	   * Instantiate uri from string.
	   * @param {String} str
	   * @param {Network?} network
	   * @returns {URI}
	   */

	  static fromString(str, network) {
	    return new this().fromString(str, network);
	  }

	  /**
	   * Serialize uri to a string.
	   * @returns {String}
	   */

	  toString() {
	    let str = 'bitcoin:';
	    str += this.address.toString();
	    const query = [];
	    if (this.amount !== -1) query.push(`amount=${Amount.btc(this.amount)}`);
	    if (this.label) query.push(`label=${escape(this.label)}`);
	    if (this.message) query.push(`message=${escape(this.message)}`);
	    if (this.request) query.push(`r=${escape(this.request)}`);
	    if (query.length > 0) str += '?' + query.join('&');
	    return str;
	  }

	  /**
	   * Inspect bitcoin uri.
	   * @returns {String}
	   */

	  inspect() {
	    return `<URI: ${this.toString()}>`;
	  }
	}

	/*
	 * Helpers
	 */

	class BitcoinQuery {
	  constructor() {
	    this.amount = null;
	    this.label = null;
	    this.message = null;
	    this.r = null;
	  }
	}
	function parsePairs(str) {
	  const parts = str.split('&');
	  const data = new BitcoinQuery();
	  let size = 0;
	  for (const pair of parts) {
	    const index = pair.indexOf('=');
	    let key, value;
	    if (index === -1) {
	      key = pair;
	      value = '';
	    } else {
	      key = pair.substring(0, index);
	      value = pair.substring(index + 1);
	    }
	    if (key.length === 0) {
	      assert(value.length === 0, 'Empty key in querystring.');
	      continue;
	    }
	    assert(size < 4, 'Too many keys in querystring.');
	    switch (key) {
	      case 'amount':
	        assert(data.amount == null, 'Duplicate key in querystring (amount).');
	        data.amount = unescape(value);
	        break;
	      case 'label':
	        assert(data.label == null, 'Duplicate key in querystring (label).');
	        data.label = unescape(value);
	        break;
	      case 'message':
	        assert(data.message == null, 'Duplicate key in querystring (message).');
	        data.message = unescape(value);
	        break;
	      case 'r':
	        assert(data.r == null, 'Duplicate key in querystring (r).');
	        data.r = unescape(value);
	        break;
	      default:
	        assert(false, `Unknown querystring key: ${value}.`);
	        break;
	    }
	    size += 1;
	  }
	  return data;
	}
	function unescape(str) {
	  try {
	    str = decodeURIComponent(str);
	    str = str.replace(/\+/g, ' ');
	  } catch (e) {
	    throw new Error('Malformed URI.');
	  }
	  if (str.indexOf('\0') !== -1) throw new Error('Malformed URI.');
	  return str;
	}
	function escape(str) {
	  str = encodeURIComponent(str);
	  str = str.replace(/%20/g, '+');
	  return str;
	}

	/*
	 * Expose
	 */

	uri = URI;
	return uri;
}

/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBtc;

function requireBtc () {
	if (hasRequiredBtc) return btc;
	hasRequiredBtc = 1;

	/**
	 * @module btc
	 */
	btc.Amount = requireAmount();
	btc.URI = requireUri();
	return btc;
}

var coins$1 = {};

/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */

var sha1;
var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);
	PADDING[0] = 0x80;
	const K = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6]);

	/**
	 * SHA1
	 */

	class SHA1 {
	  constructor() {
	    this.state = new Uint32Array(5);
	    this.msg = new Uint32Array(80);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }
	  init() {
	    this.state[0] = 0x67452301;
	    this.state[1] = 0xefcdab89;
	    this.state[2] = 0x98badcfe;
	    this.state[3] = 0x10325476;
	    this.state[4] = 0xc3d2e1f0;
	    this.size = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }
	  final() {
	    return this._final(Buffer.alloc(20));
	  }
	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    let pos = this.size & 63;
	    let off = 0;
	    this.size += len;
	    if (pos > 0) {
	      let want = 64 - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < 64) return;
	      this._transform(this.block, 0);
	    }
	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	  }
	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    const pos = this.size & 63;
	    const len = this.size * 8;
	    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 0);
	    writeU32(DESC, len >>> 0, 4);
	    this._update(PADDING, 1 + (119 - pos & 63));
	    this._update(DESC, 8);
	    for (let i = 0; i < 5; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }
	    for (let i = 0; i < 80; i++) this.msg[i] = 0;
	    for (let i = 0; i < 64; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    return out;
	  }
	  _transform(chunk, pos) {
	    const W = this.msg;
	    let a = this.state[0];
	    let b = this.state[1];
	    let c = this.state[2];
	    let d = this.state[3];
	    let e = this.state[4];
	    let i = 0;
	    for (; i < 16; i++) W[i] = readU32(chunk, pos + i * 4);
	    for (; i < 80; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
	    for (i = 0; i < 80; i++) {
	      const s = i / 20 | 0;
	      const t = rotl32(a, 5) + ft_1(s, b, c, d) + e + W[i] + K[s];
	      e = d;
	      d = c;
	      c = rotl32(b, 30);
	      b = a;
	      a = t >>> 0;
	    }
	    this.state[0] += a;
	    this.state[1] += b;
	    this.state[2] += c;
	    this.state[3] += d;
	    this.state[4] += e;
	  }
	  static hash() {
	    return new SHA1();
	  }
	  static hmac() {
	    return new HMAC(SHA1, 64);
	  }
	  static digest(data) {
	    return SHA1.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return SHA1.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = SHA1;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return SHA1.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA1.native = 0;
	SHA1.id = 'SHA1';
	SHA1.size = 20;
	SHA1.bits = 160;
	SHA1.blockSize = 64;
	SHA1.zero = Buffer.alloc(20, 0x00);
	SHA1.ctx = new SHA1();

	/*
	 * Helpers
	 */

	function rotl32(w, b) {
	  return w << b | w >>> 32 - b;
	}
	function ft_1(s, x, y, z) {
	  if (s === 0) return ch32(x, y, z);
	  if (s === 1 || s === 3) return p32(x, y, z);
	  if (s === 2) return maj32(x, y, z);
	  return 0;
	}
	function ch32(x, y, z) {
	  return x & y ^ ~x & z;
	}
	function maj32(x, y, z) {
	  return x & y ^ x & z ^ y & z;
	}
	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	function readU32(data, off) {
	  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
	}
	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha1 = SHA1;
	return sha1;
}

var policy = {};

/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredPolicy;

function requirePolicy () {
	if (hasRequiredPolicy) return policy;
	hasRequiredPolicy = 1;
	(function (exports) {

		/**
		 * @module protocol/policy
		 */
		const assert = requireAssert$1();
		const consensus = requireConsensus();

		/**
		 * Maximum transaction version (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_VERSION = consensus.MAX_TX_VERSION;

		/**
		 * Maximum standard transaction size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIZE = consensus.MAX_TX_SIZE / 10;

		/**
		 * Maximum number of transaction sigops (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIGOPS = consensus.MAX_TX_SIGOPS / 5;

		/**
		 * How much weight a sigop should
		 * add to virtual size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.BYTES_PER_SIGOP = 20;

		/**
		 * Minimum relay fee rate (policy).
		 * @const {Rate}
		 */

		exports.MIN_RELAY = 1000;

		/**
		 * Whether bare multisig outputs
		 * should be relayed (policy).
		 * @const {Boolean}
		 * @default
		 */

		exports.BARE_MULTISIG = true;

		/**
		 * Priority threshold for
		 * free transactions (policy).
		 * @const {Number}
		 * @default
		 */

		exports.FREE_THRESHOLD = consensus.COIN * 144 / 250;

		/**
		 * Max sigops per redeem script (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2SH_SIGOPS = 15;

		/**
		 * Max serialized nulldata size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_OP_RETURN_BYTES = 223;

		/**
		 * Max pushdata size in nulldata (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_OP_RETURN = 220;

		/**
		 * Max p2wsh stack size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_STACK = 100;

		/**
		 * Max p2wsh push size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_PUSH = 80;

		/**
		 * Max serialized p2wsh size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_SIZE = 3600;

		/**
		 * Default ancestor limit. 
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_ANCESTORS = 50;

		/**
		 * Default maximum mempool size in bytes.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_SIZE = 100 * 1000000;

		/**
		 * Time at which transactions
		 * fall out of the mempool.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_EXPIRY_TIME = 72 * 60 * 60;

		/**
		 * Maximum number of orphan transactions.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_ORPHANS = 100;

		/**
		 * Minimum block size to create. Block will be
		 * filled with free transactions until block
		 * reaches this weight.
		 * @const {Number}
		 * @default
		 */

		exports.MIN_BLOCK_SIZE = 0;

		/**
		 * Maximum block size to be mined.
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIZE = consensus.MAX_FORK_BLOCK_SIZE;

		/**
		 * How much of the block should be dedicated to
		 * high-priority transactions (included regardless
		 * of fee rate).
		 * @const {Number}
		 * @default
		 */

		exports.BLOCK_PRIORITY_SIZE = 0;

		/**
		 * Priority threshold to be reached before
		 * switching to fee rate comparison.
		 * @const {Number}
		 * @default
		 */

		exports.BLOCK_PRIORITY_THRESHOLD = exports.FREE_THRESHOLD;

		/**
		 * Calculate minimum fee based on rate and size.
		 * @param {Number?} size
		 * @param {Rate?} rate - Rate of satoshi per kB.
		 * @returns {Amount} fee
		 */

		exports.getMinFee = function getMinFee(size, rate) {
		  if (rate == null) rate = exports.MIN_RELAY;
		  assert(size >= 0);
		  assert(rate >= 0);
		  if (size === 0) return 0;
		  let fee = Math.floor(rate * size / 1000);
		  if (fee === 0 && rate > 0) fee = rate;
		  return fee;
		};

		/**
		 * Calculate the minimum fee in order for the transaction
		 * to be relayable, but _round to the nearest kilobyte
		 * when taking into account size.
		 * @param {Number?} size
		 * @param {Rate?} rate - Rate of satoshi per kB.
		 * @returns {Amount} fee
		 */

		exports.getRoundFee = function getRoundFee(size, rate) {
		  if (rate == null) rate = exports.MIN_RELAY;
		  assert(size >= 0);
		  assert(rate >= 0);
		  if (size === 0) return 0;
		  let fee = rate * Math.ceil(size / 1000);
		  if (fee === 0 && rate > 0) fee = rate;
		  return fee;
		};

		/**
		 * Calculate a fee rate based on size and fees.
		 * @param {Number} size
		 * @param {Amount} fee
		 * @returns {Rate}
		 */

		exports.getRate = function getRate(size, fee) {
		  assert(size >= 0);
		  assert(fee >= 0);
		  if (size === 0) return 0;
		  return Math.floor(fee * 1000 / size);
		}; 
	} (policy));
	return policy;
}

var n64 = {};

/*!
 * int64.js - int64 object for javascript.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/n64
 */

var hasRequiredN64;

function requireN64 () {
	if (hasRequiredN64) return n64;
	hasRequiredN64 = 1;

	/*
	 * N64 (abstract)
	 */

	function N64(sign) {
	  enforce(this instanceof N64, 'this', 'N64');
	  enforce(sign === 0 || sign === 1, 'sign', 'bit');

	  this.hi = 0;
	  this.lo = 0;
	  this.sign = sign;
	}

	/*
	 * Addition
	 */

	N64.prototype._add = function _add(bhi, blo) {
	  const ahi = this.hi;
	  const alo = this.lo;

	  // Credit to @indutny for this method.
	  const lo = (alo + blo) | 0;

	  const s = lo >> 31;
	  const as = alo >> 31;
	  const bs = blo >> 31;

	  const c = ((as & bs) | (~s & (as ^ bs))) & 1;

	  const hi = ((ahi + bhi) | 0) + c;

	  this.hi = hi | 0;
	  this.lo = lo;

	  return this;
	};

	N64.prototype.iadd = function iadd(b) {
	  enforce(N64.isN64(b), 'operand', 'int64');
	  return this._add(b.hi, b.lo);
	};

	N64.prototype.iaddn = function iaddn(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  return this._add((num >> 31) & -this.sign, num | 0);
	};

	N64.prototype.add = function add(b) {
	  return this.clone().iadd(b);
	};

	N64.prototype.addn = function addn(num) {
	  return this.clone().iaddn(num);
	};

	/*
	 * Subtraction
	 */

	N64.prototype._sub = function _sub(bhi, blo) {
	  bhi = ~bhi;
	  blo = ~blo;

	  if (blo === -1) {
	    blo = 0;
	    bhi += 1;
	    bhi |= 0;
	  } else {
	    blo += 1;
	  }

	  return this._add(bhi, blo);
	};

	N64.prototype.isub = function isub(b) {
	  enforce(N64.isN64(b), 'operand', 'int64');
	  return this._sub(b.hi, b.lo);
	};

	N64.prototype.isubn = function isubn(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  return this._sub((num >> 31) & -this.sign, num | 0);
	};

	N64.prototype.sub = function sub(b) {
	  return this.clone().isub(b);
	};

	N64.prototype.subn = function subn(num) {
	  return this.clone().isubn(num);
	};

	/*
	 * Multiplication
	 */

	N64.prototype._mul = function _mul(bhi, blo) {
	  const ahi = this.hi;
	  const alo = this.lo;

	  const a48 = ahi >>> 16;
	  const a32 = ahi & 0xffff;
	  const a16 = alo >>> 16;
	  const a00 = alo & 0xffff;

	  const b48 = bhi >>> 16;
	  const b32 = bhi & 0xffff;
	  const b16 = blo >>> 16;
	  const b00 = blo & 0xffff;

	  let c48 = 0;
	  let c32 = 0;
	  let c16 = 0;
	  let c00 = 0;

	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xffff;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xffff;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xffff;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xffff;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xffff;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xffff;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xffff;

	  const hi = (c48 << 16) | c32;
	  const lo = (c16 << 16) | c00;

	  this.hi = hi;
	  this.lo = lo;

	  return this;
	};

	N64.prototype.imul = function imul(b) {
	  enforce(N64.isN64(b), 'multiplicand', 'int64');
	  return this._mul(b.hi, b.lo);
	};

	N64.prototype.imuln = function imuln(num) {
	  enforce(isNumber(num), 'multiplicand', 'number');
	  return this._mul((num >> 31) & -this.sign, num | 0);
	};

	N64.prototype.mul = function mul(b) {
	  return this.clone().imul(b);
	};

	N64.prototype.muln = function muln(num) {
	  return this.clone().imuln(num);
	};

	/*
	 * Division
	 */

	N64.prototype.idiv = function idiv(b) {
	  let a = this;

	  enforce(N64.isN64(b), 'divisor', 'int64');

	  if (b.isZero())
	    throw new Error('Cannot divide by zero.');

	  if (a.isZero())
	    return a;

	  if (a.eq(b))
	    return a.set(1);

	  if (a.isSafe() && b.isSafe()) {
	    const n = a.toDouble();
	    const d = b.toDouble();
	    const q = floor(n / d);
	    return a.set(q);
	  }

	  let neg = false;

	  if (a.sign) {
	    if (a.hi < 0) {
	      if (b.hi < 0) {
	        a = a.ineg();
	        b = b.neg();
	      } else {
	        a = a.ineg();
	        neg = true;
	      }
	    } else if (b.hi < 0) {
	      b = b.neg();
	      neg = true;
	    }
	  }

	  const n = a.toU64();
	  const d = b.toU64();

	  if (n.lt(d))
	    return a.set(0);

	  if (n.ushrn(1).lt(d))
	    return a.set(neg ? -1 : 1);

	  const q = new U64();
	  const r = new U64();

	  let bit = n.bitLength();

	  while (bit--) {
	    r.ishln(1);
	    r.lo |= n.testn(bit);
	    if (r.gte(d)) {
	      r.isub(d);
	      q.setn(bit, 1);
	    }
	  }

	  a.hi = q.hi;
	  a.lo = q.lo;

	  if (neg)
	    a.ineg();

	  return a;
	};

	N64.prototype.idivn = function idivn(num) {
	  enforce(isNumber(num), 'divisor', 'number');
	  return this.idiv(this._small(num));
	};

	N64.prototype.div = function div(b) {
	  return this.clone().idiv(b);
	};

	N64.prototype.divn = function divn(num) {
	  return this.clone().idivn(num);
	};

	/*
	 * Modulo
	 */

	N64.prototype.imod = function imod(b) {
	  const a = this;

	  enforce(N64.isN64(b), 'divisor', 'int64');

	  if (b.isZero())
	    throw new Error('Cannot divide by zero.');

	  if (a.isZero())
	    return a;

	  if (a.eq(b))
	    return a.set(0);

	  if (a.isSafe() && b.isSafe()) {
	    const n = a.toDouble();
	    const d = b.toDouble();
	    const r = n % d;
	    return a.set(r);
	  }

	  return a.isub(a.div(b).imul(b));
	};

	N64.prototype.imodn = function imodn(num) {
	  enforce(isNumber(num), 'divisor', 'number');
	  return this.imod(this._small(num));
	};

	N64.prototype.mod = function mod(b) {
	  return this.clone().imod(b);
	};

	N64.prototype.modn = function modn(num) {
	  return this.clone().imodn(num);
	};

	/*
	 * Exponentiation
	 */

	N64.prototype.ipow = function ipow(b) {
	  enforce(N64.isN64(b), 'exponent', 'int64');
	  return this.ipown(b.lo);
	};

	N64.prototype.ipown = function ipown(num) {
	  enforce(isNumber(num), 'exponent', 'number');

	  if (this.isZero())
	    return this;

	  const x = this.clone();
	  const n = this;

	  let y = num >>> 0;

	  n.set(1);

	  while (y > 0) {
	    if (y & 1)
	      n.imul(x);
	    y >>>= 1;
	    x.imul(x);
	  }

	  return n;
	};

	N64.prototype.pow = function pow(b) {
	  return this.clone().ipow(b);
	};

	N64.prototype.pown = function pown(num) {
	  return this.clone().ipown(num);
	};

	N64.prototype.sqr = function sqr() {
	  return this.mul(this);
	};

	N64.prototype.isqr = function isqr() {
	  return this.imul(this);
	};

	/*
	 * AND
	 */

	N64.prototype.iand = function iand(b) {
	  enforce(N64.isN64(b), 'operand', 'int64');
	  this.hi &= b.hi;
	  this.lo &= b.lo;
	  return this;
	};

	N64.prototype.iandn = function iandn(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  this.hi &= (num >> 31) & -this.sign;
	  this.lo &= num | 0;
	  return this;
	};

	N64.prototype.and = function and(b) {
	  return this.clone().iand(b);
	};

	N64.prototype.andn = function andn(num) {
	  return this.clone().iandn(num);
	};

	/*
	 * OR
	 */

	N64.prototype.ior = function ior(b) {
	  enforce(N64.isN64(b), 'operand', 'int64');
	  this.hi |= b.hi;
	  this.lo |= b.lo;
	  return this;
	};

	N64.prototype.iorn = function iorn(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  this.hi |= (num >> 31) & -this.sign;
	  this.lo |= num | 0;
	  return this;
	};

	N64.prototype.or = function or(b) {
	  return this.clone().ior(b);
	};

	N64.prototype.orn = function orn(num) {
	  return this.clone().iorn(num);
	};

	/*
	 * XOR
	 */

	N64.prototype.ixor = function ixor(b) {
	  enforce(N64.isN64(b), 'operand', 'int64');
	  this.hi ^= b.hi;
	  this.lo ^= b.lo;
	  return this;
	};

	N64.prototype.ixorn = function ixorn(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  this.hi ^= (num >> 31) & -this.sign;
	  this.lo ^= num | 0;
	  return this;
	};

	N64.prototype.xor = function xor(b) {
	  return this.clone().ixor(b);
	};

	N64.prototype.xorn = function xorn(num) {
	  return this.clone().ixorn(num);
	};

	/*
	 * NOT
	 */

	N64.prototype.inot = function inot() {
	  this.hi = ~this.hi;
	  this.lo = ~this.lo;
	  return this;
	};

	N64.prototype.not = function not() {
	  return this.clone().inot();
	};

	/*
	 * Left Shift
	 */

	N64.prototype.ishl = function ishl(b) {
	  enforce(N64.isN64(b), 'bits', 'int64');
	  return this.ishln(b.lo);
	};

	N64.prototype.ishln = function ishln(bits) {
	  enforce(isNumber(bits), 'bits', 'number');

	  bits &= 63;

	  if (bits === 0)
	    return this;

	  let hi = this.hi;
	  let lo = this.lo;

	  if (bits < 32) {
	    hi <<= bits;
	    hi |= lo >>> (32 - bits);
	    lo <<= bits;
	  } else {
	    hi = lo << (bits - 32);
	    lo = 0;
	  }

	  this.hi = hi;
	  this.lo = lo;

	  return this;
	};

	N64.prototype.shl = function shl(b) {
	  return this.clone().ishl(b);
	};

	N64.prototype.shln = function shln(bits) {
	  return this.clone().ishln(bits);
	};

	/*
	 * Right Shift
	 */

	N64.prototype.ishr = function ishr(b) {
	  enforce(N64.isN64(b), 'bits', 'int64');
	  return this.ishrn(b.lo);
	};

	N64.prototype.ishrn = function ishrn(bits) {
	  if (!this.sign)
	    return this.iushrn(bits);

	  enforce(isNumber(bits), 'bits', 'number');

	  bits &= 63;

	  if (bits === 0)
	    return this;

	  let hi = this.hi;
	  let lo = this.lo;

	  if (bits < 32) {
	    lo >>>= bits;
	    lo |= hi << (32 - bits);
	    hi >>= bits;
	  } else {
	    lo = hi >> (bits - 32);
	    hi = hi >> 31;
	  }

	  this.hi = hi;
	  this.lo = lo;

	  return this;
	};

	N64.prototype.shr = function shr(b) {
	  return this.clone().ishr(b);
	};

	N64.prototype.shrn = function shrn(bits) {
	  return this.clone().ishrn(bits);
	};

	/*
	 * Unsigned Right Shift
	 */

	N64.prototype.iushr = function iushr(b) {
	  enforce(N64.isN64(b), 'bits', 'int64');
	  return this.iushrn(b.lo);
	};

	N64.prototype.iushrn = function iushrn(bits) {
	  enforce(isNumber(bits), 'bits', 'number');

	  bits &= 63;

	  if (bits === 0)
	    return this;

	  let hi = this.hi;
	  let lo = this.lo;

	  if (bits < 32) {
	    lo >>>= bits;
	    lo |= hi << (32 - bits);
	    hi >>>= bits;
	  } else {
	    lo = hi >>> (bits - 32);
	    hi = 0;
	  }

	  this.hi = hi | 0;
	  this.lo = lo | 0;

	  return this;
	};

	N64.prototype.ushr = function ushr(b) {
	  return this.clone().iushr(b);
	};

	N64.prototype.ushrn = function ushrn(bits) {
	  return this.clone().iushrn(bits);
	};

	/*
	 * Bit Manipulation
	 */

	N64.prototype.setn = function setn(bit, val) {
	  enforce(isNumber(bit), 'bit', 'number');

	  bit &= 63;

	  if (bit < 32) {
	    if (val)
	      this.lo |= (1 << bit);
	    else
	      this.lo &= ~(1 << bit);
	  } else {
	    if (val)
	      this.hi |= (1 << (bit - 32));
	    else
	      this.hi &= ~(1 << (bit - 32));
	  }

	  return this;
	};

	N64.prototype.testn = function testn(bit) {
	  enforce(isNumber(bit), 'bit', 'number');

	  bit &= 63;

	  if (bit < 32)
	    return (this.lo >>> bit) & 1;

	  return (this.hi >>> (bit - 32)) & 1;
	};

	N64.prototype.setb = function setb(pos, ch) {
	  enforce(isNumber(pos), 'pos', 'number');
	  enforce(isNumber(ch), 'ch', 'number');

	  pos &= 7;
	  ch &= 0xff;

	  if (pos < 4) {
	    this.lo &= ~(0xff << (pos * 8));
	    this.lo |= ch << (pos * 8);
	  } else {
	    this.hi &= ~(0xff << ((pos - 4) * 8));
	    this.hi |= ch << ((pos - 4) * 8);
	  }

	  return this;
	};

	N64.prototype.orb = function orb(pos, ch) {
	  enforce(isNumber(pos), 'pos', 'number');
	  enforce(isNumber(ch), 'ch', 'number');

	  pos &= 7;
	  ch &= 0xff;

	  if (pos < 4)
	    this.lo |= ch << (pos * 8);
	  else
	    this.hi |= ch << ((pos - 4) * 8);

	  return this;
	};

	N64.prototype.getb = function getb(pos) {
	  enforce(isNumber(pos), 'pos', 'number');

	  pos &= 7;

	  if (pos < 4)
	    return (this.lo >> (pos * 8)) & 0xff;

	  return (this.hi >> ((pos - 4) * 8)) & 0xff;
	};

	N64.prototype.imaskn = function imaskn(bit) {
	  enforce(isNumber(bit), 'bit', 'number');

	  bit &= 63;

	  if (bit < 32) {
	    this.hi = 0;
	    this.lo &= (1 << bit) - 1;
	  } else {
	    this.hi &= (1 << (bit - 32)) - 1;
	    this.lo &= 0xffffffff;
	  }

	  return this;
	};

	N64.prototype.maskn = function maskn(bit) {
	  return this.clone().imaskn(bit);
	};

	N64.prototype.andln = function andln(num) {
	  enforce(isNumber(num), 'operand', 'number');
	  return this.lo & num;
	};

	/*
	 * Negation
	 */

	N64.prototype.ineg = function ineg() {
	  let hi = ~this.hi;
	  let lo = ~this.lo;

	  if (lo === -1) {
	    lo = 0;
	    hi += 1;
	    hi |= 0;
	  } else {
	    lo += 1;
	  }

	  this.hi = hi;
	  this.lo = lo;

	  return this;
	};

	N64.prototype.neg = function neg() {
	  return this.clone().ineg();
	};

	N64.prototype.iabs = function iabs() {
	  if (this.isNeg())
	    this.ineg();
	  return this;
	};

	N64.prototype.abs = function abs() {
	  return this.clone().iabs();
	};

	/*
	 * Comparison
	 */

	N64.prototype._cmp = function _cmp(bhi, blo) {
	  const a = this;

	  let ahi = a.hi;
	  let alo = a.lo;

	  if (ahi === bhi && alo === blo)
	    return 0;

	  let neg = false;

	  if (a.sign) {
	    const x = ahi < 0;
	    const y = bhi < 0;

	    if (x && !y)
	      return -1;

	    if (!x && y)
	      return 1;

	    neg = x;
	  }

	  if (!neg) {
	    ahi >>>= 0;
	    bhi >>>= 0;
	  }

	  if (ahi < bhi)
	    return -1;

	  if (ahi > bhi)
	    return 1;

	  alo >>>= 0;
	  blo >>>= 0;

	  if (alo < blo)
	    return -1;

	  return 1;
	};

	N64.prototype.cmp = function cmp(b) {
	  enforce(N64.isN64(b), 'value', 'int64');
	  return this._cmp(b.hi, b.lo);
	};

	N64.prototype.cmpn = function cmpn(num) {
	  enforce(isNumber(num), 'value', 'number');
	  return this._cmp((num >> 31) & -this.sign, num | 0);
	};

	N64.prototype.eq = function eq(b) {
	  enforce(N64.isN64(b), 'value', 'int64');
	  return this.hi === b.hi && this.lo === b.lo;
	};

	N64.prototype.eqn = function eqn(num) {
	  enforce(isNumber(num), 'value', 'number');
	  return this.hi === ((num >> 31) & -this.sign) && this.lo === (num | 0);
	};

	N64.prototype.gt = function gt(b) {
	  return this.cmp(b) > 0;
	};

	N64.prototype.gtn = function gtn(num) {
	  return this.cmpn(num) > 0;
	};

	N64.prototype.gte = function gte(b) {
	  return this.cmp(b) >= 0;
	};

	N64.prototype.gten = function gten(num) {
	  return this.cmpn(num) >= 0;
	};

	N64.prototype.lt = function lt(b) {
	  return this.cmp(b) < 0;
	};

	N64.prototype.ltn = function ltn(num) {
	  return this.cmpn(num) < 0;
	};

	N64.prototype.lte = function lte(b) {
	  return this.cmp(b) <= 0;
	};

	N64.prototype.lten = function lten(num) {
	  return this.cmpn(num) <= 0;
	};

	N64.prototype.isZero = function isZero() {
	  return this.hi === 0 && this.lo === 0;
	};

	N64.prototype.isNeg = function isNeg() {
	  return this.sign === 1 && this.hi < 0;
	};

	N64.prototype.isOdd = function isOdd() {
	  return (this.lo & 1) === 1;
	};

	N64.prototype.isEven = function isEven() {
	  return (this.lo & 1) === 0;
	};

	/*
	 * Helpers
	 */

	N64.prototype.clone = function clone() {
	  const n = new this.constructor();
	  n.hi = this.hi;
	  n.lo = this.lo;
	  return n;
	};

	N64.prototype.inject = function inject(b) {
	  enforce(N64.isN64(b), 'value', 'int64');
	  this.hi = b.hi;
	  this.lo = b.lo;
	  return this;
	};

	N64.prototype.set = function set(num) {
	  enforce(isSafeInteger(num), 'number', 'integer');

	  let neg = false;

	  if (num < 0) {
	    num = -num;
	    neg = true;
	  }

	  this.hi = (num * (1 / 0x100000000)) | 0;
	  this.lo = num | 0;

	  if (neg)
	    this.ineg();

	  return this;
	};

	N64.prototype.join = function join(hi, lo) {
	  enforce(isNumber(hi), 'hi', 'number');
	  enforce(isNumber(lo), 'lo', 'number');
	  this.hi = hi | 0;
	  this.lo = lo | 0;
	  return this;
	};

	N64.prototype._small = function _small(num) {
	  const n = new this.constructor();
	  n.hi = (num >> 31) & -this.sign;
	  n.lo = num | 0;
	  return n;
	};

	N64.prototype.bitLength = function bitLength() {
	  let a = this;

	  if (this.isNeg())
	    a = this.neg();

	  if (a.hi === 0)
	    return countBits(a.lo);

	  return countBits(a.hi) + 32;
	};

	N64.prototype.byteLength = function byteLength() {
	  return Math.ceil(this.bitLength() / 8);
	};

	N64.prototype.isSafe = function isSafe() {
	  let hi = this.hi;

	  if (this.isNeg()) {
	    hi = ~hi;
	    if (this.lo === 0)
	      hi += 1;
	  }

	  return (hi & 0xffe00000) === 0;
	};

	N64.prototype.inspect = function inspect() {
	  let prefix = 'I64';

	  if (!this.sign)
	    prefix = 'U64';

	  return `<${prefix}: ${this.toString(10)}>`;
	};

	/*
	 * Encoding
	 */

	N64.prototype.readLE = function readLE(data, off) {
	  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
	  enforce((off >> 0) === off, 'offset', 'integer');
	  enforce(off + 8 <= data.length, 'offset', 'valid offset');
	  this.lo = readI32LE(data, off);
	  this.hi = readI32LE(data, off + 4);
	  return off + 8;
	};

	N64.prototype.readBE = function readBE(data, off) {
	  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
	  enforce((off >> 0) === off, 'offset', 'integer');
	  enforce(off + 8 <= data.length, 'offset', 'valid offset');
	  this.hi = readI32BE(data, off);
	  this.lo = readI32BE(data, off + 4);
	  return off + 8;
	};

	N64.prototype.readRaw = function readRaw(data, off) {
	  return this.readLE(data, off);
	};

	N64.prototype.writeLE = function writeLE(data, off) {
	  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
	  enforce((off >> 0) === off, 'offset', 'integer');
	  enforce(off + 8 <= data.length, 'offset', 'valid offset');
	  writeI32LE(data, this.lo, off);
	  writeI32LE(data, this.hi, off + 4);
	  return off + 8;
	};

	N64.prototype.writeBE = function writeBE(data, off) {
	  enforce(data && typeof data.length === 'number', 'data', 'arraylike');
	  enforce((off >> 0) === off, 'offset', 'integer');
	  enforce(off + 8 <= data.length, 'offset', 'valid offset');
	  writeI32BE(data, this.hi, off);
	  writeI32BE(data, this.lo, off + 4);
	  return off + 8;
	};

	N64.prototype.writeRaw = function writeRaw(data, off) {
	  return this.writeLE(data, off);
	};

	/*
	 * Conversion
	 */

	N64.prototype.toU64 = function toU64() {
	  const n = new U64();
	  n.hi = this.hi;
	  n.lo = this.lo;
	  return n;
	};

	N64.prototype.toI64 = function toI64() {
	  const n = new I64();
	  n.hi = this.hi;
	  n.lo = this.lo;
	  return n;
	};

	N64.prototype.toNumber = function toNumber() {
	  if (!this.isSafe())
	    throw new Error('Number exceeds 53 bits.');

	  return this.toDouble();
	};

	N64.prototype.toDouble = function toDouble() {
	  let hi = this.hi;

	  if (!this.sign)
	    hi >>>= 0;

	  return hi * 0x100000000 + (this.lo >>> 0);
	};

	N64.prototype.toInt = function toInt() {
	  return this.sign ? this.lo : this.lo >>> 0;
	};

	N64.prototype.toBool = function toBool() {
	  return !this.isZero();
	};

	N64.prototype.toBits = function toBits() {
	  return [this.hi, this.lo];
	};

	N64.prototype.toObject = function toObject() {
	  return { hi: this.hi, lo: this.lo };
	};

	N64.prototype.toString = function toString(base, pad) {
	  base = getBase(base);

	  if (pad == null)
	    pad = 0;

	  enforce((base >>> 0) === base, 'base', 'integer');
	  enforce((pad >>> 0) === pad, 'pad', 'integer');

	  if (base < 2 || base > 16)
	    throw new Error('Base ranges between 2 and 16.');

	  if (pad > 64)
	    throw new Error('Maximum padding is 64 characters.');

	  let n = this;
	  let neg = false;

	  if (n.isNeg()) {
	    n = n.neg();
	    neg = true;
	  }

	  let hi = n.hi >>> 0;
	  let lo = n.lo >>> 0;
	  let str = '';

	  do {
	    const mhi = hi % base;
	    hi -= mhi;
	    hi /= base;
	    lo += mhi * 0x100000000;

	    const mlo = lo % base;
	    lo -= mlo;
	    lo /= base;

	    let ch = mlo;

	    if (ch < 10)
	      ch += 0x30;
	    else
	      ch += 0x61 - 10;

	    str = String.fromCharCode(ch) + str;
	  } while (lo > 0 || hi > 0);

	  while (str.length < pad)
	    str = '0' + str;

	  if (neg)
	    str = '-' + str;

	  return str;
	};

	N64.prototype.toJSON = function toJSON() {
	  return this.toString(16, 16);
	};

	N64.prototype.toBN = function toBN(BN) {
	  const neg = this.isNeg();

	  let hi = this.hi;
	  let lo = this.lo;

	  if (neg) {
	    hi = ~hi;
	    lo = ~lo;
	    if (lo === -1) {
	      lo = 0;
	      hi += 1;
	      hi |= 0;
	    } else {
	      lo += 1;
	    }
	  }

	  hi >>>= 0;
	  lo >>>= 0;

	  const num = new BN(hi);
	  num.ishln(32);
	  num.iadd(new BN(lo));

	  if (neg)
	    num.ineg();

	  return num;
	};

	N64.prototype.toLE = function toLE(ArrayLike) {
	  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');
	  const data = alloc(ArrayLike, 8);
	  this.writeLE(data, 0);
	  return data;
	};

	N64.prototype.toBE = function toBE(ArrayLike) {
	  enforce(typeof ArrayLike === 'function', 'ArrayLike', 'constructor');
	  const data = alloc(ArrayLike, 8);
	  this.writeBE(data, 0);
	  return data;
	};

	N64.prototype.toRaw = function toRaw(ArrayLike) {
	  return this.toLE(ArrayLike);
	};

	/*
	 * Instantiation
	 */

	N64.prototype.fromNumber = function fromNumber(num) {
	  return this.set(num);
	};

	N64.prototype.fromInt = function fromInt(num) {
	  enforce(isNumber(num), 'integer', 'number');
	  return this.join((num >> 31) & -this.sign, num);
	};

	N64.prototype.fromBool = function fromBool(value) {
	  enforce(typeof value === 'boolean', 'value', 'boolean');
	  this.hi = 0;
	  this.lo = value ? 1 : 0;
	  return this;
	};

	N64.prototype.fromBits = function fromBits(hi, lo) {
	  return this.join(hi, lo);
	};

	N64.prototype.fromObject = function fromObject(num) {
	  enforce(num && typeof num === 'object', 'number', 'object');
	  return this.fromBits(num.hi, num.lo);
	};

	N64.prototype.fromString = function fromString(str, base) {
	  base = getBase(base);

	  enforce(typeof str === 'string', 'string', 'string');
	  enforce((base >>> 0) === base, 'base', 'integer');

	  if (base < 2 || base > 16)
	    throw new Error('Base ranges between 2 and 16.');

	  let neg = false;
	  let i = 0;

	  if (str.length > 0 && str[0] === '-') {
	    i += 1;
	    neg = true;
	  }

	  if (str.length === i || str.length > i + 64)
	    throw new Error('Invalid string (bad length).');

	  let hi = 0;
	  let lo = 0;

	  for (; i < str.length; i++) {
	    let ch = str.charCodeAt(i);

	    if (ch >= 0x30 && ch <= 0x39)
	      ch -= 0x30;
	    else if (ch >= 0x41 && ch <= 0x5a)
	      ch -= 0x41 - 10;
	    else if (ch >= 0x61 && ch <= 0x7a)
	      ch -= 0x61 - 10;
	    else
	      ch = base;

	    if (ch >= base)
	      throw new Error('Invalid string (parse error).');

	    lo *= base;
	    lo += ch;

	    hi *= base;

	    if (lo > 0xffffffff) {
	      ch = lo % 0x100000000;
	      hi += (lo - ch) / 0x100000000;
	      lo = ch;
	    }

	    if (hi > 0xffffffff)
	      throw new Error('Invalid string (overflow).');
	  }

	  this.hi = hi | 0;
	  this.lo = lo | 0;

	  if (neg)
	    this.ineg();

	  return this;
	};

	N64.prototype.fromJSON = function fromJSON(json) {
	  return this.fromString(json, 16);
	};

	N64.prototype.fromBN = function fromBN(num) {
	  enforce(num && isArray(num.words), 'number', 'big number');

	  const a = this;
	  const b = num.clone();
	  const neg = b.isNeg();

	  if (a.sign && b.testn(63))
	    throw new Error('Big number overflow.');

	  let i = 0;

	  while (!b.isZero()) {
	    if (i === 8)
	      throw new Error('Big number overflow.');

	    a.orb(i, b.andln(0xff));
	    b.iushrn(8);
	    i++;
	  }

	  if (neg)
	    a.ineg();

	  return a;
	};

	N64.prototype.fromLE = function fromLE(data) {
	  this.readLE(data, 0);
	  return this;
	};

	N64.prototype.fromBE = function fromBE(data) {
	  this.readBE(data, 0);
	  return this;
	};

	N64.prototype.fromRaw = function fromRaw(data) {
	  return this.fromLE(data);
	};

	N64.prototype.from = function from(num, base) {
	  if (num == null)
	    return this;

	  if (typeof num === 'number') {
	    if (typeof base === 'number')
	      return this.fromBits(num, base);
	    return this.fromNumber(num);
	  }

	  if (typeof num === 'string')
	    return this.fromString(num, base);

	  if (typeof num === 'object') {
	    if (isArray(num.words))
	      return this.fromBN(num);

	    if (typeof num.length === 'number')
	      return this.fromRaw(num);

	    return this.fromObject(num);
	  }

	  if (typeof num === 'boolean')
	    return this.fromBool(num);

	  throw new TypeError('Non-numeric object passed to N64.');
	};

	/*
	 * Static Methods
	 */

	N64.min = function min(a, b) {
	  return a.cmp(b) < 0 ? a : b;
	};

	N64.max = function max(a, b) {
	  return a.cmp(b) > 0 ? a : b;
	};

	N64.random = function random() {
	  const n = new this();
	  n.hi = (Math.random() * 0x100000000) | 0;
	  n.lo = (Math.random() * 0x100000000) | 0;
	  return n;
	};

	N64.pow = function pow(num, exp) {
	  return new this().fromInt(num).ipown(exp);
	};

	N64.shift = function shift(num, bits) {
	  return new this().fromInt(num).ishln(bits);
	};

	N64.readLE = function readLE(data, off) {
	  const n = new this();
	  n.readLE(data, off);
	  return n;
	};

	N64.readBE = function readBE(data, off) {
	  const n = new this();
	  n.readBE(data, off);
	  return n;
	};

	N64.readRaw = function readRaw(data, off) {
	  const n = new this();
	  n.readRaw(data, off);
	  return n;
	};

	N64.fromNumber = function fromNumber(num) {
	  return new this().fromNumber(num);
	};

	N64.fromInt = function fromInt(num) {
	  return new this().fromInt(num);
	};

	N64.fromBool = function fromBool(value) {
	  return new this().fromBool(value);
	};

	N64.fromBits = function fromBits(hi, lo) {
	  return new this().fromBits(hi, lo);
	};

	N64.fromObject = function fromObject(obj) {
	  return new this().fromObject(obj);
	};

	N64.fromString = function fromString(str, base) {
	  return new this().fromString(str, base);
	};

	N64.fromJSON = function fromJSON(json) {
	  return new this().fromJSON(json);
	};

	N64.fromBN = function fromBN(num) {
	  return new this().fromBN(num);
	};

	N64.fromLE = function fromLE(data) {
	  return new this().fromLE(data);
	};

	N64.fromBE = function fromBE(data) {
	  return new this().fromBE(data);
	};

	N64.fromRaw = function fromRaw(data) {
	  return new this().fromRaw(data);
	};

	N64.from = function from(num, base) {
	  return new this().from(num, base);
	};

	N64.isN64 = function isN64(obj) {
	  return obj instanceof N64;
	};

	N64.isU64 = function isU64(obj) {
	  return obj instanceof U64;
	};

	N64.isI64 = function isI64(obj) {
	  return obj instanceof I64;
	};

	/*
	 * U64
	 */

	function U64(num, base) {
	  if (!(this instanceof U64))
	    return new U64(num, base);

	  N64.call(this, 0);

	  this.from(num, base);
	}

	U64.__proto__ = N64;
	U64.prototype.__proto__ = N64.prototype;

	/*
	 * Constants
	 */

	U64.ULONG_MIN = 0x00000000;
	U64.ULONG_MAX = 0xffffffff;

	U64.UINT32_MIN = U64(0x00000000, 0x00000000);
	U64.UINT32_MAX = U64(0x00000000, 0xffffffff);

	U64.UINT64_MIN = U64(0x00000000, 0x00000000);
	U64.UINT64_MAX = U64(0xffffffff, 0xffffffff);

	/*
	 * I64
	 */

	function I64(num, base) {
	  if (!(this instanceof I64))
	    return new I64(num, base);

	  N64.call(this, 1);

	  this.from(num, base);
	}

	I64.__proto__ = N64;
	I64.prototype.__proto__ = N64.prototype;

	/*
	 * Constants
	 */

	I64.LONG_MIN = -2147483648;
	I64.LONG_MAX = 0x7fffffff;

	I64.INT32_MIN = I64(0xffffffff, 0x80000000);
	I64.INT32_MAX = I64(0x00000000, 0x7fffffff);

	I64.INT64_MIN = I64(0x80000000, 0x00000000);
	I64.INT64_MAX = I64(0x7fffffff, 0xffffffff);

	/*
	 * Helpers
	 */

	function getBase(base) {
	  if (base == null)
	    return 10;

	  if (typeof base === 'number')
	    return base;

	  switch (base) {
	    case 'bin':
	      return 2;
	    case 'oct':
	      return 8;
	    case 'dec':
	      return 10;
	    case 'hex':
	      return 16;
	  }

	  return 0;
	}

	function countBits(word) {
	  if (Math.clz32)
	    return 32 - Math.clz32(word);

	  let bit = 31;

	  for (; bit >= 0; bit--) {
	    if ((word & (1 << bit)) !== 0)
	      break;
	  }

	  return bit + 1;
	}

	function floor(n) {
	  if (n < 0)
	    return -Math.floor(-n);
	  return Math.floor(n);
	}

	function enforce(value, name, type) {
	  if (!value) {
	    const err = new TypeError(`'${name}' must be a(n) ${type}.`);
	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, enforce);
	    throw err;
	  }
	}

	function isNumber(num) {
	  return typeof num === 'number' && isFinite(num);
	}

	function isArray(num) {
	  if (Array.isArray)
	    return Array.isArray(num);

	  return ({}).toString.call(num).slice(8, -1) === 'Array';
	}

	function isSafeInteger(num) {
	  if (Number.isSafeInteger)
	    return Number.isSafeInteger(num);

	  return isNumber(num)
	    && Math.floor(num) === num
	    && num >= -9007199254740991
	    && num <= 0x001fffffffffffff;
	}

	function alloc(ArrayLike, size) {
	  if (ArrayLike.allocUnsafe)
	    return ArrayLike.allocUnsafe(size);

	  return new ArrayLike(size);
	}

	function readI32LE(data, off) {
	  return data[off]
	    | (data[off + 1] << 8)
	    | (data[off + 2] << 16)
	    | (data[off + 3] << 24);
	}

	function readI32BE(data, off) {
	  return (data[off] << 24)
	    | (data[off + 1] << 16)
	    | (data[off + 2] << 8)
	    | data[off + 3];
	}

	function writeI32LE(data, num, off) {
	  data[off] = num & 0xff;
	  data[off + 1] = (num >>> 8) & 0xff;
	  data[off + 2] = (num >>> 16) & 0xff;
	  data[off + 3] = (num >>> 24) & 0xff;
	}

	function writeI32BE(data, num, off) {
	  data[off] = (num >>> 24) & 0xff;
	  data[off + 1] = (num >>> 16) & 0xff;
	  data[off + 2] = (num >>> 8) & 0xff;
	  data[off + 3] = num & 0xff;
	}

	/*
	 * Expose
	 */

	n64.N64 = N64;
	n64.U64 = U64;
	n64.I64 = I64;
	return n64;
}

/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var scripterror;
var hasRequiredScripterror;

function requireScripterror () {
	if (hasRequiredScripterror) return scripterror;
	hasRequiredScripterror = 1;

	/**
	 * Script Error
	 * An error thrown from the scripting system,
	 * potentially pertaining to Script execution.
	 * @alias module:script.ScriptError
	 * @extends Error
	 * @property {String} message - Error message.
	 * @property {String} code - Original code passed in.
	 * @property {Number} op - Opcode.
	 * @property {Number} ip - Instruction pointer.
	 */
	class ScriptError extends Error {
	  /**
	   * Create an error.
	   * @constructor
	   * @param {String} code - Error code.
	   * @param {Opcode} op - Opcode.
	   * @param {Number?} ip - Instruction pointer.
	   */

	  constructor(code, op, ip) {
	    super();
	    this.type = 'ScriptError';
	    this.code = code;
	    this.message = code;
	    this.op = -1;
	    this.ip = -1;
	    if (typeof op === 'string') {
	      this.message = op;
	    } else if (op) {
	      this.message = `${code} (op=${op.toSymbol()}, ip=${ip})`;
	      this.op = op.value;
	      this.ip = ip;
	    }
	    if (Error.captureStackTrace) Error.captureStackTrace(this, ScriptError);
	  }
	}

	/*
	 * Expose
	 */

	scripterror = ScriptError;
	return scripterror;
}

/*!
 * scriptnum.js - script number object for bcoin.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var scriptnum;
var hasRequiredScriptnum;

function requireScriptnum () {
	if (hasRequiredScriptnum) return scriptnum;
	hasRequiredScriptnum = 1;

	const assert = requireAssert$1();
	const {
	  I64
	} = requireN64();
	const ScriptError = requireScripterror();

	/*
	 * Constants
	 */

	const EMPTY_ARRAY = Buffer.alloc(0);

	/**
	 * Script Number
	 * @see https://github.com/chjj/n64
	 * @alias module:script.ScriptNum
	 * @property {Number} hi
	 * @property {Number} lo
	 * @property {Number} sign
	 */

	class ScriptNum extends I64 {
	  /**
	   * Create a script number.
	   * @constructor
	   * @param {(Number|String|Buffer|Object)?} num
	   * @param {(String|Number)?} base
	   */

	  constructor(num, base) {
	    super(num, base);
	  }

	  /**
	   * Cast to int32.
	   * @returns {Number}
	   */

	  getInt() {
	    if (this.lt(I64.INT32_MIN)) return I64.LONG_MIN;
	    if (this.gt(I64.INT32_MAX)) return I64.LONG_MAX;
	    return this.toInt();
	  }

	  /**
	   * Serialize script number.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    let num = this;

	    // Zeroes are always empty arrays.
	    if (num.isZero()) return EMPTY_ARRAY;

	    // Need to append sign bit.
	    let neg = false;
	    if (num.isNeg()) {
	      num = num.neg();
	      neg = true;
	    }

	    // Calculate size.
	    const size = num.byteLength();
	    let offset = 0;
	    if (num.testn(size * 8 - 1)) offset = 1;

	    // Write number.
	    const data = Buffer.allocUnsafe(size + offset);
	    switch (size) {
	      case 8:
	        data[7] = num.hi >>> 24 & 0xff;
	      case 7:
	        data[6] = num.hi >> 16 & 0xff;
	      case 6:
	        data[5] = num.hi >> 8 & 0xff;
	      case 5:
	        data[4] = num.hi & 0xff;
	      case 4:
	        data[3] = num.lo >>> 24 & 0xff;
	      case 3:
	        data[2] = num.lo >> 16 & 0xff;
	      case 2:
	        data[1] = num.lo >> 8 & 0xff;
	      case 1:
	        data[0] = num.lo & 0xff;
	    }

	    // Append sign bit.
	    if (data[size - 1] & 0x80) {
	      assert(offset === 1);
	      assert(data.length === size + offset);
	      data[size] = neg ? 0x80 : 0;
	    } else if (neg) {
	      assert(offset === 0);
	      assert(data.length === size);
	      data[size - 1] |= 0x80;
	    } else {
	      assert(offset === 0);
	      assert(data.length === size);
	    }
	    return data;
	  }

	  /**
	   * Instantiate script number from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {ScriptNum}
	   */

	  fromRaw(data) {
	    assert(Buffer.isBuffer(data));

	    // Empty arrays are always zero.
	    if (data.length === 0) return this;

	    // Read number (9 bytes max).
	    switch (data.length) {
	      case 8:
	        this.hi |= data[7] << 24;
	      case 7:
	        this.hi |= data[6] << 16;
	      case 6:
	        this.hi |= data[5] << 8;
	      case 5:
	        this.hi |= data[4];
	      case 4:
	        this.lo |= data[3] << 24;
	      case 3:
	        this.lo |= data[2] << 16;
	      case 2:
	        this.lo |= data[1] << 8;
	      case 1:
	        this.lo |= data[0];
	        break;
	      default:
	        for (let i = 0; i < data.length; i++) this.orb(i, data[i]);
	        break;
	    }

	    // Remove high bit and flip sign.
	    if (data[data.length - 1] & 0x80) {
	      this.setn(data.length * 8 - 1, 0);
	      this.ineg();
	    }
	    return this;
	  }

	  /**
	   * Serialize script number.
	   * @returns {Buffer}
	   */

	  encode() {
	    return this.toRaw();
	  }

	  /**
	   * Decode and verify script number.
	   * @private
	   * @param {Buffer} data
	   * @param {Boolean?} minimal - Require minimal encoding.
	   * @param {Number?} limit - Size limit.
	   * @returns {ScriptNum}
	   */

	  decode(data, minimal, limit) {
	    assert(Buffer.isBuffer(data));
	    if (limit != null && data.length > limit) throw new ScriptError('UNKNOWN_ERROR', 'Script number overflow.');
	    if (minimal && !ScriptNum.isMinimal(data)) throw new ScriptError('UNKNOWN_ERROR', 'Non-minimal script number.');
	    return this.fromRaw(data);
	  }

	  /**
	   * Inspect script number.
	   * @returns {String}
	   */

	  inspect() {
	    return `<ScriptNum: ${this.toString(10)}>`;
	  }

	  /**
	   * Test wether a serialized script
	   * number is in its most minimal form.
	   * @param {Buffer} data
	   * @returns {Boolean}
	   */

	  static isMinimal(data) {
	    assert(Buffer.isBuffer(data));
	    if (data.length === 0) return true;
	    if ((data[data.length - 1] & 0x7f) === 0) {
	      if (data.length === 1) return false;
	      if ((data[data.length - 2] & 0x80) === 0) return false;
	    }
	    return true;
	  }

	  /**
	   * Encode serialized script number in its most minimal form.
	   * @param {Buffer} data
	   * @returns {Buffer} minimal encoded data
	   */

	  static toMinimal(data) {
	    assert(Buffer.isBuffer(data));
	    if (this.isMinimal(data)) return data;
	    const last = data[data.length - 1];

	    // We are not minimally encoded, we need to figure out how much to trim.
	    for (let i = data.length - 1; i > 0; i--) {
	      // We found a non zero byte, time to encode.
	      if (data[i - 1] !== 0) {
	        if (data[i - 1] & 0x80) {
	          // We found a byte with it sign bit set so we need one more
	          // byte.
	          data[i++] = last;
	        } else {
	          // the sign bit is clear, we can use it.
	          data[i - 1] |= last;
	        }
	        data = data.slice(0, i);
	        return data;
	      }
	    }

	    // If we the whole thing is zeros, then we have a zero.
	    data = Buffer.alloc(0);
	    return data;
	  }

	  /**
	   * Decode and verify script number.
	   * @param {Buffer} data
	   * @param {Boolean?} minimal - Require minimal encoding.
	   * @param {Number?} limit - Size limit.
	   * @returns {ScriptNum}
	   */

	  static decode(data, minimal, limit) {
	    return new this().decode(data, minimal, limit);
	  }

	  /**
	   * Test whether object is a script number.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isScriptNum(obj) {
	    return obj instanceof ScriptNum;
	  }
	}

	/*
	 * Expose
	 */

	scriptnum = ScriptNum;
	return scriptnum;
}

var common$1 = {};

/*!
 * common.js - common script functions for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	(function (exports) {

		/**
		 * @module script/common
		 */
		const assert = requireAssert$1();
		const secp256k1 = requireSecp256k1();
		const ScriptNum = requireScriptnum();

		/**
		 * Script opcodes.
		 * @enum {Number}
		 * @default
		 */

		exports.opcodes = {
		  // Push
		  OP_0: 0x00,
		  OP_PUSHDATA1: 0x4c,
		  OP_PUSHDATA2: 0x4d,
		  OP_PUSHDATA4: 0x4e,
		  OP_1NEGATE: 0x4f,
		  OP_RESERVED: 0x50,
		  OP_1: 0x51,
		  OP_2: 0x52,
		  OP_3: 0x53,
		  OP_4: 0x54,
		  OP_5: 0x55,
		  OP_6: 0x56,
		  OP_7: 0x57,
		  OP_8: 0x58,
		  OP_9: 0x59,
		  OP_10: 0x5a,
		  OP_11: 0x5b,
		  OP_12: 0x5c,
		  OP_13: 0x5d,
		  OP_14: 0x5e,
		  OP_15: 0x5f,
		  OP_16: 0x60,
		  // Control
		  OP_NOP: 0x61,
		  OP_VER: 0x62,
		  OP_IF: 0x63,
		  OP_NOTIF: 0x64,
		  OP_VERIF: 0x65,
		  OP_VERNOTIF: 0x66,
		  OP_ELSE: 0x67,
		  OP_ENDIF: 0x68,
		  OP_VERIFY: 0x69,
		  OP_RETURN: 0x6a,
		  // Stack
		  OP_TOALTSTACK: 0x6b,
		  OP_FROMALTSTACK: 0x6c,
		  OP_2DROP: 0x6d,
		  OP_2DUP: 0x6e,
		  OP_3DUP: 0x6f,
		  OP_2OVER: 0x70,
		  OP_2ROT: 0x71,
		  OP_2SWAP: 0x72,
		  OP_IFDUP: 0x73,
		  OP_DEPTH: 0x74,
		  OP_DROP: 0x75,
		  OP_DUP: 0x76,
		  OP_NIP: 0x77,
		  OP_OVER: 0x78,
		  OP_PICK: 0x79,
		  OP_ROLL: 0x7a,
		  OP_ROT: 0x7b,
		  OP_SWAP: 0x7c,
		  OP_TUCK: 0x7d,
		  // Splice
		  OP_CAT: 0x7e,
		  OP_SPLIT: 0x7f,
		  OP_NUM2BIN: 0x80,
		  OP_BIN2NUM: 0x81,
		  OP_SIZE: 0x82,
		  // Bit
		  OP_INVERT: 0x83,
		  OP_AND: 0x84,
		  OP_OR: 0x85,
		  OP_XOR: 0x86,
		  OP_EQUAL: 0x87,
		  OP_EQUALVERIFY: 0x88,
		  OP_RESERVED1: 0x89,
		  OP_RESERVED2: 0x8a,
		  // Numeric
		  OP_1ADD: 0x8b,
		  OP_1SUB: 0x8c,
		  OP_2MUL: 0x8d,
		  OP_2DIV: 0x8e,
		  OP_NEGATE: 0x8f,
		  OP_ABS: 0x90,
		  OP_NOT: 0x91,
		  OP_0NOTEQUAL: 0x92,
		  OP_ADD: 0x93,
		  OP_SUB: 0x94,
		  OP_MUL: 0x95,
		  OP_DIV: 0x96,
		  OP_MOD: 0x97,
		  OP_LSHIFT: 0x98,
		  OP_RSHIFT: 0x99,
		  OP_BOOLAND: 0x9a,
		  OP_BOOLOR: 0x9b,
		  OP_NUMEQUAL: 0x9c,
		  OP_NUMEQUALVERIFY: 0x9d,
		  OP_NUMNOTEQUAL: 0x9e,
		  OP_LESSTHAN: 0x9f,
		  OP_GREATERTHAN: 0xa0,
		  OP_LESSTHANOREQUAL: 0xa1,
		  OP_GREATERTHANOREQUAL: 0xa2,
		  OP_MIN: 0xa3,
		  OP_MAX: 0xa4,
		  OP_WITHIN: 0xa5,
		  // Crypto
		  OP_RIPEMD160: 0xa6,
		  OP_SHA1: 0xa7,
		  OP_SHA256: 0xa8,
		  OP_HASH160: 0xa9,
		  OP_HASH256: 0xaa,
		  OP_CODESEPARATOR: 0xab,
		  OP_CHECKSIG: 0xac,
		  OP_CHECKSIGVERIFY: 0xad,
		  OP_CHECKMULTISIG: 0xae,
		  OP_CHECKMULTISIGVERIFY: 0xaf,
		  // Expansion
		  OP_NOP1: 0xb0,
		  OP_CHECKLOCKTIMEVERIFY: 0xb1,
		  OP_CHECKSEQUENCEVERIFY: 0xb2,
		  OP_NOP4: 0xb3,
		  OP_NOP5: 0xb4,
		  OP_NOP6: 0xb5,
		  OP_NOP7: 0xb6,
		  OP_NOP8: 0xb7,
		  OP_NOP9: 0xb8,
		  OP_NOP10: 0xb9,
		  // More Crypto
		  OP_CHECKDATASIG: 0xba,
		  OP_CHECKDATASIGVERIFY: 0xbb,
		  // additional byte-string operations
		  OP_REVERSEBYTES: 0xbc,
		  // Custom
		  OP_INVALIDOPCODE: 0xff
		};

		/**
		 * Opcodes by value.
		 * @const {Object}
		 */

		exports.opcodesByVal = {
		  // Push
		  0x00: 'OP_0',
		  0x4c: 'OP_PUSHDATA1',
		  0x4d: 'OP_PUSHDATA2',
		  0x4e: 'OP_PUSHDATA4',
		  0x4f: 'OP_1NEGATE',
		  0x50: 'OP_RESERVED',
		  0x51: 'OP_1',
		  0x52: 'OP_2',
		  0x53: 'OP_3',
		  0x54: 'OP_4',
		  0x55: 'OP_5',
		  0x56: 'OP_6',
		  0x57: 'OP_7',
		  0x58: 'OP_8',
		  0x59: 'OP_9',
		  0x5a: 'OP_10',
		  0x5b: 'OP_11',
		  0x5c: 'OP_12',
		  0x5d: 'OP_13',
		  0x5e: 'OP_14',
		  0x5f: 'OP_15',
		  0x60: 'OP_16',
		  // Control
		  0x61: 'OP_NOP',
		  0x62: 'OP_VER',
		  0x63: 'OP_IF',
		  0x64: 'OP_NOTIF',
		  0x65: 'OP_VERIF',
		  0x66: 'OP_VERNOTIF',
		  0x67: 'OP_ELSE',
		  0x68: 'OP_ENDIF',
		  0x69: 'OP_VERIFY',
		  0x6a: 'OP_RETURN',
		  // Stack
		  0x6b: 'OP_TOALTSTACK',
		  0x6c: 'OP_FROMALTSTACK',
		  0x6d: 'OP_2DROP',
		  0x6e: 'OP_2DUP',
		  0x6f: 'OP_3DUP',
		  0x70: 'OP_2OVER',
		  0x71: 'OP_2ROT',
		  0x72: 'OP_2SWAP',
		  0x73: 'OP_IFDUP',
		  0x74: 'OP_DEPTH',
		  0x75: 'OP_DROP',
		  0x76: 'OP_DUP',
		  0x77: 'OP_NIP',
		  0x78: 'OP_OVER',
		  0x79: 'OP_PICK',
		  0x7a: 'OP_ROLL',
		  0x7b: 'OP_ROT',
		  0x7c: 'OP_SWAP',
		  0x7d: 'OP_TUCK',
		  // Splice
		  0x7e: 'OP_CAT',
		  0x7f: 'OP_SPLIT',
		  0x80: 'OP_NUM2BIN',
		  0x81: 'OP_BIN2NUM',
		  0x82: 'OP_SIZE',
		  // Bit
		  0x83: 'OP_INVERT',
		  0x84: 'OP_AND',
		  0x85: 'OP_OR',
		  0x86: 'OP_XOR',
		  0x87: 'OP_EQUAL',
		  0x88: 'OP_EQUALVERIFY',
		  0x89: 'OP_RESERVED1',
		  0x8a: 'OP_RESERVED2',
		  // Numeric
		  0x8b: 'OP_1ADD',
		  0x8c: 'OP_1SUB',
		  0x8d: 'OP_2MUL',
		  0x8e: 'OP_2DIV',
		  0x8f: 'OP_NEGATE',
		  0x90: 'OP_ABS',
		  0x91: 'OP_NOT',
		  0x92: 'OP_0NOTEQUAL',
		  0x93: 'OP_ADD',
		  0x94: 'OP_SUB',
		  0x95: 'OP_MUL',
		  0x96: 'OP_DIV',
		  0x97: 'OP_MOD',
		  0x98: 'OP_LSHIFT',
		  0x99: 'OP_RSHIFT',
		  0x9a: 'OP_BOOLAND',
		  0x9b: 'OP_BOOLOR',
		  0x9c: 'OP_NUMEQUAL',
		  0x9d: 'OP_NUMEQUALVERIFY',
		  0x9e: 'OP_NUMNOTEQUAL',
		  0x9f: 'OP_LESSTHAN',
		  0xa0: 'OP_GREATERTHAN',
		  0xa1: 'OP_LESSTHANOREQUAL',
		  0xa2: 'OP_GREATERTHANOREQUAL',
		  0xa3: 'OP_MIN',
		  0xa4: 'OP_MAX',
		  0xa5: 'OP_WITHIN',
		  // Crypto
		  0xa6: 'OP_RIPEMD160',
		  0xa7: 'OP_SHA1',
		  0xa8: 'OP_SHA256',
		  0xa9: 'OP_HASH160',
		  0xaa: 'OP_HASH256',
		  0xab: 'OP_CODESEPARATOR',
		  0xac: 'OP_CHECKSIG',
		  0xad: 'OP_CHECKSIGVERIFY',
		  0xae: 'OP_CHECKMULTISIG',
		  0xaf: 'OP_CHECKMULTISIGVERIFY',
		  // Expansion
		  0xb0: 'OP_NOP1',
		  0xb1: 'OP_CHECKLOCKTIMEVERIFY',
		  0xb2: 'OP_CHECKSEQUENCEVERIFY',
		  0xb3: 'OP_NOP4',
		  0xb4: 'OP_NOP5',
		  0xb5: 'OP_NOP6',
		  0xb6: 'OP_NOP7',
		  0xb7: 'OP_NOP8',
		  0xb8: 'OP_NOP9',
		  0xb9: 'OP_NOP10',
		  // More Crypto
		  0xba: 'OP_CHECKDATASIG',
		  0xbb: 'OP_CHECKDATASIGVERIFY',
		  // Additional byte-string operation
		  0xbc: 'OP_REVERSEBYTES',
		  // Custom
		  0xff: 'OP_INVALIDOPCODE'
		};

		/**
		 * Small ints (1 indexed, 1==0).
		 * @const {Buffer[]}
		 */

		exports.small = [Buffer.from([0x81]), Buffer.from([]), Buffer.from([0x01]), Buffer.from([0x02]), Buffer.from([0x03]), Buffer.from([0x04]), Buffer.from([0x05]), Buffer.from([0x06]), Buffer.from([0x07]), Buffer.from([0x08]), Buffer.from([0x09]), Buffer.from([0x0a]), Buffer.from([0x0b]), Buffer.from([0x0c]), Buffer.from([0x0d]), Buffer.from([0x0e]), Buffer.from([0x0f]), Buffer.from([0x10])];

		/**
		 * Script and locktime flags. See {@link VerifyFlags}.
		 * @enum {Number}
		 */

		exports.flags = {
		  VERIFY_NONE: 0,
		  VERIFY_P2SH: 1 << 0,
		  VERIFY_STRICTENC: 1 << 1,
		  VERIFY_DERSIG: 1 << 2,
		  VERIFY_LOW_S: 1 << 3,
		  VERIFY_SIGPUSHONLY: 1 << 5,
		  VERIFY_MINIMALDATA: 1 << 6,
		  VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 1 << 7,
		  VERIFY_CLEANSTACK: 1 << 8,
		  VERIFY_CHECKLOCKTIMEVERIFY: 1 << 9,
		  VERIFY_CHECKSEQUENCEVERIFY: 1 << 10,
		  VERIFY_MINIMALIF: 1 << 13,
		  VERIFY_NULLFAIL: 1 << 14,
		  VERIFY_COMPRESSED_PUBKEYTYPE: 1 << 15,
		  VERIFY_SIGHASH_FORKID: 1 << 16,
		  VERIFY_REPLAY_PROTECTION: 1 << 17,
		  VERIFY_CHECKDATASIG: 1 << 18,
		  VERIFY_SCHNORR: 1 << 19,
		  VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
		  VERIFY_SCHNORR_MULTISIG: 1 << 21,
		  VERIFY_INPUT_SIGCHECKS: 1 << 22,
		  VERIFY_REVERSEBYTES: 1 << 23,
		  VERIFY_ZERO_SIGOPS: 1 << 30,
		  REPORT_SIGCHECKS: 1 << 31
		};

		/**
		 * Consensus verify flags (used for block validation).
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.MANDATORY_VERIFY_FLAGS = exports.flags.VERIFY_P2SH;

		/**
		 * Standard verify flags (used for mempool validation).
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.STANDARD_VERIFY_FLAGS = 0 | exports.flags.MANDATORY_VERIFY_FLAGS | exports.flags.VERIFY_DERSIG | exports.flags.VERIFY_STRICTENC | exports.flags.VERIFY_MINIMALDATA | exports.flags.VERIFY_SIGPUSHONLY | exports.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS | exports.flags.VERIFY_CLEANSTACK | exports.flags.VERIFY_MINIMALIF | exports.flags.VERIFY_NULLFAIL | exports.flags.VERIFY_CHECKLOCKTIMEVERIFY | exports.flags.VERIFY_CHECKSEQUENCEVERIFY | exports.flags.VERIFY_LOW_S | exports.flags.VERIFY_SIGHASH_FORKID | exports.flags.VERIFY_CHECKDATASIG | exports.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY | exports.flags.VERIFY_SCHNORR_MULTISIG;

		/**
		 * Standard flags without mandatory bits.
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.ONLY_STANDARD_VERIFY_FLAGS = exports.flags.STANDARD_VERIFY_FLAGS & ~exports.flags.MANDATORY_VERIFY_FLAGS;

		/**
		 * Sighash Types.
		 * @enum {SighashType}
		 * @default
		 */

		exports.hashType = {
		  /*
		   * Sign all outputs.
		   */

		  ALL: 1,
		  /*
		   * Do not sign outputs (zero sequences).
		   */

		  NONE: 2,
		  /*
		   * Sign output at the same index (zero sequences).
		   */

		  SINGLE: 3,
		  /*
		   * Sighash fork ID.
		   */

		  SIGHASH_FORKID: 0x40,
		  /*
		   * Sign only the current input (mask).
		   */

		  ANYONECANPAY: 0x80
		};

		/**
		 * Sighash types by value.
		 * @const {Object}
		 */

		exports.hashTypeByVal = {
		  1: 'ALL',
		  2: 'NONE',
		  3: 'SINGLE',
		  0x80: 'ANYONECANPAY'
		};

		/**
		 * Output script types.
		 * @enum {Number}
		 */

		exports.types = {
		  NONSTANDARD: 0,
		  PUBKEY: 1,
		  PUBKEYHASH: 2,
		  SCRIPTHASH: 3,
		  MULTISIG: 4,
		  NULLDATA: 5
		};

		/**
		 * Output script types by value.
		 * @const {Object}
		 */

		exports.typesByVal = {
		  0: 'NONSTANDARD',
		  1: 'PUBKEY',
		  2: 'PUBKEYHASH',
		  3: 'SCRIPTHASH',
		  4: 'MULTISIG',
		  5: 'NULLDATA'
		};

		/**
		 * Test a signature to see whether it contains a valid sighash type.
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isHashType = function isHashType(sig) {
		  assert(Buffer.isBuffer(sig));
		  if (sig.length === 0) return false;
		  const type = sig[sig.length - 1] & ~(exports.hashType.ANYONECANPAY | exports.hashType.SIGHASH_FORKID);
		  if (type < exports.hashType.ALL || type > exports.hashType.SINGLE) return false;
		  return true;
		};

		/**
		 * Bitfield calculation helper for signatures.
		 * @param {Number} bits
		 * @returns {Number}
		 */

		exports.countBits = function countBits(bits) {
		  bits = bits - (bits >> 1 & 0x55555555);
		  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);
		  return (bits + (bits >> 4) & 0xf0f0f0f) * 0x1010101 >> 24;
		};

		/**
		 * Test whether a signature is 64-bytes in length
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isSchnorr = function isSchnorr(sig) {
		  assert(Buffer.isBuffer(sig));
		  return sig.length === 64;
		};

		/**
		 * Test a signature to see whether it contains a low S value.
		 * NOTE: signature MUST exclude sighash byte
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isLowDER = function isLowDER(sig) {
		  if (!exports.isDERSignatureEncoding(sig)) return false;
		  return secp256k1.isLowDER(sig);
		};

		/**
		 * Test whether the data element is a valid key.
		 * @param {Buffer} key
		 * @returns {Boolean}
		 */

		exports.isKeyEncoding = function isKeyEncoding(key) {
		  assert(Buffer.isBuffer(key));
		  if (key.length < 33) return false;
		  if (key[0] === 0x04) {
		    if (key.length !== 65) return false;
		  } else if (key[0] === 0x02 || key[0] === 0x03) {
		    if (key.length !== 33) return false;
		  } else {
		    return false;
		  }
		  return true;
		};

		/**
		 * Test whether the data element is a compressed key.
		 * @param {Buffer} key
		 * @returns {Boolean}
		 */

		exports.isCompressedEncoding = function isCompressedEncoding(key) {
		  assert(Buffer.isBuffer(key));
		  if (key.length !== 33) return false;
		  if (key[0] !== 0x02 && key[0] !== 0x03) return false;
		  return true;
		};

		/**
		 * Test a signature to see if it abides by BIP66.
		 * NOTE: signature MUST exclude sighash byte
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isDERSignatureEncoding = function isDERSignatureEncoding(sig) {
		  assert(Buffer.isBuffer(sig));

		  // Format:
		  //   0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
		  // * total-length: 1-byte length descriptor of everything that follows,
		  //   excluding the sighash byte.
		  // * R-length: 1-byte length descriptor of the R value that follows.
		  // * R: arbitrary-length big-endian encoded R value. It must use the shortest
		  //   possible encoding for a positive integers (which means no null bytes at
		  //   the start, except a single one when the next byte has its highest bit
		  //   set).
		  // * S-length: 1-byte length descriptor of the S value that follows.
		  // * S: arbitrary-length big-endian encoded S value. The same rules apply.
		  // * sighash: 1-byte value indicating what data is hashed (not part of the DER
		  //   signature)

		  // Minimum and maximum size constraints.
		  if (sig.length < 8) return false;
		  if (sig.length > 72) return false;

		  // A signature is of type 0x30 (compound).
		  if (sig[0] !== 0x30) return false;

		  // Make sure the length covers the entire signature.
		  if (sig[1] !== sig.length - 2) return false;

		  // Extract the length of the R element.
		  const lenR = sig[3];

		  // Make sure the length of the S element is still inside the signature.
		  if (5 + lenR >= sig.length) return false;

		  // Extract the length of the S element.
		  const lenS = sig[5 + lenR];

		  // Verify that the length of the signature matches the sum of the length
		  // of the elements.
		  if (lenR + lenS + 6 !== sig.length) return false;

		  // Check whether the R element is an integer.
		  if (sig[2] !== 0x02) return false;

		  // Zero-length integers are not allowed for R.
		  if (lenR === 0) return false;

		  // Negative numbers are not allowed for R.
		  if (sig[4] & 0x80) return false;

		  // Null bytes at the start of R are not allowed, unless R would
		  // otherwise be interpreted as a negative number.
		  if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return false;

		  // Check whether the S element is an integer.
		  if (sig[lenR + 4] !== 0x02) return false;

		  // Zero-length integers are not allowed for S.
		  if (lenS === 0) return false;

		  // Negative numbers are not allowed for S.
		  if (sig[lenR + 6] & 0x80) return false;

		  // Null bytes at the start of S are not allowed, unless S would otherwise be
		  // interpreted as a negative number.
		  if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return false;
		  return true;
		};

		/**
		 * Format stack item into bitcoind asm format.
		 * @param {Buffer} item
		 * @param {Boolean?} decode - Attempt to decode hash types.
		 * @returns {String} Human-readable string.
		 */

		exports.toASM = function toASM(item, decode) {
		  if (item.length <= 4) {
		    const num = ScriptNum.decode(item);
		    return num.toString(10);
		  }
		  if (decode && exports.isDERSignatureEncoding(item.slice(0, -1))) {
		    const type = item[item.length - 1];
		    let symbol = exports.hashTypeByVal[type & 0x1f] || '';
		    if (symbol) {
		      if (type & exports.hashType.ANYONECANPAY) symbol += '|ANYONECANPAY';
		      symbol = `[${symbol}]`;
		    }
		    return item.slice(0, -1).toString('hex') + symbol;
		  }
		  return item.toString('hex');
		};

		/**
		 * Sighash with fork value for replay protection
		 * @param {SighashType} sighash
		 * @param {Number} value
		 * @returns {SighashType}
		 */

		exports.hashTypeWithForkValue = function hashTypeWithForkValue(sighash, value) {
		  return value << 8 | sighash & 0xff;
		};

		/**
		 * Get fork value from hashtype
		 * @param {SighashType} sighash
		 * @returns {Number}
		 */

		exports.getHashTypeForkValue = function getHashTypeForkValue(sighash) {
		  return sighash >>> 8;
		}; 
	} (common$1));
	return common$1;
}

/*!
 * opcode.js - opcode object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var opcode;
var hasRequiredOpcode;

function requireOpcode () {
	if (hasRequiredOpcode) return opcode;
	hasRequiredOpcode = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const ScriptNum = requireScriptnum();
	const common = requireCommon$1();
	const opcodes = common.opcodes;
	const opCache = [];
	let PARSE_ERROR = null;

	/**
	 * Opcode
	 * A simple struct which contains
	 * an opcode and pushdata buffer.
	 * @alias module:script.Opcode
	 * @property {Number} value
	 * @property {Buffer|null} data
	 */

	class Opcode {
	  /**
	   * Create an opcode.
	   * Note: this should not be called directly.
	   * @constructor
	   * @param {Number} value - Opcode.
	   * @param {Buffer?} data - Pushdata buffer.
	   */

	  constructor(value, data) {
	    this.value = value || 0;
	    this.data = data || null;
	  }

	  /**
	   * Test whether a pushdata abides by minimaldata.
	   * @returns {Boolean}
	   */

	  isMinimal() {
	    assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);
	    if (!this.data) return true;
	    if (this.data.length === 1) {
	      if (this.data[0] === 0x81) return false;
	      if (this.data[0] >= 1 && this.data[0] <= 16) return false;
	    }
	    if (this.data.length <= 0x4b) return this.value === this.data.length;
	    if (this.data.length <= 0xff) return this.value === opcodes.OP_PUSHDATA1;
	    if (this.data.length <= 0xffff) return this.value === opcodes.OP_PUSHDATA2;
	    return true;
	  }

	  /**
	   * Test whether opcode is a disabled opcode.
	   * @param {Number?} flags - Script standard flags.
	   * @returns {Boolean}
	   */

	  isDisabled(flags) {
	    switch (this.value) {
	      case opcodes.OP_INVERT:
	      case opcodes.OP_2MUL:
	      case opcodes.OP_2DIV:
	      case opcodes.OP_MUL:
	      case opcodes.OP_LSHIFT:
	      case opcodes.OP_RSHIFT:
	        return true;
	    }
	    return false;
	  }

	  /**
	   * Test whether opcode is a branch (if/else/endif).
	   * @returns {Boolean}
	   */

	  isBranch() {
	    return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;
	  }

	  /**
	   * Test opcode equality.
	   * @param {Opcode} op
	   * @returns {Boolean}
	   */

	  equals(op) {
	    assert(Opcode.isOpcode(op));
	    if (this.value !== op.value) return false;
	    if (!this.data) {
	      assert(!op.data);
	      return true;
	    }
	    assert(op.data);
	    return this.data.equals(op.data);
	  }

	  /**
	   * Convert Opcode to opcode value.
	   * @returns {Number}
	   */

	  toOp() {
	    return this.value;
	  }

	  /**
	   * Covert opcode to data push.
	   * @returns {Buffer|null}
	   */

	  toData() {
	    return this.data;
	  }

	  /**
	   * Covert opcode to data length.
	   * @returns {Number}
	   */

	  toLength() {
	    return this.data ? this.data.length : -1;
	  }

	  /**
	   * Covert and _cast_ opcode to data push.
	   * @returns {Buffer|null}
	   */

	  toPush() {
	    if (this.value === opcodes.OP_0) return common.small[0 + 1];
	    if (this.value === opcodes.OP_1NEGATE) return common.small[-1 + 1];
	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return common.small[this.value - 0x50 + 1];
	    return this.toData();
	  }

	  /**
	   * Get string for opcode.
	   * @param {String?} enc
	   * @returns {Buffer|null}
	   */

	  toString(enc) {
	    const data = this.toPush();
	    if (!data) return null;
	    return data.toString(enc || 'utf8');
	  }

	  /**
	   * Convert opcode to small integer.
	   * @returns {Number}
	   */

	  toSmall() {
	    if (this.value === opcodes.OP_0) return 0;
	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return this.value - 0x50;
	    return -1;
	  }

	  /**
	   * Convert opcode to script number.
	   * @param {Boolean?} minimal
	   * @param {Number?} limit
	   * @returns {ScriptNum|null}
	   */

	  toNum(minimal, limit) {
	    if (this.value === opcodes.OP_0) return ScriptNum.fromInt(0);
	    if (this.value === opcodes.OP_1NEGATE) return ScriptNum.fromInt(-1);
	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16) return ScriptNum.fromInt(this.value - 0x50);
	    if (!this.data) return null;
	    return ScriptNum.decode(this.data, minimal, limit);
	  }

	  /**
	   * Convert opcode to integer.
	   * @param {Boolean?} minimal
	   * @param {Number?} limit
	   * @returns {Number}
	   */

	  toInt(minimal, limit) {
	    const num = this.toNum(minimal, limit);
	    if (!num) return -1;
	    return num.getInt();
	  }

	  /**
	   * Convert opcode to boolean.
	   * @returns {Boolean}
	   */

	  toBool() {
	    const smi = this.toSmall();
	    if (smi === -1) return false;
	    return smi === 1;
	  }

	  /**
	   * Convert opcode to its symbolic representation.
	   * @returns {String}
	   */

	  toSymbol() {
	    if (this.value === -1) return 'OP_INVALIDOPCODE';
	    const symbol = common.opcodesByVal[this.value];
	    if (!symbol) return `0x${hex8(this.value)}`;
	    return symbol;
	  }

	  /**
	   * Calculate opcode size.
	   * @returns {Number}
	   */

	  getSize() {
	    if (!this.data) return 1;
	    switch (this.value) {
	      case opcodes.OP_PUSHDATA1:
	        return 2 + this.data.length;
	      case opcodes.OP_PUSHDATA2:
	        return 3 + this.data.length;
	      case opcodes.OP_PUSHDATA4:
	        return 5 + this.data.length;
	      default:
	        return 1 + this.data.length;
	    }
	  }

	  /**
	   * Encode the opcode to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.value === -1) throw new Error('Cannot reserialize a parse error.');
	    if (!this.data) {
	      bw.writeU8(this.value);
	      return bw;
	    }
	    switch (this.value) {
	      case opcodes.OP_PUSHDATA1:
	        bw.writeU8(this.value);
	        bw.writeU8(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      case opcodes.OP_PUSHDATA2:
	        bw.writeU8(this.value);
	        bw.writeU16(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      case opcodes.OP_PUSHDATA4:
	        bw.writeU8(this.value);
	        bw.writeU32(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      default:
	        assert(this.value === this.data.length);
	        bw.writeU8(this.value);
	        bw.writeBytes(this.data);
	        break;
	    }
	    return bw;
	  }

	  /**
	   * Encode the opcode.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Convert the opcode to a bitcoind test string.
	   * @returns {String} Human-readable script code.
	   */

	  toFormat() {
	    if (this.value === -1) return '0x01';
	    if (this.data) {
	      // Numbers
	      if (this.data.length <= 4) {
	        const num = this.toNum();
	        if (this.equals(Opcode.fromNum(num))) return num.toString(10);
	      }
	      const symbol = common.opcodesByVal[this.value];
	      const data = this.data.toString('hex');

	      // Direct push
	      if (!symbol) {
	        const size = hex8(this.value);
	        return `0x${size} 0x${data}`;
	      }

	      // Pushdatas
	      let size = this.data.length.toString(16);
	      while (size.length % 2 !== 0) size = '0' + size;
	      return `${symbol} 0x${size} 0x${data}`;
	    }

	    // Opcodes
	    const symbol = common.opcodesByVal[this.value];
	    if (symbol) return symbol;

	    // Unknown opcodes
	    const value = hex8(this.value);
	    return `0x${value}`;
	  }

	  /**
	   * Format the opcode as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    if (this.value === -1) return '[error]';
	    if (this.data) return common.toASM(this.data, decode);
	    return common.opcodesByVal[this.value] || 'OP_UNKNOWN';
	  }

	  /**
	   * Instantiate an opcode from a number opcode.
	   * @param {Number} op
	   * @returns {Opcode}
	   */

	  static fromOp(op) {
	    assert(typeof op === 'number');
	    const cached = opCache[op];
	    assert(cached, 'Bad opcode.');
	    return cached;
	  }

	  /**
	   * Instantiate a pushdata opcode from
	   * a buffer (will encode minimaldata).
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromData(data) {
	    assert(Buffer.isBuffer(data));
	    if (data.length === 1) {
	      if (data[0] === 0x81) return this.fromOp(opcodes.OP_1NEGATE);
	      if (data[0] >= 1 && data[0] <= 16) return this.fromOp(data[0] + 0x50);
	    }
	    return this.fromPush(data);
	  }

	  /**
	   * Instantiate a pushdata opcode from a
	   * buffer (this differs from fromData in
	   * that it will _always_ be a pushdata op).
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromPush(data) {
	    assert(Buffer.isBuffer(data));
	    if (data.length === 0) return this.fromOp(opcodes.OP_0);
	    if (data.length <= 0x4b) return new this(data.length, data);
	    if (data.length <= 0xff) return new this(opcodes.OP_PUSHDATA1, data);
	    if (data.length <= 0xffff) return new this(opcodes.OP_PUSHDATA2, data);
	    if (data.length <= 0xffffffff) return new this(opcodes.OP_PUSHDATA4, data);
	    throw new Error('Pushdata size too large.');
	  }

	  /**
	   * Instantiate a pushdata opcode from a string.
	   * @param {String} str
	   * @param {String} [enc=utf8]
	   * @returns {Opcode}
	   */

	  static fromString(str, enc) {
	    assert(typeof str === 'string');
	    const data = Buffer.from(str, enc || 'utf8');
	    return this.fromData(data);
	  }

	  /**
	   * Instantiate an opcode from a small number.
	   * @param {Number} num
	   * @returns {Opcode}
	   */

	  static fromSmall(num) {
	    assert((num & 0xff) === num && num >= 0 && num <= 16);
	    return this.fromOp(num === 0 ? 0 : num + 0x50);
	  }

	  /**
	   * Instantiate an opcode from a ScriptNum.
	   * @param {ScriptNumber} num
	   * @returns {Opcode}
	   */

	  static fromNum(num) {
	    assert(ScriptNum.isScriptNum(num));
	    return this.fromData(num.encode());
	  }

	  /**
	   * Instantiate an opcode from a Number.
	   * @param {Number} num
	   * @returns {Opcode}
	   */

	  static fromInt(num) {
	    assert(Number.isSafeInteger(num));
	    if (num === 0) return this.fromOp(opcodes.OP_0);
	    if (num === -1) return this.fromOp(opcodes.OP_1NEGATE);
	    if (num >= 1 && num <= 16) return this.fromOp(num + 0x50);
	    return this.fromNum(ScriptNum.fromNumber(num));
	  }

	  /**
	   * Instantiate an opcode from a Number.
	   * @param {Boolean} value
	   * @returns {Opcode}
	   */

	  static fromBool(value) {
	    assert(typeof value === 'boolean');
	    return this.fromSmall(value ? 1 : 0);
	  }

	  /**
	   * Instantiate a pushdata opcode from symbolic name.
	   * @example
	   *   Opcode.fromSymbol('checksequenceverify')
	   * @param {String} name
	   * @returns {Opcode}
	   */

	  static fromSymbol(name) {
	    assert(typeof name === 'string');
	    assert(name.length > 0);
	    if (name.charCodeAt(0) & 32) name = name.toUpperCase();
	    if (!/^OP_/.test(name)) name = `OP_${name}`;
	    const op = common.opcodes[name];
	    if (op != null) return this.fromOp(op);
	    assert(/^OP_0X/.test(name), 'Unknown opcode.');
	    assert(name.length === 7, 'Unknown opcode.');
	    const value = parseInt(name.substring(5), 16);
	    assert((value & 0xff) === value, 'Unknown opcode.');
	    return this.fromOp(value);
	  }

	  /**
	   * Instantiate opcode from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Opcode}
	   */

	  static fromReader(br) {
	    const value = br.readU8();
	    const op = opCache[value];
	    if (op) return op;
	    switch (value) {
	      case opcodes.OP_PUSHDATA1:
	        {
	          if (br.left() < 1) return PARSE_ERROR;
	          const size = br.readU8();
	          if (br.left() < size) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const data = br.readBytes(size);
	          return new this(value, data);
	        }
	      case opcodes.OP_PUSHDATA2:
	        {
	          if (br.left() < 2) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const size = br.readU16();
	          if (br.left() < size) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const data = br.readBytes(size);
	          return new this(value, data);
	        }
	      case opcodes.OP_PUSHDATA4:
	        {
	          if (br.left() < 4) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const size = br.readU32();
	          if (br.left() < size) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const data = br.readBytes(size);
	          return new this(value, data);
	        }
	      default:
	        {
	          if (br.left() < value) {
	            br.seek(br.left());
	            return PARSE_ERROR;
	          }
	          const data = br.readBytes(value);
	          return new this(value, data);
	        }
	    }
	  }

	  /**
	   * Instantiate opcode from serialized data.
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Test whether an object an Opcode.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOpcode(obj) {
	    return obj instanceof Opcode;
	  }
	}

	/*
	 * Helpers
	 */

	function hex8(num) {
	  if (num <= 0x0f) return '0' + num.toString(16);
	  return num.toString(16);
	}

	/*
	 * Fill Cache
	 */

	PARSE_ERROR = Object.freeze(new Opcode(-1));
	for (let value = 0x00; value <= 0xff; value++) {
	  if (value >= 0x01 && value <= 0x4e) {
	    opCache.push(null);
	    continue;
	  }
	  const op = new Opcode(value);
	  opCache.push(Object.freeze(op));
	}

	/*
	 * Expose
	 */

	opcode = Opcode;
	return opcode;
}

/*!
 * stack.js - stack object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var stack;
var hasRequiredStack;

function requireStack () {
	if (hasRequiredStack) return stack;
	hasRequiredStack = 1;

	const assert = requireAssert$1();
	const common = requireCommon$1();
	const ScriptNum = requireScriptnum();

	/**
	 * Stack
	 * Represents the stack of a Script during execution.
	 * @alias module:script.Stack
	 * @property {Buffer[]} items - Stack items.
	 * @property {Number} length - Size of stack.
	 */

	class Stack {
	  /**
	   * Create a stack.
	   * @constructor
	   * @param {Buffer[]?} items - Stack items.
	   */

	  constructor(items) {
	    this.items = items || [];
	  }

	  /**
	   * Get length.
	   * @returns {Number}
	   */

	  get length() {
	    return this.items.length;
	  }

	  /**
	   * Set length.
	   * @param {Number} value
	   */

	  set length(value) {
	    this.items.length = value;
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {StackIterator}
	   */

	  [Symbol.iterator]() {
	    return this.items[Symbol.iterator]();
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {StackIterator}
	   */

	  values() {
	    return this.items.values();
	  }

	  /**
	   * Instantiate a key and value iterator.
	   * @returns {StackIterator}
	   */

	  entries() {
	    return this.items.entries();
	  }

	  /**
	   * Inspect the stack.
	   * @returns {String} Human-readable stack.
	   */

	  inspect() {
	    return `<Stack: ${this.toString()}>`;
	  }

	  /**
	   * Convert the stack to a string.
	   * @returns {String} Human-readable stack.
	   */

	  toString() {
	    const out = [];
	    for (const item of this.items) out.push(item.toString('hex'));
	    return out.join(' ');
	  }

	  /**
	   * Format the stack as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    const out = [];
	    for (const item of this.items) out.push(common.toASM(item, decode));
	    return out.join(' ');
	  }

	  /**
	   * Clone the stack.
	   * @returns {Stack} Cloned stack.
	   */

	  clone() {
	    return new this.constructor(this.items.slice());
	  }

	  /**
	   * Clear the stack.
	   * @returns {Stack}
	   */

	  clear() {
	    this.items.length = 0;
	    return this;
	  }

	  /**
	   * Get a stack item by index.
	   * @param {Number} index
	   * @returns {Buffer|null}
	   */

	  get(index) {
	    if (index < 0) index += this.items.length;
	    if (index < 0 || index >= this.items.length) return null;
	    return this.items[index];
	  }

	  /**
	   * Pop a stack item.
	   * @see Array#pop
	   * @returns {Buffer|null}
	   */

	  pop() {
	    const item = this.items.pop();
	    return item || null;
	  }

	  /**
	   * Shift a stack item.
	   * @see Array#shift
	   * @returns {Buffer|null}
	   */

	  shift() {
	    const item = this.items.shift();
	    return item || null;
	  }

	  /**
	   * Remove an item.
	   * @param {Number} index
	   * @returns {Buffer}
	   */

	  remove(index) {
	    if (index < 0) index += this.items.length;
	    if (index < 0 || index >= this.items.length) return null;
	    const items = this.items.splice(index, 1);
	    if (items.length === 0) return null;
	    return items[0];
	  }

	  /**
	   * Set stack item at index.
	   * @param {Number} index
	   * @param {Buffer} value
	   * @returns {Buffer}
	   */

	  set(index, item) {
	    if (index < 0) index += this.items.length;
	    assert(Buffer.isBuffer(item));
	    assert(index >= 0 && index <= this.items.length);
	    this.items[index] = item;
	    return this;
	  }

	  /**
	   * Push item onto stack.
	   * @see Array#push
	   * @param {Buffer} item
	   * @returns {Number} Stack size.
	   */

	  push(item) {
	    assert(Buffer.isBuffer(item));
	    this.items.push(item);
	    return this;
	  }

	  /**
	   * Unshift item from stack.
	   * @see Array#unshift
	   * @param {Buffer} item
	   * @returns {Number}
	   */

	  unshift(item) {
	    assert(Buffer.isBuffer(item));
	    this.items.unshift(item);
	    return this;
	  }

	  /**
	   * Insert an item.
	   * @param {Number} index
	   * @param {Buffer} item
	   * @returns {Buffer}
	   */

	  insert(index, item) {
	    if (index < 0) index += this.items.length;
	    assert(Buffer.isBuffer(item));
	    assert(index >= 0 && index <= this.items.length);
	    this.items.splice(index, 0, item);
	    return this;
	  }

	  /**
	   * Erase stack items.
	   * @param {Number} start
	   * @param {Number} end
	   * @returns {Buffer[]}
	   */

	  erase(start, end) {
	    if (start < 0) start = this.items.length + start;
	    if (end < 0) end = this.items.length + end;
	    this.items.splice(start, end - start);
	  }

	  /**
	   * Swap stack values.
	   * @param {Number} i1 - Index 1.
	   * @param {Number} i2 - Index 2.
	   */

	  swap(i1, i2) {
	    if (i1 < 0) i1 = this.items.length + i1;
	    if (i2 < 0) i2 = this.items.length + i2;
	    const v1 = this.items[i1];
	    const v2 = this.items[i2];
	    this.items[i1] = v2;
	    this.items[i2] = v1;
	  }

	  /*
	   * Data
	   */

	  getData(index) {
	    return this.get(index);
	  }
	  popData() {
	    return this.pop();
	  }
	  shiftData() {
	    return this.shift();
	  }
	  removeData(index) {
	    return this.remove(index);
	  }
	  setData(index, data) {
	    return this.set(index, data);
	  }
	  pushData(data) {
	    return this.push(data);
	  }
	  unshiftData(data) {
	    return this.unshift(data);
	  }
	  insertData(index, data) {
	    return this.insert(index, data);
	  }

	  /*
	   * Length
	   */

	  getLength(index) {
	    const item = this.get(index);
	    return item ? item.length : -1;
	  }

	  /*
	   * String
	   */

	  getString(index, enc) {
	    const item = this.get(index);
	    return item ? Stack.toString(item, enc) : null;
	  }
	  popString(enc) {
	    const item = this.pop();
	    return item ? Stack.toString(item, enc) : null;
	  }
	  shiftString(enc) {
	    const item = this.shift();
	    return item ? Stack.toString(item, enc) : null;
	  }
	  removeString(index, enc) {
	    const item = this.remove(index);
	    return item ? Stack.toString(item, enc) : null;
	  }
	  setString(index, str, enc) {
	    return this.set(index, Stack.fromString(str, enc));
	  }
	  pushString(str, enc) {
	    return this.push(Stack.fromString(str, enc));
	  }
	  unshiftString(str, enc) {
	    return this.unshift(Stack.fromString(str, enc));
	  }
	  insertString(index, str, enc) {
	    return this.insert(index, Stack.fromString(str, enc));
	  }

	  /*
	   * Num
	   */

	  getNum(index, minimal, limit) {
	    const item = this.get(index);
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }
	  popNum(minimal, limit) {
	    const item = this.pop();
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }
	  shiftNum(minimal, limit) {
	    const item = this.shift();
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }
	  removeNum(index, minimal, limit) {
	    const item = this.remove(index);
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }
	  setNum(index, num) {
	    return this.set(index, Stack.fromNum(num));
	  }
	  pushNum(num) {
	    return this.push(Stack.fromNum(num));
	  }
	  unshiftNum(num) {
	    return this.unshift(Stack.fromNum(num));
	  }
	  insertNum(index, num) {
	    return this.insert(index, Stack.fromNum(num));
	  }

	  /*
	   * Int
	   */

	  getInt(index, minimal, limit) {
	    const item = this.get(index);
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }
	  popInt(minimal, limit) {
	    const item = this.pop();
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }
	  shiftInt(minimal, limit) {
	    const item = this.shift();
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }
	  removeInt(index, minimal, limit) {
	    const item = this.remove(index);
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }
	  setInt(index, num) {
	    return this.set(index, Stack.fromInt(num));
	  }
	  pushInt(num) {
	    return this.push(Stack.fromInt(num));
	  }
	  unshiftInt(num) {
	    return this.unshift(Stack.fromInt(num));
	  }
	  insertInt(index, num) {
	    return this.insert(index, Stack.fromInt(num));
	  }

	  /*
	   * Bool
	   */

	  getBool(index) {
	    const item = this.get(index);
	    return item ? Stack.toBool(item) : false;
	  }
	  popBool() {
	    const item = this.pop();
	    return item ? Stack.toBool(item) : false;
	  }
	  shiftBool() {
	    const item = this.shift();
	    return item ? Stack.toBool(item) : false;
	  }
	  removeBool(index) {
	    const item = this.remove(index);
	    return item ? Stack.toBool(item) : false;
	  }
	  setBool(index, value) {
	    return this.set(index, Stack.fromBool(value));
	  }
	  pushBool(value) {
	    return this.push(Stack.fromBool(value));
	  }
	  unshiftBool(value) {
	    return this.unshift(Stack.fromBool(value));
	  }
	  insertBool(index, value) {
	    return this.insert(index, Stack.fromBool(value));
	  }

	  /**
	   * Test an object to see if it is a Stack.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isStack(obj) {
	    return obj instanceof Stack;
	  }

	  /*
	   * Encoding
	   */

	  static toString(item, enc) {
	    assert(Buffer.isBuffer(item));
	    return item.toString(enc || 'utf8');
	  }
	  static fromString(str, enc) {
	    assert(typeof str === 'string');
	    return Buffer.from(str, enc || 'utf8');
	  }
	  static toNum(item, minimal, limit) {
	    return ScriptNum.decode(item, minimal, limit);
	  }
	  static fromNum(num) {
	    assert(ScriptNum.isScriptNum(num));
	    return num.encode();
	  }
	  static toInt(item, minimal, limit) {
	    const num = Stack.toNum(item, minimal, limit);
	    return num.getInt();
	  }
	  static fromInt(int) {
	    assert(typeof int === 'number');
	    if (int >= -1 && int <= 16) return common.small[int + 1];
	    const num = ScriptNum.fromNumber(int);
	    return Stack.fromNum(num);
	  }
	  static toBool(item) {
	    assert(Buffer.isBuffer(item));
	    for (let i = 0; i < item.length; i++) {
	      if (item[i] !== 0) {
	        // Cannot be negative zero
	        if (i === item.length - 1 && item[i] === 0x80) return false;
	        return true;
	      }
	    }
	    return false;
	  }
	  static fromBool(value) {
	    assert(typeof value === 'boolean');
	    return Stack.fromInt(value ? 1 : 0);
	  }
	}

	/*
	 * Expose
	 */

	stack = Stack;
	return stack;
}

var metrics;
var hasRequiredMetrics;

function requireMetrics () {
	if (hasRequiredMetrics) return metrics;
	hasRequiredMetrics = 1;
	requireAssert$1();
	class Metrics {
	  constructor(sigchecks) {
	    this.sigchecks = sigchecks || 0;
	    this.init();
	  }
	  init() {
	    return this.sigchecks;
	  }
	}
	metrics = Metrics;
	return metrics;
}

/*!
 * script.js - script interpreter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var script$1;
var hasRequiredScript$1;

function requireScript$1 () {
	if (hasRequiredScript$1) return script$1;
	hasRequiredScript$1 = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const ripemd160 = requireRipemd160();
	const sha1 = requireSha1();
	const sha256 = requireSha256();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const secp256k1 = requireSecp256k1();
	const consensus = requireConsensus();
	const policy = requirePolicy();
	const Opcode = requireOpcode();
	const Stack = requireStack();
	const ScriptError = requireScripterror();
	const ScriptNum = requireScriptnum();
	const common = requireCommon$1();
	const Address = requireAddress();
	const Metrics = requireMetrics();
	const opcodes = common.opcodes;
	const scriptTypes = common.types;
	const countBits = common.countBits;
	const {
	  encoding
	} = bio;

	/*
	 * Constants
	 */

	const EMPTY_BUFFER = Buffer.alloc(0);
	const metrics = new Metrics();

	/**
	 * Script
	 * Represents a input or output script.
	 * @alias module:script.Script
	 * @property {Array} code - Parsed script code.
	 * @property {Buffer?} raw - Serialized script.
	 * @property {Number} length - Number of parsed opcodes.
	 */

	class Script {
	  /**
	   * Create a script.
	   * @constructor
	   * @param {Buffer|Array|Object} code
	   */

	  constructor(options) {
	    this.raw = EMPTY_BUFFER;
	    this.code = [];
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Get length.
	   * @returns {Number}
	   */

	  get length() {
	    return this.code.length;
	  }

	  /**
	   * Set length.
	   * @param {Number} value
	   */

	  set length(value) {
	    this.code.length = value;
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Script data is required.');
	    if (Buffer.isBuffer(options)) return this.fromRaw(options);
	    if (Array.isArray(options)) return this.fromArray(options);
	    if (options.raw) {
	      if (!options.code) return this.fromRaw(options.raw);
	      assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');
	      this.raw = options.raw;
	    }
	    if (options.code) {
	      if (!options.raw) return this.fromArray(options.code);
	      assert(Array.isArray(options.code), 'Code must be an array.');
	      this.code = options.code;
	    }
	    return this;
	  }

	  /**
	   * Insantiate script from options object.
	   * @param {Object} options
	   * @returns {Script}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {ScriptIterator}
	   */

	  values() {
	    return this.code.values();
	  }

	  /**
	   * Instantiate a key and value iterator.
	   * @returns {ScriptIterator}
	   */

	  entries() {
	    return this.code.entries();
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {ScriptIterator}
	   */

	  [Symbol.iterator]() {
	    return this.code[Symbol.iterator]();
	  }

	  /**
	   * Convert the script to an array of
	   * Buffers (pushdatas) and Numbers
	   * (opcodes).
	   * @returns {Array}
	   */

	  toArray() {
	    return this.code.slice();
	  }

	  /**
	   * Inject properties from an array of
	   * of buffers and numbers.
	   * @private
	   * @param {Array} code
	   * @returns {Script}
	   */

	  fromArray(code) {
	    assert(Array.isArray(code));
	    this.clear();
	    for (const op of code) this.push(op);
	    return this.compile();
	  }

	  /**
	   * Instantiate script from an array
	   * of buffers and numbers.
	   * @param {Array} code
	   * @returns {Script}
	   */

	  static fromArray(code) {
	    return new this().fromArray(code);
	  }

	  /**
	   * Convert script to stack items.
	   * @returns {Buffer[]}
	   */

	  toItems() {
	    const items = [];
	    for (const op of this.code) {
	      const data = op.toPush();
	      if (!data) throw new Error('Non-push opcode in script.');
	      items.push(data);
	    }
	    return items;
	  }

	  /**
	   * Inject data from stack items.
	   * @private
	   * @param {Buffer[]} items
	   * @returns {Script}
	   */

	  fromItems(items) {
	    assert(Array.isArray(items));
	    this.clear();
	    for (const item of items) this.pushData(item);
	    return this.compile();
	  }

	  /**
	   * Instantiate script from stack items.
	   * @param {Buffer[]} items
	   * @returns {Script}
	   */

	  static fromItems(items) {
	    return new this().fromItems(items);
	  }

	  /**
	   * Convert script to stack.
	   * @returns {Stack}
	   */

	  toStack() {
	    return new Stack(this.toItems());
	  }

	  /**
	   * Inject data from stack.
	   * @private
	   * @param {Stack} stack
	   * @returns {Script}
	   */

	  fromStack(stack) {
	    return this.fromItems(stack.items);
	  }

	  /**
	   * Instantiate script from stack.
	   * @param {Stack} stack
	   * @returns {Script}
	   */

	  static fromStack(stack) {
	    return new this().fromStack(stack);
	  }

	  /**
	   * Clone the script.
	   * @returns {Script} Cloned script.
	   */

	  clone() {
	    return new this.constructor().inject(this);
	  }

	  /**
	   * Inject properties from script.
	   * Used for cloning.
	   * @private
	   * @param {Script} script
	   * @returns {Script}
	   */

	  inject(script) {
	    this.raw = script.raw;
	    this.code = script.code.slice();
	    return this;
	  }

	  /**
	   * Test equality against script.
	   * @param {Script} script
	   * @returns {Boolean}
	   */

	  equals(script) {
	    assert(Script.isScript(script));
	    return this.raw.equals(script.raw);
	  }

	  /**
	   * Compare against another script.
	   * @param {Script} script
	   * @returns {Number}
	   */

	  compare(script) {
	    assert(Script.isScript(script));
	    return this.raw.compare(script.raw);
	  }

	  /**
	   * Clear the script.
	   * @returns {Script}
	   */

	  clear() {
	    this.raw = EMPTY_BUFFER;
	    this.code.length = 0;
	    return this;
	  }

	  /**
	   * Inspect the script.
	   * @returns {String} Human-readable script code.
	   */

	  inspect() {
	    return `<Script: ${this.toString()}>`;
	  }

	  /**
	   * Convert the script to a bitcoind test string.
	   * @returns {String} Human-readable script code.
	   */

	  toString() {
	    const out = [];
	    for (const op of this.code) out.push(op.toFormat());
	    return out.join(' ');
	  }

	  /**
	   * Format the script as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    if (this.isNulldata()) decode = false;
	    const out = [];
	    for (const op of this.code) out.push(op.toASM(decode));
	    return out.join(' ');
	  }

	  /**
	   * Re-encode the script internally. Useful if you
	   * changed something manually in the `code` array.
	   * @returns {Script}
	   */

	  compile() {
	    if (this.code.length === 0) return this.clear();
	    let size = 0;
	    for (const op of this.code) size += op.getSize();
	    const bw = bio.write(size);
	    for (const op of this.code) op.toWriter(bw);
	    this.raw = bw.render();
	    return this;
	  }

	  /**
	   * Write the script to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeVarBytes(this.raw);
	    return bw;
	  }

	  /**
	   * Encode the script to a Buffer. See {@link Script#encode}.
	   * @param {String} enc - Encoding, either `'hex'` or `null`.
	   * @returns {Buffer|String} Serialized script.
	   */

	  toRaw() {
	    return this.raw;
	  }

	  /**
	   * Convert script to a hex string.
	   * @returns {String}
	   */

	  toJSON() {
	    return this.toRaw().toString('hex');
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {String} json
	   */

	  fromJSON(json) {
	    assert(typeof json === 'string', 'Code must be a string.');
	    return this.fromRaw(Buffer.from(json, 'hex'));
	  }

	  /**
	   * Instantiate script from a hex string.
	   * @params {String} json
	   * @returns {Script}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Get the script's "subscript" starting at a separator.
	   * @param {Number} index - The last separator to sign/verify beyond.
	   * @returns {Script} Subscript.
	   */

	  getSubscript(index) {
	    if (index === 0) return this.clone();
	    const script = new Script();
	    for (let i = index; i < this.code.length; i++) {
	      const op = this.code[i];
	      if (op.value === -1) break;
	      script.code.push(op);
	    }
	    return script.compile();
	  }

	  /**
	   * Get the script's "subscript" starting at a separator.
	   * Remove all OP_CODESEPARATORs if present. This bizarre
	   * behavior is necessary for signing and verification when
	   * code separators are present.
	   * @returns {Script} Subscript.
	   */

	  removeSeparators() {
	    let found = false;

	    // Optimizing for the common case:
	    // Check for any separators first.
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      if (op.value === opcodes.OP_CODESEPARATOR) {
	        found = true;
	        break;
	      }
	    }
	    if (!found) return this;

	    // Uncommon case: someone actually
	    // has a code separator. Go through
	    // and remove them all.
	    const script = new Script();
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      if (op.value !== opcodes.OP_CODESEPARATOR) script.code.push(op);
	    }
	    return script.compile();
	  }

	  /**
	   * Get the value of the checkBits while calculated as little endian.
	   * @param {Buffer} abkam - Stack depth of the dummy element.
	   * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
	   * @returns {Number}
	   */

	  bitcalculator(abkam, nKeysCount) {
	    let checkBits = 0;
	    const bitfield_size = (nKeysCount + 7) / 8;
	    for (let i = 0; i < bitfield_size; i++) {
	      checkBits |= abkam[i] << 8 * i;
	    }
	    return checkBits;
	  }

	  /**
	   * Execute and interpret the script.
	   * @param {Stack} stack - Script execution stack.
	   * @param {Number?} flags - Script standard flags.
	   * @param {TX?} tx - Transaction being verified.
	   * @param {Number?} index - Index of input being verified.
	   * @param {Amount?} value - Previous output value.
	   * @param {Number?} sigchecks
	   * @throws {ScriptError} Will be thrown on VERIFY failures.
	   */

	  execute(stack, flags, tx, index, value, sigchecks) {
	    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;
	    if (this.getSize() > consensus.MAX_SCRIPT_SIZE) throw new ScriptError('SCRIPT_SIZE');
	    const state = [];
	    const alt = [];
	    let lastSep = 0;
	    let opCount = 0;
	    let negate = 0;
	    let checkBits;
	    let minimal = false;
	    if (flags & Script.flags.VERIFY_MINIMALDATA) minimal = true;
	    for (let ip = 0; ip < this.code.length; ip++) {
	      const op = this.code[ip];
	      if (op.value === -1) throw new ScriptError('BAD_OPCODE', op, ip);
	      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);
	      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);
	      if (op.isDisabled(flags)) throw new ScriptError('DISABLED_OPCODE', op, ip);
	      if (negate && !op.isBranch()) {
	        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);
	        continue;
	      }
	      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {
	        if (minimal && !op.isMinimal()) throw new ScriptError('MINIMALDATA', op, ip);
	        stack.push(op.data);
	        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE', op, ip);
	        continue;
	      }
	      switch (op.value) {
	        case opcodes.OP_0:
	          {
	            stack.pushInt(0);
	            break;
	          }
	        case opcodes.OP_1NEGATE:
	          {
	            stack.pushInt(-1);
	            break;
	          }
	        case opcodes.OP_1:
	        case opcodes.OP_2:
	        case opcodes.OP_3:
	        case opcodes.OP_4:
	        case opcodes.OP_5:
	        case opcodes.OP_6:
	        case opcodes.OP_7:
	        case opcodes.OP_8:
	        case opcodes.OP_9:
	        case opcodes.OP_10:
	        case opcodes.OP_11:
	        case opcodes.OP_12:
	        case opcodes.OP_13:
	        case opcodes.OP_14:
	        case opcodes.OP_15:
	        case opcodes.OP_16:
	          {
	            stack.pushInt(op.value - 0x50);
	            break;
	          }
	        case opcodes.OP_NOP:
	          {
	            break;
	          }
	        case opcodes.OP_CHECKLOCKTIMEVERIFY:
	          {
	            // OP_CHECKLOCKTIMEVERIFY = OP_NOP2
	            if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
	              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	              break;
	            }
	            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const num = stack.getNum(-1, minimal, 5);
	            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);
	            const locktime = num.toDouble();
	            if (!tx.verifyLocktime(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);
	            break;
	          }
	        case opcodes.OP_CHECKSEQUENCEVERIFY:
	          {
	            // OP_CHECKSEQUENCEVERIFY = OP_NOP3
	            if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
	              if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	              break;
	            }
	            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const num = stack.getNum(-1, minimal, 5);
	            if (num.isNeg()) throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);
	            const locktime = num.toDouble();
	            if (!tx.verifySequence(index, locktime)) throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);
	            break;
	          }
	        case opcodes.OP_NOP1:
	        case opcodes.OP_NOP4:
	        case opcodes.OP_NOP5:
	        case opcodes.OP_NOP6:
	        case opcodes.OP_NOP7:
	        case opcodes.OP_NOP8:
	        case opcodes.OP_NOP9:
	        case opcodes.OP_NOP10:
	          {
	            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS) throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	            break;
	          }
	        case opcodes.OP_IF:
	        case opcodes.OP_NOTIF:
	          {
	            let val = false;
	            if (!negate) {
	              if (stack.length < 1) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);
	              if (flags & Script.flags.VERIFY_MINIMALIF) {
	                const item = stack.get(-1);
	                if (item.length > 1) throw new ScriptError('MINIMALIF');
	                if (item.length === 1 && item[0] !== 1) throw new ScriptError('MINIMALIF');
	              }
	              val = stack.getBool(-1);
	              if (op.value === opcodes.OP_NOTIF) val = !val;
	              stack.pop();
	            }
	            state.push(val);
	            if (!val) negate += 1;
	            break;
	          }
	        case opcodes.OP_ELSE:
	          {
	            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);
	            state[state.length - 1] = !state[state.length - 1];
	            if (!state[state.length - 1]) negate += 1;else negate -= 1;
	            break;
	          }
	        case opcodes.OP_ENDIF:
	          {
	            if (state.length === 0) throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);
	            if (!state.pop()) negate -= 1;
	            break;
	          }
	        case opcodes.OP_VERIFY:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            if (!stack.getBool(-1)) throw new ScriptError('VERIFY', op, ip);
	            stack.pop();
	            break;
	          }
	        case opcodes.OP_RETURN:
	          {
	            throw new ScriptError('OP_RETURN', op, ip);
	          }
	        case opcodes.OP_TOALTSTACK:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            alt.push(stack.pop());
	            break;
	          }
	        case opcodes.OP_FROMALTSTACK:
	          {
	            if (alt.length === 0) throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);
	            stack.push(alt.pop());
	            break;
	          }
	        case opcodes.OP_2DROP:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.pop();
	            stack.pop();
	            break;
	          }
	        case opcodes.OP_2DUP:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-2);
	            const v2 = stack.get(-1);
	            stack.push(v1);
	            stack.push(v2);
	            break;
	          }
	        case opcodes.OP_3DUP:
	          {
	            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-3);
	            const v2 = stack.get(-2);
	            const v3 = stack.get(-1);
	            stack.push(v1);
	            stack.push(v2);
	            stack.push(v3);
	            break;
	          }
	        case opcodes.OP_2OVER:
	          {
	            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-4);
	            const v2 = stack.get(-3);
	            stack.push(v1);
	            stack.push(v2);
	            break;
	          }
	        case opcodes.OP_2ROT:
	          {
	            if (stack.length < 6) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-6);
	            const v2 = stack.get(-5);
	            stack.erase(-6, -4);
	            stack.push(v1);
	            stack.push(v2);
	            break;
	          }
	        case opcodes.OP_2SWAP:
	          {
	            if (stack.length < 4) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.swap(-4, -2);
	            stack.swap(-3, -1);
	            break;
	          }
	        case opcodes.OP_IFDUP:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            if (stack.getBool(-1)) {
	              const val = stack.get(-1);
	              stack.push(val);
	            }
	            break;
	          }
	        case opcodes.OP_DEPTH:
	          {
	            stack.pushInt(stack.length);
	            break;
	          }
	        case opcodes.OP_DROP:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.pop();
	            break;
	          }
	        case opcodes.OP_DUP:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(stack.get(-1));
	            break;
	          }
	        case opcodes.OP_NIP:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.remove(-2);
	            break;
	          }
	        case opcodes.OP_OVER:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(stack.get(-2));
	            break;
	          }
	        case opcodes.OP_PICK:
	        case opcodes.OP_ROLL:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const num = stack.getInt(-1, minimal, 4);
	            stack.pop();
	            if (num < 0 || num >= stack.length) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const val = stack.get(-num - 1);
	            if (op.value === opcodes.OP_ROLL) stack.remove(-num - 1);
	            stack.push(val);
	            break;
	          }
	        case opcodes.OP_ROT:
	          {
	            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.swap(-3, -2);
	            stack.swap(-2, -1);
	            break;
	          }
	        case opcodes.OP_SWAP:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.swap(-2, -1);
	            break;
	          }
	        case opcodes.OP_TUCK:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.insert(-2, stack.get(-1));
	            break;
	          }
	        case opcodes.OP_SIZE:
	          {
	            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.pushInt(stack.get(-1).length);
	            break;
	          }
	        case opcodes.OP_EQUAL:
	        case opcodes.OP_EQUALVERIFY:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-2);
	            const v2 = stack.get(-1);
	            const res = v1.equals(v2);
	            stack.pop();
	            stack.pop();
	            stack.pushBool(res);
	            if (op.value === opcodes.OP_EQUALVERIFY) {
	              if (!res) throw new ScriptError('EQUALVERIFY', op, ip);
	              stack.pop();
	            }
	            break;
	          }
	        case opcodes.OP_1ADD:
	        case opcodes.OP_1SUB:
	        case opcodes.OP_NEGATE:
	        case opcodes.OP_ABS:
	        case opcodes.OP_NOT:
	        case opcodes.OP_0NOTEQUAL:
	          {
	            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            let num = stack.getNum(-1, minimal, 4);
	            let cmp;
	            switch (op.value) {
	              case opcodes.OP_1ADD:
	                num.iaddn(1);
	                break;
	              case opcodes.OP_1SUB:
	                num.isubn(1);
	                break;
	              case opcodes.OP_NEGATE:
	                num.ineg();
	                break;
	              case opcodes.OP_ABS:
	                num.iabs();
	                break;
	              case opcodes.OP_NOT:
	                cmp = num.isZero();
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_0NOTEQUAL:
	                cmp = !num.isZero();
	                num = ScriptNum.fromBool(cmp);
	                break;
	              default:
	                assert(false, 'Fatal script error.');
	                break;
	            }
	            stack.pop();
	            stack.pushNum(num);
	            break;
	          }
	        case opcodes.OP_ADD:
	        case opcodes.OP_SUB:
	        case opcodes.OP_DIV:
	        case opcodes.OP_MOD:
	        case opcodes.OP_BOOLAND:
	        case opcodes.OP_BOOLOR:
	        case opcodes.OP_NUMEQUAL:
	        case opcodes.OP_NUMEQUALVERIFY:
	        case opcodes.OP_NUMNOTEQUAL:
	        case opcodes.OP_LESSTHAN:
	        case opcodes.OP_GREATERTHAN:
	        case opcodes.OP_LESSTHANOREQUAL:
	        case opcodes.OP_GREATERTHANOREQUAL:
	        case opcodes.OP_MIN:
	        case opcodes.OP_MAX:
	          {
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const n1 = stack.getNum(-2, minimal, 4);
	            const n2 = stack.getNum(-1, minimal, 4);
	            let num, cmp;
	            switch (op.value) {
	              case opcodes.OP_ADD:
	                num = n1.iadd(n2);
	                break;
	              case opcodes.OP_SUB:
	                num = n1.isub(n2);
	                break;
	              case opcodes.OP_DIV:
	                if (n2.isZero()) throw new ScriptError('DIV_BY_ZERO', op, ip);
	                num = n1.div(n2);
	                break;
	              case opcodes.OP_MOD:
	                if (n2.isZero()) throw new ScriptError('MOD_BY_ZERO', op, ip);
	                num = n1.mod(n2);
	                break;
	              case opcodes.OP_BOOLAND:
	                cmp = n1.toBool() && n2.toBool();
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_BOOLOR:
	                cmp = n1.toBool() || n2.toBool();
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_NUMEQUAL:
	                cmp = n1.eq(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_NUMEQUALVERIFY:
	                cmp = n1.eq(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_NUMNOTEQUAL:
	                cmp = !n1.eq(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_LESSTHAN:
	                cmp = n1.lt(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_GREATERTHAN:
	                cmp = n1.gt(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_LESSTHANOREQUAL:
	                cmp = n1.lte(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_GREATERTHANOREQUAL:
	                cmp = n1.gte(n2);
	                num = ScriptNum.fromBool(cmp);
	                break;
	              case opcodes.OP_MIN:
	                num = ScriptNum.min(n1, n2);
	                break;
	              case opcodes.OP_MAX:
	                num = ScriptNum.max(n1, n2);
	                break;
	              default:
	                assert(false, 'Fatal script error.');
	                break;
	            }
	            stack.pop();
	            stack.pop();
	            stack.pushNum(num);
	            if (op.value === opcodes.OP_NUMEQUALVERIFY) {
	              if (!stack.getBool(-1)) throw new ScriptError('NUMEQUALVERIFY', op, ip);
	              stack.pop();
	            }
	            break;
	          }
	        case opcodes.OP_WITHIN:
	          {
	            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const n1 = stack.getNum(-3, minimal, 4);
	            const n2 = stack.getNum(-2, minimal, 4);
	            const n3 = stack.getNum(-1, minimal, 4);
	            const val = n2.lte(n1) && n1.lt(n3);
	            stack.pop();
	            stack.pop();
	            stack.pop();
	            stack.pushBool(val);
	            break;
	          }
	        case opcodes.OP_RIPEMD160:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(ripemd160.digest(stack.pop()));
	            break;
	          }
	        case opcodes.OP_SHA1:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(sha1.digest(stack.pop()));
	            break;
	          }
	        case opcodes.OP_SHA256:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(sha256.digest(stack.pop()));
	            break;
	          }
	        case opcodes.OP_HASH160:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(hash160.digest(stack.pop()));
	            break;
	          }
	        case opcodes.OP_HASH256:
	          {
	            if (stack.length === 0) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            stack.push(hash256.digest(stack.pop()));
	            break;
	          }
	        case opcodes.OP_CODESEPARATOR:
	          {
	            lastSep = ip + 1;
	            break;
	          }
	        case opcodes.OP_CHECKSIG:
	        case opcodes.OP_CHECKSIGVERIFY:
	          {
	            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const sig = stack.get(-2);
	            const key = stack.get(-1);
	            const subscript = this.getSubscript(lastSep);
	            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig);
	            checkTransactionSignature(sig, flags);
	            validateKey(key, flags);
	            let res = false;
	            if (sig.length > 0) {
	              const type = sig[sig.length - 1];
	              const hash = tx.signatureHash(index, subscript, value, type, flags);
	              res = verifySignature(hash, sig.slice(0, -1), key, flags);
	              metrics.sigchecks += 1;
	              metrics.sigchecks;
	            }
	            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {
	              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);
	            }
	            stack.pop();
	            stack.pop();
	            stack.pushBool(res);
	            if (op.value === opcodes.OP_CHECKSIGVERIFY) {
	              if (!res) throw new ScriptError('CHECKSIGVERIFY', op, ip);
	              stack.pop();
	            }
	            break;
	          }
	        case opcodes.OP_CHECKDATASIG:
	        case opcodes.OP_CHECKDATASIGVERIFY:
	          {
	            // (sig message pubkey -- bool)
	            if (stack.length < 3) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const sig = stack.get(-3);
	            const msg = stack.get(-2);
	            const key = stack.get(-1);
	            validateDataSignature(sig, flags);
	            validateKey(key, flags);
	            let res = false;
	            if (sig.length > 0) {
	              const hash = sha256.digest(msg);
	              res = verifySignature(hash, sig, key, flags);
	              metrics.sigchecks += 1;
	              metrics.sigchecks;
	            }
	            if (!res && flags & Script.flags.VERIFY_NULLFAIL) {
	              if (sig.length !== 0) throw new ScriptError('NULLFAIL', op, ip);
	            }
	            stack.pop();
	            stack.pop();
	            stack.pop();
	            stack.pushBool(res);
	            if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {
	              if (!res) throw new ScriptError('CHECKDATASIGVERIFY', op, ip);
	              stack.pop();
	            }
	            break;
	          }
	        case opcodes.OP_CHECKMULTISIG:
	        case opcodes.OP_CHECKMULTISIGVERIFY:
	          {
	            if (!tx) throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');
	            let keyCount = 1;
	            let sigCount = 0;
	            let keyTop, sigTop;
	            if (stack.length < keyCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            let nKeysCount = stack.getInt(-keyCount, minimal, 4);
	            let okey = nKeysCount + 2;
	            let ikey, isig;
	            if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS) throw new ScriptError('PUBKEY_COUNT', op, ip);
	            opCount += nKeysCount;
	            if (opCount > consensus.MAX_SCRIPT_OPS) throw new ScriptError('OP_COUNT', op, ip);
	            keyCount += 1;
	            keyTop = keyCount;

	            // stack depth of nSigsCount
	            sigCount = keyTop + nKeysCount;
	            ikey = keyCount;
	            keyCount += nKeysCount;
	            if (stack.length < sigCount) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            let nSigsCount = stack.getInt(-sigCount, minimal, 4);
	            if (nSigsCount < 0 || nSigsCount > nKeysCount) throw new ScriptError('SIG_COUNT', op, ip);

	            // stack depth of the top signature
	            sigTop = sigCount + 1;

	            // stack depth of the dummy element
	            const dummy = sigTop + nSigsCount;
	            if (stack.length < dummy) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            keyCount += 1;
	            isig = keyCount;
	            keyCount += nSigsCount;
	            const subscript = this.getSubscript(lastSep);
	            let res = true;
	            if (flags & Script.flags.VERIFY_SCHNORR_MULTISIG && stack.get(-dummy).length !== 0) {
	              assert(consensus.MAX_MULTISIG_PUBKEYS < 32);
	              if (nKeysCount > 32) throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);
	              const bitfield_size = Math.floor((nKeysCount + 7) / 8);
	              const abkam = stack.get(-dummy);
	              if (abkam.length !== bitfield_size) throw new ScriptError('BITFIELD_SIZE', op, ip);
	              checkBits = this.bitcalculator(abkam, nKeysCount);
	              const mask = (1 << nKeysCount) - 1;
	              const numBits = countBits(checkBits);
	              if ((checkBits & mask) !== checkBits) throw new ScriptError('BIT_RANGE', op, ip);
	              if (numBits !== nSigsCount) throw new ScriptError('INVALID_BIT_COUNT', op, ip);
	              const bKey = keyTop + nKeysCount - 1;
	              const bSig = sigTop + nSigsCount - 1;
	              let ik3y = 0;
	              for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {
	                if (checkBits >> ik3y === 0) {
	                  throw new ScriptError('INVALID_BIT_RANGE', op, ip);
	                }
	                while ((checkBits >> ik3y & 0x01) === 0) {
	                  ik3y++;
	                }
	                if (ik3y >= nKeysCount) throw new ScriptError('PUBKEY_COUNT', op, ip);
	                const sig = stack.get(-bSig + is1g);
	                const key = stack.get(-bKey + ik3y);

	                // Handle checkbits left over
	                if (!sig) continue;
	                checkTransactionSchnorrSig(sig, flags);
	                validateKey(key, flags);
	                if (sig.length > 0) {
	                  const type = sig[sig.length - 1];
	                  const hash = tx.signatureHash(index, subscript, value, type, flags);
	                  res = verifySignature(hash, sig.slice(0, -1), key, flags);
	                  metrics.sigchecks += 1;
	                  metrics.sigchecks;
	                }
	                while (keyCount > 1) {
	                  if (!res && flags & Script.flags.VERIFY_NULLFAIL) {
	                    if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);
	                  }
	                  if (okey > 0) okey -= 1;
	                  stack.pop();
	                  keyCount -= 1;
	                }
	              }
	              if (checkBits >> ik3y !== 0) throw new ScriptError('INVALID_BIT_COUNT', op, ip);
	              stack.pop();
	              stack.pushBool(res);
	            } else {
	              // Legacy Multisig (ECDSA / NULL)
	              // A bug causes CHECKMULTISIG to consume one extra
	              // argument whose contents were not checked in any way.

	              for (let j = 0; j < nSigsCount; j++) {
	                const sig = stack.get(-sigTop - j);
	                if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID) || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID)) subscript.findAndDelete(sig, flags);
	              }
	              while (res && nSigsCount > 0) {
	                const sig = stack.get(-isig);
	                const key = stack.get(-ikey);
	                checkTransactionECDSASignature(sig, flags);
	                validateKey(key, flags);
	                if (sig.length > 0) {
	                  const type = sig[sig.length - 1];
	                  const hash = tx.signatureHash(index, subscript, value, type, flags);
	                  if (checksig(hash, sig, key)) {
	                    isig += 1;
	                    nSigsCount -= 1;
	                  }
	                }
	                ikey += 1;
	                nKeysCount -= 1;
	                if (nSigsCount > nKeysCount) res = false;
	              }
	              while (keyCount > 1) {
	                if (!res && flags & Script.flags.VERIFY_NULLFAIL) {
	                  if (okey === 0 && stack.get(-1).length !== 0) throw new ScriptError('NULLFAIL', op, ip);
	                }
	                if (okey > 0) okey -= 1;
	                stack.pop();
	                keyCount -= 1;
	              }
	              if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	              stack.pop();
	              stack.pushBool(res);
	              if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {
	                if (!res) throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);
	                stack.pop();
	              }
	            }
	            break;
	          }

	        //
	        // Byte string operations
	        //
	        case opcodes.OP_CAT:
	          {
	            // (x1 x2 -- out)
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-2);
	            const v2 = stack.get(-1);
	            if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {
	              throw new ScriptError('PUSH_SIZE', op, ip);
	            }
	            stack.pop();
	            stack.pop();
	            stack.push(Buffer.concat([v1, v2]));
	            break;
	          }
	        case opcodes.OP_SPLIT:
	          {
	            // (in position -- x1 x2)
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const data = stack.get(-2);

	            // Make sure the split point is appropriate.
	            const pos = stack.getInt(-1, minimal, 4);
	            if (pos < 0 || pos > data.length) throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);

	            // Prepare the results in their own buffer as `data`
	            // will be invalidated.
	            const n1 = data.slice(0, pos);
	            const n2 = data.slice(pos);

	            // Replace existing stack values by the new values.
	            stack.set(-2, n1);
	            stack.set(-1, n2);
	            break;
	          }
	        case opcodes.OP_REVERSEBYTES:
	          {
	            if (stack.length < 1) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const data = stack.get(-1);
	            data.reverse();
	            break;
	          }

	        //
	        // Bitwise logic
	        //
	        case opcodes.OP_AND:
	        case opcodes.OP_OR:
	        case opcodes.OP_XOR:
	          {
	            // (x1 x2 - out)
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const v1 = stack.get(-2);
	            const v2 = stack.get(-1);

	            // Inputs must be the same size
	            if (v1.length !== v2.length) throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);
	            const raw = Buffer.alloc(v1.length);
	            switch (op.value) {
	              case opcodes.OP_AND:
	                for (let i = 0; i < v1.length; i++) {
	                  raw[i] = v1[i] & v2[i];
	                }
	                break;
	              case opcodes.OP_OR:
	                for (let i = 0; i < v1.length; i++) {
	                  raw[i] = v1[i] | v2[i];
	                }
	                break;
	              case opcodes.OP_XOR:
	                for (let i = 0; i < v1.length; i++) {
	                  raw[i] = v1[i] ^ v2[i];
	                }
	                break;
	            }

	            // And pop v1 and v2.
	            stack.pop();
	            stack.pop();
	            stack.push(raw);
	            break;
	          }

	        //
	        // Conversion operations
	        //
	        case opcodes.OP_NUM2BIN:
	          {
	            // (in size -- out)
	            if (stack.length < 2) throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            const size = stack.getInt(-1, minimal, 4);
	            if (size < 0 || size > consensus.MAX_SCRIPT_PUSH) throw new ScriptError('PUSH_SIZE', op, ip);
	            stack.pop();
	            const n = stack.get(-1);
	            const v = ScriptNum.toMinimal(Buffer.from(n));

	            // Try to see if we can fit that number in the number of
	            // byte requested.
	            if (v.length > size)
	              // We definitively cannot.
	              throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);

	            // We already have an element of the right size, we don't need to do
	            // anything.
	            if (v.length === size) {
	              stack.pop();
	              stack.push(v);
	              break;
	            }
	            const raw = Buffer.alloc(size);
	            v.copy(raw);
	            let signbit = 0x00;
	            if (v.length > 0) {
	              signbit = v[v.length - 1] & 0x80;
	              raw[v.length - 1] &= 0x7f;
	            }
	            raw[size - 1] = signbit;
	            stack.pop();
	            stack.push(raw);
	            break;
	          }
	        case opcodes.OP_BIN2NUM:
	          {
	            // (in -- out)
	            if (stack.length < 1) {
	              throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	            }
	            const n = stack.get(-1);
	            const v = ScriptNum.toMinimal(Buffer.from(n));
	            stack.pop();
	            stack.push(v);

	            // The resulting number must be a valid number.
	            if (!ScriptNum.isMinimal(v) || v.length > 4) throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);
	            break;
	          }
	        default:
	          {
	            throw new ScriptError('BAD_OPCODE', op, ip);
	          }
	      }
	    }
	    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK) throw new ScriptError('STACK_SIZE');
	    if (state.length !== 0) throw new ScriptError('UNBALANCED_CONDITIONAL');
	  }

	  /**
	   * Remove all matched data elements from
	   * a script's code (used to remove signatures
	   * before verification). Note that this
	   * compares and removes data on the _byte level_.
	   * It also reserializes the data to a single
	   * script with minimaldata encoding beforehand.
	   * A signature will _not_ be removed if it is
	   * not minimaldata.
	   * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
	   * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
	   * @param {Buffer} data - Data element to match against.
	   * @returns {Number} Total.
	   */

	  findAndDelete(data) {
	    const target = Opcode.fromPush(data);
	    if (this.raw.length < target.getSize()) return 0;
	    let found = false;
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      if (op.equals(target)) {
	        found = true;
	        break;
	      }
	    }
	    if (!found) return 0;
	    const code = [];
	    let total = 0;
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      if (op.equals(target)) {
	        total += 1;
	        continue;
	      }
	      code.push(op);
	    }
	    this.code = code;
	    this.compile();
	    return total;
	  }

	  /**
	   * Find a data element in a script.
	   * @param {Buffer} data - Data element to match against.
	   * @returns {Number} Index (`-1` if not present).
	   */

	  indexOf(data) {
	    for (let i = 0; i < this.code.length; i++) {
	      const op = this.code[i];
	      if (op.value === -1) break;
	      if (!op.data) continue;
	      if (op.data.equals(data)) return i;
	    }
	    return -1;
	  }

	  /**
	   * Test a script to see if it is likely
	   * to be script code (no weird opcodes).
	   * @param {Number?} flags - Script standard flags.
	   * @returns {Boolean}
	   */

	  isCode(flags) {
	    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;
	    for (const op of this.code) {
	      if (op.value === -1) return false;
	      if (op.isDisabled(flags)) return false;
	      switch (op.value) {
	        case opcodes.OP_RESERVED:
	        case opcodes.OP_NOP:
	        case opcodes.OP_VER:
	        case opcodes.OP_VERIF:
	        case opcodes.OP_VERNOTIF:
	        case opcodes.OP_RESERVED1:
	        case opcodes.OP_RESERVED2:
	        case opcodes.OP_NOP1:
	          return false;
	      }
	      if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY) return false;
	    }
	    return true;
	  }

	  /**
	   * Inject properties from a pay-to-pubkey script.
	   * @private
	   * @param {Buffer} key
	   */

	  fromPubkey(key) {
	    assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));
	    this.raw = Buffer.allocUnsafe(1 + key.length + 1);
	    this.raw[0] = key.length;
	    key.copy(this.raw, 1);
	    this.raw[1 + key.length] = opcodes.OP_CHECKSIG;
	    key = this.raw.slice(1, 1 + key.length);
	    this.code.length = 0;
	    this.code.push(Opcode.fromPush(key));
	    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));
	    return this;
	  }

	  /**
	   * Create a pay-to-pubkey script.
	   * @param {Buffer} key
	   * @returns {Script}
	   */

	  static fromPubkey(key) {
	    return new this().fromPubkey(key);
	  }

	  /**
	   * Inject properties from a pay-to-pubkeyhash script.
	   * @private
	   * @param {Buffer} hash
	   */

	  fromPubkeyhash(hash) {
	    assert(Buffer.isBuffer(hash) && hash.length === 20);
	    this.raw = Buffer.allocUnsafe(25);
	    this.raw[0] = opcodes.OP_DUP;
	    this.raw[1] = opcodes.OP_HASH160;
	    this.raw[2] = 0x14;
	    hash.copy(this.raw, 3);
	    this.raw[23] = opcodes.OP_EQUALVERIFY;
	    this.raw[24] = opcodes.OP_CHECKSIG;
	    hash = this.raw.slice(3, 23);
	    this.code.length = 0;
	    this.code.push(Opcode.fromOp(opcodes.OP_DUP));
	    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
	    this.code.push(Opcode.fromPush(hash));
	    this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));
	    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));
	    return this;
	  }

	  /**
	   * Create a pay-to-pubkeyhash script.
	   * @param {Buffer} hash
	   * @returns {Script}
	   */

	  static fromPubkeyhash(hash) {
	    return new this().fromPubkeyhash(hash);
	  }

	  /**
	   * Inject properties from pay-to-multisig script.
	   * @private
	   * @param {Number} m
	   * @param {Number} n
	   * @param {Buffer[]} keys
	   */

	  fromMultisig(m, n, keys) {
	    assert((m & 0xff) === m && (n & 0xff) === n);
	    assert(Array.isArray(keys));
	    assert(keys.length === n, '`n` keys are required for multisig.');
	    assert(m >= 1 && m <= n);
	    assert(n >= 1 && n <= 15);
	    this.clear();
	    this.pushSmall(m);
	    for (const key of sortKeys(keys)) this.pushData(key);
	    this.pushSmall(n);
	    this.pushOp(opcodes.OP_CHECKMULTISIG);
	    return this.compile();
	  }

	  /**
	   * Create a pay-to-multisig script.
	   * @param {Number} m
	   * @param {Number} n
	   * @param {Buffer[]} keys
	   * @returns {Script}
	   */

	  static fromMultisig(m, n, keys) {
	    return new this().fromMultisig(m, n, keys);
	  }

	  /**
	   * Inject properties from a pay-to-scripthash script.
	   * @private
	   * @param {Buffer} hash
	   */

	  fromScripthash(hash) {
	    assert(Buffer.isBuffer(hash) && hash.length === 20);
	    this.raw = Buffer.allocUnsafe(23);
	    this.raw[0] = opcodes.OP_HASH160;
	    this.raw[1] = 0x14;
	    hash.copy(this.raw, 2);
	    this.raw[22] = opcodes.OP_EQUAL;
	    hash = this.raw.slice(2, 22);
	    this.code.length = 0;
	    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
	    this.code.push(Opcode.fromPush(hash));
	    this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));
	    return this;
	  }

	  /**
	   * Create a pay-to-scripthash script.
	   * @param {Buffer} hash
	   * @returns {Script}
	   */

	  static fromScripthash(hash) {
	    return new this().fromScripthash(hash);
	  }

	  /**
	   * Inject properties from a nulldata/opreturn script.
	   * @private
	   * @param {Buffer} flags
	   */

	  fromNulldata(flags) {
	    assert(Buffer.isBuffer(flags));
	    assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');
	    this.clear();
	    this.pushOp(opcodes.OP_RETURN);
	    this.pushData(flags);
	    return this.compile();
	  }

	  /**
	   * Create a nulldata/opreturn script.
	   * @param {Buffer} flags
	   * @returns {Script}
	   */

	  static fromNulldata(flags) {
	    return new this().fromNulldata(flags);
	  }

	  /**
	   * Inject properties from an address.
	   * @private
	   * @param {Address|AddressString} address
	   */

	  fromAddress(address) {
	    if (typeof address === 'string') address = Address.fromString(address);
	    assert(address instanceof Address, 'Not an address.');
	    if (address.isPubkeyhash()) return this.fromPubkeyhash(address.hash);
	    if (address.isScripthash()) return this.fromScripthash(address.hash);
	    throw new Error('Unknown address type.');
	  }

	  /**
	   * Create an output script from an address.
	   * @param {Address|AddressString} address
	   * @returns {Script}
	   */

	  static fromAddress(address) {
	    return new this().fromAddress(address);
	  }

	  /**
	   * Grab and deserialize the redeem script.
	   * @returns {Script|null} Redeem script.
	   */

	  getRedeem() {
	    let data = null;
	    for (const op of this.code) {
	      if (op.value === -1) return null;
	      if (op.value > opcodes.OP_16) return null;
	      data = op.data;
	    }
	    if (!data) return null;
	    return Script.fromRaw(data);
	  }

	  /**
	   * Get the standard script type.
	   * @returns {ScriptType}
	   */

	  getType() {
	    if (this.isPubkey()) return scriptTypes.PUBKEY;
	    if (this.isPubkeyhash()) return scriptTypes.PUBKEYHASH;
	    if (this.isScripthash()) return scriptTypes.SCRIPTHASH;
	    if (this.isMultisig()) return scriptTypes.MULTISIG;
	    if (this.isNulldata()) return scriptTypes.NULLDATA;
	    return scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Test whether a script is of an unknown/non-standard type.
	   * @returns {Boolean}
	   */

	  isUnknown() {
	    return this.getType() === scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Test whether the script is standard by policy standards.
	   * @returns {Boolean}
	   */

	  isStandard() {
	    const [m, n] = this.getMultisig();
	    if (m !== -1) {
	      if (n < 1 || n > 3) return false;
	      if (m < 1 || m > n) return false;
	      return true;
	    }
	    if (this.isNulldata()) return this.raw.length <= policy.MAX_OP_RETURN_BYTES;
	    return this.getType() !== scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Calculate the size of the script
	   * excluding the varint size bytes.
	   * @returns {Number}
	   */

	  getSize() {
	    return this.raw.length;
	  }

	  /**
	   * Calculate the size of the script
	   * including the varint size bytes.
	   * @returns {Number}
	   */

	  getVarSize() {
	    return encoding.sizeVarBytes(this.raw);
	  }

	  /**
	   * "Guess" the address of the input script.
	   * This method is not 100% reliable.
	   * @returns {Address|null}
	   */

	  getInputAddress() {
	    return Address.fromInputScript(this);
	  }

	  /**
	   * Get the address of the script if present. Note that
	   * pubkey and multisig scripts will be treated as though
	   * they are pubkeyhash and scripthashes respectively.
	   * @returns {Address|null}
	   */

	  getAddress() {
	    return Address.fromScript(this);
	  }

	  /**
	   * Get the hash160 of the raw script.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  hash160(enc) {
	    let hash = hash160.digest(this.toRaw());
	    if (enc === 'hex') hash = hash.toString('hex');
	    return hash;
	  }

	  /**
	   * Get the sha256 of the raw script.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  sha256(enc) {
	    let hash = sha256.digest(this.toRaw());
	    if (enc === 'hex') hash = hash.toString('hex');
	    return hash;
	  }

	  /**
	   * Test whether the output script is pay-to-pubkey.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isPubkey(minimal) {
	    if (minimal) {
	      return this.raw.length >= 35 && (this.raw[0] === 33 || this.raw[0] === 65) && this.raw[0] + 2 === this.raw.length && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;
	    }
	    if (this.code.length !== 2) return false;
	    const size = this.getLength(0);
	    return (size === 33 || size === 65) && this.getOp(1) === opcodes.OP_CHECKSIG;
	  }

	  /**
	   * Get P2PK key if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getPubkey(minimal) {
	    if (!this.isPubkey(minimal)) return null;
	    if (minimal) return this.raw.slice(1, 1 + this.raw[0]);
	    return this.getData(0);
	  }

	  /**
	   * Test whether the output script is pay-to-pubkeyhash.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isPubkeyhash(minimal) {
	    if (minimal || this.raw.length === 25) {
	      return this.raw.length === 25 && this.raw[0] === opcodes.OP_DUP && this.raw[1] === opcodes.OP_HASH160 && this.raw[2] === 0x14 && this.raw[23] === opcodes.OP_EQUALVERIFY && this.raw[24] === opcodes.OP_CHECKSIG;
	    }
	    if (this.code.length !== 5) return false;
	    return this.getOp(0) === opcodes.OP_DUP && this.getOp(1) === opcodes.OP_HASH160 && this.getLength(2) === 20 && this.getOp(3) === opcodes.OP_EQUALVERIFY && this.getOp(4) === opcodes.OP_CHECKSIG;
	  }

	  /**
	   * Get P2PKH hash if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getPubkeyhash(minimal) {
	    if (!this.isPubkeyhash(minimal)) return null;
	    if (minimal) return this.raw.slice(3, 23);
	    return this.getData(2);
	  }

	  /**
	     * Test whether the output script is pay-to-multisig.
	     * @param {Boolean} [minimal=true] - Minimaldata only.
	     * @returns {Boolean}
	     */

	  isMultisig(minimal) {
	    if (this.code.length < 4 || this.code.length > 19) return false;
	    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG) return false;
	    const m = this.getSmall(0);
	    if (m < 1) return false;
	    const n = this.getSmall(-2);
	    if (n < 1 || m > n) return false;
	    if (this.code.length !== n + 3) return false;
	    for (let i = 1; i < n + 1; i++) {
	      const op = this.code[i];
	      const size = op.toLength();
	      if (size !== 33 && size !== 65) return false;
	      if (minimal && !op.isMinimal()) return false;
	    }
	    return true;
	  }

	  /**
	   * Get multisig m and n values if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Array} [m, n]
	   */

	  getMultisig(minimal) {
	    if (!this.isMultisig(minimal)) return [-1, -1];
	    return [this.getSmall(0), this.getSmall(-2)];
	  }

	  /**
	   * Test whether the output script is pay-to-scripthash. Note that
	   * bitcoin itself requires scripthashes to be in strict minimaldata
	   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
	   * _not_ be recognized as a scripthash.
	   * @returns {Boolean}
	   */

	  isScripthash() {
	    return this.raw.length === 23 && this.raw[0] === opcodes.OP_HASH160 && this.raw[1] === 0x14 && this.raw[22] === opcodes.OP_EQUAL;
	  }

	  /**
	   * Get P2SH hash if present.
	   * @returns {Buffer|null}
	   */

	  getScripthash() {
	    if (!this.isScripthash()) return null;
	    return this.getData(1);
	  }

	  /**
	   * Test whether the output script is nulldata/opreturn.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isNulldata(minimal) {
	    if (this.code.length === 0) return false;
	    if (this.getOp(0) !== opcodes.OP_RETURN) return false;
	    if (this.code.length === 1) return true;
	    if (minimal) {
	      if (this.raw.length > policy.MAX_OP_RETURN_BYTES) return false;
	    }
	    for (let i = 1; i < this.code.length; i++) {
	      const op = this.code[i];
	      if (op.value === -1) return false;
	      if (op.value > opcodes.OP_16) return false;
	      if (minimal && !op.isMinimal()) return false;
	    }
	    return true;
	  }

	  /**
	   * Get OP_RETURN data if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getNulldata(minimal) {
	    if (!this.isNulldata(minimal)) return null;
	    for (let i = 1; i < this.code.length; i++) {
	      const op = this.code[i];
	      const data = op.toPush();
	      if (data) return data;
	    }
	    return EMPTY_BUFFER;
	  }

	  /**
	   * Test whether the output script is a witness program.
	   * Note that this will return true even for malformed
	   * witness v0 programs.
	   * @returns {Boolean}
	   */

	  isProgram() {
	    if (this.raw.length < 4 || this.raw.length > 42) return false;
	    if (this.raw[0] !== opcodes.OP_0 && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {
	      return false;
	    }
	    if (this.raw[1] + 2 !== this.raw.length) return false;
	    return true;
	  }

	  /**
	   * Test whether the output script is unspendable.
	   * @returns {Boolean}
	   */

	  isUnspendable() {
	    if (this.raw.length > consensus.MAX_SCRIPT_SIZE) return true;
	    return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;
	  }

	  /**
	   * "Guess" the type of the input script.
	   * This method is not 100% reliable.
	   * @returns {ScriptType}
	   */

	  getInputType() {
	    if (this.isPubkeyInput()) return scriptTypes.PUBKEY;
	    if (this.isPubkeyhashInput()) return scriptTypes.PUBKEYHASH;
	    if (this.isScripthashInput()) return scriptTypes.SCRIPTHASH;
	    if (this.isMultisigInput()) return scriptTypes.MULTISIG;
	    return scriptTypes.NONSTANDARD;
	  }

	  /**
	   * "Guess" whether the input script is an unknown/non-standard type.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isUnknownInput() {
	    return this.getInputType() === scriptTypes.NONSTANDARD;
	  }

	  /**
	   * "Guess" whether the input script is pay-to-pubkey.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isPubkeyInput() {
	    if (this.code.length !== 1) return false;
	    const size = this.getLength(0);
	    return size >= 9 && size <= 73;
	  }

	  /**
	   * Get P2PK signature if present.
	   * @returns {Buffer|null}
	   */

	  getPubkeyInput() {
	    if (!this.isPubkeyInput()) return null;
	    return this.getData(0);
	  }

	  /**
	   * "Guess" whether the input script is pay-to-pubkeyhash.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isPubkeyhashInput() {
	    if (this.code.length !== 2) return false;
	    const sig = this.getLength(0);
	    const key = this.getLength(1);
	    return sig >= 9 && sig <= 73 && (key === 33 || key === 65);
	  }

	  /**
	   * Get P2PKH signature and key if present.
	   * @returns {Array} [sig, key]
	   */

	  getPubkeyhashInput() {
	    if (!this.isPubkeyhashInput()) return [null, null];
	    return [this.getData(0), this.getData(1)];
	  }

	  /**
	   * "Guess" whether the input script is pay-to-multisig.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isMultisigInput() {
	    if (this.code.length < 2) return false;
	    if (this.getOp(0) !== opcodes.OP_0) return false;
	    if (this.getOp(1) > opcodes.OP_PUSHDATA4) return false;

	    // We need to rule out scripthash
	    // because it may look like multisig.
	    if (this.isScripthashInput()) return false;
	    for (let i = 1; i < this.code.length; i++) {
	      const size = this.getLength(i);
	      if (size < 9 || size > 73) return false;
	    }
	    return true;
	  }

	  /**
	   * Get multisig signatures if present.
	   * @returns {Buffer[]|null}
	   */

	  getMultisigInput() {
	    if (!this.isMultisigInput()) return null;
	    const sigs = [];
	    for (let i = 1; i < this.code.length; i++) sigs.push(this.getData(i));
	    return sigs;
	  }

	  /**
	   * "Guess" whether the input script is pay-to-scripthash.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isScripthashInput() {
	    if (this.code.length < 1) return false;

	    // Grab the raw redeem script.
	    const raw = this.getData(-1);

	    // Last data element should be an array
	    // for the redeem script.
	    if (!raw) return false;

	    // Testing for scripthash inputs requires
	    // some evil magic to work. We do it by
	    // ruling things _out_. This test will not
	    // be correct 100% of the time. We rule
	    // out that the last data element is: a
	    // null dummy, a valid signature, a valid
	    // key, and we ensure that it is at least
	    // a script that does not use undefined
	    // opcodes.
	    if (raw.length === 0) return false;
	    if (common.isDERSignatureEncoding(raw.slice(0, -1))) return false;
	    if (common.isKeyEncoding(raw)) return false;
	    const redeem = Script.fromRaw(raw);
	    if (!redeem.isCode()) return false;
	    if (redeem.isUnspendable()) return false;
	    if (!this.isPushOnly()) return false;
	    return true;
	  }

	  /**
	   * Get P2SH redeem script if present.
	   * @returns {Buffer|null}
	   */

	  getScripthashInput() {
	    if (!this.isScripthashInput()) return null;
	    return this.getData(-1);
	  }

	  /**
	   * Get coinbase height.
	   * @returns {Number} `-1` if not present.
	   */

	  getCoinbaseHeight() {
	    return Script.getCoinbaseHeight(this.raw);
	  }

	  /**
	   * Get coinbase height.
	   * @param {Buffer} raw - Raw script.
	   * @returns {Number} `-1` if not present.
	   */

	  static getCoinbaseHeight(raw) {
	    if (raw.length === 0) return -1;
	    if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16) return raw[0] - 0x50;
	    if (raw[0] > 0x06) return -1;
	    const op = Opcode.fromRaw(raw);
	    const num = op.toNum();
	    if (!num) return 1;
	    if (num.isNeg()) return -1;
	    if (!op.equals(Opcode.fromNum(num))) return -1;
	    return num.toDouble();
	  }

	  /**
	   * Test the script against a bloom filter.
	   * @param {Bloom} filter
	   * @returns {Boolean}
	   */

	  test(filter) {
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      if (!op.data || op.data.length === 0) continue;
	      if (filter.test(op.data)) return true;
	    }
	    return false;
	  }

	  /**
	   * Test the script to see if it contains only push ops.
	   * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
	   * @returns {Boolean}
	   */

	  isPushOnly() {
	    for (const op of this.code) {
	      if (op.value === -1) return false;
	      if (op.value > opcodes.OP_16) return false;
	    }
	    return true;
	  }

	  /**
	   * Count the sigops in the script.
	   * @param {Boolean} accurate - Whether to enable accurate counting. This will
	   * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
	   * @returns {Number} sigop count
	   */

	  getSigops(accurate, flags) {
	    if (flags & Script.flags.VERIFY_ZERO_SIGOPS) return 0;
	    let total = 0;
	    let lastOp = -1;
	    for (const op of this.code) {
	      if (op.value === -1) break;
	      switch (op.value) {
	        case opcodes.OP_CHECKSIG:
	        case opcodes.OP_CHECKSIGVERIFY:
	          total += 1;
	          break;
	        case opcodes.OP_CHECKSDATAIG:
	        case opcodes.OP_CHECKDATASIGVERIFY:
	          if (flags & Script.flags.VERIFY_CHECKDATASIG) {
	            total += 1;
	          }
	          break;
	        case opcodes.OP_CHECKMULTISIG:
	        case opcodes.OP_CHECKMULTISIGVERIFY:
	          if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16) total += lastOp - 0x50;else total += consensus.MAX_MULTISIG_PUBKEYS;
	          break;
	      }
	      lastOp = op.value;
	    }
	    return total;
	  }

	  /**
	   * Count the sigops in the script, taking into account redeem scripts.
	   * @param {Script} input - Input script, needed for access to redeem script.
	   * @param {VerifyFlags} flags
	   * @returns {Number} sigop count
	   */

	  getScripthashSigops(input, flags) {
	    if (!this.isScripthash()) return this.getSigops(true, flags);
	    const redeem = input.getRedeem();
	    if (!redeem) return 0;
	    return redeem.getSigops(true, flags);
	  }

	  /*
	   * Mutation
	   */

	  get(index) {
	    if (index < 0) index += this.code.length;
	    if (index < 0 || index >= this.code.length) return null;
	    return this.code[index];
	  }
	  pop() {
	    const op = this.code.pop();
	    return op || null;
	  }
	  shift() {
	    const op = this.code.shift();
	    return op || null;
	  }
	  remove(index) {
	    if (index < 0) index += this.code.length;
	    if (index < 0 || index >= this.code.length) return null;
	    const items = this.code.splice(index, 1);
	    if (items.length === 0) return null;
	    return items[0];
	  }
	  set(index, op) {
	    if (index < 0) index += this.code.length;
	    assert(Opcode.isOpcode(op));
	    assert(index >= 0 && index <= this.code.length);
	    this.code[index] = op;
	    return this;
	  }
	  push(op) {
	    assert(Opcode.isOpcode(op));
	    this.code.push(op);
	    return this;
	  }
	  unshift(op) {
	    assert(Opcode.isOpcode(op));
	    this.code.unshift(op);
	    return this;
	  }
	  insert(index, op) {
	    if (index < 0) index += this.code.length;
	    assert(Opcode.isOpcode(op));
	    assert(index >= 0 && index <= this.code.length);
	    this.code.splice(index, 0, op);
	    return this;
	  }

	  /*
	   * Op
	   */

	  getOp(index) {
	    const op = this.get(index);
	    return op ? op.value : -1;
	  }
	  popOp() {
	    const op = this.pop();
	    return op ? op.value : -1;
	  }
	  shiftOp() {
	    const op = this.shift();
	    return op ? op.value : -1;
	  }
	  removeOp(index) {
	    const op = this.remove(index);
	    return op ? op.value : -1;
	  }
	  setOp(index, value) {
	    return this.set(index, Opcode.fromOp(value));
	  }
	  pushOp(value) {
	    return this.push(Opcode.fromOp(value));
	  }
	  unshiftOp(value) {
	    return this.unshift(Opcode.fromOp(value));
	  }
	  insertOp(index, value) {
	    return this.insert(index, Opcode.fromOp(value));
	  }

	  /*
	   * Data
	   */

	  getData(index) {
	    const op = this.get(index);
	    return op ? op.data : null;
	  }
	  popData() {
	    const op = this.pop();
	    return op ? op.data : null;
	  }
	  shiftData() {
	    const op = this.shift();
	    return op ? op.data : null;
	  }
	  removeData(index) {
	    const op = this.remove(index);
	    return op ? op.data : null;
	  }
	  setData(index, data) {
	    return this.set(index, Opcode.fromData(data));
	  }
	  pushData(data) {
	    return this.push(Opcode.fromData(data));
	  }
	  unshiftData(data) {
	    return this.unshift(Opcode.fromData(data));
	  }
	  insertData(index, data) {
	    return this.insert(index, Opcode.fromData(data));
	  }

	  /*
	   * Length
	   */

	  getLength(index) {
	    const op = this.get(index);
	    return op ? op.toLength() : -1;
	  }

	  /*
	   * Push
	   */

	  getPush(index) {
	    const op = this.get(index);
	    return op ? op.toPush() : null;
	  }
	  popPush() {
	    const op = this.pop();
	    return op ? op.toPush() : null;
	  }
	  shiftPush() {
	    const op = this.shift();
	    return op ? op.toPush() : null;
	  }
	  removePush(index) {
	    const op = this.remove(index);
	    return op ? op.toPush() : null;
	  }
	  setPush(index, data) {
	    return this.set(index, Opcode.fromPush(data));
	  }
	  pushPush(data) {
	    return this.push(Opcode.fromPush(data));
	  }
	  unshiftPush(data) {
	    return this.unshift(Opcode.fromPush(data));
	  }
	  insertPush(index, data) {
	    return this.insert(index, Opcode.fromPush(data));
	  }

	  /*
	   * String
	   */

	  getString(index, enc) {
	    const op = this.get(index);
	    return op ? op.toString(enc) : null;
	  }
	  popString(enc) {
	    const op = this.pop();
	    return op ? op.toString(enc) : null;
	  }
	  shiftString(enc) {
	    const op = this.shift();
	    return op ? op.toString(enc) : null;
	  }
	  removeString(index, enc) {
	    const op = this.remove(index);
	    return op ? op.toString(enc) : null;
	  }
	  setString(index, str, enc) {
	    return this.set(index, Opcode.fromString(str, enc));
	  }
	  pushString(str, enc) {
	    return this.push(Opcode.fromString(str, enc));
	  }
	  unshiftString(str, enc) {
	    return this.unshift(Opcode.fromString(str, enc));
	  }
	  insertString(index, str, enc) {
	    return this.insert(index, Opcode.fromString(str, enc));
	  }

	  /*
	   * Small
	   */

	  getSmall(index) {
	    const op = this.get(index);
	    return op ? op.toSmall() : -1;
	  }
	  popSmall() {
	    const op = this.pop();
	    return op ? op.toSmall() : -1;
	  }
	  shiftSmall() {
	    const op = this.shift();
	    return op ? op.toSmall() : -1;
	  }
	  removeSmall(index) {
	    const op = this.remove(index);
	    return op ? op.toSmall() : -1;
	  }
	  setSmall(index, num) {
	    return this.set(index, Opcode.fromSmall(num));
	  }
	  pushSmall(num) {
	    return this.push(Opcode.fromSmall(num));
	  }
	  unshiftSmall(num) {
	    return this.unshift(Opcode.fromSmall(num));
	  }
	  insertSmall(index, num) {
	    return this.insert(index, Opcode.fromSmall(num));
	  }

	  /*
	   * Num
	   */

	  getNum(index, minimal, limit) {
	    const op = this.get(index);
	    return op ? op.toNum(minimal, limit) : null;
	  }
	  popNum(minimal, limit) {
	    const op = this.pop();
	    return op ? op.toNum(minimal, limit) : null;
	  }
	  shiftNum(minimal, limit) {
	    const op = this.shift();
	    return op ? op.toNum(minimal, limit) : null;
	  }
	  removeNum(index, minimal, limit) {
	    const op = this.remove(index);
	    return op ? op.toNum(minimal, limit) : null;
	  }
	  setNum(index, num) {
	    return this.set(index, Opcode.fromNum(num));
	  }
	  pushNum(num) {
	    return this.push(Opcode.fromNum(num));
	  }
	  unshiftNum(num) {
	    return this.unshift(Opcode.fromNum(num));
	  }
	  insertNum(index, num) {
	    return this.insert(index, Opcode.fromNum(num));
	  }

	  /*
	   * Int
	   */

	  getInt(index, minimal, limit) {
	    const op = this.get(index);
	    return op ? op.toInt(minimal, limit) : -1;
	  }
	  popInt(minimal, limit) {
	    const op = this.pop();
	    return op ? op.toInt(minimal, limit) : -1;
	  }
	  shiftInt(minimal, limit) {
	    const op = this.shift();
	    return op ? op.toInt(minimal, limit) : -1;
	  }
	  removeInt(index, minimal, limit) {
	    const op = this.remove(index);
	    return op ? op.toInt(minimal, limit) : -1;
	  }
	  setInt(index, num) {
	    return this.set(index, Opcode.fromInt(num));
	  }
	  pushInt(num) {
	    return this.push(Opcode.fromInt(num));
	  }
	  unshiftInt(num) {
	    return this.unshift(Opcode.fromInt(num));
	  }
	  insertInt(index, num) {
	    return this.insert(index, Opcode.fromInt(num));
	  }

	  /*
	   * Bool
	   */

	  getBool(index) {
	    const op = this.get(index);
	    return op ? op.toBool() : false;
	  }
	  popBool() {
	    const op = this.pop();
	    return op ? op.toBool() : false;
	  }
	  shiftBool() {
	    const op = this.shift();
	    return op ? op.toBool() : false;
	  }
	  removeBool(index) {
	    const op = this.remove(index);
	    return op ? op.toBool() : false;
	  }
	  setBool(index, value) {
	    return this.set(index, Opcode.fromBool(value));
	  }
	  pushBool(value) {
	    return this.push(Opcode.fromBool(value));
	  }
	  unshiftBool(value) {
	    return this.unshift(Opcode.fromBool(value));
	  }
	  insertBool(index, value) {
	    return this.insert(index, Opcode.fromBool(value));
	  }

	  /*
	   * Symbol
	   */

	  getSym(index) {
	    const op = this.get(index);
	    return op ? op.toSymbol() : null;
	  }
	  popSym() {
	    const op = this.pop();
	    return op ? op.toSymbol() : null;
	  }
	  shiftSym() {
	    const op = this.shift();
	    return op ? op.toSymbol() : null;
	  }
	  removeSym(index) {
	    const op = this.remove(index);
	    return op ? op.toSymbol() : null;
	  }
	  setSym(index, symbol) {
	    return this.set(index, Opcode.fromSymbol(symbol));
	  }
	  pushSym(symbol) {
	    return this.push(Opcode.fromSymbol(symbol));
	  }
	  unshiftSym(symbol) {
	    return this.unshift(Opcode.fromSymbol(symbol));
	  }
	  insertSym(index, symbol) {
	    return this.insert(index, Opcode.fromSymbol(symbol));
	  }

	  /**
	   * Inject properties from bitcoind test string.
	   * @private
	   * @param {String} items - Script string.
	   * @throws Parse error.
	   */

	  fromString(code) {
	    assert(typeof code === 'string');
	    code = code.trim();
	    if (code.length === 0) return this;
	    const items = code.split(/\s+/);
	    const bw = bio.write();
	    for (const item of items) {
	      let symbol = item;
	      if (symbol.charCodeAt(0) & 32) symbol = symbol.toUpperCase();
	      if (!/^OP_/.test(symbol)) symbol = `OP_${symbol}`;
	      const value = opcodes[symbol];
	      if (value == null) {
	        if (item[0] === '\'') {
	          assert(item[item.length - 1] === '\'', 'Invalid string.');
	          const str = item.slice(1, -1);
	          const op = Opcode.fromString(str);
	          bw.writeBytes(op.toRaw());
	          continue;
	        }
	        if (/^-?\d+$/.test(item)) {
	          const num = ScriptNum.fromString(item, 10);
	          const op = Opcode.fromNum(num);
	          bw.writeBytes(op.toRaw());
	          continue;
	        }
	        assert(item.indexOf('0x') === 0, 'Unknown opcode.');
	        const hex = item.substring(2);
	        const data = Buffer.from(hex, 'hex');
	        assert(data.length === hex.length / 2, 'Invalid hex string.');
	        bw.writeBytes(data);
	        continue;
	      }
	      bw.writeU8(value);
	    }
	    return this.fromRaw(bw.render());
	  }

	  /**
	   * Parse a bitcoind test script
	   * string into a script object.
	   * @param {String} items - Script string.
	   * @returns {Script}
	   * @throws Parse error.
	   */

	  static fromString(code) {
	    return new this().fromString(code);
	  }

	  /**
	   * Verify an input and output script, and a witness if present.
	   * @param {Script} input
	   * @param {Null} witness
	   * @param {Script} output
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Amount} value
	   * @param {VerifyFlags} flags
	   * @param {Number?} sigchecks
	   * @throws {ScriptError}
	   */

	  static verify(input, witness, output, tx, index, value, flags, sigchecks) {
	    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;
	    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {
	      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY');
	    }
	    if (flags & Script.flags.VERIFY_SIGHASH_FORKID) flags |= Script.flags.VERIFY_STRICTENC;

	    // Setup a stack.
	    let stack = new Stack();

	    // Execute the input script
	    input.execute(stack, flags, tx, index, value, metrics.sigchecks);

	    // Copy the stack for P2SH
	    let copy;
	    if (flags & Script.flags.VERIFY_P2SH) copy = stack.clone();

	    // Execute the previous output script.
	    output.execute(stack, flags, tx, index, value, metrics.sigchecks);

	    // Verify the stack values.
	    if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE');

	    // If the script is P2SH, execute the real output script
	    if (flags & Script.flags.VERIFY_P2SH && output.isScripthash()) {
	      // P2SH can only have push ops in the scriptSig
	      if (!input.isPushOnly()) throw new ScriptError('SIG_PUSHONLY');

	      // Reset the stack
	      stack = copy;

	      // Stack should not be empty at this point
	      if (stack.length === 0) throw new ScriptError('EVAL_FALSE');

	      // Grab the real redeem script
	      const raw = stack.pop();
	      const redeem = Script.fromRaw(raw);
	      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0 && stack.length === 0 && redeem.isProgram()) {
	        // Before activation all transaction count a value of 0
	        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {
	          metrics.sigchecks = 0;
	        }
	        return;
	      }

	      // Execute the redeem script.
	      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);

	      // Verify the the stack values.
	      if (stack.length === 0 || !stack.getBool(-1)) throw new ScriptError('EVAL_FALSE');
	    }

	    // Ensure there is nothing left on the stack.
	    if (flags & Script.flags.VERIFY_CLEANSTACK) {
	      assert((flags & Script.flags.VERIFY_P2SH) !== 0);
	      if (stack.length !== 1) throw new ScriptError('CLEANSTACK');
	    }
	    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {
	      if (input.getSize() < metrics.sigchecks * 43 - 60) throw new ScriptError('INPUT_SIGCHECKS');
	    }
	    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {
	      metrics.sigchecks = 0;
	    }
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    return this.fromRaw(br.readVarBytes());
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer}
	   */

	  fromRaw(data) {
	    const br = bio.read(data);
	    this.raw = data;
	    while (br.left()) this.code.push(Opcode.fromReader(br));
	    return this;
	  }

	  /**
	   * Create a script from buffer reader.
	   * @param {BufferReader} br
	   * @param {String?} enc - Either `"hex"` or `null`.
	   * @returns {Script}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Create a script from a serialized buffer.
	   * @param {Buffer|String} data - Serialized script.
	   * @param {String?} enc - Either `"hex"` or `null`.
	   * @returns {Script}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object a Script.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isScript(obj) {
	    return obj instanceof Script;
	  }
	}

	/**
	 * Script opcodes.
	 * @enum {Number}
	 * @default
	 */

	Script.opcodes = common.opcodes;

	/**
	 * Opcodes by value.
	 * @const {RevMap}
	 */

	Script.opcodesByVal = common.opcodesByVal;

	/**
	 * Script and locktime flags. See {@link VerifyFlags}.
	 * @enum {Number}
	 */

	Script.flags = common.flags;

	/**
	 * Sighash Types.
	 * @enum {SighashType}
	 * @default
	 */

	Script.hashType = common.hashType;

	/**
	 * Sighash types by value.
	 * @const {RevMap}
	 */

	Script.hashTypeByVal = common.hashTypeByVal;

	/**
	 * Output script types.
	 * @enum {Number}
	 */

	Script.types = common.types;

	/**
	 * Output script types by value.
	 * @const {RevMap}
	 */

	Script.typesByVal = common.typesByVal;

	/*
	 * Helpers
	 */

	function sortKeys(keys) {
	  return keys.slice().sort((a, b) => {
	    return a.compare(b);
	  });
	}

	/**
	 * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.
	 * @param {Buffer} key
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateKey(key, flags) {
	  assert(Buffer.isBuffer(key));
	  assert(typeof flags === 'number');
	  if (flags & Script.flags.VERIFY_STRICTENC) {
	    if (!common.isKeyEncoding(key)) throw new ScriptError('PUBKEYTYPE');
	  }
	  if (flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE && !common.isCompressedEncoding(key)) {
	    throw new ScriptError('NONCOMPRESSED_PUBKEY');
	  }
	  return true;
	}

	/**
	 * Test whether the raw element is a valid signature based
	 * on the encoding, S value, and sighash type.
	 * In an ECDSA-only context, 64-byte signatures are bannned
	 * when Schnorr Flag is set.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateECDSASignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');
	  if (common.isSchnorr(sig)) throw new ScriptError('SIG_BADLENGTH');
	  if (flags & Script.flags.VERIFY_DERSIG || flags & Script.flags.VERIFY_LOW_S || flags & Script.flags.VERIFY_STRICTENC) {
	    if (!common.isDERSignatureEncoding(sig)) throw new ScriptError('SIG_DER');
	  }
	  if (flags & Script.flags.VERIFY_LOW_S) {
	    if (!common.isLowDER(sig)) throw new ScriptError('SIG_HIGH_S');
	  }
	  return true;
	}

	/**
	 * Test whether the tx element is a valid signature based
	 * on the encoding, S value, and sighash type. Requires
	 * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.
	 * Note that this will allow zero-length signatures.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkSighashEncoding(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');
	  if (flags & Script.flags.VERIFY_STRICTENC) {
	    if (!common.isHashType(sig)) throw new ScriptError('SIG_HASHTYPE');
	    const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;
	    const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;
	    if (!forkEnabled && usesFork) throw new ScriptError('ILLEGAL_FORKID');
	    if (forkEnabled && !usesFork) throw new ScriptError('MUST_USE_FORKID');
	  }
	  return true;
	}

	/**
	 * Test whether the transaction tested against
	 * the Sighash Encoding is a valid Schnorr Signature.
	 * Requires Sighash
	 * @param {Buffer} sig
	 * @param {VeirfyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkTransactionSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // allow empty sigs
	  if (sig.length === 0) return true;
	  validateSchnorrSignature(sig.slice(0, -1), flags);
	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the transaction is tested
	 * against the sighash encoding w schnorr / ecdsa
	 * for multisig opcodes.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 */

	function checkTransactionSchnorrSig(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs.
	  if (sig.length === 0) return true;
	  if (!isSchnorrEncoded(sig.slice(0, -1), flags)) return validateECDSASignature(sig.slice(0, -1), flags);
	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the transaction tested against
	 * the Sighash Encoding is a valid ECDSA Signature.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkTransactionECDSASignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs
	  if (sig.length === 0) return true;
	  validateECDSASignature(sig.slice(0, -1), flags);
	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the data element is a valid signature based
	 * on the encoding, S value, and sighash type. Requires
	 * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S
	 * to be enabled respectively. Note that this will allow zero-length
	 * signatures.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateDataSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs
	  if (sig.length === 0) return true;
	  return validateSchnorrSignature(sig.slice(0, sig.length), flags);
	}

	/**
	 * Test whether the Signature is valid in context
	 * 64-byte signatures are interpreted as schnorr signatures.
	 * Always correctly encoded when Verify_SCHNORR flag is set.
	 * @param {Buffer} sig
	 * @param {Buffer} msg - Signature hash.
	 * @param {VerifyFlags?} flags
	 * @returns {Promise}
	 * @throws {ScriptError}
	 */

	function validateSchnorrSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');
	  if (common.isSchnorr(sig)) return true;
	  return validateECDSASignature(sig, flags);
	}

	/**
	 * Test whether the current signature is schnorr encoded.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function isSchnorrEncoded(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');
	  if (common.isSchnorr(sig)) return true;
	  throw new ScriptError('SIG_NONSCHNORR');
	}

	/**
	 * Test whether the signature from the stack
	 * is valid in either Schnorr or DER Format.
	 * Always encoded correctly when Schnorr flag is set.
	 * @param {Buffer} hash
	 * @param {Buffer} sig
	 * @param {Buffer} key
	 * @param {Number} flags
	 */

	function verifySignature(hash, sig, key, flags) {
	  assert(Buffer.isBuffer(hash));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));
	  assert(typeof flags === 'number');
	  let res = false;
	  if (sig.length === 64) {
	    res = secp256k1.schnorrVerify(hash, sig, key, flags);
	  } else {
	    res = secp256k1.verifyDER(hash, sig, key, flags);
	  }
	  return res;
	}

	/**
	 * Verify a signature, taking into account sighash type.
	 * @param {Buffer} msg - Signature hash.
	 * @param {Buffer} sig
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function checksig(msg, sig, key) {
	  return secp256k1.verifyDER(msg, sig.slice(0, -1), key);
	}

	/*
	 * Expose
	 */

	script$1 = Script;
	return script$1;
}

/*!
 * slp.js - simple ledger protocol script for bcash
 * Copyright (c) 2021, Vin Armani (MIT License).
 * https://github.com/badger-cash/bcash
 */

var slp;
var hasRequiredSlp;

function requireSlp () {
	if (hasRequiredSlp) return slp;
	hasRequiredSlp = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  U64
	} = requireN64();
	requireConsensus();
	const Script = requireScript$1();
	requireScriptnum();

	/**
	 * SLP Coin Record
	 */

	const SLP_TYPES = {
	  GENESIS: 0x00,
	  MINT: 0x01,
	  SEND: 0x02,
	  BATON: 0x03,
	  BURN: 0x04
	};
	class SlpCoinRecord {
	  /**
	   * Create a record of SLP data for a given coin.
	   * @param {Buffer?} hash the output hash of the coin
	   * @param {Number?} vout the output index of the coin
	   * @param {Buffer?} tokenId 32 byte txid
	   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
	   * @param {Buffer} value big endian value of token base units
	   * @param {String} type GENESIS | MINT | SEND | BURN | BATON
	   * @param {Number?} version token type
	   * @constructor
	   */

	  constructor(options = {}) {
	    this.hash = options.hash;
	    this.vout = options.vout;
	    this.tokenId = options.tokenId;
	    this.tokenIndex = options.tokenIndex;
	    this.value = options.value;
	    this.type = options.type;
	    this.version = options.version;
	  }

	  /**
	   * Get the value as 64 bit big-endian buffer
	   * @private
	   * @returns {Buffer}
	   */
	  getValueUInt64BE() {
	    assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');
	    const padding = Buffer.alloc(8 - this.value.length);
	    return Buffer.concat([padding, this.value]);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromDbData(data) {
	    const br = bio.read(data);
	    this.tokenIndex = br.readBytes(4);
	    const valueBytes = br.readVarBytes();
	    const padding = Buffer.alloc(8 - valueBytes.length);
	    this.value = Buffer.concat([padding, valueBytes]);
	    this.type = Object.keys(SLP_TYPES)[br.readU8()];
	    // Get version and handle if out of bounds
	    try {
	      this.version = br.readU8();
	    } catch (err) {
	      if (err.code === 'ERR_ENCODING') this.version = 1;else throw err;
	    }
	    assert(this.version >= 1 && this.version <= 2);
	    assert(Object.keys(SLP_TYPES).includes(this.type));
	    return this;
	  }

	  /**
	   * Instantiate SLP record from serialized data.
	   * @param {Buffer} data
	   * @returns {SlpCoinRecord}
	   */

	  static fromDbData(data) {
	    return new this().fromDbData(data);
	  }

	  /**
	   * Serialize the SLP record.
	   * @returns {Buffer}
	   */

	  toDbData() {
	    assert(this.tokenIndex, 'Missing tokenIndex');
	    assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash');
	    // assert(this.value, 'Missing token amount (in base units)')
	    assert(this.value.byteLength, 'Token amount must be a buffer');
	    assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN');
	    // Remove padding (minimal)
	    for (let i = 0; i < this.value.length; i++) {
	      if (this.value[i] != 0) {
	        this.value = this.value.slice(i);
	        break;
	      }
	    }
	    const bw = bio.write();
	    bw.writeBytes(this.tokenIndex);
	    bw.writeVarBytes(this.value);
	    bw.writeU8(SLP_TYPES[this.type]);
	    bw.writeU8(this.version || 1);
	    return bw.render();
	  }

	  /**
	   * Convert object to JSON.
	   * @returns {Object}
	   */

	  getJSON() {
	    assert(this.tokenId, 'tokenId must be defined');
	    const json = {
	      hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,
	      vout: this.vout,
	      tokenId: this.tokenId.toString('hex'),
	      value: U64.fromBE(this.value).toString(10),
	      type: this.type,
	      version: this.version || 1
	    };
	    return json;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {SlpCoinRecord}
	   */

	  fromJSON(json) {
	    this.hash = Buffer.from(json.hash, 'hex').reverse();
	    this.vout = json.vout;
	    this.tokenId = Buffer.from(json.tokenId, 'hex');
	    this.value = U64.fromString(json.value).toBE(Buffer);
	    this.type = json.type;
	    this.version = json.version || 1;
	    return this;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {TokenRecord}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }
	}

	/**
	 * Token Record
	 */

	class TokenRecord {
	  /**
	   * Create a token record.
	   * @constructor
	   * @param {Buffer?} tokenId
	   * @param {Buffer?} tokenIndex
	   * @param {String?} ticker
	   * @param {String?} name
	   * @param {String?} uri
	   * @param {String?} hash
	   * @param {Number} decimals
	   * @param {Number?} version
	   * @param {Buffer?} vaultScriptHash
	   */

	  constructor(options = {}) {
	    this.tokenId = options.tokenId;
	    this.tokenIndex = options.tokenIndex;
	    this.ticker = options.ticker || '';
	    this.name = options.name || '';
	    this.uri = options.uri || '';
	    this.hash = options.hash || '';
	    this.decimals = options.decimals;
	    this.version = options.version;
	    if (this.version === 2) this.vaultScriptHash = options.vaultScriptHash;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromDbData(data) {
	    const br = bio.read(data);
	    this.tokenId = br.readHash();
	    this.ticker = br.readVarString('utf8');
	    // assert(this.ticker.length > 0);

	    this.name = br.readVarString('utf8');
	    // assert(this.name.length > 0);

	    this.uri = br.readVarString('utf8');
	    this.hash = br.readVarString('hex');
	    this.decimals = br.readU8();
	    // Get version and handle if out of bounds
	    try {
	      this.version = br.readU8();
	    } catch (err) {
	      if (err.code === 'ERR_ENCODING') {
	        this.version = 1;
	      } else throw err;
	    }

	    // Read MINT vault ScriptHash
	    if (this.version === 2) this.vaultScriptHash = br.readBytes(20);
	    assert(this.version >= 1 && this.version <= 2);
	    // assert(this.decimals >= 0 && this.decimals < 9);

	    return this;
	  }

	  /**
	   * Instantiate token record from serialized data.
	   * @param {Buffer} data
	   * @returns {TokenRecord}
	   */

	  static fromDbData(data) {
	    return new this().fromDbData(data);
	  }

	  /**
	   * Serialize the token record.
	   * @returns {Buffer}
	   */

	  toDbData() {
	    const bw = bio.write();
	    const encoding = bio.encoding;
	    bw.writeHash(this.tokenId);
	    bw.writeVarString(this.ticker, 'utf8');
	    if (this.ticker.length === 0) bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.name, 'utf8');
	    if (this.name.length === 0) bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.uri, 'utf8');
	    if (this.uri.length === 0) bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.hash, 'hex');
	    if (this.hash.length === 0) bw.offset += encoding.sizeVarint(0);
	    bw.writeU8(this.decimals);
	    bw.writeU8(this.version || 1);
	    if (this.version === 2) bw.writeBytes(this.vaultScriptHash);
	    return bw.render();
	  }

	  /**
	   * Convert object to JSON.
	   * @returns {Object}
	   */

	  getJSON() {
	    assert(this.tokenId, 'tokenId must be defined');
	    const json = {
	      tokenId: this.tokenId.toString('hex'),
	      ticker: this.ticker,
	      name: this.name,
	      uri: this.uri,
	      hash: this.hash,
	      decimals: this.decimals,
	      version: this.version || 1
	    };
	    if (json.version === 2 && this.vaultScriptHash) json.vaultScriptHash = this.vaultScriptHash.toString('hex');
	    return json;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {SlpCoinRecord}
	   */

	  fromJSON(json) {
	    this.tokenId = Buffer.from(json.tokenId, 'hex');
	    this.ticker = json.ticker;
	    this.name = json.name;
	    this.uri = json.uri;
	    this.hash = json.hash;
	    this.decimals = json.decimals;
	    this.version = json.version;
	    if (json.version === 2 && json.vaultScriptHash) this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');
	    return this;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {TokenRecord}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }
	}

	/**
	 * SLP
	 * @alias module:script.SLP
	 * @extends Script
	 */

	class SLP extends Script {
	  /**
	   * Create an SLP script.
	   * @constructor
	   * @param {Buffer|Array|Object} code
	   */

	  constructor(options) {
	    super(options);
	    this.valid = null;
	  }

	  /**
	   * Is SLP script is of valid construction?
	   * Use this as opposed to calling property this.isValid
	   * @private
	   * @returns {Boolean}
	   */
	  isValidSlp() {
	    if (this.valid === null) {
	      this.valid = this.verifySlp();
	    }
	    return this.valid;
	  }

	  /**
	   * Test whether SLP script is of valid construction
	   * (Does not test if transaction is valid SLP transaction)
	   * @private
	   * @param {Script?} script
	   * @returns {Boolean}
	   */

	  verifySlp(script) {
	    if (script == undefined) script = this;
	    if (script.getSym(0) != 'OP_RETURN') return false;

	    // LOKAD_ID
	    if (script.getString(1, 'hex') != '534c5000') return false;

	    // Check version
	    const versionHex = script.getString(2, 'hex');
	    if (versionHex != '01' && versionHex != '02') return false;

	    // Type
	    const type = script.getType();
	    switch (type) {
	      case 'GENESIS':
	        {
	          if (script.code.length != 11) return false;
	          // Hash
	          if (!script.getData(7)) return false;
	          if (script.getData(7).length != 0 && script.getData(7).length != 32) return false;
	          // Decimals
	          if (!script.getData(8)) return false;
	          if (script.getData(8).length != 1 || script.getInt(8) > 9) return false;
	          if (versionHex == '01') {
	            // Mint Baton
	            if (!script.getData(9)) return false;
	            if (script.getData(9).length > 1) return false;
	            if (script.getData(9).length == 1 && script.getInt(9) < 2) return false;
	          } else if (versionHex == '02') {
	            // Mint Vault ScriptHash
	            if (!script.getData(9)) return false;
	            if (script.getData(9).length != 20) return false;
	          }
	          // Minted Tokens
	          if (script.getData(10).length != 8) return false;
	          break;
	        }
	      case 'MINT':
	        {
	          if (versionHex == '01') {
	            if (script.code.length != 7) return false;
	          }
	          if (versionHex == '02') {
	            if (script.code.length < 6) return false;
	          }
	          // Token ID
	          if (script.getData(4).length != 32) return false;
	          if (versionHex == '01') {
	            // Mint Baton
	            if (!script.getData(5)) return false;
	            if (script.getData(5).length > 1) return false;
	            if (script.getData(5).length == 1 && script.getInt(5) < 2) return false;
	            // Minted Tokens
	            if (script.getData(6).length != 8) return false;
	          } else if (versionHex == '02') {
	            const outputs = script.code.slice(5);
	            for (let i = 0; i < outputs.length; i++) {
	              const op = outputs[i];
	              // Sent Tokens
	              if (op.data.length != 8) return false;
	            }
	          }
	          break;
	        }
	      case 'SEND':
	        {
	          if (script.code.length < 6) return false;
	          // Token ID
	          if (script.getData(4).length != 32) return false;
	          const outputs = script.code.slice(5);
	          for (let i = 0; i < outputs.length; i++) {
	            const op = outputs[i];
	            // Sent Tokens
	            if (op.data.length != 8) return false;
	          }
	          break;
	        }
	      case 'BURN':
	        {
	          if (script.code.length != 6) return false;
	          // Token ID
	          if (script.getData(4).length != 32) return false;
	          // Sent Tokens
	          if (script.getData(5).length != 8) return false;
	          break;
	        }
	      default:
	        {
	          return false;
	        }
	    }
	    return true;
	  }

	  /**
	   * Test whether script is of valid construction
	   * (Does not test if transaction is valid SLP transaction)
	   * @param {Script?} script
	   * @returns {Boolean}
	   */

	  static verifySlp(script) {
	    return new this().verifySlp(script);
	  }

	  /**
	   * Inject properties from a script
	   * @private
	   * @param {Script} code
	   * @returns {SLP}
	   */

	  fromScript(script) {
	    this.inject(script);
	    return this;
	  }

	  /**
	   * Inject properties from a script
	   * @param {Script} code
	   * @returns {SLP}
	   */

	  static fromScript(script) {
	    return new this().fromScript(script);
	  }

	  /**
	   * Get token ID for this script
	   * @private
	   * @returns {Hash}
	   */

	  getTokenId() {
	    assert(this.verifySlp(), 'This is not a valid SLP script');

	    // Type
	    const type = this.getType();
	    assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script');

	    // Return tokenId as buffer
	    return this.getData(4);
	  }

	  /**
	   * Get records for a this script
	   * @private
	   * @param {Buffer?} txId The txid of the transaction containing this script
	   * @returns {(SlpCoinRecord | TokenRecord)[]}
	   */

	  getRecords(txId) {
	    assert(this.isValidSlp(), 'Must be a valid SLP Script');
	    const type = this.getType();
	    assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');
	    assert(txId.byteLength, 'tokenId must be a buffer');
	    assert(txId.length == 32, 'tokenId must be a sha256 hash');
	    switch (type) {
	      case 'GENESIS':
	        {
	          return this.getGenesisRecords(txId);
	        }
	      case 'MINT':
	        {
	          return this.getMintRecords(txId);
	        }
	      case 'SEND':
	        {
	          return this.getSendRecords(txId);
	        }
	      case 'BURN':
	        {
	          return this.getBurnRecords(txId);
	        }
	      default:
	        {
	          return null;
	        }
	    }
	  }

	  /**
	   * Get records for a GENESIS script
	   * @private
	   * @param {Buffer} tokenId The tokenId of the transaction containing this script
	   * @returns {(SlpCoinRecord | TokenRecord)[]}
	   */

	  getGenesisRecords(tokenId) {
	    assert(tokenId.byteLength, 'tokenId must be a buffer');
	    assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'GENESIS', 'This is not a GENESIS transaction');
	    const versionInt = this.getInt(2);
	    const records = [];
	    // Create TokenRecord
	    records.push(this.constructor.TokenRecord({
	      tokenId,
	      version: versionInt,
	      ticker: this.getString(4, 'utf-8'),
	      name: this.getString(5, 'utf-8'),
	      uri: this.getString(6, 'utf-8'),
	      hash: this.getString(7, 'hex'),
	      decimals: this.getInt(8),
	      vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined
	    }));
	    // Create Minted Tokens SLPCoinRecord
	    records.push(this.constructor.SlpCoinRecord({
	      hash: Buffer.from(tokenId).reverse(),
	      vout: 1,
	      tokenId,
	      value: this.getData(10),
	      type,
	      version: this.getInt(2)
	    }));
	    // Create Mint Baton SLPCoinRecord
	    if (versionInt === 1 && this.getInt(9) >= 2) {
	      const valBuf = Buffer.alloc(1);
	      valBuf.writeInt8(1);
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(tokenId).reverse(),
	        vout: this.getInt(9),
	        tokenId,
	        value: valBuf,
	        type: 'BATON',
	        version: this.getInt(2)
	      }));
	    }
	    return records;
	  }

	  /**
	   * Get records for a MINT script
	   * @private
	   * @param {Buffer} txId The txHash of the transaction containing this script
	   * @returns {SlpCoinRecord[]}
	   */

	  getMintRecords(txId) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'MINT', 'This is not a MINT transaction');
	    const versionInt = this.getInt(2);
	    const records = [];
	    // Create Minted Tokens SLPCoinRecord
	    if (versionInt === 1) {
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(txId).reverse(),
	        vout: 1,
	        tokenId: this.getData(4),
	        value: this.getData(6),
	        type,
	        version: versionInt
	      }));
	      // Create Mint Baton SLPCoinRecord
	      if (this.getInt(5) >= 2) {
	        const valBuf = U64.fromInt(1).toBE(Buffer);
	        records.push(this.constructor.SlpCoinRecord({
	          hash: Buffer.from(txId).reverse(),
	          vout: this.getInt(5),
	          tokenId: this.getData(4),
	          value: valBuf,
	          type: 'BATON',
	          version: versionInt
	        }));
	      }
	    } else if (versionInt === 2) {
	      // Mimic Token Type 1 SEND
	      const outputs = this.code.slice(5);
	      for (let i = 0; i < outputs.length; i++) {
	        const valueBuf = outputs[i].toData();
	        const vout = i + 1;

	        // Create Token Type 2 Mint Tokens SLPCoinRecord
	        records.push(this.constructor.SlpCoinRecord({
	          hash: Buffer.from(txId).reverse(),
	          vout,
	          tokenId: this.getData(4),
	          value: valueBuf,
	          type,
	          version: this.getInt(2)
	        }));
	      }
	    }
	    return records;
	  }

	  /**
	   * Get records for a SEND script
	   * @private
	   * @param {Buffer} txId The txHash of the transaction containing this script
	   * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
	   * @returns {SlpCoinRecord[]}
	   */

	  getSendRecords(txId, nonStandardOuts = false) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'SEND', 'This is not a SEND transaction');
	    const records = [];
	    const outputs = this.code.slice(5);
	    for (let i = 0; i < outputs.length; i++) {
	      const valueBuf = outputs[i].toData();
	      const vout = nonStandardOuts ? i : i + 1;

	      // Create Send Tokens SLPCoinRecord
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(txId).reverse(),
	        vout,
	        tokenId: this.getData(4),
	        value: valueBuf,
	        type,
	        version: this.getInt(2)
	      }));
	    }
	    return records;
	  }
	  getBurnRecords(txId, nonStandardOuts = false) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'BURN', 'This is not a BURN transaction');
	    const records = [];
	    const valueBuf = this.code[5].toData();

	    // Create Send Tokens SLPCoinRecord
	    records.push(this.constructor.SlpCoinRecord({
	      hash: Buffer.from(txId).reverse(),
	      vout: 0,
	      tokenId: this.getData(4),
	      value: valueBuf,
	      type,
	      version: this.getInt(2)
	    }));
	    return records;
	  }

	  /**
	   * Re-encode the script internally. Useful if you
	   * changed something manually in the `code` array.
	   * @returns {Script}
	   */

	  compile() {
	    super.compile();
	    this.valid = null;
	    this.isValidSlp();
	  }

	  /**
	   * Inspect the script.
	   * @returns {String} Human-readable script code.
	   */

	  inspect() {
	    return `<SLP: ${this.toString()}>`;
	  }
	  getType() {
	    return this.getString(3);
	  }

	  /**
	   * Create a new TokenRecord
	   * @param {Buffer?} tokenId
	   * @param {Buffer?} tokenIndex
	   * @param {String?} ticker
	   * @param {String?} name
	   * @param {String?} uri
	   * @param {String?} hash
	   * @param {Number} decimals
	   * @param {Number?} version
	   * @returns {TokenRecord}
	   */

	  static TokenRecord(options = {}) {
	    return new TokenRecord(options);
	  }

	  /**
	   * Create a new SlpCoinRecord
	   * @param {Buffer?} hash the output hash of the coin
	   * @param {Number?} vout the output index of the coin
	   * @param {Buffer?} tokenId 32 byte txid
	   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
	   * @param {Number} value
	   * @param {String} type GENESIS | MINT | SEND | BATON
	   * @param {Number?} version
	   * @returns {SlpCoinRecord}
	   */

	  static SlpCoinRecord(options = {}) {
	    return new SlpCoinRecord(options);
	  }
	}
	slp = SLP;
	return slp;
}

/*!
 * output.js - output object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var output;
var hasRequiredOutput;

function requireOutput () {
	if (hasRequiredOutput) return output;
	hasRequiredOutput = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const Amount = requireAmount();
	const Network = requireNetwork();
	const Address = requireAddress();
	const Script = requireScript$1();
	const SLP = requireSlp();
	const policy = requirePolicy();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Represents a transaction output.
	 * @alias module:primitives.Output
	 * @property {Amount} value
	 * @property {Script} script
	 * @property {SlpCoinRecord?} slp
	 */

	class Output {
	  /**
	   * Create an output.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.value = 0;
	    this.script = new Script();
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Output data is required.');
	    if (options.value) {
	      assert(Number.isSafeInteger(options.value) && options.value >= 0, 'Value must be a uint64.');
	      this.value = options.value;
	    }
	    if (options.script) this.script.fromOptions(options.script);
	    if (options.address) this.script.fromAddress(options.address);
	    if (options.slp) {
	      if (options.slp.constructor === SLP.SlpCoinRecord().constructor) this.slp = options.slp;
	    }
	    return this;
	  }

	  /**
	   * Instantiate output from options object.
	   * @param {Object} options
	   * @returns {Output}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Inject properties from script/value pair.
	   * @private
	   * @param {Script|Address} script
	   * @param {Amount} value
	   * @returns {Output}
	   */

	  fromScript(script, value) {
	    if (typeof script === 'string') script = Address.fromString(script);
	    if (script instanceof Address) script = Script.fromAddress(script);
	    assert(script instanceof Script, 'Script must be a Script.');
	    assert(Number.isSafeInteger(value) && value >= 0, 'Value must be a uint64.');
	    this.script = script;
	    this.value = value;
	    return this;
	  }

	  /**
	   * Instantiate output from script/value pair.
	   * @param {Script|Address} script
	   * @param {Amount} value
	   * @returns {Output}
	   */

	  static fromScript(script, value) {
	    return new this().fromScript(script, value);
	  }

	  /**
	   * Clone the output.
	   * @returns {Output}
	   */

	  clone() {
	    const output = new this.constructor();
	    output.value = this.value;
	    output.script.inject(this.script);
	    return output;
	  }

	  /**
	   * Test equality against another output.
	   * @param {Output} output
	   * @returns {Boolean}
	   */

	  equals(output) {
	    assert(Output.isOutput(output));
	    return this.value === output.value && this.script.equals(output.script);
	  }

	  /**
	   * Compare against another output (BIP69).
	   * @param {Output} output
	   * @returns {Number}
	   */

	  compare(output) {
	    assert(Output.isOutput(output));
	    const cmp = this.value - output.value;
	    if (cmp !== 0) return cmp;
	    return this.script.compare(output.script);
	  }

	  /**
	   * Get the script type as a string.
	   * @returns {ScriptType} type
	   */

	  getType() {
	    return Script.typesByVal[this.script.getType()].toLowerCase();
	  }

	  /**
	   * Get the address.
	   * @returns {Address} address
	   */

	  getAddress() {
	    return this.script.getAddress();
	  }

	  /**
	   * Get the address hash.
	   * @param {String?} enc
	   * @returns {Hash} hash
	   */

	  getHash(enc) {
	    const addr = this.getAddress();
	    if (!addr) return null;
	    return addr.getHash(enc);
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    const hr = {
	      type: this.getType(),
	      value: Amount.btc(this.value),
	      script: this.script,
	      address: this.getAddress()
	    };
	    if (this.slp) {
	      return {
	        ...hr,
	        slp: this.slp
	      };
	    }
	    return hr;
	  }

	  /**
	   * Convert the output to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the output to an object suitable
	   * for JSON serialization.
	   * @param {Network} network
	   * @returns {Object}
	   */

	  getJSON(network) {
	    let addr = this.getAddress();
	    network = Network.get(network);
	    if (addr) addr = addr.toString(network);
	    const json = {
	      value: this.value,
	      script: this.script.toJSON(),
	      address: addr
	    };
	    if (this.slp) {
	      return {
	        ...json,
	        slp: this.slp.getJSON()
	      };
	    }
	    return json;
	  }

	  /**
	   * Calculate the dust threshold for this
	   * output, based on serialize size and rate.
	   * @param {Rate?} rate
	   * @returns {Amount}
	   */

	  getDustThreshold(rate) {
	    if (this.script.isUnspendable()) return 0;
	    let size = this.getSize();
	    size += 32 + 4 + 1 + 107 + 4;
	    return 3 * policy.getMinFee(size, rate);
	  }

	  /**
	   * Calculate size of serialized output.
	   * @returns {Number}
	   */

	  getSize() {
	    return 8 + this.script.getVarSize();
	  }

	  /**
	   * Test whether the output should be considered dust.
	   * @param {Rate?} rate
	   * @returns {Boolean}
	   */

	  isDust(rate) {
	    return this.value < this.getDustThreshold(rate);
	  }

	  /**
	   * Inject properties from a JSON object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Output data is required.');
	    assert(Number.isSafeInteger(json.value) && json.value >= 0, 'Value must be a uint64.');
	    this.value = json.value;
	    this.script.fromJSON(json.script);
	    if (json.slp) {
	      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);
	    }
	    return this;
	  }

	  /**
	   * Instantiate an Output from a jsonified output object.
	   * @param {Object} json - The jsonified output object.
	   * @returns {Output}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Write the output to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeI64(this.value);
	    bw.writeVarBytes(this.script.toRaw());
	    return bw;
	  }

	  /**
	   * Serialize the output.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.value = br.readI64();
	    this.script.fromRaw(br.readVarBytes());
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate an output from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Output}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate an output from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Output}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test an object to see if it is an Output.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOutput(obj) {
	    return obj instanceof Output;
	  }
	}

	/*
	 * Expose
	 */

	output = Output;
	return output;
}

/*!
 * outpoint.js - outpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var outpoint;
var hasRequiredOutpoint;

function requireOutpoint () {
	if (hasRequiredOutpoint) return outpoint;
	hasRequiredOutpoint = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const util = requireUtil();
	const consensus = requireConsensus();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Outpoint
	 * Represents a COutPoint.
	 * @alias module:primitives.Outpoint
	 * @property {Hash} hash
	 * @property {Number} index
	 */

	class Outpoint {
	  /**
	   * Create an outpoint.
	   * @constructor
	   * @param {Hash?} hash
	   * @param {Number?} index
	   */

	  constructor(hash, index) {
	    this.hash = consensus.ZERO_HASH;
	    this.index = 0xffffffff;
	    if (hash != null) {
	      assert(Buffer.isBuffer(hash));
	      assert(index >>> 0 === index, 'Index must be a uint32.');
	      this.hash = hash;
	      this.index = index;
	    }
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Outpoint data is required.');
	    assert(Buffer.isBuffer(options.hash));
	    assert(options.index >>> 0 === options.index, 'Index must be a uint32.');
	    this.hash = options.hash;
	    this.index = options.index;
	    return this;
	  }

	  /**
	   * Instantate outpoint from options object.
	   * @param {Object} options
	   * @returns {Outpoint}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the outpoint.
	   * @returns {Outpoint}
	   */

	  clone() {
	    const outpoint = new this.constructor();
	    outpoint.hash = this.hash;
	    outpoint.index = this.index;
	    return outpoint;
	  }

	  /**
	   * Test equality against another outpoint.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  equals(prevout) {
	    assert(Outpoint.isOutpoint(prevout));
	    return this.hash.equals(prevout.hash) && this.index === prevout.index;
	  }

	  /**
	   * Compare against another outpoint (BIP69).
	   * @param {Outpoint} prevout
	   * @returns {Number}
	   */

	  compare(prevout) {
	    assert(Outpoint.isOutpoint(prevout));
	    const cmp = strcmp(this.txid(), prevout.txid());
	    if (cmp !== 0) return cmp;
	    return this.index - prevout.index;
	  }

	  /**
	   * Test whether the outpoint is null (hash of zeroes
	   * with max-u32 index). Used to detect coinbases.
	   * @returns {Boolean}
	   */

	  isNull() {
	    return this.index === 0xffffffff && this.hash.equals(consensus.ZERO_HASH);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Serialize outpoint to a key
	   * suitable for a hash table.
	   * @returns {String}
	   */

	  toKey() {
	    return this.toRaw();
	  }

	  /**
	   * Inject properties from hash table key.
	   * @private
	   * @param {String} key
	   * @returns {Outpoint}
	   */

	  fromKey(key) {
	    this.hash = key.slice(0, 32);
	    this.index = bio.readU32(key, 32);
	    return this;
	  }

	  /**
	   * Instantiate outpoint from hash table key.
	   * @param {String} key
	   * @returns {Outpoint}
	   */

	  static fromKey(key) {
	    return new this().fromKey(key);
	  }

	  /**
	   * Write outpoint to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeHash(this.hash);
	    bw.writeU32(this.index);
	    return bw;
	  }

	  /**
	   * Calculate size of outpoint.
	   * @returns {Number}
	   */

	  getSize() {
	    return 36;
	  }

	  /**
	   * Serialize outpoint.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.toWriter(bio.write(36)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.hash = br.readHash();
	    this.index = br.readU32();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate outpoint from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Outpoint}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate outpoint from serialized data.
	   * @param {Buffer} data
	   * @returns {Outpoint}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @params {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Outpoint data is required.');
	    assert(typeof json.hash === 'string', 'Hash must be a string.');
	    assert(json.index >>> 0 === json.index, 'Index must be a uint32.');
	    this.hash = util.fromRev(json.hash);
	    this.index = json.index;
	    return this;
	  }

	  /**
	   * Convert the outpoint to an object suitable
	   * for JSON serialization. Note that the hash
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @returns {Object}
	   */

	  toJSON() {
	    return {
	      hash: util.revHex(this.hash),
	      index: this.index
	    };
	  }

	  /**
	   * Instantiate outpoint from json object.
	   * @param {Object} json
	   * @returns {Outpoint}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inject properties from tx.
	   * @private
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index) {
	    assert(tx);
	    assert(typeof index === 'number');
	    assert(index >= 0);
	    this.hash = tx.hash();
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate outpoint from tx.
	   * @param {TX} tx
	   * @param {Number} index
	   * @returns {Outpoint}
	   */

	  static fromTX(tx, index) {
	    return new this().fromTX(tx, index);
	  }

	  /**
	   * Serialize outpoint to a key
	   * suitable for a hash table.
	   * @param {Hash} hash
	   * @param {Number} index
	   * @returns {String}
	   */

	  static toKey(hash, index) {
	    return new Outpoint(hash, index).toKey();
	  }

	  /**
	   * Convert the outpoint to a user-friendly string.
	   * @returns {String}
	   */

	  [inspectSymbol]() {
	    return `<Outpoint: ${this.rhash()}/${this.index}>`;
	  }

	  /**
	   * Test an object to see if it is an outpoint.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOutpoint(obj) {
	    return obj instanceof Outpoint;
	  }
	}

	/*
	 * Helpers
	 */

	function strcmp(a, b) {
	  const len = Math.min(a.length, b.length);
	  for (let i = 0; i < len; i++) {
	    if (a[i] < b[i]) return -1;
	    if (a[i] > b[i]) return 1;
	  }
	  if (a.length < b.length) return -1;
	  if (a.length > b.length) return 1;
	  return 0;
	}

	/*
	 * Expose
	 */

	outpoint = Outpoint;
	return outpoint;
}

/*!
 * coin.js - coin object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coin;
var hasRequiredCoin;

function requireCoin () {
	if (hasRequiredCoin) return coin;
	hasRequiredCoin = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const util = requireUtil();
	const Amount = requireAmount();
	const Output = requireOutput();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const Outpoint = requireOutpoint();
	const SLP = requireSlp();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Coin
	 * Represents an unspent output.
	 * @alias module:primitives.Coin
	 * @extends Output
	 * @property {Number} version
	 * @property {Number} height
	 * @property {Amount} value
	 * @property {Script} script
	 * @property {Boolean} coinbase
	 * @property {Hash} hash
	 * @property {Number} index
	 */

	class Coin extends Output {
	  /**
	   * Create a coin.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();
	    this.version = 1;
	    this.height = -1;
	    this.coinbase = false;
	    this.hash = consensus.ZERO_HASH;
	    this.index = 0;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject options into coin.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Coin data is required.');
	    if (options.version != null) {
	      assert(options.version >>> 0 === options.version, 'Version must be a uint32.');
	      this.version = options.version;
	    }
	    if (options.height != null) {
	      if (options.height !== -1) {
	        assert(options.height >>> 0 === options.height, 'Height must be a uint32.');
	        this.height = options.height;
	      } else {
	        this.height = -1;
	      }
	    }
	    if (options.value != null) {
	      assert(Number.isSafeInteger(options.value) && options.value >= 0, 'Value must be a uint64.');
	      this.value = options.value;
	    }
	    if (options.script) this.script.fromOptions(options.script);
	    if (options.coinbase != null) {
	      assert(typeof options.coinbase === 'boolean', 'Coinbase must be a boolean.');
	      this.coinbase = options.coinbase;
	    }
	    if (options.hash != null) {
	      assert(Buffer.isBuffer(options.hash));
	      this.hash = options.hash;
	    }
	    if (options.index != null) {
	      assert(options.index >>> 0 === options.index, 'Index must be a uint32.');
	      this.index = options.index;
	    }
	    return this;
	  }

	  /**
	   * Instantiate Coin from options object.
	   * @private
	   * @param {Object} options
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the coin.
	   * @private
	   * @returns {Coin}
	   */

	  clone() {
	    assert(false, 'Coins are not cloneable.');
	  }

	  /**
	   * Calculate number of confirmations since coin was created.
	   * @param {Number?} height - Current chain height. Network
	   * height is used if not passed in.
	   * @return {Number}
	   */

	  getDepth(height) {
	    assert(typeof height === 'number', 'Must pass a height.');
	    if (this.height === -1) return 0;
	    if (height === -1) return 0;
	    if (height < this.height) return 0;
	    return height - this.height + 1;
	  }

	  /**
	   * Serialize coin to a key
	   * suitable for a hash table.
	   * @returns {String}
	   */

	  toKey() {
	    return Outpoint.toKey(this.hash, this.index);
	  }

	  /**
	   * Inject properties from hash table key.
	   * @private
	   * @param {String} key
	   * @returns {Coin}
	   */

	  fromKey(key) {
	    const {
	      hash,
	      index
	    } = Outpoint.fromKey(key);
	    this.hash = hash;
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate coin from hash table key.
	   * @param {String} key
	   * @returns {Coin}
	   */

	  static fromKey(key) {
	    return new this().fromKey(key);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Convert the coin to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    const hr = {
	      type: this.getType(),
	      version: this.version,
	      height: this.height,
	      value: Amount.btc(this.value),
	      script: this.script,
	      coinbase: this.coinbase,
	      hash: this.hash ? util.revHex(this.hash) : null,
	      index: this.index,
	      address: this.getAddress()
	    };
	    if (this.slp) {
	      return {
	        ...hr,
	        slp: this.slp
	      };
	    }
	    return hr;
	  }

	  /**
	   * Convert the coin to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the coin to an object suitable
	   * for JSON serialization. Note that the hash
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {Boolean} minimal
	   * @returns {Object}
	   */

	  getJSON(network, minimal) {
	    let addr = this.getAddress();
	    network = Network.get(network);
	    if (addr) addr = addr.toString(network);
	    const json = {
	      version: this.version,
	      height: this.height,
	      value: this.value,
	      script: this.script.toJSON(),
	      address: addr,
	      coinbase: this.coinbase,
	      hash: !minimal ? this.rhash() : undefined,
	      index: !minimal ? this.index : undefined
	    };
	    if (this.slp) {
	      return {
	        ...json,
	        slp: this.slp.getJSON()
	      };
	    }
	    return json;
	  }

	  /**
	   * Inject JSON properties into coin.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Coin data required.');
	    assert(json.version >>> 0 === json.version, 'Version must be a uint32.');
	    assert(json.height === -1 || json.height >>> 0 === json.height, 'Height must be a uint32.');
	    assert(Number.isSafeInteger(json.value) && json.value >= 0, 'Value must be a uint64.');
	    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');
	    this.version = json.version;
	    this.height = json.height;
	    this.value = json.value;
	    this.script.fromJSON(json.script);
	    this.coinbase = json.coinbase;
	    if (json.hash != null) {
	      assert(typeof json.hash === 'string', 'Hash must be a string.');
	      assert(json.hash.length === 64, 'Hash must be a string.');
	      assert(json.index >>> 0 === json.index, 'Index must be a uint32.');
	      this.hash = util.fromRev(json.hash);
	      this.index = json.index;
	    }
	    if (json.slp) {
	      json.slp.hash = json.hash;
	      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);
	    }
	    return this;
	  }

	  /**
	   * Instantiate an Coin from a jsonified coin object.
	   * @param {Object} json - The jsonified coin object.
	   * @returns {Coin}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate size of coin.
	   * @returns {Number}
	   */

	  getSize() {
	    return 17 + this.script.getVarSize();
	  }

	  /**
	   * Write the coin to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    let height = this.height;
	    if (height === -1) height = 0x7fffffff;
	    bw.writeU32(this.version);
	    bw.writeU32(height);
	    bw.writeI64(this.value);
	    bw.writeVarBytes(this.script.toRaw());
	    bw.writeU8(this.coinbase ? 1 : 0);
	    return bw;
	  }

	  /**
	   * Serialize the coin.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from serialized buffer writer.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.version = br.readU32();
	    this.height = br.readU32();
	    this.value = br.readI64();
	    this.script.fromRaw(br.readVarBytes());
	    this.coinbase = br.readU8() === 1;
	    if (this.height === 0x7fffffff) this.height = -1;
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a coin from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Coin}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Coin}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index, height) {
	    assert(typeof index === 'number');
	    assert(typeof height === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.version = tx.version;
	    this.height = height;
	    this.value = tx.outputs[index].value;
	    this.script = tx.outputs[index].script;
	    this.coinbase = tx.isCoinbase();
	    this.hash = tx.hash();
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {Coin}
	   */

	  static fromTX(tx, index, height) {
	    return new this().fromTX(tx, index, height);
	  }

	  /**
	   * Test an object to see if it is a Coin.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isCoin(obj) {
	    return obj instanceof Coin;
	  }
	}

	/*
	 * Expose
	 */

	coin = Coin;
	return coin;
}

var compress = {};

/*!
 * compress.js - coin compressor for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCompress;

function requireCompress () {
	if (hasRequiredCompress) return compress;
	hasRequiredCompress = 1;

	/**
	 * @module coins/compress
	 * @ignore
	 */
	const assert = requireAssert$1();
	const {
	  encoding
	} = requireBufio();
	const secp256k1 = requireSecp256k1();
	const consensus = requireConsensus();

	/*
	 * Constants
	 */

	const COMPRESS_TYPES = 6;
	const EMPTY_BUFFER = Buffer.alloc(0);

	/**
	 * Compress a script, write directly to the buffer.
	 * @param {Script} script
	 * @param {BufferWriter} bw
	 */

	function compressScript(script, bw) {
	  // Attempt to compress the output scripts.
	  // We can _only_ ever compress them if
	  // they are serialized as minimaldata, as
	  // we need to recreate them when we read
	  // them.

	  // P2PKH -> 0 | key-hash
	  // Saves 5 bytes.
	  const pkh = script.getPubkeyhash(true);
	  if (pkh) {
	    bw.writeU8(0);
	    bw.writeBytes(pkh);
	    return bw;
	  }

	  // P2SH -> 1 | script-hash
	  // Saves 3 bytes.
	  const sh = script.getScripthash();
	  if (sh) {
	    bw.writeU8(1);
	    bw.writeBytes(sh);
	    return bw;
	  }

	  // P2PK -> 2-5 | compressed-key
	  // Only works if the key is valid.
	  // Saves up to 35 bytes.
	  const pk = script.getPubkey(true);
	  if (pk) {
	    if (publicKeyVerify(pk)) {
	      const key = compressKey(pk);
	      bw.writeBytes(key);
	      return bw;
	    }
	  }

	  // Raw -> varlen + 10 | script
	  bw.writeVarint(script.raw.length + COMPRESS_TYPES);
	  bw.writeBytes(script.raw);
	  return bw;
	}

	/**
	 * Decompress a script from buffer reader.
	 * @param {Script} script
	 * @param {BufferReader} br
	 */

	function decompressScript(script, br) {
	  // Decompress the script.
	  switch (br.readU8()) {
	    case 0:
	      {
	        const hash = br.readBytes(20, true);
	        script.fromPubkeyhash(hash);
	        break;
	      }
	    case 1:
	      {
	        const hash = br.readBytes(20, true);
	        script.fromScripthash(hash);
	        break;
	      }
	    case 2:
	    case 3:
	    case 4:
	    case 5:
	      {
	        br.offset -= 1;
	        const data = br.readBytes(33, true);
	        // Decompress the key. If this fails,
	        // we have database corruption!
	        const key = decompressKey(data);
	        script.fromPubkey(key);
	        break;
	      }
	    default:
	      {
	        br.offset -= 1;
	        const size = br.readVarint() - COMPRESS_TYPES;
	        if (size > consensus.MAX_SCRIPT_SIZE) {
	          // This violates consensus rules.
	          // We don't need to read it.
	          script.fromNulldata(EMPTY_BUFFER);
	          br.seek(size);
	        } else {
	          const data = br.readBytes(size);
	          script.fromRaw(data);
	        }
	        break;
	      }
	  }
	  return script;
	}

	/**
	 * Calculate script size.
	 * @returns {Number}
	 */

	function sizeScript(script) {
	  if (script.isPubkeyhash(true)) return 21;
	  if (script.isScripthash()) return 21;
	  const pk = script.getPubkey(true);
	  if (pk) {
	    if (publicKeyVerify(pk)) return 33;
	  }
	  let size = 0;
	  size += encoding.sizeVarint(script.raw.length + COMPRESS_TYPES);
	  size += script.raw.length;
	  return size;
	}

	/**
	 * Compress an output.
	 * @param {Output} output
	 * @param {BufferWriter} bw
	 */

	function compressOutput(output, bw) {
	  bw.writeVarint(output.value);
	  compressScript(output.script, bw);
	  return bw;
	}

	/**
	 * Decompress a script from buffer reader.
	 * @param {Output} output
	 * @param {BufferReader} br
	 */

	function decompressOutput(output, br) {
	  output.value = br.readVarint();
	  decompressScript(output.script, br);
	  return output;
	}

	/**
	 * Calculate output size.
	 * @returns {Number}
	 */

	function sizeOutput(output) {
	  let size = 0;
	  size += encoding.sizeVarint(output.value);
	  size += sizeScript(output.script);
	  return size;
	}

	/**
	 * Verify a public key (no hybrid keys allowed).
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function publicKeyVerify(key) {
	  if (key.length === 0) return false;
	  switch (key[0]) {
	    case 0x02:
	    case 0x03:
	      return key.length === 33;
	    case 0x04:
	      if (key.length !== 65) return false;
	      return secp256k1.publicKeyVerify(key);
	    default:
	      return false;
	  }
	}

	/**
	 * Compress a public key to coins compression format.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function compressKey(key) {
	  let out;
	  switch (key[0]) {
	    case 0x02:
	    case 0x03:
	      // Key is already compressed.
	      out = key;
	      break;
	    case 0x04:
	      // Compress the key normally.
	      out = secp256k1.publicKeyConvert(key, true);
	      // Store the oddness.
	      // Pseudo-hybrid format.
	      out[0] = 0x04 | key[64] & 0x01;
	      break;
	    default:
	      throw new Error('Bad point format.');
	  }
	  assert(out.length === 33);
	  return out;
	}

	/**
	 * Decompress a public key from the coins compression format.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function decompressKey(key) {
	  const format = key[0];
	  assert(key.length === 33);
	  switch (format) {
	    case 0x02:
	    case 0x03:
	      return key;
	    case 0x04:
	      key[0] = 0x02;
	      break;
	    case 0x05:
	      key[0] = 0x03;
	      break;
	    default:
	      throw new Error('Bad point format.');
	  }

	  // Decompress the key.
	  const out = secp256k1.publicKeyConvert(key, false);

	  // Reset the first byte so as not to
	  // mutate the original buffer.
	  key[0] = format;
	  return out;
	}

	/*
	 * Expose
	 */

	compress.pack = compressOutput;
	compress.unpack = decompressOutput;
	compress.size = sizeOutput;
	return compress;
}

/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coinentry;
var hasRequiredCoinentry;

function requireCoinentry () {
	if (hasRequiredCoinentry) return coinentry;
	hasRequiredCoinentry = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const Coin = requireCoin();
	const Output = requireOutput();
	const compress = requireCompress();
	const {
	  encoding
	} = bio;

	/*
	 * Constants
	 */

	const NUM_FLAGS = 1;
	const MAX_HEIGHT = (1 << 32 - NUM_FLAGS >>> 0) - 1;

	/**
	 * Coin Entry
	 * Represents an unspent output.
	 * @alias module:coins.CoinEntry
	 * @property {Number} version - Transaction version.
	 * @property {Number} height - Transaction height (-1 if unconfirmed).
	 * @property {Boolean} coinbase - Whether the containing
	 * transaction is a coinbase.
	 * @property {Output} output
	 * @property {Boolean} spent
	 * @property {Buffer} raw
	 */

	class CoinEntry {
	  /**
	   * Create a coin entry.
	   * @constructor
	   */

	  constructor() {
	    this.version = 1;
	    this.height = -1;
	    this.coinbase = false;
	    this.output = new Output();
	    this.spent = false;
	    this.raw = null;
	  }

	  /**
	   * Convert coin entry to an output.
	   * @returns {Output}
	   */

	  toOutput() {
	    return this.output;
	  }

	  /**
	   * Convert coin entry to a coin.
	   * @param {Outpoint} prevout
	   * @returns {Coin}
	   */

	  toCoin(prevout) {
	    const coin = new Coin();
	    coin.version = this.version;
	    coin.height = this.height;
	    coin.coinbase = this.coinbase;
	    coin.script = this.output.script;
	    coin.value = this.output.value;
	    coin.hash = prevout.hash;
	    coin.index = prevout.index;
	    return coin;
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromOutput(output) {
	    this.output = output;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromOutput(output) {
	    return new this().fromOutput(output);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromCoin(coin) {
	    this.version = coin.version;
	    this.height = coin.height;
	    this.coinbase = coin.coinbase;
	    this.output.script = coin.script;
	    this.output.value = coin.value;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromCoin(coin) {
	    return new this().fromCoin(coin);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index, height) {
	    assert(typeof index === 'number');
	    assert(typeof height === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.version = tx.version;
	    this.height = height;
	    this.coinbase = tx.isCoinbase();
	    this.output = tx.outputs[index];
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromTX(tx, index, height) {
	    return new this().fromTX(tx, index, height);
	  }

	  /**
	   * Calculate size of coin.
	   * @returns {Number}
	   */

	  getSize() {
	    if (this.raw) return this.raw.length;
	    let size = 0;
	    size += encoding.sizeVarint(this.version);
	    size += 4;
	    size += compress.size(this.output);
	    return size;
	  }

	  /**
	   * Write the coin to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.raw) {
	      bw.writeBytes(this.raw);
	      return bw;
	    }
	    let height = this.height;
	    let field = 0;
	    if (this.coinbase) field |= 1;
	    if (height === -1) height = MAX_HEIGHT;
	    field |= height << NUM_FLAGS;
	    bw.writeVarint(this.version);
	    bw.writeU32(field);
	    compress.pack(this.output, bw);
	    return bw;
	  }

	  /**
	   * Serialize the coin.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    if (this.raw) return this.raw;
	    const size = this.getSize();
	    const bw = bio.write(size);
	    this.toWriter(bw);
	    this.raw = bw.render();
	    return this.raw;
	  }

	  /**
	   * Inject properties from serialized buffer writer.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    const version = br.readVarint();
	    const field = br.readU32();
	    let height = field >>> NUM_FLAGS;
	    if (height === MAX_HEIGHT) height = -1;
	    this.version = version;
	    this.coinbase = (field & 1) !== 0;
	    this.height = height;
	    compress.unpack(this.output, br);
	    return this;
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @returns {CoinEntry}
	   */

	  static fromReader(data) {
	    return new this().fromReader(data);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    this.fromReader(bio.read(data));
	    this.raw = data;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @returns {CoinEntry}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }
	}

	/*
	 * Expose
	 */

	coinentry = CoinEntry;
	return coinentry;
}

/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coins;
var hasRequiredCoins$1;

function requireCoins$1 () {
	if (hasRequiredCoins$1) return coins;
	hasRequiredCoins$1 = 1;

	const assert = requireAssert$1();
	const CoinEntry = requireCoinentry();

	/**
	 * Coins
	 * Represents the outputs for a single transaction.
	 * @alias module:coins.Coins
	 * @property {Map[]} outputs - Coins.
	 */

	class Coins {
	  /**
	   * Create coins.
	   * @constructor
	   */

	  constructor() {
	    this.outputs = new Map();
	  }

	  /**
	   * Add a single entry to the collection.
	   * @param {Number} index
	   * @param {CoinEntry} coin
	   * @returns {CoinEntry}
	   */

	  add(index, coin) {
	    assert(index >>> 0 === index);
	    assert(coin);
	    this.outputs.set(index, coin);
	    return coin;
	  }

	  /**
	   * Add a single output to the collection.
	   * @param {Number} index
	   * @param {Output} output
	   * @returns {CoinEntry}
	   */

	  addOutput(index, output) {
	    return this.add(index, CoinEntry.fromOutput(output));
	  }

	  /**
	   * Add an output to the collection by output index.
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Number} height
	   * @returns {CoinEntry}
	   */

	  addIndex(tx, index, height) {
	    return this.add(index, CoinEntry.fromTX(tx, index, height));
	  }

	  /**
	   * Add a single coin to the collection.
	   * @param {Coin} coin
	   * @returns {CoinEntry}
	   */

	  addCoin(coin) {
	    return this.add(coin.index, CoinEntry.fromCoin(coin));
	  }

	  /**
	   * Test whether the collection has a coin.
	   * @param {Number} index
	   * @returns {Boolean}
	   */

	  has(index) {
	    return this.outputs.has(index);
	  }

	  /**
	   * Test whether the collection has an unspent coin.
	   * @param {Number} index
	   * @returns {Boolean}
	   */

	  isUnspent(index) {
	    const coin = this.outputs.get(index);
	    if (!coin || coin.spent) return false;
	    return true;
	  }

	  /**
	   * Get a coin entry.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  get(index) {
	    return this.outputs.get(index) || null;
	  }

	  /**
	   * Get an output.
	   * @param {Number} index
	   * @returns {Output|null}
	   */

	  getOutput(index) {
	    const coin = this.outputs.get(index);
	    if (!coin) return null;
	    return coin.output;
	  }

	  /**
	   * Get a coin.
	   * @param {Outpoint} prevout
	   * @returns {Coin|null}
	   */

	  getCoin(prevout) {
	    const coin = this.outputs.get(prevout.index);
	    if (!coin) return null;
	    return coin.toCoin(prevout);
	  }

	  /**
	   * Spend a coin entry and return it.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  spend(index) {
	    const coin = this.get(index);
	    if (!coin || coin.spent) return null;
	    coin.spent = true;
	    return coin;
	  }

	  /**
	   * Remove a coin entry and return it.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  remove(index) {
	    const coin = this.get(index);
	    if (!coin) return null;
	    this.outputs.delete(index);
	    return coin;
	  }

	  /**
	   * Test whether the coins are fully spent.
	   * @returns {Boolean}
	   */

	  isEmpty() {
	    return this.outputs.size === 0;
	  }

	  /**
	   * Inject properties from tx.
	   * @private
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  fromTX(tx, height) {
	    assert(typeof height === 'number');
	    for (let i = 0; i < tx.outputs.length; i++) {
	      const output = tx.outputs[i];
	      if (output.script.isUnspendable()) continue;
	      const entry = CoinEntry.fromTX(tx, i, height);
	      this.outputs.set(i, entry);
	    }
	    return this;
	  }

	  /**
	   * Instantiate a coins object from a transaction.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  static fromTX(tx, height) {
	    return new this().fromTX(tx, height);
	  }
	}

	/*
	 * Expose
	 */

	coins = Coins;
	return coins;
}

var bufferMap = {};

var custom = {};

var hasRequiredCustom;

function requireCustom () {
	if (hasRequiredCustom) return custom;
	hasRequiredCustom = 1;

	const {inspect} = require$$0$4;

	custom.custom = inspect.custom || 'inspect';
	return custom;
}

var hasRequiredBufferMap;

function requireBufferMap () {
	if (hasRequiredBufferMap) return bufferMap;
	hasRequiredBufferMap = 1;

	const {custom} = requireCustom();

	/**
	 * Buffer Map
	 */

	class BufferMap {
	  constructor(iterable) {
	    this.map = new Map();

	    if (iterable != null) {
	      for (const [key, value] of iterable)
	        this.set(key, value);
	    }
	  }

	  get size() {
	    return this.map.size;
	  }

	  get(key) {
	    const item = this.map.get(toBinary(key));

	    if (!item)
	      return undefined;

	    return item.value;
	  }

	  has(key) {
	    return this.map.has(toBinary(key));
	  }

	  set(key, value) {
	    this.map.set(toBinary(key), new BufferItem(key, value));
	    return this;
	  }

	  delete(key) {
	    return this.map.delete(toBinary(key));
	  }

	  clear() {
	    this.map.clear();
	  }

	  [Symbol.iterator]() {
	    return this.entries();
	  }

	  *entries() {
	    for (const {key, value} of this.map.values())
	      yield [key, value];
	  }

	  *keys() {
	    for (const {key} of this.map.values())
	      yield key;
	  }

	  *values() {
	    for (const {value} of this.map.values())
	      yield value;
	  }

	  forEach(func, self) {
	    if (typeof func !== 'function')
	      throw new TypeError(`${typeof func} is not a function`);

	    for (const {key, value} of this.map.values())
	      func.call(self, value, key, this);
	  }

	  toKeys() {
	    const out = [];

	    for (const {key} of this.map.values())
	      out.push(key);

	    return out;
	  }

	  toValues() {
	    const out = [];

	    for (const {value} of this.map.values())
	      out.push(value);

	    return out;
	  }

	  toArray() {
	    return this.toValues();
	  }

	  [custom]() {
	    const map = new Map();

	    for (const {key, value} of this.map.values())
	      map.set(toHex(key), value);

	    return map;
	  }
	}

	/**
	 * Buffer Set
	 */

	class BufferSet {
	  constructor(iterable) {
	    this.map = new Map();

	    if (iterable != null) {
	      for (const key of iterable)
	        this.add(key);
	    }
	  }

	  get size() {
	    return this.map.size;
	  }

	  has(key) {
	    return this.map.has(toBinary(key));
	  }

	  add(key) {
	    this.map.set(toBinary(key), key);
	    return this;
	  }

	  delete(key) {
	    return this.map.delete(toBinary(key));
	  }

	  clear() {
	    this.map.clear();
	  }

	  [Symbol.iterator]() {
	    return this.keys();
	  }

	  *entries() {
	    for (const key of this.map.values())
	      yield [key, key];
	  }

	  keys() {
	    return this.map.values();
	  }

	  values() {
	    return this.map.values();
	  }

	  forEach(func, self) {
	    if (typeof func !== 'function')
	      throw new TypeError(`${typeof func} is not a function`);

	    for (const key of this.map.values())
	      func.call(self, key, key, this);
	  }

	  toKeys() {
	    const out = [];

	    for (const key of this.map.values())
	      out.push(key);

	    return out;
	  }

	  toValues() {
	    return this.toKeys();
	  }

	  toArray() {
	    return this.toKeys();
	  }

	  [custom]() {
	    const set = new Set();

	    for (const key of this.map.values())
	      set.add(toHex(key));

	    return set;
	  }
	}

	/**
	 * Buffer Item
	 */

	class BufferItem {
	  constructor(key, value) {
	    this.key = key;
	    this.value = value;
	  }
	}

	/*
	 * Helpers
	 */

	const HAS_SHARED_ARRAY_BUFFER = typeof SharedArrayBuffer === 'function';

	function isArrayBuffer(key) {
	  if (key instanceof ArrayBuffer)
	    return true;

	  if (HAS_SHARED_ARRAY_BUFFER) {
	    if (key instanceof SharedArrayBuffer)
	      return true;
	  }

	  return false;
	}

	function toBuffer(key) {
	  if (ArrayBuffer.isView(key))
	    return Buffer$1.from(key.buffer, key.byteOffset, key.byteLength);

	  if (isArrayBuffer(key))
	    return Buffer$1.from(key, 0, key.byteLength);

	  throw new TypeError('Non-buffer passed to buffer map/set.');
	}

	function encode(key, encoding) {
	  if (!Buffer$1.isBuffer(key))
	    key = toBuffer(key);

	  return key.toString(encoding);
	}

	function toBinary(key) {
	  return encode(key, 'binary');
	}

	function toHex(key) {
	  return encode(key, 'hex');
	}

	/*
	 * Expose
	 */

	bufferMap.BufferMap = BufferMap;
	bufferMap.BufferSet = BufferSet;
	return bufferMap;
}

/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var undocoins;
var hasRequiredUndocoins;

function requireUndocoins () {
	if (hasRequiredUndocoins) return undocoins;
	hasRequiredUndocoins = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const CoinEntry = requireCoinentry();

	/**
	 * Undo Coins
	 * Coins need to be resurrected from somewhere
	 * during a reorg. The undo coins store all
	 * spent coins in a single record per block
	 * (in a compressed format).
	 * @alias module:coins.UndoCoins
	 * @property {UndoCoin[]} items
	 */

	class UndoCoins {
	  /**
	   * Create undo coins.
	   * @constructor
	   */

	  constructor() {
	    this.items = [];
	  }

	  /**
	   * Push coin entry onto undo coin array.
	   * @param {CoinEntry}
	   * @returns {Number}
	   */

	  push(coin) {
	    return this.items.push(coin);
	  }

	  /**
	   * Calculate undo coins size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += 4;
	    for (const coin of this.items) size += coin.getSize();
	    return size;
	  }

	  /**
	   * Serialize all undo coins.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    const bw = bio.write(size);
	    bw.writeU32(this.items.length);
	    for (const coin of this.items) coin.toWriter(bw);
	    return bw.render();
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {UndoCoins}
	   */

	  fromRaw(data) {
	    const br = bio.read(data);
	    const count = br.readU32();
	    for (let i = 0; i < count; i++) this.items.push(CoinEntry.fromReader(br));
	    return this;
	  }

	  /**
	   * Instantiate undo coins from serialized data.
	   * @param {Buffer} data
	   * @returns {UndoCoins}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether the undo coins have any members.
	   * @returns {Boolean}
	   */

	  isEmpty() {
	    return this.items.length === 0;
	  }

	  /**
	   * Render the undo coins.
	   * @returns {Buffer}
	   */

	  commit() {
	    const raw = this.toRaw();
	    this.items.length = 0;
	    return raw;
	  }

	  /**
	   * Re-apply undo coins to a view, effectively unspending them.
	   * @param {CoinView} view
	   * @param {Outpoint} prevout
	   */

	  apply(view, prevout) {
	    const undo = this.items.pop();
	    assert(undo);
	    view.addEntry(prevout, undo);
	  }
	}

	/*
	 * Expose
	 */

	undocoins = UndoCoins;
	return undocoins;
}

/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coinview;
var hasRequiredCoinview;

function requireCoinview () {
	if (hasRequiredCoinview) return coinview;
	hasRequiredCoinview = 1;

	const {
	  BufferMap
	} = requireBufferMap();
	const Coins = requireCoins$1();
	const UndoCoins = requireUndocoins();
	const CoinEntry = requireCoinentry();

	/**
	 * Coin View
	 * Represents a coin viewpoint:
	 * a snapshot of {@link Coins} objects.
	 * @alias module:coins.CoinView
	 * @property {Object} map
	 * @property {UndoCoins} undo
	 */

	class CoinView {
	  /**
	   * Create a coin view.
	   * @constructor
	   */

	  constructor() {
	    this.map = new BufferMap();
	    this.undo = new UndoCoins();
	  }

	  /**
	   * Get coins.
	   * @param {Hash} hash
	   * @returns {Coins} coins
	   */

	  get(hash) {
	    return this.map.get(hash);
	  }

	  /**
	   * Test whether the view has an entry.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  has(hash) {
	    return this.map.has(hash);
	  }

	  /**
	   * Add coins to the collection.
	   * @param {Hash} hash
	   * @param {Coins} coins
	   * @returns {Coins}
	   */

	  add(hash, coins) {
	    this.map.set(hash, coins);
	    return coins;
	  }

	  /**
	   * Ensure existence of coins object in the collection.
	   * @param {Hash} hash
	   * @returns {Coins}
	   */

	  ensure(hash) {
	    const coins = this.map.get(hash);
	    if (coins) return coins;
	    return this.add(hash, new Coins());
	  }

	  /**
	   * Remove coins from the collection.
	   * @param {Coins} coins
	   * @returns {Coins|null}
	   */

	  remove(hash) {
	    const coins = this.map.get(hash);
	    if (!coins) return null;
	    this.map.delete(hash);
	    return coins;
	  }

	  /**
	   * Add a tx to the collection.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  addTX(tx, height) {
	    const hash = tx.hash();
	    const coins = Coins.fromTX(tx, height);
	    return this.add(hash, coins);
	  }

	  /**
	   * Remove a tx from the collection.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  removeTX(tx, height) {
	    const hash = tx.hash();
	    const coins = Coins.fromTX(tx, height);
	    for (const coin of coins.outputs.values()) coin.spent = true;
	    return this.add(hash, coins);
	  }

	  /**
	   * Add an entry to the collection.
	   * @param {Outpoint} prevout
	   * @param {CoinEntry} coin
	   * @returns {CoinEntry|null}
	   */

	  addEntry(prevout, coin) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.ensure(hash);
	    return coins.add(index, coin);
	  }

	  /**
	   * Add a coin to the collection.
	   * @param {Coin} coin
	   * @returns {CoinEntry|null}
	   */

	  addCoin(coin) {
	    const coins = this.ensure(coin.hash);
	    return coins.addCoin(coin);
	  }

	  /**
	   * Add an output to the collection.
	   * @param {Outpoint} prevout
	   * @param {Output} output
	   * @returns {CoinEntry|null}
	   */

	  addOutput(prevout, output) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.ensure(hash);
	    return coins.addOutput(index, output);
	  }

	  /**
	   * Add an output to the collection by output index.
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Number} height
	   * @returns {CoinEntry|null}
	   */

	  addIndex(tx, index, height) {
	    const hash = tx.hash();
	    const coins = this.ensure(hash);
	    return coins.addIndex(tx, index, height);
	  }

	  /**
	   * Spend an output.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  spendEntry(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return null;
	    const coin = coins.spend(index);
	    if (!coin) return null;
	    this.undo.push(coin);
	    return coin;
	  }

	  /**
	   * Remove an output.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  removeEntry(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return null;
	    return coins.remove(index);
	  }

	  /**
	   * Test whether the view has an entry by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  hasEntry(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return false;
	    return coins.has(index);
	  }

	  /**
	   * Get a single entry by prevout.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  getEntry(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return null;
	    return coins.get(index);
	  }

	  /**
	   * Test whether an entry has been spent by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  isUnspent(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return false;
	    return coins.isUnspent(index);
	  }

	  /**
	   * Get a single coin by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Coin|null}
	   */

	  getCoin(prevout) {
	    const coins = this.get(prevout.hash);
	    if (!coins) return null;
	    return coins.getCoin(prevout);
	  }

	  /**
	   * Get a single output by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Output|null}
	   */

	  getOutput(prevout) {
	    const {
	      hash,
	      index
	    } = prevout;
	    const coins = this.get(hash);
	    if (!coins) return null;
	    return coins.getOutput(index);
	  }

	  /**
	   * Get coins height by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Number}
	   */

	  getHeight(prevout) {
	    const coin = this.getEntry(prevout);
	    if (!coin) return -1;
	    return coin.height;
	  }

	  /**
	   * Get coins coinbase flag by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  isCoinbase(prevout) {
	    const coin = this.getEntry(prevout);
	    if (!coin) return false;
	    return coin.coinbase;
	  }

	  /**
	   * Test whether the view has an entry by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  hasEntryFor(input) {
	    return this.hasEntry(input.prevout);
	  }

	  /**
	   * Get a single entry by input.
	   * @param {Input} input
	   * @returns {CoinEntry|null}
	   */

	  getEntryFor(input) {
	    return this.getEntry(input.prevout);
	  }

	  /**
	   * Test whether an entry has been spent by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  isUnspentFor(input) {
	    return this.isUnspent(input.prevout);
	  }

	  /**
	   * Get a single coin by input.
	   * @param {Input} input
	   * @returns {Coin|null}
	   */

	  getCoinFor(input) {
	    return this.getCoin(input.prevout);
	  }

	  /**
	   * Get a single output by input.
	   * @param {Input} input
	   * @returns {Output|null}
	   */

	  getOutputFor(input) {
	    return this.getOutput(input.prevout);
	  }

	  /**
	   * Get coins height by input.
	   * @param {Input} input
	   * @returns {Number}
	   */

	  getHeightFor(input) {
	    return this.getHeight(input.prevout);
	  }

	  /**
	   * Get coins coinbase flag by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  isCoinbaseFor(input) {
	    return this.isCoinbase(input.prevout);
	  }

	  /**
	   * Retrieve coins from database.
	   * @method
	   * @param {ChainDB} db
	   * @param {Outpoint} prevout
	   * @returns {Promise} - Returns {@link CoinEntry}.
	   */

	  async readCoin(db, prevout) {
	    const cache = this.getEntry(prevout);
	    if (cache) return cache;
	    const coin = await db.readCoin(prevout);
	    if (!coin) return null;
	    return this.addEntry(prevout, coin);
	  }

	  /**
	   * Read all input coins into unspent map.
	   * @method
	   * @param {ChainDB} db
	   * @param {TX} tx
	   * @returns {Promise} - Returns {Boolean}.
	   */

	  async readInputs(db, tx) {
	    let found = true;
	    for (const {
	      prevout
	    } of tx.inputs) {
	      if (!(await this.readCoin(db, prevout))) found = false;
	    }
	    return found;
	  }

	  /**
	   * Spend coins for transaction.
	   * @method
	   * @param {ChainDB} db
	   * @param {TX} tx
	   * @returns {Promise} - Returns {Boolean}.
	   */

	  async spendInputs(db, tx) {
	    let i = 0;
	    while (i < tx.inputs.length) {
	      const len = Math.min(i + 4, tx.inputs.length);
	      const jobs = [];
	      for (; i < len; i++) {
	        const {
	          prevout
	        } = tx.inputs[i];
	        jobs.push(this.readCoin(db, prevout));
	      }
	      const coins = await Promise.all(jobs);
	      for (const coin of coins) {
	        if (!coin || coin.spent) return false;
	        coin.spent = true;
	        this.undo.push(coin);
	      }
	    }
	    return true;
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize(tx) {
	    let size = 0;
	    size += tx.inputs.length;
	    for (const {
	      prevout
	    } of tx.inputs) {
	      const coin = this.getEntry(prevout);
	      if (!coin) continue;
	      size += coin.getSize();
	    }
	    return size;
	  }

	  /**
	   * Write coin data to buffer writer
	   * as it pertains to a transaction.
	   * @param {BufferWriter} bw
	   * @param {TX} tx
	   */

	  toWriter(bw, tx) {
	    for (const {
	      prevout
	    } of tx.inputs) {
	      const coin = this.getEntry(prevout);
	      if (!coin) {
	        bw.writeU8(0);
	        continue;
	      }
	      bw.writeU8(1);
	      coin.toWriter(bw);
	    }
	    return bw;
	  }

	  /**
	   * Read serialized view data from a buffer
	   * reader as it pertains to a transaction.
	   * @private
	   * @param {BufferReader} br
	   * @param {TX} tx
	   */

	  fromReader(br, tx) {
	    for (const {
	      prevout
	    } of tx.inputs) {
	      if (br.readU8() === 0) continue;
	      const coin = CoinEntry.fromReader(br);
	      this.addEntry(prevout, coin);
	    }
	    return this;
	  }

	  /**
	   * Read serialized view data from a buffer
	   * reader as it pertains to a transaction.
	   * @param {BufferReader} br
	   * @param {TX} tx
	   * @returns {CoinView}
	   */

	  static fromReader(br, tx) {
	    return new this().fromReader(br, tx);
	  }
	}

	/*
	 * Expose
	 */

	coinview = CoinView;
	return coinview;
}

/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCoins;

function requireCoins () {
	if (hasRequiredCoins) return coins$1;
	hasRequiredCoins = 1;

	/**
	 * @module coins
	 */
	coins$1.Coins = requireCoins$1();
	coins$1.CoinView = requireCoinview();
	coins$1.compress = requireCompress();
	coins$1.UndoCoins = requireUndocoins();
	return coins$1;
}

var hd$1 = {};

var common = {};

/*!
 * lru.js - LRU cache for bcoin
 * Copyright (c) 2014-2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var lru;
var hasRequiredLru;

function requireLru () {
	if (hasRequiredLru) return lru;
	hasRequiredLru = 1;

	const assert = requireAssert$1();

	/**
	 * LRU Cache
	 */

	class LRU {
	  /**
	   * Create an LRU cache.
	   * @constructor
	   * @param {Number} capacity
	   * @param {Function?} getSize
	   * @param {Function?} CustomMap
	   */

	  constructor(capacity, getSize, CustomMap) {
	    assert(typeof capacity === 'number', 'Capacity must be a number.');
	    assert(capacity >= 0, 'Capacity cannot be negative.');
	    assert(!getSize || typeof getSize === 'function', 'Bad size callback.');
	    assert(!CustomMap || typeof CustomMap === 'function');

	    this.map = CustomMap ? new CustomMap() : new Map();
	    this.size = 0;
	    this.items = 0;
	    this.head = null;
	    this.tail = null;
	    this.pending = null;

	    this.capacity = capacity;
	    this.getSize = getSize;
	  }

	  /**
	   * Calculate size of an item.
	   * @private
	   * @param {LRUItem} item
	   * @returns {Number} Size.
	   */

	  _getSize(item) {
	    if (this.getSize)
	      return 120 + this.getSize(item.value, item.key);

	    return 1;
	  }

	  /**
	   * Compact the LRU linked list.
	   * @private
	   */

	  _compact() {
	    if (this.size <= this.capacity)
	      return;

	    let item = null;
	    let next = null;

	    for (item = this.head; item; item = next) {
	      if (this.size <= this.capacity)
	        break;

	      this.size -= this._getSize(item);
	      this.items -= 1;
	      this.map.delete(item.key);

	      next = item.next;

	      item.prev = null;
	      item.next = null;
	    }

	    if (!item) {
	      this.head = null;
	      this.tail = null;
	      return;
	    }

	    this.head = item;
	    item.prev = null;
	  }

	  /**
	   * Reset the cache. Clear all items.
	   */

	  reset() {
	    let item, next;

	    for (item = this.head; item; item = next) {
	      this.map.delete(item.key);
	      this.items -= 1;
	      next = item.next;
	      item.prev = null;
	      item.next = null;
	    }

	    assert(!item);

	    this.size = 0;
	    this.head = null;
	    this.tail = null;
	  }

	  /**
	   * Add an item to the cache.
	   * @param {String|Number} key
	   * @param {Object} value
	   */

	  set(key, value) {
	    if (this.capacity === 0)
	      return;

	    let item = this.map.get(key);

	    if (item) {
	      this.size -= this._getSize(item);
	      item.value = value;
	      this.size += this._getSize(item);
	      this._removeList(item);
	      this._appendList(item);
	      this._compact();
	      return;
	    }

	    item = new LRUItem(key, value);

	    this.map.set(key, item);

	    this._appendList(item);

	    this.size += this._getSize(item);
	    this.items += 1;

	    this._compact();
	  }

	  /**
	   * Retrieve an item from the cache.
	   * @param {String|Number} key
	   * @returns {Object} Item.
	   */

	  get(key) {
	    if (this.capacity === 0)
	      return null;

	    const item = this.map.get(key);

	    if (!item)
	      return null;

	    this._removeList(item);
	    this._appendList(item);

	    return item.value;
	  }

	  /**
	   * Test whether the cache contains a key.
	   * @param {String|Number} key
	   * @returns {Boolean}
	   */

	  has(key) {
	    if (this.capacity === 0)
	      return false;
	    return this.map.has(key);
	  }

	  /**
	   * Remove an item from the cache.
	   * @param {String|Number} key
	   * @returns {Boolean} Whether an item was removed.
	   */

	  remove(key) {
	    if (this.capacity === 0)
	      return false;

	    const item = this.map.get(key);

	    if (!item)
	      return false;

	    this.size -= this._getSize(item);
	    this.items -= 1;

	    this.map.delete(key);

	    this._removeList(item);

	    return true;
	  }

	  /**
	   * Prepend an item to the linked list (sets new head).
	   * @private
	   * @param {LRUItem}
	   */

	  _prependList(item) {
	    this._insertList(null, item);
	  }

	  /**
	   * Append an item to the linked list (sets new tail).
	   * @private
	   * @param {LRUItem}
	   */

	  _appendList(item) {
	    this._insertList(this.tail, item);
	  }

	  /**
	   * Insert item into the linked list.
	   * @private
	   * @param {LRUItem|null} ref
	   * @param {LRUItem} item
	   */

	  _insertList(ref, item) {
	    assert(!item.next);
	    assert(!item.prev);

	    if (ref == null) {
	      if (!this.head) {
	        this.head = item;
	        this.tail = item;
	      } else {
	        this.head.prev = item;
	        item.next = this.head;
	        this.head = item;
	      }
	      return;
	    }

	    item.next = ref.next;
	    item.prev = ref;
	    ref.next = item;

	    if (item.next)
	      item.next.prev = item;

	    if (ref === this.tail)
	      this.tail = item;
	  }

	  /**
	   * Remove item from the linked list.
	   * @private
	   * @param {LRUItem}
	   */

	  _removeList(item) {
	    if (item.prev)
	      item.prev.next = item.next;

	    if (item.next)
	      item.next.prev = item.prev;

	    if (item === this.head)
	      this.head = item.next;

	    if (item === this.tail)
	      this.tail = item.prev || this.head;

	    if (!this.head)
	      assert(!this.tail);

	    if (!this.tail)
	      assert(!this.head);

	    item.prev = null;
	    item.next = null;
	  }

	  /**
	   * Collect all keys in the cache, sorted by LRU.
	   * @returns {String[]}
	   */

	  keys() {
	    const items = [];

	    for (let item = this.head; item; item = item.next) {
	      if (item === this.head)
	        assert(!item.prev);
	      if (!item.prev)
	        assert(item === this.head);
	      if (!item.next)
	        assert(item === this.tail);
	      items.push(item.key);
	    }

	    return items;
	  }

	  /**
	   * Collect all values in the cache, sorted by LRU.
	   * @returns {String[]}
	   */

	  values() {
	    const items = [];

	    for (let item = this.head; item; item = item.next)
	      items.push(item.value);

	    return items;
	  }

	  /**
	   * Convert the LRU cache to an array of items.
	   * @returns {Object[]}
	   */

	  toArray() {
	    const items = [];

	    for (let item = this.head; item; item = item.next)
	      items.push(item);

	    return items;
	  }

	  /**
	   * Create an atomic batch for the lru
	   * (used for caching database writes).
	   * @returns {LRUBatch}
	   */

	  batch() {
	    return new LRUBatch(this);
	  }

	  /**
	   * Start the pending batch.
	   */

	  start() {
	    assert(!this.pending);
	    this.pending = this.batch();
	  }

	  /**
	   * Clear the pending batch.
	   */

	  clear() {
	    assert(this.pending);
	    this.pending.clear();
	  }

	  /**
	   * Drop the pending batch.
	   */

	  drop() {
	    assert(this.pending);
	    this.pending = null;
	  }

	  /**
	   * Commit the pending batch.
	   */

	  commit() {
	    assert(this.pending);
	    this.pending.commit();
	    this.pending = null;
	  }

	  /**
	   * Push an item onto the pending batch.
	   * @param {String} key
	   * @param {Object} value
	   */

	  push(key, value) {
	    assert(this.pending);

	    if (this.capacity === 0)
	      return;

	    this.pending.set(key, value);
	  }

	  /**
	   * Push a removal onto the pending batch.
	   * @param {String} key
	   */

	  unpush(key) {
	    assert(this.pending);

	    if (this.capacity === 0)
	      return;

	    this.pending.remove(key);
	  }
	}

	/**
	 * LRU Item
	 * @alias module:utils.LRUItem
	 */

	class LRUItem {
	  /**
	   * Create an LRU item.
	   * @constructor
	   * @private
	   * @param {String} key
	   * @param {Object} value
	   */

	  constructor(key, value) {
	    this.key = key;
	    this.value = value;
	    this.next = null;
	    this.prev = null;
	  }
	}

	/**
	 * LRU Batch
	 * @alias module:utils.LRUBatch
	 */

	class LRUBatch {
	  /**
	   * Create an LRU batch.
	   * @constructor
	   * @param {LRU} lru
	   */

	  constructor(lru) {
	    this.lru = lru;
	    this.ops = [];
	  }

	  /**
	   * Push an item onto the batch.
	   * @param {String} key
	   * @param {Object} value
	   */

	  set(key, value) {
	    this.ops.push(new LRUOp(false, key, value));
	  }

	  /**
	   * Push a removal onto the batch.
	   * @param {String} key
	   */

	  remove(key) {
	    this.ops.push(new LRUOp(true, key, null));
	  }

	  /**
	   * Clear the batch.
	   */

	  clear() {
	    this.ops.length = 0;
	  }

	  /**
	   * Commit the batch.
	   */

	  commit() {
	    for (const op of this.ops) {
	      if (op.remove) {
	        this.lru.remove(op.key);
	        continue;
	      }
	      this.lru.set(op.key, op.value);
	    }

	    this.ops.length = 0;
	  }
	}

	/**
	 * LRU Op
	 * @alias module:utils.LRUOp
	 * @private
	 */

	class LRUOp {
	  /**
	   * Create an LRU op.
	   * @constructor
	   * @param {Boolean} remove
	   * @param {String} key
	   * @param {Object} value
	   */

	  constructor(remove, key, value) {
	    this.remove = remove;
	    this.key = key;
	    this.value = value;
	  }
	}

	/*
	 * Expose
	 */

	lru = LRU;
	return lru;
}

var blru;
var hasRequiredBlru;

function requireBlru () {
	if (hasRequiredBlru) return blru;
	hasRequiredBlru = 1;

	blru = requireLru();
	return blru;
}

/*!
 * common.js - common functions for hd
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports) {

		const assert = requireAssert$1();
		const LRU = requireBlru();
		const common = exports;

		/**
		 * Index at which hardening begins.
		 * @const {Number}
		 * @default
		 */

		common.HARDENED = 0x80000000;

		/**
		 * Min entropy bits.
		 * @const {Number}
		 * @default
		 */

		common.MIN_ENTROPY = 128;

		/**
		 * Max entropy bits.
		 * @const {Number}
		 * @default
		 */

		common.MAX_ENTROPY = 512;

		/**
		 * LRU cache to avoid deriving keys twice.
		 * @type {LRU}
		 */

		common.cache = new LRU(500);

		/**
		 * Parse a derivation path and return an array of indexes.
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
		 * @param {String} path
		 * @param {Boolean} hard
		 * @returns {Number[]}
		 */

		common.parsePath = function parsePath(path, hard) {
		  assert(typeof path === 'string');
		  assert(typeof hard === 'boolean');
		  assert(path.length >= 1);
		  assert(path.length <= 3062);
		  const parts = path.split('/');
		  const root = parts[0];
		  if (root !== 'm' && root !== 'M' && root !== 'm\'' && root !== 'M\'') {
		    throw new Error('Invalid path root.');
		  }
		  const result = [];
		  for (let i = 1; i < parts.length; i++) {
		    let part = parts[i];
		    const hardened = part[part.length - 1] === '\'';
		    if (hardened) part = part.slice(0, -1);
		    if (part.length > 10) throw new Error('Path index too large.');
		    if (!/^\d+$/.test(part)) throw new Error('Path index is non-numeric.');
		    let index = parseInt(part, 10);
		    if (index >>> 0 !== index) throw new Error('Path index out of range.');
		    if (hardened) {
		      index |= common.HARDENED;
		      index >>>= 0;
		    }
		    if (!hard && index & common.HARDENED) throw new Error('Path index cannot be hardened.');
		    result.push(index);
		  }
		  return result;
		};

		/**
		 * Test whether the key is a master key.
		 * @param {HDPrivateKey|HDPublicKey} key
		 * @returns {Boolean}
		 */

		common.isMaster = function isMaster(key) {
		  return key.depth === 0 && key.childIndex === 0 && key.parentFingerPrint === 0;
		};

		/**
		 * Test whether the key is (most likely) a BIP44 account key.
		 * @param {HDPrivateKey|HDPublicKey} key
		 * @param {Number?} account
		 * @returns {Boolean}
		 */

		common.isAccount = function isAccount(key, account) {
		  if (account != null) {
		    const index = (common.HARDENED | account) >>> 0;
		    if (key.childIndex !== index) return false;
		  }
		  return key.depth === 3 && (key.childIndex & common.HARDENED) !== 0;
		};

		/**
		 * A compressed pubkey of all zeroes.
		 * @const {Buffer}
		 * @default
		 */

		common.ZERO_KEY = Buffer.alloc(33, 0x00); 
	} (common));
	return common;
}

/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var cleanse_1;
var hasRequiredCleanse;

function requireCleanse () {
	if (hasRequiredCleanse) return cleanse_1;
	hasRequiredCleanse = 1;

	const assert = requireAssert();
	const random = requireRandom();

	/**
	 * A maybe-secure memzero.
	 * @param {Buffer} data
	 */

	function cleanse(data) {
	  assert(Buffer.isBuffer(data));
	  random.randomFill(data, 0, data.length);
	}

	/*
	 * Static
	 */

	cleanse.native = 0;

	/*
	 * Expose
	 */

	cleanse_1 = cleanse;
	return cleanse_1;
}

var pbkdf2 = {};

/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */

var hasRequiredPbkdf2;

function requirePbkdf2 () {
	if (hasRequiredPbkdf2) return pbkdf2;
	hasRequiredPbkdf2 = 1;

	const assert = requireAssert();
	const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto || {};
	const subtle = crypto.subtle || {};

	/**
	 * Perform key derivation using PBKDF2.
	 * @param {Function} hash
	 * @param {Buffer} pass
	 * @param {Buffer} salt
	 * @param {Number} iter
	 * @param {Number} len
	 * @returns {Buffer}
	 */

	function derive(hash, pass, salt, iter, len) {
	  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
	  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
	  if (salt == null) salt = Buffer.alloc(0);
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(pass));
	  assert(Buffer.isBuffer(salt));
	  assert(iter >>> 0 === iter);
	  assert(len >>> 0 === len);
	  const size = hash.size;
	  const blocks = Math.ceil(len / size);
	  const out = Buffer.alloc(blocks * size);
	  const state = Buffer.alloc(salt.length + 4);
	  salt.copy(state, 0);

	  // Preemptively shorten key.
	  if (pass.length > hash.blockSize) {
	    pass = hash.digest(pass);
	    assert(pass.length <= hash.blockSize);
	  }
	  for (let i = 0; i < blocks; i++) {
	    const round = i + 1;
	    state[salt.length + 0] = round >>> 24;
	    state[salt.length + 1] = round >>> 16;
	    state[salt.length + 2] = round >>> 8;
	    state[salt.length + 3] = round;
	    const block = hash.mac(state, pass);
	    let mac = block;
	    for (let j = 1; j < iter; j++) {
	      mac = hash.mac(mac, pass);
	      for (let k = 0; k < size; k++) block[k] ^= mac[k];
	    }
	    block.copy(out, i * size);
	  }
	  return out.slice(0, len);
	}

	/**
	 * Execute pbkdf2 asynchronously.
	 * @param {Function} hash
	 * @param {Buffer} pass
	 * @param {Buffer} salt
	 * @param {Number} iter
	 * @param {Number} len
	 * @returns {Promise}
	 */

	async function deriveAsync(hash, pass, salt, iter, len) {
	  if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
	  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
	  if (salt == null) salt = Buffer.alloc(0);
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(pass));
	  assert(Buffer.isBuffer(salt));
	  assert(iter >>> 0 === iter);
	  assert(len >>> 0 === len);
	  const name = getHash(hash);
	  if (!subtle.importKey || !subtle.deriveBits || !name) return derive(hash, pass, salt, iter, len);
	  const algo = {
	    name: 'PBKDF2'
	  };
	  const use = ['deriveBits'];
	  const options = {
	    name: 'PBKDF2',
	    salt: salt,
	    iterations: iter,
	    hash: name
	  };
	  const key = await subtle.importKey('raw', pass, algo, false, use);
	  const out = await subtle.deriveBits(options, key, len * 8);
	  return Buffer.from(out);
	}

	/*
	 * Helpers
	 */

	function getHash(hash) {
	  switch (hash.id) {
	    case 'SHA1':
	      return 'SHA-1';
	    case 'SHA256':
	      return 'SHA-256';
	    case 'SHA384':
	      return 'SHA-384';
	    case 'SHA512':
	      return 'SHA-512';
	    default:
	      return null;
	  }
	}

	/*
	 * Expose
	 */

	pbkdf2.native = 0;
	pbkdf2.derive = derive;
	pbkdf2.deriveAsync = deriveAsync;
	return pbkdf2;
}

/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */

var sha512;
var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512;
	hasRequiredSha512 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(16, 0x00);
	const PADDING = Buffer.alloc(128, 0x00);
	PADDING[0] = 0x80;
	const K = new Uint32Array([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);

	/**
	 * SHA512
	 */

	class SHA512 {
	  constructor() {
	    this.state = new Uint32Array(16);
	    this.msg = new Uint32Array(160);
	    this.block = Buffer.alloc(128);
	    this.size = FINALIZED;
	  }
	  init() {
	    this.state[0] = 0x6a09e667;
	    this.state[1] = 0xf3bcc908;
	    this.state[2] = 0xbb67ae85;
	    this.state[3] = 0x84caa73b;
	    this.state[4] = 0x3c6ef372;
	    this.state[5] = 0xfe94f82b;
	    this.state[6] = 0xa54ff53a;
	    this.state[7] = 0x5f1d36f1;
	    this.state[8] = 0x510e527f;
	    this.state[9] = 0xade682d1;
	    this.state[10] = 0x9b05688c;
	    this.state[11] = 0x2b3e6c1f;
	    this.state[12] = 0x1f83d9ab;
	    this.state[13] = 0xfb41bd6b;
	    this.state[14] = 0x5be0cd19;
	    this.state[15] = 0x137e2179;
	    this.size = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }
	  final() {
	    return this._final(Buffer.alloc(64));
	  }
	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    let pos = this.size & 127;
	    let off = 0;
	    this.size += len;
	    if (pos > 0) {
	      let want = 128 - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < 128) return;
	      this._transform(this.block, 0);
	    }
	    while (len >= 128) {
	      this._transform(data, off);
	      off += 128;
	      len -= 128;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	  }

	  /**
	   * Finalize SHA512 context.
	   * @private
	   * @param {Buffer} out
	   * @returns {Buffer}
	   */

	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    const pos = this.size & 127;
	    const len = this.size * 8;
	    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 8);
	    writeU32(DESC, len >>> 0, 12);
	    this._update(PADDING, 1 + (239 - pos & 127));
	    this._update(DESC, 16);
	    for (let i = 0; i < 16; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }
	    for (let i = 0; i < 160; i++) this.msg[i] = 0;
	    for (let i = 0; i < 128; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    return out;
	  }
	  _prepare(chunk, pos) {
	    const W = this.msg;
	    let i = 0;
	    for (; i < 32; i++) W[i] = readU32(chunk, pos + i * 4);
	    for (; i < 160; i += 2) {
	      const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
	      const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	      const c1_hi = W[i - 14];
	      const c1_lo = W[i - 13];
	      const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
	      const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	      const c3_hi = W[i - 32];
	      const c3_lo = W[i - 31];
	      W[i + 0] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
	      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
	    }
	  }
	  _transform(chunk, pos) {
	    const W = this.msg;
	    this._prepare(chunk, pos);
	    let ah = this.state[0];
	    let al = this.state[1];
	    let bh = this.state[2];
	    let bl = this.state[3];
	    let ch = this.state[4];
	    let cl = this.state[5];
	    let dh = this.state[6];
	    let dl = this.state[7];
	    let eh = this.state[8];
	    let el = this.state[9];
	    let fh = this.state[10];
	    let fl = this.state[11];
	    let gh = this.state[12];
	    let gl = this.state[13];
	    let hh = this.state[14];
	    let hl = this.state[15];
	    for (let i = 0; i < W.length; i += 2) {
	      let c0_hi = hh;
	      let c0_lo = hl;
	      let c1_hi = s1_512_hi(eh, el);
	      let c1_lo = s1_512_lo(eh, el);
	      const c2_hi = ch64_hi(eh, el, fh, fl, gh);
	      const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	      const c3_hi = K[i + 0];
	      const c3_lo = K[i + 1];
	      const c4_hi = W[i + 0];
	      const c4_lo = W[i + 1];
	      const T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
	      const T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
	      c0_hi = s0_512_hi(ah, al);
	      c0_lo = s0_512_lo(ah, al);
	      c1_hi = maj64_hi(ah, al, bh, bl, ch);
	      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
	      const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	      const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
	      hh = gh;
	      hl = gl;
	      gh = fh;
	      gl = fl;
	      fh = eh;
	      fl = el;
	      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	      el = sum64_lo(dl, dl, T1_hi, T1_lo);
	      dh = ch;
	      dl = cl;
	      ch = bh;
	      cl = bl;
	      bh = ah;
	      bl = al;
	      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	    }
	    sum64(this.state, 0, ah, al);
	    sum64(this.state, 2, bh, bl);
	    sum64(this.state, 4, ch, cl);
	    sum64(this.state, 6, dh, dl);
	    sum64(this.state, 8, eh, el);
	    sum64(this.state, 10, fh, fl);
	    sum64(this.state, 12, gh, gl);
	    sum64(this.state, 14, hh, hl);
	  }
	  static hash() {
	    return new SHA512();
	  }
	  static hmac() {
	    return new HMAC(SHA512, 128);
	  }
	  static digest(data) {
	    return SHA512.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 64);
	    assert(Buffer.isBuffer(right) && right.length === 64);
	    return SHA512.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = SHA512;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return SHA512.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA512.native = 0;
	SHA512.id = 'SHA512';
	SHA512.size = 64;
	SHA512.bits = 512;
	SHA512.blockSize = 128;
	SHA512.zero = Buffer.alloc(64, 0x00);
	SHA512.ctx = new SHA512();

	/*
	 * Helpers
	 */

	function sum64(buf, pos, ah, al) {
	  const bh = buf[pos + 0];
	  const bl = buf[pos + 1];
	  const lo = al + bl >>> 0;
	  const hi = (lo < al) + ah + bh;
	  buf[pos + 0] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	function sum64_hi(ah, al, bh, bl) {
	  const lo = al + bl >>> 0;
	  const hi = (lo < al) + ah + bh;
	  return hi >>> 0;
	}
	function sum64_lo(ah, al, bh, bl) {
	  const lo = al + bl;
	  return lo >>> 0;
	}
	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  let carry = 0;
	  let lo = al;
	  lo = lo + bl >>> 0;
	  carry += lo < al;
	  lo = lo + cl >>> 0;
	  carry += lo < cl;
	  lo = lo + dl >>> 0;
	  carry += lo < dl;
	  const hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  const lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  let carry = 0;
	  let lo = al;
	  lo = lo + bl >>> 0;
	  carry += lo < al;
	  lo = lo + cl >>> 0;
	  carry += lo < cl;
	  lo = lo + dl >>> 0;
	  carry += lo < dl;
	  lo = lo + el >>> 0;
	  carry += lo < el;
	  const hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  const lo = al + bl + cl + dl + el;
	  return lo >>> 0;
	}
	function rotr64_hi(ah, al, num) {
	  const r = al << 32 - num | ah >>> num;
	  return r >>> 0;
	}
	function rotr64_lo(ah, al, num) {
	  const r = ah << 32 - num | al >>> num;
	  return r >>> 0;
	}
	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}
	function shr64_lo(ah, al, num) {
	  const r = ah << 32 - num | al >>> num;
	  return r >>> 0;
	}
	function ch64_hi(xh, xl, yh, yl, zh, zl) {
	  const r = xh & yh ^ ~xh & zh;
	  return r >>> 0;
	}
	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  const r = xl & yl ^ ~xl & zl;
	  return r >>> 0;
	}
	function maj64_hi(xh, xl, yh, yl, zh, zl) {
	  const r = xh & yh ^ xh & zh ^ yh & zh;
	  return r >>> 0;
	}
	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  const r = xl & yl ^ xl & zl ^ yl & zl;
	  return r >>> 0;
	}
	function s0_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 28);
	  const c1_hi = rotr64_hi(xl, xh, 2); // 34
	  const c2_hi = rotr64_hi(xl, xh, 7); // 39
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}
	function s0_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 28);
	  const c1_lo = rotr64_lo(xl, xh, 2); // 34
	  const c2_lo = rotr64_lo(xl, xh, 7); // 39
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}
	function s1_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 14);
	  const c1_hi = rotr64_hi(xh, xl, 18);
	  const c2_hi = rotr64_hi(xl, xh, 9); // 41
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}
	function s1_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 14);
	  const c1_lo = rotr64_lo(xh, xl, 18);
	  const c2_lo = rotr64_lo(xl, xh, 9); // 41
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}
	function g0_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 1);
	  const c1_hi = rotr64_hi(xh, xl, 8);
	  const c2_hi = shr64_hi(xh, xl, 7);
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}
	function g0_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 1);
	  const c1_lo = rotr64_lo(xh, xl, 8);
	  const c2_lo = shr64_lo(xh, xl, 7);
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}
	function g1_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 19);
	  const c1_hi = rotr64_hi(xl, xh, 29); // 61
	  const c2_hi = shr64_hi(xh, xl, 6);
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}
	function g1_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 19);
	  const c1_lo = rotr64_lo(xl, xh, 29); // 61
	  const c2_lo = shr64_lo(xh, xl, 6);
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}
	function readU32(data, off) {
	  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
	}
	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha512 = SHA512;
	return sha512;
}

var wordlist = {};

var chineseSimplified;
var hasRequiredChineseSimplified;

function requireChineseSimplified () {
	if (hasRequiredChineseSimplified) return chineseSimplified;
	hasRequiredChineseSimplified = 1;

	chineseSimplified = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
	return chineseSimplified;
}

var chineseTraditional;
var hasRequiredChineseTraditional;

function requireChineseTraditional () {
	if (hasRequiredChineseTraditional) return chineseTraditional;
	hasRequiredChineseTraditional = 1;

	chineseTraditional = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
	return chineseTraditional;
}

var english;
var hasRequiredEnglish;

function requireEnglish () {
	if (hasRequiredEnglish) return english;
	hasRequiredEnglish = 1;

	english = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];
	return english;
}

var french;
var hasRequiredFrench;

function requireFrench () {
	if (hasRequiredFrench) return french;
	hasRequiredFrench = 1;

	french = ['abaisser', 'abandon', 'abdiquer', 'abeille', 'abolir', 'aborder', 'aboutir', 'aboyer', 'abrasif', 'abreuver', 'abriter', 'abroger', 'abrupt', 'absence', 'absolu', 'absurde', 'abusif', 'abyssal', 'academie', 'acajou', 'acarien', 'accabler', 'accepter', 'acclamer', 'accolade', 'accroche', 'accuser', 'acerbe', 'achat', 'acheter', 'aciduler', 'acier', 'acompte', 'acquerir', 'acronyme', 'acteur', 'actif', 'actuel', 'adepte', 'adequat', 'adhesif', 'adjectif', 'adjuger', 'admettre', 'admirer', 'adopter', 'adorer', 'adoucir', 'adresse', 'adroit', 'adulte', 'adverbe', 'aerer', 'aeronef', 'affaire', 'affecter', 'affiche', 'affreux', 'affubler', 'agacer', 'agencer', 'agile', 'agiter', 'agrafer', 'agreable', 'agrume', 'aider', 'aiguille', 'ailier', 'aimable', 'aisance', 'ajouter', 'ajuster', 'alarmer', 'alchimie', 'alerte', 'algebre', 'algue', 'aliener', 'aliment', 'alleger', 'alliage', 'allouer', 'allumer', 'alourdir', 'alpaga', 'altesse', 'alveole', 'amateur', 'ambigu', 'ambre', 'amenager', 'amertume', 'amidon', 'amiral', 'amorcer', 'amour', 'amovible', 'amphibie', 'ampleur', 'amusant', 'analyse', 'anaphore', 'anarchie', 'anatomie', 'ancien', 'aneantir', 'angle', 'angoisse', 'anguleux', 'animal', 'annexer', 'annonce', 'annuel', 'anodin', 'anomalie', 'anonyme', 'anormal', 'antenne', 'antidote', 'anxieux', 'apaiser', 'aperitif', 'aplanir', 'apologie', 'appareil', 'appeler', 'apporter', 'appuyer', 'aquarium', 'aqueduc', 'arbitre', 'arbuste', 'ardeur', 'ardoise', 'argent', 'arlequin', 'armature', 'armement', 'armoire', 'armure', 'arpenter', 'arracher', 'arriver', 'arroser', 'arsenic', 'arteriel', 'article', 'aspect', 'asphalte', 'aspirer', 'assaut', 'asservir', 'assiette', 'associer', 'assurer', 'asticot', 'astre', 'astuce', 'atelier', 'atome', 'atrium', 'atroce', 'attaque', 'attentif', 'attirer', 'attraper', 'aubaine', 'auberge', 'audace', 'audible', 'augurer', 'aurore', 'automne', 'autruche', 'avaler', 'avancer', 'avarice', 'avenir', 'averse', 'aveugle', 'aviateur', 'avide', 'avion', 'aviser', 'avoine', 'avouer', 'avril', 'axial', 'axiome', 'badge', 'bafouer', 'bagage', 'baguette', 'baignade', 'balancer', 'balcon', 'baleine', 'balisage', 'bambin', 'bancaire', 'bandage', 'banlieue', 'banniere', 'banquier', 'barbier', 'baril', 'baron', 'barque', 'barrage', 'bassin', 'bastion', 'bataille', 'bateau', 'batterie', 'baudrier', 'bavarder', 'belette', 'belier', 'belote', 'benefice', 'berceau', 'berger', 'berline', 'bermuda', 'besace', 'besogne', 'betail', 'beurre', 'biberon', 'bicycle', 'bidule', 'bijou', 'bilan', 'bilingue', 'billard', 'binaire', 'biologie', 'biopsie', 'biotype', 'biscuit', 'bison', 'bistouri', 'bitume', 'bizarre', 'blafard', 'blague', 'blanchir', 'blessant', 'blinder', 'blond', 'bloquer', 'blouson', 'bobard', 'bobine', 'boire', 'boiser', 'bolide', 'bonbon', 'bondir', 'bonheur', 'bonifier', 'bonus', 'bordure', 'borne', 'botte', 'boucle', 'boueux', 'bougie', 'boulon', 'bouquin', 'bourse', 'boussole', 'boutique', 'boxeur', 'branche', 'brasier', 'brave', 'brebis', 'breche', 'breuvage', 'bricoler', 'brigade', 'brillant', 'brioche', 'brique', 'brochure', 'broder', 'bronzer', 'brousse', 'broyeur', 'brume', 'brusque', 'brutal', 'bruyant', 'buffle', 'buisson', 'bulletin', 'bureau', 'burin', 'bustier', 'butiner', 'butoir', 'buvable', 'buvette', 'cabanon', 'cabine', 'cachette', 'cadeau', 'cadre', 'cafeine', 'caillou', 'caisson', 'calculer', 'calepin', 'calibre', 'calmer', 'calomnie', 'calvaire', 'camarade', 'camera', 'camion', 'campagne', 'canal', 'caneton', 'canon', 'cantine', 'canular', 'capable', 'caporal', 'caprice', 'capsule', 'capter', 'capuche', 'carabine', 'carbone', 'caresser', 'caribou', 'carnage', 'carotte', 'carreau', 'carton', 'cascade', 'casier', 'casque', 'cassure', 'causer', 'caution', 'cavalier', 'caverne', 'caviar', 'cedille', 'ceinture', 'celeste', 'cellule', 'cendrier', 'censurer', 'central', 'cercle', 'cerebral', 'cerise', 'cerner', 'cerveau', 'cesser', 'chagrin', 'chaise', 'chaleur', 'chambre', 'chance', 'chapitre', 'charbon', 'chasseur', 'chaton', 'chausson', 'chavirer', 'chemise', 'chenille', 'chequier', 'chercher', 'cheval', 'chien', 'chiffre', 'chignon', 'chimere', 'chiot', 'chlorure', 'chocolat', 'choisir', 'chose', 'chouette', 'chrome', 'chute', 'cigare', 'cigogne', 'cimenter', 'cinema', 'cintrer', 'circuler', 'cirer', 'cirque', 'citerne', 'citoyen', 'citron', 'civil', 'clairon', 'clameur', 'claquer', 'classe', 'clavier', 'client', 'cligner', 'climat', 'clivage', 'cloche', 'clonage', 'cloporte', 'cobalt', 'cobra', 'cocasse', 'cocotier', 'coder', 'codifier', 'coffre', 'cogner', 'cohesion', 'coiffer', 'coincer', 'colere', 'colibri', 'colline', 'colmater', 'colonel', 'combat', 'comedie', 'commande', 'compact', 'concert', 'conduire', 'confier', 'congeler', 'connoter', 'consonne', 'contact', 'convexe', 'copain', 'copie', 'corail', 'corbeau', 'cordage', 'corniche', 'corpus', 'correct', 'cortege', 'cosmique', 'costume', 'coton', 'coude', 'coupure', 'courage', 'couteau', 'couvrir', 'coyote', 'crabe', 'crainte', 'cravate', 'crayon', 'creature', 'crediter', 'cremeux', 'creuser', 'crevette', 'cribler', 'crier', 'cristal', 'critere', 'croire', 'croquer', 'crotale', 'crucial', 'cruel', 'crypter', 'cubique', 'cueillir', 'cuillere', 'cuisine', 'cuivre', 'culminer', 'cultiver', 'cumuler', 'cupide', 'curatif', 'curseur', 'cyanure', 'cycle', 'cylindre', 'cynique', 'daigner', 'damier', 'danger', 'danseur', 'dauphin', 'debattre', 'debiter', 'deborder', 'debrider', 'debutant', 'decaler', 'decembre', 'dechirer', 'decider', 'declarer', 'decorer', 'decrire', 'decupler', 'dedale', 'deductif', 'deesse', 'defensif', 'defiler', 'defrayer', 'degager', 'degivrer', 'deglutir', 'degrafer', 'dejeuner', 'delice', 'deloger', 'demander', 'demeurer', 'demolir', 'denicher', 'denouer', 'dentelle', 'denuder', 'depart', 'depenser', 'dephaser', 'deplacer', 'deposer', 'deranger', 'derober', 'desastre', 'descente', 'desert', 'designer', 'desobeir', 'dessiner', 'destrier', 'detacher', 'detester', 'detourer', 'detresse', 'devancer', 'devenir', 'deviner', 'devoir', 'diable', 'dialogue', 'diamant', 'dicter', 'differer', 'digerer', 'digital', 'digne', 'diluer', 'dimanche', 'diminuer', 'dioxyde', 'directif', 'diriger', 'discuter', 'disposer', 'dissiper', 'distance', 'divertir', 'diviser', 'docile', 'docteur', 'dogme', 'doigt', 'domaine', 'domicile', 'dompter', 'donateur', 'donjon', 'donner', 'dopamine', 'dortoir', 'dorure', 'dosage', 'doseur', 'dossier', 'dotation', 'douanier', 'double', 'douceur', 'douter', 'doyen', 'dragon', 'draper', 'dresser', 'dribbler', 'droiture', 'duperie', 'duplexe', 'durable', 'durcir', 'dynastie', 'eblouir', 'ecarter', 'echarpe', 'echelle', 'eclairer', 'eclipse', 'eclore', 'ecluse', 'ecole', 'economie', 'ecorce', 'ecouter', 'ecraser', 'ecremer', 'ecrivain', 'ecrou', 'ecume', 'ecureuil', 'edifier', 'eduquer', 'effacer', 'effectif', 'effigie', 'effort', 'effrayer', 'effusion', 'egaliser', 'egarer', 'ejecter', 'elaborer', 'elargir', 'electron', 'elegant', 'elephant', 'eleve', 'eligible', 'elitisme', 'eloge', 'elucider', 'eluder', 'emballer', 'embellir', 'embryon', 'emeraude', 'emission', 'emmener', 'emotion', 'emouvoir', 'empereur', 'employer', 'emporter', 'emprise', 'emulsion', 'encadrer', 'enchere', 'enclave', 'encoche', 'endiguer', 'endosser', 'endroit', 'enduire', 'energie', 'enfance', 'enfermer', 'enfouir', 'engager', 'engin', 'englober', 'enigme', 'enjamber', 'enjeu', 'enlever', 'ennemi', 'ennuyeux', 'enrichir', 'enrobage', 'enseigne', 'entasser', 'entendre', 'entier', 'entourer', 'entraver', 'enumerer', 'envahir', 'enviable', 'envoyer', 'enzyme', 'eolien', 'epaissir', 'epargne', 'epatant', 'epaule', 'epicerie', 'epidemie', 'epier', 'epilogue', 'epine', 'episode', 'epitaphe', 'epoque', 'epreuve', 'eprouver', 'epuisant', 'equerre', 'equipe', 'eriger', 'erosion', 'erreur', 'eruption', 'escalier', 'espadon', 'espece', 'espiegle', 'espoir', 'esprit', 'esquiver', 'essayer', 'essence', 'essieu', 'essorer', 'estime', 'estomac', 'estrade', 'etagere', 'etaler', 'etanche', 'etatique', 'eteindre', 'etendoir', 'eternel', 'ethanol', 'ethique', 'ethnie', 'etirer', 'etoffer', 'etoile', 'etonnant', 'etourdir', 'etrange', 'etroit', 'etude', 'euphorie', 'evaluer', 'evasion', 'eventail', 'evidence', 'eviter', 'evolutif', 'evoquer', 'exact', 'exagerer', 'exaucer', 'exceller', 'excitant', 'exclusif', 'excuse', 'executer', 'exemple', 'exercer', 'exhaler', 'exhorter', 'exigence', 'exiler', 'exister', 'exotique', 'expedier', 'explorer', 'exposer', 'exprimer', 'exquis', 'extensif', 'extraire', 'exulter', 'fable', 'fabuleux', 'facette', 'facile', 'facture', 'faiblir', 'falaise', 'fameux', 'famille', 'farceur', 'farfelu', 'farine', 'farouche', 'fasciner', 'fatal', 'fatigue', 'faucon', 'fautif', 'faveur', 'favori', 'febrile', 'feconder', 'federer', 'felin', 'femme', 'femur', 'fendoir', 'feodal', 'fermer', 'feroce', 'ferveur', 'festival', 'feuille', 'feutre', 'fevrier', 'fiasco', 'ficeler', 'fictif', 'fidele', 'figure', 'filature', 'filetage', 'filiere', 'filleul', 'filmer', 'filou', 'filtrer', 'financer', 'finir', 'fiole', 'firme', 'fissure', 'fixer', 'flairer', 'flamme', 'flasque', 'flatteur', 'fleau', 'fleche', 'fleur', 'flexion', 'flocon', 'flore', 'fluctuer', 'fluide', 'fluvial', 'folie', 'fonderie', 'fongible', 'fontaine', 'forcer', 'forgeron', 'formuler', 'fortune', 'fossile', 'foudre', 'fougere', 'fouiller', 'foulure', 'fourmi', 'fragile', 'fraise', 'franchir', 'frapper', 'frayeur', 'fregate', 'freiner', 'frelon', 'fremir', 'frenesie', 'frere', 'friable', 'friction', 'frisson', 'frivole', 'froid', 'fromage', 'frontal', 'frotter', 'fruit', 'fugitif', 'fuite', 'fureur', 'furieux', 'furtif', 'fusion', 'futur', 'gagner', 'galaxie', 'galerie', 'gambader', 'garantir', 'gardien', 'garnir', 'garrigue', 'gazelle', 'gazon', 'geant', 'gelatine', 'gelule', 'gendarme', 'general', 'genie', 'genou', 'gentil', 'geologie', 'geometre', 'geranium', 'germe', 'gestuel', 'geyser', 'gibier', 'gicler', 'girafe', 'givre', 'glace', 'glaive', 'glisser', 'globe', 'gloire', 'glorieux', 'golfeur', 'gomme', 'gonfler', 'gorge', 'gorille', 'goudron', 'gouffre', 'goulot', 'goupille', 'gourmand', 'goutte', 'graduel', 'graffiti', 'graine', 'grand', 'grappin', 'gratuit', 'gravir', 'grenat', 'griffure', 'griller', 'grimper', 'grogner', 'gronder', 'grotte', 'groupe', 'gruger', 'grutier', 'gruyere', 'guepard', 'guerrier', 'guide', 'guimauve', 'guitare', 'gustatif', 'gymnaste', 'gyrostat', 'habitude', 'hachoir', 'halte', 'hameau', 'hangar', 'hanneton', 'haricot', 'harmonie', 'harpon', 'hasard', 'helium', 'hematome', 'herbe', 'herisson', 'hermine', 'heron', 'hesiter', 'heureux', 'hiberner', 'hibou', 'hilarant', 'histoire', 'hiver', 'homard', 'hommage', 'homogene', 'honneur', 'honorer', 'honteux', 'horde', 'horizon', 'horloge', 'hormone', 'horrible', 'houleux', 'housse', 'hublot', 'huileux', 'humain', 'humble', 'humide', 'humour', 'hurler', 'hydromel', 'hygiene', 'hymne', 'hypnose', 'idylle', 'ignorer', 'iguane', 'illicite', 'illusion', 'image', 'imbiber', 'imiter', 'immense', 'immobile', 'immuable', 'impact', 'imperial', 'implorer', 'imposer', 'imprimer', 'imputer', 'incarner', 'incendie', 'incident', 'incliner', 'incolore', 'indexer', 'indice', 'inductif', 'inedit', 'ineptie', 'inexact', 'infini', 'infliger', 'informer', 'infusion', 'ingerer', 'inhaler', 'inhiber', 'injecter', 'injure', 'innocent', 'inoculer', 'inonder', 'inscrire', 'insecte', 'insigne', 'insolite', 'inspirer', 'instinct', 'insulter', 'intact', 'intense', 'intime', 'intrigue', 'intuitif', 'inutile', 'invasion', 'inventer', 'inviter', 'invoquer', 'ironique', 'irradier', 'irreel', 'irriter', 'isoler', 'ivoire', 'ivresse', 'jaguar', 'jaillir', 'jambe', 'janvier', 'jardin', 'jauger', 'jaune', 'javelot', 'jetable', 'jeton', 'jeudi', 'jeunesse', 'joindre', 'joncher', 'jongler', 'joueur', 'jouissif', 'journal', 'jovial', 'joyau', 'joyeux', 'jubiler', 'jugement', 'junior', 'jupon', 'juriste', 'justice', 'juteux', 'juvenile', 'kayak', 'kimono', 'kiosque', 'label', 'labial', 'labourer', 'lacerer', 'lactose', 'lagune', 'laine', 'laisser', 'laitier', 'lambeau', 'lamelle', 'lampe', 'lanceur', 'langage', 'lanterne', 'lapin', 'largeur', 'larme', 'laurier', 'lavabo', 'lavoir', 'lecture', 'legal', 'leger', 'legume', 'lessive', 'lettre', 'levier', 'lexique', 'lezard', 'liasse', 'liberer', 'libre', 'licence', 'licorne', 'liege', 'lievre', 'ligature', 'ligoter', 'ligue', 'limer', 'limite', 'limonade', 'limpide', 'lineaire', 'lingot', 'lionceau', 'liquide', 'lisiere', 'lister', 'lithium', 'litige', 'littoral', 'livreur', 'logique', 'lointain', 'loisir', 'lombric', 'loterie', 'louer', 'lourd', 'loutre', 'louve', 'loyal', 'lubie', 'lucide', 'lucratif', 'lueur', 'lugubre', 'luisant', 'lumiere', 'lunaire', 'lundi', 'luron', 'lutter', 'luxueux', 'machine', 'magasin', 'magenta', 'magique', 'maigre', 'maillon', 'maintien', 'mairie', 'maison', 'majorer', 'malaxer', 'malefice', 'malheur', 'malice', 'mallette', 'mammouth', 'mandater', 'maniable', 'manquant', 'manteau', 'manuel', 'marathon', 'marbre', 'marchand', 'mardi', 'maritime', 'marqueur', 'marron', 'marteler', 'mascotte', 'massif', 'materiel', 'matiere', 'matraque', 'maudire', 'maussade', 'mauve', 'maximal', 'mechant', 'meconnu', 'medaille', 'medecin', 'mediter', 'meduse', 'meilleur', 'melange', 'melodie', 'membre', 'memoire', 'menacer', 'mener', 'menhir', 'mensonge', 'mentor', 'mercredi', 'merite', 'merle', 'messager', 'mesure', 'metal', 'meteore', 'methode', 'metier', 'meuble', 'miauler', 'microbe', 'miette', 'mignon', 'migrer', 'milieu', 'million', 'mimique', 'mince', 'mineral', 'minimal', 'minorer', 'minute', 'miracle', 'miroiter', 'missile', 'mixte', 'mobile', 'moderne', 'moelleux', 'mondial', 'moniteur', 'monnaie', 'monotone', 'monstre', 'montagne', 'monument', 'moqueur', 'morceau', 'morsure', 'mortier', 'moteur', 'motif', 'mouche', 'moufle', 'moulin', 'mousson', 'mouton', 'mouvant', 'multiple', 'munition', 'muraille', 'murene', 'murmure', 'muscle', 'museum', 'musicien', 'mutation', 'muter', 'mutuel', 'myriade', 'myrtille', 'mystere', 'mythique', 'nageur', 'nappe', 'narquois', 'narrer', 'natation', 'nation', 'nature', 'naufrage', 'nautique', 'navire', 'nebuleux', 'nectar', 'nefaste', 'negation', 'negliger', 'negocier', 'neige', 'nerveux', 'nettoyer', 'neurone', 'neutron', 'neveu', 'niche', 'nickel', 'nitrate', 'niveau', 'noble', 'nocif', 'nocturne', 'noirceur', 'noisette', 'nomade', 'nombreux', 'nommer', 'normatif', 'notable', 'notifier', 'notoire', 'nourrir', 'nouveau', 'novateur', 'novembre', 'novice', 'nuage', 'nuancer', 'nuire', 'nuisible', 'numero', 'nuptial', 'nuque', 'nutritif', 'obeir', 'objectif', 'obliger', 'obscur', 'observer', 'obstacle', 'obtenir', 'obturer', 'occasion', 'occuper', 'ocean', 'octobre', 'octroyer', 'octupler', 'oculaire', 'odeur', 'odorant', 'offenser', 'officier', 'offrir', 'ogive', 'oiseau', 'oisillon', 'olfactif', 'olivier', 'ombrage', 'omettre', 'onctueux', 'onduler', 'onereux', 'onirique', 'opale', 'opaque', 'operer', 'opinion', 'opportun', 'opprimer', 'opter', 'optique', 'orageux', 'orange', 'orbite', 'ordonner', 'oreille', 'organe', 'orgueil', 'orifice', 'ornement', 'orque', 'ortie', 'osciller', 'osmose', 'ossature', 'otarie', 'ouragan', 'ourson', 'outil', 'outrager', 'ouvrage', 'ovation', 'oxyde', 'oxygene', 'ozone', 'paisible', 'palace', 'palmares', 'palourde', 'palper', 'panache', 'panda', 'pangolin', 'paniquer', 'panneau', 'panorama', 'pantalon', 'papaye', 'papier', 'papoter', 'papyrus', 'paradoxe', 'parcelle', 'paresse', 'parfumer', 'parler', 'parole', 'parrain', 'parsemer', 'partager', 'parure', 'parvenir', 'passion', 'pasteque', 'paternel', 'patience', 'patron', 'pavillon', 'pavoiser', 'payer', 'paysage', 'peigne', 'peintre', 'pelage', 'pelican', 'pelle', 'pelouse', 'peluche', 'pendule', 'penetrer', 'penible', 'pensif', 'penurie', 'pepite', 'peplum', 'perdrix', 'perforer', 'periode', 'permuter', 'perplexe', 'persil', 'perte', 'peser', 'petale', 'petit', 'petrir', 'peuple', 'pharaon', 'phobie', 'phoque', 'photon', 'phrase', 'physique', 'piano', 'pictural', 'piece', 'pierre', 'pieuvre', 'pilote', 'pinceau', 'pipette', 'piquer', 'pirogue', 'piscine', 'piston', 'pivoter', 'pixel', 'pizza', 'placard', 'plafond', 'plaisir', 'planer', 'plaque', 'plastron', 'plateau', 'pleurer', 'plexus', 'pliage', 'plomb', 'plonger', 'pluie', 'plumage', 'pochette', 'poesie', 'poete', 'pointe', 'poirier', 'poisson', 'poivre', 'polaire', 'policier', 'pollen', 'polygone', 'pommade', 'pompier', 'ponctuel', 'ponderer', 'poney', 'portique', 'position', 'posseder', 'posture', 'potager', 'poteau', 'potion', 'pouce', 'poulain', 'poumon', 'pourpre', 'poussin', 'pouvoir', 'prairie', 'pratique', 'precieux', 'predire', 'prefixe', 'prelude', 'prenom', 'presence', 'pretexte', 'prevoir', 'primitif', 'prince', 'prison', 'priver', 'probleme', 'proceder', 'prodige', 'profond', 'progres', 'proie', 'projeter', 'prologue', 'promener', 'propre', 'prospere', 'proteger', 'prouesse', 'proverbe', 'prudence', 'pruneau', 'psychose', 'public', 'puceron', 'puiser', 'pulpe', 'pulsar', 'punaise', 'punitif', 'pupitre', 'purifier', 'puzzle', 'pyramide', 'quasar', 'querelle', 'question', 'quietude', 'quitter', 'quotient', 'racine', 'raconter', 'radieux', 'ragondin', 'raideur', 'raisin', 'ralentir', 'rallonge', 'ramasser', 'rapide', 'rasage', 'ratisser', 'ravager', 'ravin', 'rayonner', 'reactif', 'reagir', 'realiser', 'reanimer', 'recevoir', 'reciter', 'reclamer', 'recolter', 'recruter', 'reculer', 'recycler', 'rediger', 'redouter', 'refaire', 'reflexe', 'reformer', 'refrain', 'refuge', 'regalien', 'region', 'reglage', 'regulier', 'reiterer', 'rejeter', 'rejouer', 'relatif', 'relever', 'relief', 'remarque', 'remede', 'remise', 'remonter', 'remplir', 'remuer', 'renard', 'renfort', 'renifler', 'renoncer', 'rentrer', 'renvoi', 'replier', 'reporter', 'reprise', 'reptile', 'requin', 'reserve', 'resineux', 'resoudre', 'respect', 'rester', 'resultat', 'retablir', 'retenir', 'reticule', 'retomber', 'retracer', 'reunion', 'reussir', 'revanche', 'revivre', 'revolte', 'revulsif', 'richesse', 'rideau', 'rieur', 'rigide', 'rigoler', 'rincer', 'riposter', 'risible', 'risque', 'rituel', 'rival', 'riviere', 'rocheux', 'romance', 'rompre', 'ronce', 'rondin', 'roseau', 'rosier', 'rotatif', 'rotor', 'rotule', 'rouge', 'rouille', 'rouleau', 'routine', 'royaume', 'ruban', 'rubis', 'ruche', 'ruelle', 'rugueux', 'ruiner', 'ruisseau', 'ruser', 'rustique', 'rythme', 'sabler', 'saboter', 'sabre', 'sacoche', 'safari', 'sagesse', 'saisir', 'salade', 'salive', 'salon', 'saluer', 'samedi', 'sanction', 'sanglier', 'sarcasme', 'sardine', 'saturer', 'saugrenu', 'saumon', 'sauter', 'sauvage', 'savant', 'savonner', 'scalpel', 'scandale', 'scelerat', 'scenario', 'sceptre', 'schema', 'science', 'scinder', 'score', 'scrutin', 'sculpter', 'seance', 'secable', 'secher', 'secouer', 'secreter', 'sedatif', 'seduire', 'seigneur', 'sejour', 'selectif', 'semaine', 'sembler', 'semence', 'seminal', 'senateur', 'sensible', 'sentence', 'separer', 'sequence', 'serein', 'sergent', 'serieux', 'serrure', 'serum', 'service', 'sesame', 'sevir', 'sevrage', 'sextuple', 'sideral', 'siecle', 'sieger', 'siffler', 'sigle', 'signal', 'silence', 'silicium', 'simple', 'sincere', 'sinistre', 'siphon', 'sirop', 'sismique', 'situer', 'skier', 'social', 'socle', 'sodium', 'soigneux', 'soldat', 'soleil', 'solitude', 'soluble', 'sombre', 'sommeil', 'somnoler', 'sonde', 'songeur', 'sonnette', 'sonore', 'sorcier', 'sortir', 'sosie', 'sottise', 'soucieux', 'soudure', 'souffle', 'soulever', 'soupape', 'source', 'soutirer', 'souvenir', 'spacieux', 'spatial', 'special', 'sphere', 'spiral', 'stable', 'station', 'sternum', 'stimulus', 'stipuler', 'strict', 'studieux', 'stupeur', 'styliste', 'sublime', 'substrat', 'subtil', 'subvenir', 'succes', 'sucre', 'suffixe', 'suggerer', 'suiveur', 'sulfate', 'superbe', 'supplier', 'surface', 'suricate', 'surmener', 'surprise', 'sursaut', 'survie', 'suspect', 'syllabe', 'symbole', 'symetrie', 'synapse', 'syntaxe', 'systeme', 'tabac', 'tablier', 'tactile', 'tailler', 'talent', 'talisman', 'talonner', 'tambour', 'tamiser', 'tangible', 'tapis', 'taquiner', 'tarder', 'tarif', 'tartine', 'tasse', 'tatami', 'tatouage', 'taupe', 'taureau', 'taxer', 'temoin', 'temporel', 'tenaille', 'tendre', 'teneur', 'tenir', 'tension', 'terminer', 'terne', 'terrible', 'tetine', 'texte', 'theme', 'theorie', 'therapie', 'thorax', 'tibia', 'tiede', 'timide', 'tirelire', 'tiroir', 'tissu', 'titane', 'titre', 'tituber', 'toboggan', 'tolerant', 'tomate', 'tonique', 'tonneau', 'toponyme', 'torche', 'tordre', 'tornade', 'torpille', 'torrent', 'torse', 'tortue', 'totem', 'toucher', 'tournage', 'tousser', 'toxine', 'traction', 'trafic', 'tragique', 'trahir', 'train', 'trancher', 'travail', 'trefle', 'tremper', 'tresor', 'treuil', 'triage', 'tribunal', 'tricoter', 'trilogie', 'triomphe', 'tripler', 'triturer', 'trivial', 'trombone', 'tronc', 'tropical', 'troupeau', 'tuile', 'tulipe', 'tumulte', 'tunnel', 'turbine', 'tuteur', 'tutoyer', 'tuyau', 'tympan', 'typhon', 'typique', 'tyran', 'ubuesque', 'ultime', 'ultrason', 'unanime', 'unifier', 'union', 'unique', 'unitaire', 'univers', 'uranium', 'urbain', 'urticant', 'usage', 'usine', 'usuel', 'usure', 'utile', 'utopie', 'vacarme', 'vaccin', 'vagabond', 'vague', 'vaillant', 'vaincre', 'vaisseau', 'valable', 'valise', 'vallon', 'valve', 'vampire', 'vanille', 'vapeur', 'varier', 'vaseux', 'vassal', 'vaste', 'vecteur', 'vedette', 'vegetal', 'vehicule', 'veinard', 'veloce', 'vendredi', 'venerer', 'venger', 'venimeux', 'ventouse', 'verdure', 'verin', 'vernir', 'verrou', 'verser', 'vertu', 'veston', 'veteran', 'vetuste', 'vexant', 'vexer', 'viaduc', 'viande', 'victoire', 'vidange', 'video', 'vignette', 'vigueur', 'vilain', 'village', 'vinaigre', 'violon', 'vipere', 'virement', 'virtuose', 'virus', 'visage', 'viseur', 'vision', 'visqueux', 'visuel', 'vital', 'vitesse', 'viticole', 'vitrine', 'vivace', 'vivipare', 'vocation', 'voguer', 'voile', 'voisin', 'voiture', 'volaille', 'volcan', 'voltiger', 'volume', 'vorace', 'vortex', 'voter', 'vouloir', 'voyage', 'voyelle', 'wagon', 'xenon', 'yacht', 'zebre', 'zenith', 'zeste', 'zoologie'];
	return french;
}

var italian;
var hasRequiredItalian;

function requireItalian () {
	if (hasRequiredItalian) return italian;
	hasRequiredItalian = 1;

	italian = ['abaco', 'abbaglio', 'abbinato', 'abete', 'abisso', 'abolire', 'abrasivo', 'abrogato', 'accadere', 'accenno', 'accusato', 'acetone', 'achille', 'acido', 'acqua', 'acre', 'acrilico', 'acrobata', 'acuto', 'adagio', 'addebito', 'addome', 'adeguato', 'aderire', 'adipe', 'adottare', 'adulare', 'affabile', 'affetto', 'affisso', 'affranto', 'aforisma', 'afoso', 'africano', 'agave', 'agente', 'agevole', 'aggancio', 'agire', 'agitare', 'agonismo', 'agricolo', 'agrumeto', 'aguzzo', 'alabarda', 'alato', 'albatro', 'alberato', 'albo', 'albume', 'alce', 'alcolico', 'alettone', 'alfa', 'algebra', 'aliante', 'alibi', 'alimento', 'allagato', 'allegro', 'allievo', 'allodola', 'allusivo', 'almeno', 'alogeno', 'alpaca', 'alpestre', 'altalena', 'alterno', 'alticcio', 'altrove', 'alunno', 'alveolo', 'alzare', 'amalgama', 'amanita', 'amarena', 'ambito', 'ambrato', 'ameba', 'america', 'ametista', 'amico', 'ammasso', 'ammenda', 'ammirare', 'ammonito', 'amore', 'ampio', 'ampliare', 'amuleto', 'anacardo', 'anagrafe', 'analista', 'anarchia', 'anatra', 'anca', 'ancella', 'ancora', 'andare', 'andrea', 'anello', 'angelo', 'angolare', 'angusto', 'anima', 'annegare', 'annidato', 'anno', 'annuncio', 'anonimo', 'anticipo', 'anzi', 'apatico', 'apertura', 'apode', 'apparire', 'appetito', 'appoggio', 'approdo', 'appunto', 'aprile', 'arabica', 'arachide', 'aragosta', 'araldica', 'arancio', 'aratura', 'arazzo', 'arbitro', 'archivio', 'ardito', 'arenile', 'argento', 'argine', 'arguto', 'aria', 'armonia', 'arnese', 'arredato', 'arringa', 'arrosto', 'arsenico', 'arso', 'artefice', 'arzillo', 'asciutto', 'ascolto', 'asepsi', 'asettico', 'asfalto', 'asino', 'asola', 'aspirato', 'aspro', 'assaggio', 'asse', 'assoluto', 'assurdo', 'asta', 'astenuto', 'astice', 'astratto', 'atavico', 'ateismo', 'atomico', 'atono', 'attesa', 'attivare', 'attorno', 'attrito', 'attuale', 'ausilio', 'austria', 'autista', 'autonomo', 'autunno', 'avanzato', 'avere', 'avvenire', 'avviso', 'avvolgere', 'azione', 'azoto', 'azzimo', 'azzurro', 'babele', 'baccano', 'bacino', 'baco', 'badessa', 'badilata', 'bagnato', 'baita', 'balcone', 'baldo', 'balena', 'ballata', 'balzano', 'bambino', 'bandire', 'baraonda', 'barbaro', 'barca', 'baritono', 'barlume', 'barocco', 'basilico', 'basso', 'batosta', 'battuto', 'baule', 'bava', 'bavosa', 'becco', 'beffa', 'belgio', 'belva', 'benda', 'benevole', 'benigno', 'benzina', 'bere', 'berlina', 'beta', 'bibita', 'bici', 'bidone', 'bifido', 'biga', 'bilancia', 'bimbo', 'binocolo', 'biologo', 'bipede', 'bipolare', 'birbante', 'birra', 'biscotto', 'bisesto', 'bisnonno', 'bisonte', 'bisturi', 'bizzarro', 'blando', 'blatta', 'bollito', 'bonifico', 'bordo', 'bosco', 'botanico', 'bottino', 'bozzolo', 'braccio', 'bradipo', 'brama', 'branca', 'bravura', 'bretella', 'brevetto', 'brezza', 'briglia', 'brillante', 'brindare', 'broccolo', 'brodo', 'bronzina', 'brullo', 'bruno', 'bubbone', 'buca', 'budino', 'buffone', 'buio', 'bulbo', 'buono', 'burlone', 'burrasca', 'bussola', 'busta', 'cadetto', 'caduco', 'calamaro', 'calcolo', 'calesse', 'calibro', 'calmo', 'caloria', 'cambusa', 'camerata', 'camicia', 'cammino', 'camola', 'campale', 'canapa', 'candela', 'cane', 'canino', 'canotto', 'cantina', 'capace', 'capello', 'capitolo', 'capogiro', 'cappero', 'capra', 'capsula', 'carapace', 'carcassa', 'cardo', 'carisma', 'carovana', 'carretto', 'cartolina', 'casaccio', 'cascata', 'caserma', 'caso', 'cassone', 'castello', 'casuale', 'catasta', 'catena', 'catrame', 'cauto', 'cavillo', 'cedibile', 'cedrata', 'cefalo', 'celebre', 'cellulare', 'cena', 'cenone', 'centesimo', 'ceramica', 'cercare', 'certo', 'cerume', 'cervello', 'cesoia', 'cespo', 'ceto', 'chela', 'chiaro', 'chicca', 'chiedere', 'chimera', 'china', 'chirurgo', 'chitarra', 'ciao', 'ciclismo', 'cifrare', 'cigno', 'cilindro', 'ciottolo', 'circa', 'cirrosi', 'citrico', 'cittadino', 'ciuffo', 'civetta', 'civile', 'classico', 'clinica', 'cloro', 'cocco', 'codardo', 'codice', 'coerente', 'cognome', 'collare', 'colmato', 'colore', 'colposo', 'coltivato', 'colza', 'coma', 'cometa', 'commando', 'comodo', 'computer', 'comune', 'conciso', 'condurre', 'conferma', 'congelare', 'coniuge', 'connesso', 'conoscere', 'consumo', 'continuo', 'convegno', 'coperto', 'copione', 'coppia', 'copricapo', 'corazza', 'cordata', 'coricato', 'cornice', 'corolla', 'corpo', 'corredo', 'corsia', 'cortese', 'cosmico', 'costante', 'cottura', 'covato', 'cratere', 'cravatta', 'creato', 'credere', 'cremoso', 'crescita', 'creta', 'criceto', 'crinale', 'crisi', 'critico', 'croce', 'cronaca', 'crostata', 'cruciale', 'crusca', 'cucire', 'cuculo', 'cugino', 'cullato', 'cupola', 'curatore', 'cursore', 'curvo', 'cuscino', 'custode', 'dado', 'daino', 'dalmata', 'damerino', 'daniela', 'dannoso', 'danzare', 'datato', 'davanti', 'davvero', 'debutto', 'decennio', 'deciso', 'declino', 'decollo', 'decreto', 'dedicato', 'definito', 'deforme', 'degno', 'delegare', 'delfino', 'delirio', 'delta', 'demenza', 'denotato', 'dentro', 'deposito', 'derapata', 'derivare', 'deroga', 'descritto', 'deserto', 'desiderio', 'desumere', 'detersivo', 'devoto', 'diametro', 'dicembre', 'diedro', 'difeso', 'diffuso', 'digerire', 'digitale', 'diluvio', 'dinamico', 'dinnanzi', 'dipinto', 'diploma', 'dipolo', 'diradare', 'dire', 'dirotto', 'dirupo', 'disagio', 'discreto', 'disfare', 'disgelo', 'disposto', 'distanza', 'disumano', 'dito', 'divano', 'divelto', 'dividere', 'divorato', 'doblone', 'docente', 'doganale', 'dogma', 'dolce', 'domato', 'domenica', 'dominare', 'dondolo', 'dono', 'dormire', 'dote', 'dottore', 'dovuto', 'dozzina', 'drago', 'druido', 'dubbio', 'dubitare', 'ducale', 'duna', 'duomo', 'duplice', 'duraturo', 'ebano', 'eccesso', 'ecco', 'eclissi', 'economia', 'edera', 'edicola', 'edile', 'editoria', 'educare', 'egemonia', 'egli', 'egoismo', 'egregio', 'elaborato', 'elargire', 'elegante', 'elencato', 'eletto', 'elevare', 'elfico', 'elica', 'elmo', 'elsa', 'eluso', 'emanato', 'emblema', 'emesso', 'emiro', 'emotivo', 'emozione', 'empirico', 'emulo', 'endemico', 'enduro', 'energia', 'enfasi', 'enoteca', 'entrare', 'enzima', 'epatite', 'epilogo', 'episodio', 'epocale', 'eppure', 'equatore', 'erario', 'erba', 'erboso', 'erede', 'eremita', 'erigere', 'ermetico', 'eroe', 'erosivo', 'errante', 'esagono', 'esame', 'esanime', 'esaudire', 'esca', 'esempio', 'esercito', 'esibito', 'esigente', 'esistere', 'esito', 'esofago', 'esortato', 'esoso', 'espanso', 'espresso', 'essenza', 'esso', 'esteso', 'estimare', 'estonia', 'estroso', 'esultare', 'etilico', 'etnico', 'etrusco', 'etto', 'euclideo', 'europa', 'evaso', 'evidenza', 'evitato', 'evoluto', 'evviva', 'fabbrica', 'faccenda', 'fachiro', 'falco', 'famiglia', 'fanale', 'fanfara', 'fango', 'fantasma', 'fare', 'farfalla', 'farinoso', 'farmaco', 'fascia', 'fastoso', 'fasullo', 'faticare', 'fato', 'favoloso', 'febbre', 'fecola', 'fede', 'fegato', 'felpa', 'feltro', 'femmina', 'fendere', 'fenomeno', 'fermento', 'ferro', 'fertile', 'fessura', 'festivo', 'fetta', 'feudo', 'fiaba', 'fiducia', 'fifa', 'figurato', 'filo', 'finanza', 'finestra', 'finire', 'fiore', 'fiscale', 'fisico', 'fiume', 'flacone', 'flamenco', 'flebo', 'flemma', 'florido', 'fluente', 'fluoro', 'fobico', 'focaccia', 'focoso', 'foderato', 'foglio', 'folata', 'folclore', 'folgore', 'fondente', 'fonetico', 'fonia', 'fontana', 'forbito', 'forchetta', 'foresta', 'formica', 'fornaio', 'foro', 'fortezza', 'forzare', 'fosfato', 'fosso', 'fracasso', 'frana', 'frassino', 'fratello', 'freccetta', 'frenata', 'fresco', 'frigo', 'frollino', 'fronde', 'frugale', 'frutta', 'fucilata', 'fucsia', 'fuggente', 'fulmine', 'fulvo', 'fumante', 'fumetto', 'fumoso', 'fune', 'funzione', 'fuoco', 'furbo', 'furgone', 'furore', 'fuso', 'futile', 'gabbiano', 'gaffe', 'galateo', 'gallina', 'galoppo', 'gambero', 'gamma', 'garanzia', 'garbo', 'garofano', 'garzone', 'gasdotto', 'gasolio', 'gastrico', 'gatto', 'gaudio', 'gazebo', 'gazzella', 'geco', 'gelatina', 'gelso', 'gemello', 'gemmato', 'gene', 'genitore', 'gennaio', 'genotipo', 'gergo', 'ghepardo', 'ghiaccio', 'ghisa', 'giallo', 'gilda', 'ginepro', 'giocare', 'gioiello', 'giorno', 'giove', 'girato', 'girone', 'gittata', 'giudizio', 'giurato', 'giusto', 'globulo', 'glutine', 'gnomo', 'gobba', 'golf', 'gomito', 'gommone', 'gonfio', 'gonna', 'governo', 'gracile', 'grado', 'grafico', 'grammo', 'grande', 'grattare', 'gravoso', 'grazia', 'greca', 'gregge', 'grifone', 'grigio', 'grinza', 'grotta', 'gruppo', 'guadagno', 'guaio', 'guanto', 'guardare', 'gufo', 'guidare', 'ibernato', 'icona', 'identico', 'idillio', 'idolo', 'idra', 'idrico', 'idrogeno', 'igiene', 'ignaro', 'ignorato', 'ilare', 'illeso', 'illogico', 'illudere', 'imballo', 'imbevuto', 'imbocco', 'imbuto', 'immane', 'immerso', 'immolato', 'impacco', 'impeto', 'impiego', 'importo', 'impronta', 'inalare', 'inarcare', 'inattivo', 'incanto', 'incendio', 'inchino', 'incisivo', 'incluso', 'incontro', 'incrocio', 'incubo', 'indagine', 'india', 'indole', 'inedito', 'infatti', 'infilare', 'inflitto', 'ingaggio', 'ingegno', 'inglese', 'ingordo', 'ingrosso', 'innesco', 'inodore', 'inoltrare', 'inondato', 'insano', 'insetto', 'insieme', 'insonnia', 'insulina', 'intasato', 'intero', 'intonaco', 'intuito', 'inumidire', 'invalido', 'invece', 'invito', 'iperbole', 'ipnotico', 'ipotesi', 'ippica', 'iride', 'irlanda', 'ironico', 'irrigato', 'irrorare', 'isolato', 'isotopo', 'isterico', 'istituto', 'istrice', 'italia', 'iterare', 'labbro', 'labirinto', 'lacca', 'lacerato', 'lacrima', 'lacuna', 'laddove', 'lago', 'lampo', 'lancetta', 'lanterna', 'lardoso', 'larga', 'laringe', 'lastra', 'latenza', 'latino', 'lattuga', 'lavagna', 'lavoro', 'legale', 'leggero', 'lembo', 'lentezza', 'lenza', 'leone', 'lepre', 'lesivo', 'lessato', 'lesto', 'letterale', 'leva', 'levigato', 'libero', 'lido', 'lievito', 'lilla', 'limatura', 'limitare', 'limpido', 'lineare', 'lingua', 'liquido', 'lira', 'lirica', 'lisca', 'lite', 'litigio', 'livrea', 'locanda', 'lode', 'logica', 'lombare', 'londra', 'longevo', 'loquace', 'lorenzo', 'loto', 'lotteria', 'luce', 'lucidato', 'lumaca', 'luminoso', 'lungo', 'lupo', 'luppolo', 'lusinga', 'lusso', 'lutto', 'macabro', 'macchina', 'macero', 'macinato', 'madama', 'magico', 'maglia', 'magnete', 'magro', 'maiolica', 'malafede', 'malgrado', 'malinteso', 'malsano', 'malto', 'malumore', 'mana', 'mancia', 'mandorla', 'mangiare', 'manifesto', 'mannaro', 'manovra', 'mansarda', 'mantide', 'manubrio', 'mappa', 'maratona', 'marcire', 'maretta', 'marmo', 'marsupio', 'maschera', 'massaia', 'mastino', 'materasso', 'matricola', 'mattone', 'maturo', 'mazurca', 'meandro', 'meccanico', 'mecenate', 'medesimo', 'meditare', 'mega', 'melassa', 'melis', 'melodia', 'meninge', 'meno', 'mensola', 'mercurio', 'merenda', 'merlo', 'meschino', 'mese', 'messere', 'mestolo', 'metallo', 'metodo', 'mettere', 'miagolare', 'mica', 'micelio', 'michele', 'microbo', 'midollo', 'miele', 'migliore', 'milano', 'milite', 'mimosa', 'minerale', 'mini', 'minore', 'mirino', 'mirtillo', 'miscela', 'missiva', 'misto', 'misurare', 'mitezza', 'mitigare', 'mitra', 'mittente', 'mnemonico', 'modello', 'modifica', 'modulo', 'mogano', 'mogio', 'mole', 'molosso', 'monastero', 'monco', 'mondina', 'monetario', 'monile', 'monotono', 'monsone', 'montato', 'monviso', 'mora', 'mordere', 'morsicato', 'mostro', 'motivato', 'motosega', 'motto', 'movenza', 'movimento', 'mozzo', 'mucca', 'mucosa', 'muffa', 'mughetto', 'mugnaio', 'mulatto', 'mulinello', 'multiplo', 'mummia', 'munto', 'muovere', 'murale', 'musa', 'muscolo', 'musica', 'mutevole', 'muto', 'nababbo', 'nafta', 'nanometro', 'narciso', 'narice', 'narrato', 'nascere', 'nastrare', 'naturale', 'nautica', 'naviglio', 'nebulosa', 'necrosi', 'negativo', 'negozio', 'nemmeno', 'neofita', 'neretto', 'nervo', 'nessuno', 'nettuno', 'neutrale', 'neve', 'nevrotico', 'nicchia', 'ninfa', 'nitido', 'nobile', 'nocivo', 'nodo', 'nome', 'nomina', 'nordico', 'normale', 'norvegese', 'nostrano', 'notare', 'notizia', 'notturno', 'novella', 'nucleo', 'nulla', 'numero', 'nuovo', 'nutrire', 'nuvola', 'nuziale', 'oasi', 'obbedire', 'obbligo', 'obelisco', 'oblio', 'obolo', 'obsoleto', 'occasione', 'occhio', 'occidente', 'occorrere', 'occultare', 'ocra', 'oculato', 'odierno', 'odorare', 'offerta', 'offrire', 'offuscato', 'oggetto', 'oggi', 'ognuno', 'olandese', 'olfatto', 'oliato', 'oliva', 'ologramma', 'oltre', 'omaggio', 'ombelico', 'ombra', 'omega', 'omissione', 'ondoso', 'onere', 'onice', 'onnivoro', 'onorevole', 'onta', 'operato', 'opinione', 'opposto', 'oracolo', 'orafo', 'ordine', 'orecchino', 'orefice', 'orfano', 'organico', 'origine', 'orizzonte', 'orma', 'ormeggio', 'ornativo', 'orologio', 'orrendo', 'orribile', 'ortensia', 'ortica', 'orzata', 'orzo', 'osare', 'oscurare', 'osmosi', 'ospedale', 'ospite', 'ossa', 'ossidare', 'ostacolo', 'oste', 'otite', 'otre', 'ottagono', 'ottimo', 'ottobre', 'ovale', 'ovest', 'ovino', 'oviparo', 'ovocito', 'ovunque', 'ovviare', 'ozio', 'pacchetto', 'pace', 'pacifico', 'padella', 'padrone', 'paese', 'paga', 'pagina', 'palazzina', 'palesare', 'pallido', 'palo', 'palude', 'pandoro', 'pannello', 'paolo', 'paonazzo', 'paprica', 'parabola', 'parcella', 'parere', 'pargolo', 'pari', 'parlato', 'parola', 'partire', 'parvenza', 'parziale', 'passivo', 'pasticca', 'patacca', 'patologia', 'pattume', 'pavone', 'peccato', 'pedalare', 'pedonale', 'peggio', 'peloso', 'penare', 'pendice', 'penisola', 'pennuto', 'penombra', 'pensare', 'pentola', 'pepe', 'pepita', 'perbene', 'percorso', 'perdonato', 'perforare', 'pergamena', 'periodo', 'permesso', 'perno', 'perplesso', 'persuaso', 'pertugio', 'pervaso', 'pesatore', 'pesista', 'peso', 'pestifero', 'petalo', 'pettine', 'petulante', 'pezzo', 'piacere', 'pianta', 'piattino', 'piccino', 'picozza', 'piega', 'pietra', 'piffero', 'pigiama', 'pigolio', 'pigro', 'pila', 'pilifero', 'pillola', 'pilota', 'pimpante', 'pineta', 'pinna', 'pinolo', 'pioggia', 'piombo', 'piramide', 'piretico', 'pirite', 'pirolisi', 'pitone', 'pizzico', 'placebo', 'planare', 'plasma', 'platano', 'plenario', 'pochezza', 'poderoso', 'podismo', 'poesia', 'poggiare', 'polenta', 'poligono', 'pollice', 'polmonite', 'polpetta', 'polso', 'poltrona', 'polvere', 'pomice', 'pomodoro', 'ponte', 'popoloso', 'porfido', 'poroso', 'porpora', 'porre', 'portata', 'posa', 'positivo', 'possesso', 'postulato', 'potassio', 'potere', 'pranzo', 'prassi', 'pratica', 'precluso', 'predica', 'prefisso', 'pregiato', 'prelievo', 'premere', 'prenotare', 'preparato', 'presenza', 'pretesto', 'prevalso', 'prima', 'principe', 'privato', 'problema', 'procura', 'produrre', 'profumo', 'progetto', 'prolunga', 'promessa', 'pronome', 'proposta', 'proroga', 'proteso', 'prova', 'prudente', 'prugna', 'prurito', 'psiche', 'pubblico', 'pudica', 'pugilato', 'pugno', 'pulce', 'pulito', 'pulsante', 'puntare', 'pupazzo', 'pupilla', 'puro', 'quadro', 'qualcosa', 'quasi', 'querela', 'quota', 'raccolto', 'raddoppio', 'radicale', 'radunato', 'raffica', 'ragazzo', 'ragione', 'ragno', 'ramarro', 'ramingo', 'ramo', 'randagio', 'rantolare', 'rapato', 'rapina', 'rappreso', 'rasatura', 'raschiato', 'rasente', 'rassegna', 'rastrello', 'rata', 'ravveduto', 'reale', 'recepire', 'recinto', 'recluta', 'recondito', 'recupero', 'reddito', 'redimere', 'regalato', 'registro', 'regola', 'regresso', 'relazione', 'remare', 'remoto', 'renna', 'replica', 'reprimere', 'reputare', 'resa', 'residente', 'responso', 'restauro', 'rete', 'retina', 'retorica', 'rettifica', 'revocato', 'riassunto', 'ribadire', 'ribelle', 'ribrezzo', 'ricarica', 'ricco', 'ricevere', 'riciclato', 'ricordo', 'ricreduto', 'ridicolo', 'ridurre', 'rifasare', 'riflesso', 'riforma', 'rifugio', 'rigare', 'rigettato', 'righello', 'rilassato', 'rilevato', 'rimanere', 'rimbalzo', 'rimedio', 'rimorchio', 'rinascita', 'rincaro', 'rinforzo', 'rinnovo', 'rinomato', 'rinsavito', 'rintocco', 'rinuncia', 'rinvenire', 'riparato', 'ripetuto', 'ripieno', 'riportare', 'ripresa', 'ripulire', 'risata', 'rischio', 'riserva', 'risibile', 'riso', 'rispetto', 'ristoro', 'risultato', 'risvolto', 'ritardo', 'ritegno', 'ritmico', 'ritrovo', 'riunione', 'riva', 'riverso', 'rivincita', 'rivolto', 'rizoma', 'roba', 'robotico', 'robusto', 'roccia', 'roco', 'rodaggio', 'rodere', 'roditore', 'rogito', 'rollio', 'romantico', 'rompere', 'ronzio', 'rosolare', 'rospo', 'rotante', 'rotondo', 'rotula', 'rovescio', 'rubizzo', 'rubrica', 'ruga', 'rullino', 'rumine', 'rumoroso', 'ruolo', 'rupe', 'russare', 'rustico', 'sabato', 'sabbiare', 'sabotato', 'sagoma', 'salasso', 'saldatura', 'salgemma', 'salivare', 'salmone', 'salone', 'saltare', 'saluto', 'salvo', 'sapere', 'sapido', 'saporito', 'saraceno', 'sarcasmo', 'sarto', 'sassoso', 'satellite', 'satira', 'satollo', 'saturno', 'savana', 'savio', 'saziato', 'sbadiglio', 'sbalzo', 'sbancato', 'sbarra', 'sbattere', 'sbavare', 'sbendare', 'sbirciare', 'sbloccato', 'sbocciato', 'sbrinare', 'sbruffone', 'sbuffare', 'scabroso', 'scadenza', 'scala', 'scambiare', 'scandalo', 'scapola', 'scarso', 'scatenare', 'scavato', 'scelto', 'scenico', 'scettro', 'scheda', 'schiena', 'sciarpa', 'scienza', 'scindere', 'scippo', 'sciroppo', 'scivolo', 'sclerare', 'scodella', 'scolpito', 'scomparto', 'sconforto', 'scoprire', 'scorta', 'scossone', 'scozzese', 'scriba', 'scrollare', 'scrutinio', 'scuderia', 'scultore', 'scuola', 'scuro', 'scusare', 'sdebitare', 'sdoganare', 'seccatura', 'secondo', 'sedano', 'seggiola', 'segnalato', 'segregato', 'seguito', 'selciato', 'selettivo', 'sella', 'selvaggio', 'semaforo', 'sembrare', 'seme', 'seminato', 'sempre', 'senso', 'sentire', 'sepolto', 'sequenza', 'serata', 'serbato', 'sereno', 'serio', 'serpente', 'serraglio', 'servire', 'sestina', 'setola', 'settimana', 'sfacelo', 'sfaldare', 'sfamato', 'sfarzoso', 'sfaticato', 'sfera', 'sfida', 'sfilato', 'sfinge', 'sfocato', 'sfoderare', 'sfogo', 'sfoltire', 'sforzato', 'sfratto', 'sfruttato', 'sfuggito', 'sfumare', 'sfuso', 'sgabello', 'sgarbato', 'sgonfiare', 'sgorbio', 'sgrassato', 'sguardo', 'sibilo', 'siccome', 'sierra', 'sigla', 'signore', 'silenzio', 'sillaba', 'simbolo', 'simpatico', 'simulato', 'sinfonia', 'singolo', 'sinistro', 'sino', 'sintesi', 'sinusoide', 'sipario', 'sisma', 'sistole', 'situato', 'slitta', 'slogatura', 'sloveno', 'smarrito', 'smemorato', 'smentito', 'smeraldo', 'smilzo', 'smontare', 'smottato', 'smussato', 'snellire', 'snervato', 'snodo', 'sobbalzo', 'sobrio', 'soccorso', 'sociale', 'sodale', 'soffitto', 'sogno', 'soldato', 'solenne', 'solido', 'sollazzo', 'solo', 'solubile', 'solvente', 'somatico', 'somma', 'sonda', 'sonetto', 'sonnifero', 'sopire', 'soppeso', 'sopra', 'sorgere', 'sorpasso', 'sorriso', 'sorso', 'sorteggio', 'sorvolato', 'sospiro', 'sosta', 'sottile', 'spada', 'spalla', 'spargere', 'spatola', 'spavento', 'spazzola', 'specie', 'spedire', 'spegnere', 'spelatura', 'speranza', 'spessore', 'spettrale', 'spezzato', 'spia', 'spigoloso', 'spillato', 'spinoso', 'spirale', 'splendido', 'sportivo', 'sposo', 'spranga', 'sprecare', 'spronato', 'spruzzo', 'spuntino', 'squillo', 'sradicare', 'srotolato', 'stabile', 'stacco', 'staffa', 'stagnare', 'stampato', 'stantio', 'starnuto', 'stasera', 'statuto', 'stelo', 'steppa', 'sterzo', 'stiletto', 'stima', 'stirpe', 'stivale', 'stizzoso', 'stonato', 'storico', 'strappo', 'stregato', 'stridulo', 'strozzare', 'strutto', 'stuccare', 'stufo', 'stupendo', 'subentro', 'succoso', 'sudore', 'suggerito', 'sugo', 'sultano', 'suonare', 'superbo', 'supporto', 'surgelato', 'surrogato', 'sussurro', 'sutura', 'svagare', 'svedese', 'sveglio', 'svelare', 'svenuto', 'svezia', 'sviluppo', 'svista', 'svizzera', 'svolta', 'svuotare', 'tabacco', 'tabulato', 'tacciare', 'taciturno', 'tale', 'talismano', 'tampone', 'tannino', 'tara', 'tardivo', 'targato', 'tariffa', 'tarpare', 'tartaruga', 'tasto', 'tattico', 'taverna', 'tavolata', 'tazza', 'teca', 'tecnico', 'telefono', 'temerario', 'tempo', 'temuto', 'tendone', 'tenero', 'tensione', 'tentacolo', 'teorema', 'terme', 'terrazzo', 'terzetto', 'tesi', 'tesserato', 'testato', 'tetro', 'tettoia', 'tifare', 'tigella', 'timbro', 'tinto', 'tipico', 'tipografo', 'tiraggio', 'tiro', 'titanio', 'titolo', 'titubante', 'tizio', 'tizzone', 'toccare', 'tollerare', 'tolto', 'tombola', 'tomo', 'tonfo', 'tonsilla', 'topazio', 'topologia', 'toppa', 'torba', 'tornare', 'torrone', 'tortora', 'toscano', 'tossire', 'tostatura', 'totano', 'trabocco', 'trachea', 'trafila', 'tragedia', 'tralcio', 'tramonto', 'transito', 'trapano', 'trarre', 'trasloco', 'trattato', 'trave', 'treccia', 'tremolio', 'trespolo', 'tributo', 'tricheco', 'trifoglio', 'trillo', 'trincea', 'trio', 'tristezza', 'triturato', 'trivella', 'tromba', 'trono', 'troppo', 'trottola', 'trovare', 'truccato', 'tubatura', 'tuffato', 'tulipano', 'tumulto', 'tunisia', 'turbare', 'turchino', 'tuta', 'tutela', 'ubicato', 'uccello', 'uccisore', 'udire', 'uditivo', 'uffa', 'ufficio', 'uguale', 'ulisse', 'ultimato', 'umano', 'umile', 'umorismo', 'uncinetto', 'ungere', 'ungherese', 'unicorno', 'unificato', 'unisono', 'unitario', 'unte', 'uovo', 'upupa', 'uragano', 'urgenza', 'urlo', 'usanza', 'usato', 'uscito', 'usignolo', 'usuraio', 'utensile', 'utilizzo', 'utopia', 'vacante', 'vaccinato', 'vagabondo', 'vagliato', 'valanga', 'valgo', 'valico', 'valletta', 'valoroso', 'valutare', 'valvola', 'vampata', 'vangare', 'vanitoso', 'vano', 'vantaggio', 'vanvera', 'vapore', 'varano', 'varcato', 'variante', 'vasca', 'vedetta', 'vedova', 'veduto', 'vegetale', 'veicolo', 'velcro', 'velina', 'velluto', 'veloce', 'venato', 'vendemmia', 'vento', 'verace', 'verbale', 'vergogna', 'verifica', 'vero', 'verruca', 'verticale', 'vescica', 'vessillo', 'vestale', 'veterano', 'vetrina', 'vetusto', 'viandante', 'vibrante', 'vicenda', 'vichingo', 'vicinanza', 'vidimare', 'vigilia', 'vigneto', 'vigore', 'vile', 'villano', 'vimini', 'vincitore', 'viola', 'vipera', 'virgola', 'virologo', 'virulento', 'viscoso', 'visione', 'vispo', 'vissuto', 'visura', 'vita', 'vitello', 'vittima', 'vivanda', 'vivido', 'viziare', 'voce', 'voga', 'volatile', 'volere', 'volpe', 'voragine', 'vulcano', 'zampogna', 'zanna', 'zappato', 'zattera', 'zavorra', 'zefiro', 'zelante', 'zelo', 'zenzero', 'zerbino', 'zibetto', 'zinco', 'zircone', 'zitto', 'zolla', 'zotico', 'zucchero', 'zufolo', 'zulu', 'zuppa'];
	return italian;
}

var japanese;
var hasRequiredJapanese;

function requireJapanese () {
	if (hasRequiredJapanese) return japanese;
	hasRequiredJapanese = 1;

	japanese = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
	return japanese;
}

var spanish;
var hasRequiredSpanish;

function requireSpanish () {
	if (hasRequiredSpanish) return spanish;
	hasRequiredSpanish = 1;

	spanish = ['abaco', 'abdomen', 'abeja', 'abierto', 'abogado', 'abono', 'aborto', 'abrazo', 'abrir', 'abuelo', 'abuso', 'acabar', 'academia', 'acceso', 'accion', 'aceite', 'acelga', 'acento', 'aceptar', 'acido', 'aclarar', 'acne', 'acoger', 'acoso', 'activo', 'acto', 'actriz', 'actuar', 'acudir', 'acuerdo', 'acusar', 'adicto', 'admitir', 'adoptar', 'adorno', 'aduana', 'adulto', 'aereo', 'afectar', 'aficion', 'afinar', 'afirmar', 'agil', 'agitar', 'agonia', 'agosto', 'agotar', 'agregar', 'agrio', 'agua', 'agudo', 'aguila', 'aguja', 'ahogo', 'ahorro', 'aire', 'aislar', 'ajedrez', 'ajeno', 'ajuste', 'alacran', 'alambre', 'alarma', 'alba', 'album', 'alcalde', 'aldea', 'alegre', 'alejar', 'alerta', 'aleta', 'alfiler', 'alga', 'algodon', 'aliado', 'aliento', 'alivio', 'alma', 'almeja', 'almibar', 'altar', 'alteza', 'altivo', 'alto', 'altura', 'alumno', 'alzar', 'amable', 'amante', 'amapola', 'amargo', 'amasar', 'ambar', 'ambito', 'ameno', 'amigo', 'amistad', 'amor', 'amparo', 'amplio', 'ancho', 'anciano', 'ancla', 'andar', 'anden', 'anemia', 'angulo', 'anillo', 'animo', 'anis', 'anotar', 'antena', 'antiguo', 'antojo', 'anual', 'anular', 'anuncio', 'anadir', 'anejo', 'ano', 'apagar', 'aparato', 'apetito', 'apio', 'aplicar', 'apodo', 'aporte', 'apoyo', 'aprender', 'aprobar', 'apuesta', 'apuro', 'arado', 'arana', 'arar', 'arbitro', 'arbol', 'arbusto', 'archivo', 'arco', 'arder', 'ardilla', 'arduo', 'area', 'arido', 'aries', 'armonia', 'arnes', 'aroma', 'arpa', 'arpon', 'arreglo', 'arroz', 'arruga', 'arte', 'artista', 'asa', 'asado', 'asalto', 'ascenso', 'asegurar', 'aseo', 'asesor', 'asiento', 'asilo', 'asistir', 'asno', 'asombro', 'aspero', 'astilla', 'astro', 'astuto', 'asumir', 'asunto', 'atajo', 'ataque', 'atar', 'atento', 'ateo', 'atico', 'atleta', 'atomo', 'atraer', 'atroz', 'atun', 'audaz', 'audio', 'auge', 'aula', 'aumento', 'ausente', 'autor', 'aval', 'avance', 'avaro', 'ave', 'avellana', 'avena', 'avestruz', 'avion', 'aviso', 'ayer', 'ayuda', 'ayuno', 'azafran', 'azar', 'azote', 'azucar', 'azufre', 'azul', 'baba', 'babor', 'bache', 'bahia', 'baile', 'bajar', 'balanza', 'balcon', 'balde', 'bambu', 'banco', 'banda', 'bano', 'barba', 'barco', 'barniz', 'barro', 'bascula', 'baston', 'basura', 'batalla', 'bateria', 'batir', 'batuta', 'baul', 'bazar', 'bebe', 'bebida', 'bello', 'besar', 'beso', 'bestia', 'bicho', 'bien', 'bingo', 'blanco', 'bloque', 'blusa', 'boa', 'bobina', 'bobo', 'boca', 'bocina', 'boda', 'bodega', 'boina', 'bola', 'bolero', 'bolsa', 'bomba', 'bondad', 'bonito', 'bono', 'bonsai', 'borde', 'borrar', 'bosque', 'bote', 'botin', 'boveda', 'bozal', 'bravo', 'brazo', 'brecha', 'breve', 'brillo', 'brinco', 'brisa', 'broca', 'broma', 'bronce', 'brote', 'bruja', 'brusco', 'bruto', 'buceo', 'bucle', 'bueno', 'buey', 'bufanda', 'bufon', 'buho', 'buitre', 'bulto', 'burbuja', 'burla', 'burro', 'buscar', 'butaca', 'buzon', 'caballo', 'cabeza', 'cabina', 'cabra', 'cacao', 'cadaver', 'cadena', 'caer', 'cafe', 'caida', 'caiman', 'caja', 'cajon', 'cal', 'calamar', 'calcio', 'caldo', 'calidad', 'calle', 'calma', 'calor', 'calvo', 'cama', 'cambio', 'camello', 'camino', 'campo', 'cancer', 'candil', 'canela', 'canguro', 'canica', 'canto', 'cana', 'canon', 'caoba', 'caos', 'capaz', 'capitan', 'capote', 'captar', 'capucha', 'cara', 'carbon', 'carcel', 'careta', 'carga', 'carino', 'carne', 'carpeta', 'carro', 'carta', 'casa', 'casco', 'casero', 'caspa', 'castor', 'catorce', 'catre', 'caudal', 'causa', 'cazo', 'cebolla', 'ceder', 'cedro', 'celda', 'celebre', 'celoso', 'celula', 'cemento', 'ceniza', 'centro', 'cerca', 'cerdo', 'cereza', 'cero', 'cerrar', 'certeza', 'cesped', 'cetro', 'chacal', 'chaleco', 'champu', 'chancla', 'chapa', 'charla', 'chico', 'chiste', 'chivo', 'choque', 'choza', 'chuleta', 'chupar', 'ciclon', 'ciego', 'cielo', 'cien', 'cierto', 'cifra', 'cigarro', 'cima', 'cinco', 'cine', 'cinta', 'cipres', 'circo', 'ciruela', 'cisne', 'cita', 'ciudad', 'clamor', 'clan', 'claro', 'clase', 'clave', 'cliente', 'clima', 'clinica', 'cobre', 'coccion', 'cochino', 'cocina', 'coco', 'codigo', 'codo', 'cofre', 'coger', 'cohete', 'cojin', 'cojo', 'cola', 'colcha', 'colegio', 'colgar', 'colina', 'collar', 'colmo', 'columna', 'combate', 'comer', 'comida', 'comodo', 'compra', 'conde', 'conejo', 'conga', 'conocer', 'consejo', 'contar', 'copa', 'copia', 'corazon', 'corbata', 'corcho', 'cordon', 'corona', 'correr', 'coser', 'cosmos', 'costa', 'craneo', 'crater', 'crear', 'crecer', 'creido', 'crema', 'cria', 'crimen', 'cripta', 'crisis', 'cromo', 'cronica', 'croqueta', 'crudo', 'cruz', 'cuadro', 'cuarto', 'cuatro', 'cubo', 'cubrir', 'cuchara', 'cuello', 'cuento', 'cuerda', 'cuesta', 'cueva', 'cuidar', 'culebra', 'culpa', 'culto', 'cumbre', 'cumplir', 'cuna', 'cuneta', 'cuota', 'cupon', 'cupula', 'curar', 'curioso', 'curso', 'curva', 'cutis', 'dama', 'danza', 'dar', 'dardo', 'datil', 'deber', 'debil', 'decada', 'decir', 'dedo', 'defensa', 'definir', 'dejar', 'delfin', 'delgado', 'delito', 'demora', 'denso', 'dental', 'deporte', 'derecho', 'derrota', 'desayuno', 'deseo', 'desfile', 'desnudo', 'destino', 'desvio', 'detalle', 'detener', 'deuda', 'dia', 'diablo', 'diadema', 'diamante', 'diana', 'diario', 'dibujo', 'dictar', 'diente', 'dieta', 'diez', 'dificil', 'digno', 'dilema', 'diluir', 'dinero', 'directo', 'dirigir', 'disco', 'diseno', 'disfraz', 'diva', 'divino', 'doble', 'doce', 'dolor', 'domingo', 'don', 'donar', 'dorado', 'dormir', 'dorso', 'dos', 'dosis', 'dragon', 'droga', 'ducha', 'duda', 'duelo', 'dueno', 'dulce', 'duo', 'duque', 'durar', 'dureza', 'duro', 'ebano', 'ebrio', 'echar', 'eco', 'ecuador', 'edad', 'edicion', 'edificio', 'editor', 'educar', 'efecto', 'eficaz', 'eje', 'ejemplo', 'elefante', 'elegir', 'elemento', 'elevar', 'elipse', 'elite', 'elixir', 'elogio', 'eludir', 'embudo', 'emitir', 'emocion', 'empate', 'empeno', 'empleo', 'empresa', 'enano', 'encargo', 'enchufe', 'encia', 'enemigo', 'enero', 'enfado', 'enfermo', 'engano', 'enigma', 'enlace', 'enorme', 'enredo', 'ensayo', 'ensenar', 'entero', 'entrar', 'envase', 'envio', 'epoca', 'equipo', 'erizo', 'escala', 'escena', 'escolar', 'escribir', 'escudo', 'esencia', 'esfera', 'esfuerzo', 'espada', 'espejo', 'espia', 'esposa', 'espuma', 'esqui', 'estar', 'este', 'estilo', 'estufa', 'etapa', 'eterno', 'etica', 'etnia', 'evadir', 'evaluar', 'evento', 'evitar', 'exacto', 'examen', 'exceso', 'excusa', 'exento', 'exigir', 'exilio', 'existir', 'exito', 'experto', 'explicar', 'exponer', 'extremo', 'fabrica', 'fabula', 'fachada', 'facil', 'factor', 'faena', 'faja', 'falda', 'fallo', 'falso', 'faltar', 'fama', 'familia', 'famoso', 'faraon', 'farmacia', 'farol', 'farsa', 'fase', 'fatiga', 'fauna', 'favor', 'fax', 'febrero', 'fecha', 'feliz', 'feo', 'feria', 'feroz', 'fertil', 'fervor', 'festin', 'fiable', 'fianza', 'fiar', 'fibra', 'ficcion', 'ficha', 'fideo', 'fiebre', 'fiel', 'fiera', 'fiesta', 'figura', 'fijar', 'fijo', 'fila', 'filete', 'filial', 'filtro', 'fin', 'finca', 'fingir', 'finito', 'firma', 'flaco', 'flauta', 'flecha', 'flor', 'flota', 'fluir', 'flujo', 'fluor', 'fobia', 'foca', 'fogata', 'fogon', 'folio', 'folleto', 'fondo', 'forma', 'forro', 'fortuna', 'forzar', 'fosa', 'foto', 'fracaso', 'fragil', 'franja', 'frase', 'fraude', 'freir', 'freno', 'fresa', 'frio', 'frito', 'fruta', 'fuego', 'fuente', 'fuerza', 'fuga', 'fumar', 'funcion', 'funda', 'furgon', 'furia', 'fusil', 'futbol', 'futuro', 'gacela', 'gafas', 'gaita', 'gajo', 'gala', 'galeria', 'gallo', 'gamba', 'ganar', 'gancho', 'ganga', 'ganso', 'garaje', 'garza', 'gasolina', 'gastar', 'gato', 'gavilan', 'gemelo', 'gemir', 'gen', 'genero', 'genio', 'gente', 'geranio', 'gerente', 'germen', 'gesto', 'gigante', 'gimnasio', 'girar', 'giro', 'glaciar', 'globo', 'gloria', 'gol', 'golfo', 'goloso', 'golpe', 'goma', 'gordo', 'gorila', 'gorra', 'gota', 'goteo', 'gozar', 'grada', 'grafico', 'grano', 'grasa', 'gratis', 'grave', 'grieta', 'grillo', 'gripe', 'gris', 'grito', 'grosor', 'grua', 'grueso', 'grumo', 'grupo', 'guante', 'guapo', 'guardia', 'guerra', 'guia', 'guino', 'guion', 'guiso', 'guitarra', 'gusano', 'gustar', 'haber', 'habil', 'hablar', 'hacer', 'hacha', 'hada', 'hallar', 'hamaca', 'harina', 'haz', 'hazana', 'hebilla', 'hebra', 'hecho', 'helado', 'helio', 'hembra', 'herir', 'hermano', 'heroe', 'hervir', 'hielo', 'hierro', 'higado', 'higiene', 'hijo', 'himno', 'historia', 'hocico', 'hogar', 'hoguera', 'hoja', 'hombre', 'hongo', 'honor', 'honra', 'hora', 'hormiga', 'horno', 'hostil', 'hoyo', 'hueco', 'huelga', 'huerta', 'hueso', 'huevo', 'huida', 'huir', 'humano', 'humedo', 'humilde', 'humo', 'hundir', 'huracan', 'hurto', 'icono', 'ideal', 'idioma', 'idolo', 'iglesia', 'iglu', 'igual', 'ilegal', 'ilusion', 'imagen', 'iman', 'imitar', 'impar', 'imperio', 'imponer', 'impulso', 'incapaz', 'indice', 'inerte', 'infiel', 'informe', 'ingenio', 'inicio', 'inmenso', 'inmune', 'innato', 'insecto', 'instante', 'interes', 'intimo', 'intuir', 'inutil', 'invierno', 'ira', 'iris', 'ironia', 'isla', 'islote', 'jabali', 'jabon', 'jamon', 'jarabe', 'jardin', 'jarra', 'jaula', 'jazmin', 'jefe', 'jeringa', 'jinete', 'jornada', 'joroba', 'joven', 'joya', 'juerga', 'jueves', 'juez', 'jugador', 'jugo', 'juguete', 'juicio', 'junco', 'jungla', 'junio', 'juntar', 'jupiter', 'jurar', 'justo', 'juvenil', 'juzgar', 'kilo', 'koala', 'labio', 'lacio', 'lacra', 'lado', 'ladron', 'lagarto', 'lagrima', 'laguna', 'laico', 'lamer', 'lamina', 'lampara', 'lana', 'lancha', 'langosta', 'lanza', 'lapiz', 'largo', 'larva', 'lastima', 'lata', 'latex', 'latir', 'laurel', 'lavar', 'lazo', 'leal', 'leccion', 'leche', 'lector', 'leer', 'legion', 'legumbre', 'lejano', 'lengua', 'lento', 'lena', 'leon', 'leopardo', 'lesion', 'letal', 'letra', 'leve', 'leyenda', 'libertad', 'libro', 'licor', 'lider', 'lidiar', 'lienzo', 'liga', 'ligero', 'lima', 'limite', 'limon', 'limpio', 'lince', 'lindo', 'linea', 'lingote', 'lino', 'linterna', 'liquido', 'liso', 'lista', 'litera', 'litio', 'litro', 'llaga', 'llama', 'llanto', 'llave', 'llegar', 'llenar', 'llevar', 'llorar', 'llover', 'lluvia', 'lobo', 'locion', 'loco', 'locura', 'logica', 'logro', 'lombriz', 'lomo', 'lonja', 'lote', 'lucha', 'lucir', 'lugar', 'lujo', 'luna', 'lunes', 'lupa', 'lustro', 'luto', 'luz', 'maceta', 'macho', 'madera', 'madre', 'maduro', 'maestro', 'mafia', 'magia', 'mago', 'maiz', 'maldad', 'maleta', 'malla', 'malo', 'mama', 'mambo', 'mamut', 'manco', 'mando', 'manejar', 'manga', 'maniqui', 'manjar', 'mano', 'manso', 'manta', 'manana', 'mapa', 'maquina', 'mar', 'marco', 'marea', 'marfil', 'margen', 'marido', 'marmol', 'marron', 'martes', 'marzo', 'masa', 'mascara', 'masivo', 'matar', 'materia', 'matiz', 'matriz', 'maximo', 'mayor', 'mazorca', 'mecha', 'medalla', 'medio', 'medula', 'mejilla', 'mejor', 'melena', 'melon', 'memoria', 'menor', 'mensaje', 'mente', 'menu', 'mercado', 'merengue', 'merito', 'mes', 'meson', 'meta', 'meter', 'metodo', 'metro', 'mezcla', 'miedo', 'miel', 'miembro', 'miga', 'mil', 'milagro', 'militar', 'millon', 'mimo', 'mina', 'minero', 'minimo', 'minuto', 'miope', 'mirar', 'misa', 'miseria', 'misil', 'mismo', 'mitad', 'mito', 'mochila', 'mocion', 'moda', 'modelo', 'moho', 'mojar', 'molde', 'moler', 'molino', 'momento', 'momia', 'monarca', 'moneda', 'monja', 'monto', 'mono', 'morada', 'morder', 'moreno', 'morir', 'morro', 'morsa', 'mortal', 'mosca', 'mostrar', 'motivo', 'mover', 'movil', 'mozo', 'mucho', 'mudar', 'mueble', 'muela', 'muerte', 'muestra', 'mugre', 'mujer', 'mula', 'muleta', 'multa', 'mundo', 'muneca', 'mural', 'muro', 'musculo', 'museo', 'musgo', 'musica', 'muslo', 'nacar', 'nacion', 'nadar', 'naipe', 'naranja', 'nariz', 'narrar', 'nasal', 'natal', 'nativo', 'natural', 'nausea', 'naval', 'nave', 'navidad', 'necio', 'nectar', 'negar', 'negocio', 'negro', 'neon', 'nervio', 'neto', 'neutro', 'nevar', 'nevera', 'nicho', 'nido', 'niebla', 'nieto', 'ninez', 'nino', 'nitido', 'nivel', 'nobleza', 'noche', 'nomina', 'noria', 'norma', 'norte', 'nota', 'noticia', 'novato', 'novela', 'novio', 'nube', 'nuca', 'nucleo', 'nudillo', 'nudo', 'nuera', 'nueve', 'nuez', 'nulo', 'numero', 'nutria', 'oasis', 'obeso', 'obispo', 'objeto', 'obra', 'obrero', 'observar', 'obtener', 'obvio', 'oca', 'ocaso', 'oceano', 'ochenta', 'ocho', 'ocio', 'ocre', 'octavo', 'octubre', 'oculto', 'ocupar', 'ocurrir', 'odiar', 'odio', 'odisea', 'oeste', 'ofensa', 'oferta', 'oficio', 'ofrecer', 'ogro', 'oido', 'oir', 'ojo', 'ola', 'oleada', 'olfato', 'olivo', 'olla', 'olmo', 'olor', 'olvido', 'ombligo', 'onda', 'onza', 'opaco', 'opcion', 'opera', 'opinar', 'oponer', 'optar', 'optica', 'opuesto', 'oracion', 'orador', 'oral', 'orbita', 'orca', 'orden', 'oreja', 'organo', 'orgia', 'orgullo', 'oriente', 'origen', 'orilla', 'oro', 'orquesta', 'oruga', 'osadia', 'oscuro', 'osezno', 'oso', 'ostra', 'otono', 'otro', 'oveja', 'ovulo', 'oxido', 'oxigeno', 'oyente', 'ozono', 'pacto', 'padre', 'paella', 'pagina', 'pago', 'pais', 'pajaro', 'palabra', 'palco', 'paleta', 'palido', 'palma', 'paloma', 'palpar', 'pan', 'panal', 'panico', 'pantera', 'panuelo', 'papa', 'papel', 'papilla', 'paquete', 'parar', 'parcela', 'pared', 'parir', 'paro', 'parpado', 'parque', 'parrafo', 'parte', 'pasar', 'paseo', 'pasion', 'paso', 'pasta', 'pata', 'patio', 'patria', 'pausa', 'pauta', 'pavo', 'payaso', 'peaton', 'pecado', 'pecera', 'pecho', 'pedal', 'pedir', 'pegar', 'peine', 'pelar', 'peldano', 'pelea', 'peligro', 'pellejo', 'pelo', 'peluca', 'pena', 'pensar', 'penon', 'peon', 'peor', 'pepino', 'pequeno', 'pera', 'percha', 'perder', 'pereza', 'perfil', 'perico', 'perla', 'permiso', 'perro', 'persona', 'pesa', 'pesca', 'pesimo', 'pestana', 'petalo', 'petroleo', 'pez', 'pezuna', 'picar', 'pichon', 'pie', 'piedra', 'pierna', 'pieza', 'pijama', 'pilar', 'piloto', 'pimienta', 'pino', 'pintor', 'pinza', 'pina', 'piojo', 'pipa', 'pirata', 'pisar', 'piscina', 'piso', 'pista', 'piton', 'pizca', 'placa', 'plan', 'plata', 'playa', 'plaza', 'pleito', 'pleno', 'plomo', 'pluma', 'plural', 'pobre', 'poco', 'poder', 'podio', 'poema', 'poesia', 'poeta', 'polen', 'policia', 'pollo', 'polvo', 'pomada', 'pomelo', 'pomo', 'pompa', 'poner', 'porcion', 'portal', 'posada', 'poseer', 'posible', 'poste', 'potencia', 'potro', 'pozo', 'prado', 'precoz', 'pregunta', 'premio', 'prensa', 'preso', 'previo', 'primo', 'principe', 'prision', 'privar', 'proa', 'probar', 'proceso', 'producto', 'proeza', 'profesor', 'programa', 'prole', 'promesa', 'pronto', 'propio', 'proximo', 'prueba', 'publico', 'puchero', 'pudor', 'pueblo', 'puerta', 'puesto', 'pulga', 'pulir', 'pulmon', 'pulpo', 'pulso', 'puma', 'punto', 'punal', 'puno', 'pupa', 'pupila', 'pure', 'quedar', 'queja', 'quemar', 'querer', 'queso', 'quieto', 'quimica', 'quince', 'quitar', 'rabano', 'rabia', 'rabo', 'racion', 'radical', 'raiz', 'rama', 'rampa', 'rancho', 'rango', 'rapaz', 'rapido', 'rapto', 'rasgo', 'raspa', 'rato', 'rayo', 'raza', 'razon', 'reaccion', 'realidad', 'rebano', 'rebote', 'recaer', 'receta', 'rechazo', 'recoger', 'recreo', 'recto', 'recurso', 'red', 'redondo', 'reducir', 'reflejo', 'reforma', 'refran', 'refugio', 'regalo', 'regir', 'regla', 'regreso', 'rehen', 'reino', 'reir', 'reja', 'relato', 'relevo', 'relieve', 'relleno', 'reloj', 'remar', 'remedio', 'remo', 'rencor', 'rendir', 'renta', 'reparto', 'repetir', 'reposo', 'reptil', 'res', 'rescate', 'resina', 'respeto', 'resto', 'resumen', 'retiro', 'retorno', 'retrato', 'reunir', 'reves', 'revista', 'rey', 'rezar', 'rico', 'riego', 'rienda', 'riesgo', 'rifa', 'rigido', 'rigor', 'rincon', 'rinon', 'rio', 'riqueza', 'risa', 'ritmo', 'rito', 'rizo', 'roble', 'roce', 'rociar', 'rodar', 'rodeo', 'rodilla', 'roer', 'rojizo', 'rojo', 'romero', 'romper', 'ron', 'ronco', 'ronda', 'ropa', 'ropero', 'rosa', 'rosca', 'rostro', 'rotar', 'rubi', 'rubor', 'rudo', 'rueda', 'rugir', 'ruido', 'ruina', 'ruleta', 'rulo', 'rumbo', 'rumor', 'ruptura', 'ruta', 'rutina', 'sabado', 'saber', 'sabio', 'sable', 'sacar', 'sagaz', 'sagrado', 'sala', 'saldo', 'salero', 'salir', 'salmon', 'salon', 'salsa', 'salto', 'salud', 'salvar', 'samba', 'sancion', 'sandia', 'sanear', 'sangre', 'sanidad', 'sano', 'santo', 'sapo', 'saque', 'sardina', 'sarten', 'sastre', 'satan', 'sauna', 'saxofon', 'seccion', 'seco', 'secreto', 'secta', 'sed', 'seguir', 'seis', 'sello', 'selva', 'semana', 'semilla', 'senda', 'sensor', 'senal', 'senor', 'separar', 'sepia', 'sequia', 'ser', 'serie', 'sermon', 'servir', 'sesenta', 'sesion', 'seta', 'setenta', 'severo', 'sexo', 'sexto', 'sidra', 'siesta', 'siete', 'siglo', 'signo', 'silaba', 'silbar', 'silencio', 'silla', 'simbolo', 'simio', 'sirena', 'sistema', 'sitio', 'situar', 'sobre', 'socio', 'sodio', 'sol', 'solapa', 'soldado', 'soledad', 'solido', 'soltar', 'solucion', 'sombra', 'sondeo', 'sonido', 'sonoro', 'sonrisa', 'sopa', 'soplar', 'soporte', 'sordo', 'sorpresa', 'sorteo', 'sosten', 'sotano', 'suave', 'subir', 'suceso', 'sudor', 'suegra', 'suelo', 'sueno', 'suerte', 'sufrir', 'sujeto', 'sultan', 'sumar', 'superar', 'suplir', 'suponer', 'supremo', 'sur', 'surco', 'sureno', 'surgir', 'susto', 'sutil', 'tabaco', 'tabique', 'tabla', 'tabu', 'taco', 'tacto', 'tajo', 'talar', 'talco', 'talento', 'talla', 'talon', 'tamano', 'tambor', 'tango', 'tanque', 'tapa', 'tapete', 'tapia', 'tapon', 'taquilla', 'tarde', 'tarea', 'tarifa', 'tarjeta', 'tarot', 'tarro', 'tarta', 'tatuaje', 'tauro', 'taza', 'tazon', 'teatro', 'techo', 'tecla', 'tecnica', 'tejado', 'tejer', 'tejido', 'tela', 'telefono', 'tema', 'temor', 'templo', 'tenaz', 'tender', 'tener', 'tenis', 'tenso', 'teoria', 'terapia', 'terco', 'termino', 'ternura', 'terror', 'tesis', 'tesoro', 'testigo', 'tetera', 'texto', 'tez', 'tibio', 'tiburon', 'tiempo', 'tienda', 'tierra', 'tieso', 'tigre', 'tijera', 'tilde', 'timbre', 'timido', 'timo', 'tinta', 'tio', 'tipico', 'tipo', 'tira', 'tiron', 'titan', 'titere', 'titulo', 'tiza', 'toalla', 'tobillo', 'tocar', 'tocino', 'todo', 'toga', 'toldo', 'tomar', 'tono', 'tonto', 'topar', 'tope', 'toque', 'torax', 'torero', 'tormenta', 'torneo', 'toro', 'torpedo', 'torre', 'torso', 'tortuga', 'tos', 'tosco', 'toser', 'toxico', 'trabajo', 'tractor', 'traer', 'trafico', 'trago', 'traje', 'tramo', 'trance', 'trato', 'trauma', 'trazar', 'trebol', 'tregua', 'treinta', 'tren', 'trepar', 'tres', 'tribu', 'trigo', 'tripa', 'triste', 'triunfo', 'trofeo', 'trompa', 'tronco', 'tropa', 'trote', 'trozo', 'truco', 'trueno', 'trufa', 'tuberia', 'tubo', 'tuerto', 'tumba', 'tumor', 'tunel', 'tunica', 'turbina', 'turismo', 'turno', 'tutor', 'ubicar', 'ulcera', 'umbral', 'unidad', 'unir', 'universo', 'uno', 'untar', 'una', 'urbano', 'urbe', 'urgente', 'urna', 'usar', 'usuario', 'util', 'utopia', 'uva', 'vaca', 'vacio', 'vacuna', 'vagar', 'vago', 'vaina', 'vajilla', 'vale', 'valido', 'valle', 'valor', 'valvula', 'vampiro', 'vara', 'variar', 'varon', 'vaso', 'vecino', 'vector', 'vehiculo', 'veinte', 'vejez', 'vela', 'velero', 'veloz', 'vena', 'vencer', 'venda', 'veneno', 'vengar', 'venir', 'venta', 'venus', 'ver', 'verano', 'verbo', 'verde', 'vereda', 'verja', 'verso', 'verter', 'via', 'viaje', 'vibrar', 'vicio', 'victima', 'vida', 'video', 'vidrio', 'viejo', 'viernes', 'vigor', 'vil', 'villa', 'vinagre', 'vino', 'vinedo', 'violin', 'viral', 'virgo', 'virtud', 'visor', 'vispera', 'vista', 'vitamina', 'viudo', 'vivaz', 'vivero', 'vivir', 'vivo', 'volcan', 'volumen', 'volver', 'voraz', 'votar', 'voto', 'voz', 'vuelo', 'vulgar', 'yacer', 'yate', 'yegua', 'yema', 'yerno', 'yeso', 'yodo', 'yoga', 'yogur', 'zafiro', 'zanja', 'zapato', 'zarza', 'zona', 'zorro', 'zumo', 'zurdo'];
	return spanish;
}

/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredWordlist;

function requireWordlist () {
	if (hasRequiredWordlist) return wordlist;
	hasRequiredWordlist = 1;

	wordlist.get = function get(name) {
	  switch (name) {
	    case 'simplified chinese':
	      return requireChineseSimplified();
	    case 'traditional chinese':
	      return requireChineseTraditional();
	    case 'english':
	      return requireEnglish();
	    case 'french':
	      return requireFrench();
	    case 'italian':
	      return requireItalian();
	    case 'japanese':
	      return requireJapanese();
	    case 'spanish':
	      return requireSpanish();
	    default:
	      throw new Error(`Unknown language: ${name}.`);
	  }
	};
	return wordlist;
}

/*!
 * nfkd.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var nfkd_1;
var hasRequiredNfkd;

function requireNfkd () {
	if (hasRequiredNfkd) return nfkd_1;
	hasRequiredNfkd = 1;

	/**
	 * Normalize unicode string.
	 * @alias module:utils.nfkd
	 * @param {String} str
	 * @returns {String}
	 */
	function nfkd(str) {
	  return str.normalize('NFKD');
	}

	/*
	 * Expose
	 */

	nfkd_1 = nfkd;
	return nfkd_1;
}

/*!
 * mnemonic.js - hd mnemonics for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var mnemonic;
var hasRequiredMnemonic;

function requireMnemonic () {
	if (hasRequiredMnemonic) return mnemonic;
	hasRequiredMnemonic = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const sha256 = requireSha256();
	const cleanse = requireCleanse();
	const random = requireRandom();
	const pbkdf2 = requirePbkdf2();
	const sha512 = requireSha512();
	const wordlist = requireWordlist();
	const common = requireCommon();
	const nfkd = requireNfkd();
	const {
	  inspectSymbol
	} = requireUtils();

	/*
	 * Constants
	 */

	const wordlistCache = Object.create(null);

	/**
	 * HD Mnemonic
	 * @alias module:hd.Mnemonic
	 */

	class Mnemonic {
	  /**
	   * Create a mnemonic.
	   * @constructor
	   * @param {Object} options
	   * @param {Number?} options.bit - Bits of entropy (Must
	   * be a multiple of 8) (default=128).
	   * @param {Buffer?} options.entropy - Entropy bytes. Will
	   * be generated with `options.bits` bits of entropy
	   * if not present.
	   * @param {String?} options.phrase - Mnemonic phrase (will
	   * be generated if not present).
	   * @param {String?} options.language - Language.
	   */

	  constructor(options) {
	    this.bits = common.MIN_ENTROPY;
	    this.language = 'english';
	    this.entropy = null;
	    this.phrase = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    if (typeof options === 'string') options = {
	      phrase: options
	    };
	    if (options.bits != null) {
	      assert((options.bits & 0xffff) === options.bits);
	      assert(options.bits >= common.MIN_ENTROPY);
	      assert(options.bits <= common.MAX_ENTROPY);
	      assert(options.bits % 32 === 0);
	      this.bits = options.bits;
	    }
	    if (options.language) {
	      assert(typeof options.language === 'string');
	      assert(Mnemonic.languages.indexOf(options.language) !== -1);
	      this.language = options.language;
	    }
	    if (options.phrase) {
	      this.fromPhrase(options.phrase);
	      return this;
	    }
	    if (options.entropy) {
	      this.fromEntropy(options.entropy);
	      return this;
	    }
	    return this;
	  }

	  /**
	   * Instantiate mnemonic from options.
	   * @param {Object} options
	   * @returns {Mnemonic}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Destroy the mnemonic (zeroes entropy).
	   */

	  destroy() {
	    this.bits = common.MIN_ENTROPY;
	    this.language = 'english';
	    if (this.entropy) {
	      cleanse(this.entropy);
	      this.entropy = null;
	    }
	    this.phrase = null;
	  }

	  /**
	   * Generate the seed.
	   * @param {String?} passphrase
	   * @returns {Buffer} pbkdf2 seed.
	   */

	  toSeed(passphrase) {
	    if (!passphrase) passphrase = '';
	    const phrase = nfkd(this.getPhrase());
	    const passwd = nfkd(`mnemonic${passphrase}`);
	    return pbkdf2.derive(sha512, Buffer.from(phrase, 'utf8'), Buffer.from(passwd, 'utf8'), 2048, 64);
	  }

	  /**
	   * Get or generate entropy.
	   * @returns {Buffer}
	   */

	  getEntropy() {
	    if (!this.entropy) this.entropy = random.randomBytes(this.bits / 8);
	    assert(this.bits / 8 === this.entropy.length);
	    return this.entropy;
	  }

	  /**
	   * Generate a mnemonic phrase from chosen language.
	   * @returns {String}
	   */

	  getPhrase() {
	    if (this.phrase) return this.phrase;

	    // Include the first `ENT / 32` bits
	    // of the hash (the checksum).
	    const wbits = this.bits + this.bits / 32;

	    // Get entropy and checksum.
	    const entropy = this.getEntropy();
	    const chk = sha256.digest(entropy);

	    // Append the hash to the entropy to
	    // make things easy when grabbing
	    // the checksum bits.
	    const size = Math.ceil(wbits / 8);
	    const data = Buffer.allocUnsafe(size);
	    entropy.copy(data, 0);
	    chk.copy(data, entropy.length);

	    // Build the mnemonic by reading
	    // 11 bit indexes from the entropy.
	    const list = Mnemonic.getWordlist(this.language);
	    let phrase = [];
	    for (let i = 0; i < wbits / 11; i++) {
	      let index = 0;
	      for (let j = 0; j < 11; j++) {
	        const pos = i * 11 + j;
	        const bit = pos % 8;
	        const oct = (pos - bit) / 8;
	        index <<= 1;
	        index |= data[oct] >>> 7 - bit & 1;
	      }
	      phrase.push(list.words[index]);
	    }

	    // Japanese likes double-width spaces.
	    if (this.language === 'japanese') phrase = phrase.join('\u3000');else phrase = phrase.join(' ');
	    this.phrase = phrase;
	    return phrase;
	  }

	  /**
	   * Inject properties from phrase.
	   * @private
	   * @param {String} phrase
	   */

	  fromPhrase(phrase) {
	    assert(typeof phrase === 'string');
	    assert(phrase.length <= 1000);
	    const words = phrase.trim().split(/[\s\u3000]+/);
	    const wbits = words.length * 11;
	    const cbits = wbits % 32;
	    assert(cbits !== 0, 'Invalid checksum.');
	    const bits = wbits - cbits;
	    assert(bits >= common.MIN_ENTROPY);
	    assert(bits <= common.MAX_ENTROPY);
	    assert(bits % 32 === 0);
	    const size = Math.ceil(wbits / 8);
	    const data = Buffer.allocUnsafe(size);
	    data.fill(0);
	    const lang = Mnemonic.getLanguage(words[0]);
	    const list = Mnemonic.getWordlist(lang);

	    // Rebuild entropy bytes.
	    for (let i = 0; i < words.length; i++) {
	      const word = words[i];
	      const index = list.map[word];
	      if (index == null) throw new Error('Could not find word.');
	      for (let j = 0; j < 11; j++) {
	        const pos = i * 11 + j;
	        const bit = pos % 8;
	        const oct = (pos - bit) / 8;
	        const val = index >>> 10 - j & 1;
	        data[oct] |= val << 7 - bit;
	      }
	    }
	    const cbytes = Math.ceil(cbits / 8);
	    const entropy = data.slice(0, data.length - cbytes);
	    const chk1 = data.slice(data.length - cbytes);
	    const chk2 = sha256.digest(entropy);

	    // Verify checksum.
	    for (let i = 0; i < cbits; i++) {
	      const bit = i % 8;
	      const oct = (i - bit) / 8;
	      const b1 = chk1[oct] >>> 7 - bit & 1;
	      const b2 = chk2[oct] >>> 7 - bit & 1;
	      if (b1 !== b2) throw new Error('Invalid checksum.');
	    }
	    assert(bits / 8 === entropy.length);
	    this.bits = bits;
	    this.language = lang;
	    this.entropy = entropy;
	    this.phrase = phrase;
	    return this;
	  }

	  /**
	   * Instantiate mnemonic from a phrase (validates checksum).
	   * @param {String} phrase
	   * @returns {Mnemonic}
	   * @throws on bad checksum
	   */

	  static fromPhrase(phrase) {
	    return new this().fromPhrase(phrase);
	  }

	  /**
	   * Inject properties from entropy.
	   * @private
	   * @param {Buffer} entropy
	   * @param {String?} lang
	   */

	  fromEntropy(entropy, lang) {
	    assert(Buffer.isBuffer(entropy));
	    assert(entropy.length * 8 >= common.MIN_ENTROPY);
	    assert(entropy.length * 8 <= common.MAX_ENTROPY);
	    assert(entropy.length * 8 % 32 === 0);
	    assert(!lang || Mnemonic.languages.indexOf(lang) !== -1);
	    this.entropy = entropy;
	    this.bits = entropy.length * 8;
	    if (lang) this.language = lang;
	    return this;
	  }

	  /**
	   * Instantiate mnemonic from entropy.
	   * @param {Buffer} entropy
	   * @param {String?} lang
	   * @returns {Mnemonic}
	   */

	  static fromEntropy(entropy, lang) {
	    return new this().fromEntropy(entropy, lang);
	  }

	  /**
	   * Determine a single word's language.
	   * @param {String} word
	   * @returns {String} Language.
	   * @throws on not found.
	   */

	  static getLanguage(word) {
	    for (const lang of Mnemonic.languages) {
	      const list = Mnemonic.getWordlist(lang);
	      if (list.map[word] != null) return lang;
	    }
	    throw new Error('Could not determine language.');
	  }

	  /**
	   * Retrieve the wordlist for a language.
	   * @param {String} lang
	   * @returns {Object}
	   */

	  static getWordlist(lang) {
	    const cache = wordlistCache[lang];
	    if (cache) return cache;
	    const words = wordlist.get(lang);
	    const list = new WordList(words);
	    wordlistCache[lang] = list;
	    return list;
	  }

	  /**
	   * Convert mnemonic to a json-friendly object.
	   * @returns {Object}
	   */

	  toJSON() {
	    return {
	      bits: this.bits,
	      language: this.language,
	      entropy: this.getEntropy().toString('hex'),
	      phrase: this.getPhrase()
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json);
	    assert((json.bits & 0xffff) === json.bits);
	    assert(typeof json.language === 'string');
	    assert(typeof json.entropy === 'string');
	    assert(typeof json.phrase === 'string');
	    assert(json.bits >= common.MIN_ENTROPY);
	    assert(json.bits <= common.MAX_ENTROPY);
	    assert(json.bits % 32 === 0);
	    assert(json.bits / 8 === json.entropy.length / 2);
	    this.bits = json.bits;
	    this.language = json.language;
	    this.entropy = Buffer.from(json.entropy, 'hex');
	    this.phrase = json.phrase;
	    return this;
	  }

	  /**
	   * Instantiate mnemonic from json object.
	   * @param {Object} json
	   * @returns {Mnemonic}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += 3;
	    size += this.getEntropy().length;
	    return size;
	  }

	  /**
	   * Write the mnemonic to a buffer writer.
	   * @params {BufferWriter} bw
	   */

	  toWriter(bw) {
	    const lang = Mnemonic.languages.indexOf(this.language);
	    assert(lang !== -1);
	    bw.writeU16(this.bits);
	    bw.writeU8(lang);
	    bw.writeBytes(this.getEntropy());
	    return bw;
	  }

	  /**
	   * Serialize mnemonic.
	   * @returns {Buffer}
	   */

	  toRaw(writer) {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    const bits = br.readU16();
	    assert(bits >= common.MIN_ENTROPY);
	    assert(bits <= common.MAX_ENTROPY);
	    assert(bits % 32 === 0);
	    const language = Mnemonic.languages[br.readU8()];
	    assert(language);
	    this.bits = bits;
	    this.language = language;
	    this.entropy = br.readBytes(bits / 8);
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate mnemonic from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Mnemonic}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate mnemonic from serialized data.
	   * @param {Buffer} data
	   * @returns {Mnemonic}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the mnemonic to a string.
	   * @returns {String}
	   */

	  toString() {
	    return this.getPhrase();
	  }

	  /**
	   * Inspect the mnemonic.
	   * @returns {String}
	   */

	  [inspectSymbol]() {
	    return `<Mnemonic: ${this.getPhrase()}>`;
	  }

	  /**
	   * Test whether an object is a Mnemonic.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMnemonic(obj) {
	    return obj instanceof Mnemonic;
	  }
	}

	/**
	 * List of languages.
	 * @const {String[]}
	 * @default
	 */

	Mnemonic.languages = ['simplified chinese', 'traditional chinese', 'english', 'french', 'italian', 'japanese', 'spanish'];

	/**
	 * Word List
	 * @ignore
	 */

	class WordList {
	  /**
	   * Create word list.
	   * @constructor
	   * @ignore
	   * @param {Array} words
	   */

	  constructor(words) {
	    this.words = words;
	    this.map = Object.create(null);
	    for (let i = 0; i < words.length; i++) {
	      const word = words[i];
	      this.map[word] = i;
	    }
	  }
	}

	/*
	 * Expose
	 */

	mnemonic = Mnemonic;
	return mnemonic;
}

/*!
 * public.js - hd public keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var _public;
var hasRequired_public;

function require_public () {
	if (hasRequired_public) return _public;
	hasRequired_public = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  base58
	} = requireBstring();
	const sha512 = requireSha512();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const cleanse = requireCleanse();
	const secp256k1 = requireSecp256k1();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const common = requireCommon();

	/**
	 * HDPublicKey
	 * @alias module:hd.PublicKey
	 * @property {Number} depth
	 * @property {Number} parentFingerPrint
	 * @property {Number} childIndex
	 * @property {Buffer} chainCode
	 * @property {Buffer} publicKey
	 */

	class HDPublicKey {
	  /**
	   * Create an HD public key.
	   * @constructor
	   * @param {Object|Base58String} options
	   * @param {Base58String?} options.xkey - Serialized base58 key.
	   * @param {Number?} options.depth
	   * @param {Number?} options.parentFingerPrint
	   * @param {Number?} options.childIndex
	   * @param {Buffer?} options.chainCode
	   * @param {Buffer?} options.publicKey
	   */

	  constructor(options) {
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = consensus.ZERO_HASH;
	    this.publicKey = common.ZERO_KEY;
	    this.fingerPrint = -1;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'No options for HDPublicKey');
	    assert((options.depth & 0xff) === options.depth);
	    assert(options.parentFingerPrint >>> 0 === options.parentFingerPrint);
	    assert(options.childIndex >>> 0 === options.childIndex);
	    assert(Buffer.isBuffer(options.chainCode));
	    assert(Buffer.isBuffer(options.publicKey));
	    this.depth = options.depth;
	    this.parentFingerPrint = options.parentFingerPrint;
	    this.childIndex = options.childIndex;
	    this.chainCode = options.chainCode;
	    this.publicKey = options.publicKey;
	    return this;
	  }

	  /**
	   * Instantiate HD public key from options object.
	   * @param {Object} options
	   * @returns {HDPublicKey}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Get HD public key (self).
	   * @returns {HDPublicKey}
	   */

	  toPublic() {
	    return this;
	  }

	  /**
	   * Get cached base58 xprivkey (always null here).
	   * @returns {null}
	   */

	  xprivkey(network) {
	    return null;
	  }

	  /**
	   * Get cached base58 xpubkey.
	   * @returns {Base58String}
	   */

	  xpubkey(network) {
	    return this.toBase58(network);
	  }

	  /**
	   * Destroy the key (zeroes chain code and pubkey).
	   */

	  destroy() {
	    this.depth = 0;
	    this.childIndex = 0;
	    this.parentFingerPrint = 0;
	    cleanse(this.chainCode);
	    cleanse(this.publicKey);
	    this.fingerPrint = -1;
	  }

	  /**
	   * Derive a child key.
	   * @param {Number} index - Derivation index.
	   * @param {Boolean?} hardened - Whether the derivation
	   * should be hardened (throws if true).
	   * @returns {HDPrivateKey}
	   * @throws on `hardened`
	   */

	  derive(index, hardened) {
	    assert(typeof index === 'number');
	    if (index >>> 0 !== index) throw new Error('Index out of range.');
	    if (index & common.HARDENED || hardened) throw new Error('Cannot derive hardened.');
	    if (this.depth >= 0xff) throw new Error('Depth too high.');
	    const id = this.getID(index);
	    const cache = common.cache.get(id);
	    if (cache) return cache;
	    const bw = bio.pool(37);
	    bw.writeBytes(this.publicKey);
	    bw.writeU32BE(index);
	    const data = bw.render();
	    const hash = sha512.mac(data, this.chainCode);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);
	    let key;
	    try {
	      key = secp256k1.publicKeyTweakAdd(this.publicKey, left, true);
	    } catch (e) {
	      return this.derive(index + 1);
	    }
	    if (this.fingerPrint === -1) {
	      const fp = hash160.digest(this.publicKey);
	      this.fingerPrint = fp.readUInt32BE(0, true);
	    }
	    const child = new this.constructor();
	    child.depth = this.depth + 1;
	    child.parentFingerPrint = this.fingerPrint;
	    child.childIndex = index;
	    child.chainCode = right;
	    child.publicKey = key;
	    common.cache.set(id, child);
	    return child;
	  }

	  /**
	   * Unique HD key ID.
	   * @private
	   * @param {Number} index
	   * @returns {String}
	   */

	  getID(index) {
	    return 'b' + this.publicKey.toString('hex') + index;
	  }

	  /**
	   * Derive a BIP44 account key (does not derive, only ensures account key).
	   * @method
	   * @param {Number} purpose
	   * @param {Number} type
	   * @param {Number} account
	   * @returns {HDPublicKey}
	   * @throws Error if key is not already an account key.
	   */

	  deriveAccount(purpose, type, account) {
	    assert(purpose >>> 0 === purpose);
	    assert(type >>> 0 === type);
	    assert(account >>> 0 === account);
	    assert(this.isAccount(account), 'Cannot derive account index.');
	    return this;
	  }

	  /**
	   * Test whether the key is a master key.
	   * @method
	   * @returns {Boolean}
	   */

	  isMaster() {
	    return common.isMaster(this);
	  }

	  /**
	   * Test whether the key is (most likely) a BIP44 account key.
	   * @method
	   * @param {Number?} account
	   * @returns {Boolean}
	   */

	  isAccount(account) {
	    return common.isAccount(this, account);
	  }

	  /**
	   * Test whether a string is a valid path.
	   * @param {String} path
	   * @param {Boolean?} hardened
	   * @returns {Boolean}
	   */

	  static isValidPath(path) {
	    try {
	      common.parsePath(path, false);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Derive a key from a derivation path.
	   * @param {String} path
	   * @returns {HDPublicKey}
	   * @throws Error if `path` is not a valid path.
	   * @throws Error if hardened.
	   */

	  derivePath(path) {
	    const indexes = common.parsePath(path, false);
	    let key = this;
	    for (const index of indexes) key = key.derive(index);
	    return key;
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  equals(obj) {
	    assert(HDPublicKey.isHDPublicKey(obj));
	    return this.depth === obj.depth && this.parentFingerPrint === obj.parentFingerPrint && this.childIndex === obj.childIndex && this.chainCode.equals(obj.chainCode) && this.publicKey.equals(obj.publicKey);
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  compare(key) {
	    assert(HDPublicKey.isHDPublicKey(key));
	    let cmp = this.depth - key.depth;
	    if (cmp !== 0) return cmp;
	    cmp = this.parentFingerPrint - key.parentFingerPrint;
	    if (cmp !== 0) return cmp;
	    cmp = this.childIndex - key.childIndex;
	    if (cmp !== 0) return cmp;
	    cmp = this.chainCode.compare(key.chainCode);
	    if (cmp !== 0) return cmp;
	    cmp = this.publicKey.compare(key.publicKey);
	    if (cmp !== 0) return cmp;
	    return 0;
	  }

	  /**
	   * Convert key to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      xpubkey: this.xpubkey(network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   * @param {Network?} network
	   */

	  fromJSON(json, network) {
	    assert(json.xpubkey, 'Could not handle HD key JSON.');
	    this.fromBase58(json.xpubkey, network);
	    return this;
	  }

	  /**
	   * Instantiate an HDPublicKey from a jsonified key object.
	   * @param {Object} json - The jsonified transaction object.
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromJSON(json, network) {
	    return new this().fromJSON(json, network);
	  }

	  /**
	   * Test whether an object is in the form of a base58 xpubkey.
	   * @param {String} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {Boolean}
	   */

	  static isBase58(data, network) {
	    if (typeof data !== 'string') return false;
	    if (data.length < 4) return false;
	    const prefix = data.substring(0, 4);
	    try {
	      Network.fromPublic58(prefix, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a buffer has a valid network prefix.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {NetworkType}
	   */

	  static isRaw(data, network) {
	    if (!Buffer.isBuffer(data)) return false;
	    if (data.length < 4) return false;
	    const version = data.readUInt32BE(0, true);
	    try {
	      Network.fromPublic(version, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Inject properties from a base58 key.
	   * @private
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   */

	  fromBase58(xkey, network) {
	    assert(typeof xkey === 'string');
	    return this.fromRaw(base58.decode(xkey), network);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   */

	  fromReader(br, network) {
	    const version = br.readU32BE();
	    Network.fromPublic(version, network);
	    this.depth = br.readU8();
	    this.parentFingerPrint = br.readU32BE();
	    this.childIndex = br.readU32BE();
	    this.chainCode = br.readBytes(32);
	    this.publicKey = br.readBytes(33);
	    br.verifyChecksum(hash256.digest);
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   */

	  fromRaw(data, network) {
	    return this.fromReader(bio.read(data), network);
	  }

	  /**
	   * Serialize key data to base58 extended key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Write the key to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {(Network|NetworkType)?} network
	   */

	  toWriter(bw, network) {
	    network = Network.get(network);
	    bw.writeU32BE(network.keyPrefix.xpubkey);
	    bw.writeU8(this.depth);
	    bw.writeU32BE(this.parentFingerPrint);
	    bw.writeU32BE(this.childIndex);
	    bw.writeBytes(this.chainCode);
	    bw.writeBytes(this.publicKey);
	    bw.writeChecksum(hash256.digest);
	    return bw;
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return 82;
	  }

	  /**
	   * Serialize the key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Buffer}
	   */

	  toRaw(network) {
	    return this.toWriter(bio.write(82), network).render();
	  }

	  /**
	   * Instantiate an HD public key from a base58 string.
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   * @returns {HDPublicKey}
	   */

	  static fromBase58(xkey, network) {
	    return new this().fromBase58(xkey, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPublicKey}
	   */

	  static fromReader(br, network) {
	    return new this().fromReader(br, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPublicKey}
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Test whether an object is a HDPublicKey.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHDPublicKey(obj) {
	    return obj instanceof HDPublicKey;
	  }
	}

	/*
	 * Expose
	 */

	_public = HDPublicKey;
	return _public;
}

/*!
 * private.js - hd private keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var _private;
var hasRequired_private;

function require_private () {
	if (hasRequired_private) return _private;
	hasRequired_private = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  base58
	} = requireBstring();
	const sha512 = requireSha512();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const cleanse = requireCleanse();
	const random = requireRandom();
	const secp256k1 = requireSecp256k1();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const common = requireCommon();
	const Mnemonic = requireMnemonic();
	const HDPublicKey = require_public();

	/*
	 * Constants
	 */

	const SEED_SALT = Buffer.from('Bitcoin seed', 'ascii');

	/**
	 * HDPrivateKey
	 * @alias module:hd.PrivateKey
	 * @property {Number} depth
	 * @property {Number} parentFingerPrint
	 * @property {Number} childIndex
	 * @property {Buffer} chainCode
	 * @property {Buffer} privateKey
	 */

	class HDPrivateKey {
	  /**
	   * Create an hd private key.
	   * @constructor
	   * @param {Object|String} options
	   * @param {Number?} options.depth
	   * @param {Number?} options.parentFingerPrint
	   * @param {Number?} options.childIndex
	   * @param {Buffer?} options.chainCode
	   * @param {Buffer?} options.privateKey
	   */

	  constructor(options) {
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = consensus.ZERO_HASH;
	    this.privateKey = consensus.ZERO_HASH;
	    this.publicKey = common.ZERO_KEY;
	    this.fingerPrint = -1;
	    this._hdPublicKey = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'No options for HD private key.');
	    assert((options.depth & 0xff) === options.depth);
	    assert(options.parentFingerPrint >>> 0 === options.parentFingerPrint);
	    assert(options.childIndex >>> 0 === options.childIndex);
	    assert(Buffer.isBuffer(options.chainCode));
	    assert(Buffer.isBuffer(options.privateKey));
	    this.depth = options.depth;
	    this.parentFingerPrint = options.parentFingerPrint;
	    this.childIndex = options.childIndex;
	    this.chainCode = options.chainCode;
	    this.privateKey = options.privateKey;
	    this.publicKey = secp256k1.publicKeyCreate(options.privateKey, true);
	    return this;
	  }

	  /**
	   * Instantiate HD private key from options object.
	   * @param {Object} options
	   * @returns {HDPrivateKey}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Get HD public key.
	   * @returns {HDPublicKey}
	   */

	  toPublic() {
	    let key = this._hdPublicKey;
	    if (!key) {
	      key = new HDPublicKey();
	      key.depth = this.depth;
	      key.parentFingerPrint = this.parentFingerPrint;
	      key.childIndex = this.childIndex;
	      key.chainCode = this.chainCode;
	      key.publicKey = this.publicKey;
	      this._hdPublicKey = key;
	    }
	    return key;
	  }

	  /**
	   * Get cached base58 xprivkey.
	   * @returns {Base58String}
	   */

	  xprivkey(network) {
	    return this.toBase58(network);
	  }

	  /**
	   * Get cached base58 xpubkey.
	   * @returns {Base58String}
	   */

	  xpubkey(network) {
	    return this.toPublic().xpubkey(network);
	  }

	  /**
	   * Destroy the key (zeroes chain code, privkey, and pubkey).
	   * @param {Boolean} pub - Destroy hd public key as well.
	   */

	  destroy(pub) {
	    this.depth = 0;
	    this.childIndex = 0;
	    this.parentFingerPrint = 0;
	    cleanse(this.chainCode);
	    cleanse(this.privateKey);
	    cleanse(this.publicKey);
	    this.fingerPrint = -1;
	    if (this._hdPublicKey) {
	      if (pub) this._hdPublicKey.destroy();
	      this._hdPublicKey = null;
	    }
	  }

	  /**
	   * Derive a child key.
	   * @param {Number} index - Derivation index.
	   * @param {Boolean?} hardened - Whether the derivation should be hardened.
	   * @returns {HDPrivateKey}
	   */

	  derive(index, hardened) {
	    assert(typeof index === 'number');
	    if (index >>> 0 !== index) throw new Error('Index out of range.');
	    if (this.depth >= 0xff) throw new Error('Depth too high.');
	    if (hardened) {
	      index |= common.HARDENED;
	      index >>>= 0;
	    }
	    const id = this.getID(index);
	    const cache = common.cache.get(id);
	    if (cache) return cache;
	    const bw = bio.pool(37);
	    if (index & common.HARDENED) {
	      bw.writeU8(0);
	      bw.writeBytes(this.privateKey);
	      bw.writeU32BE(index);
	    } else {
	      bw.writeBytes(this.publicKey);
	      bw.writeU32BE(index);
	    }
	    const data = bw.render();
	    const hash = sha512.mac(data, this.chainCode);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);
	    let key;
	    try {
	      key = secp256k1.privateKeyTweakAdd(this.privateKey, left);
	    } catch (e) {
	      return this.derive(index + 1);
	    }
	    if (this.fingerPrint === -1) {
	      const fp = hash160.digest(this.publicKey);
	      this.fingerPrint = fp.readUInt32BE(0, true);
	    }
	    const child = new this.constructor();
	    child.depth = this.depth + 1;
	    child.parentFingerPrint = this.fingerPrint;
	    child.childIndex = index;
	    child.chainCode = right;
	    child.privateKey = key;
	    child.publicKey = secp256k1.publicKeyCreate(key, true);
	    common.cache.set(id, child);
	    return child;
	  }

	  /**
	   * Unique HD key ID.
	   * @private
	   * @param {Number} index
	   * @returns {String}
	   */

	  getID(index) {
	    return 'v' + this.publicKey.toString('hex') + index;
	  }

	  /**
	   * Derive a BIP44 account key.
	   * @param {Number} purpose
	   * @param {Number} type
	   * @param {Number} account
	   * @returns {HDPrivateKey}
	   * @throws Error if key is not a master key.
	   */

	  deriveAccount(purpose, type, account) {
	    assert(purpose >>> 0 === purpose, 'Purpose must be a number.');
	    assert(type >>> 0 === type, 'Account index must be a number.');
	    assert(account >>> 0 === account, 'Account index must be a number.');
	    assert(this.isMaster(), 'Cannot derive account index.');
	    return this.derive(purpose, true).derive(type, true).derive(account, true);
	  }

	  /**
	   * Test whether the key is a master key.
	   * @returns {Boolean}
	   */

	  isMaster() {
	    return common.isMaster(this);
	  }

	  /**
	   * Test whether the key is (most likely) a BIP44 account key.
	   * @param {Number?} account
	   * @returns {Boolean}
	   */

	  isAccount(account) {
	    return common.isAccount(this, account);
	  }

	  /**
	   * Test whether an object is in the form of a base58 xprivkey.
	   * @param {String} data
	   * @param {Network?} network
	   * @returns {Boolean}
	   */

	  static isBase58(data, network) {
	    if (typeof data !== 'string') return false;
	    if (data.length < 4) return false;
	    const prefix = data.substring(0, 4);
	    try {
	      Network.fromPrivate58(prefix, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a buffer has a valid network prefix.
	   * @param {Buffer} data
	   * @param {Network?} network
	   * @returns {Boolean}
	   */

	  static isRaw(data, network) {
	    if (!Buffer.isBuffer(data)) return false;
	    if (data.length < 4) return false;
	    const version = data.readUInt32BE(0, true);
	    try {
	      Network.fromPrivate(version, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a string is a valid path.
	   * @param {String} path
	   * @returns {Boolean}
	   */

	  static isValidPath(path) {
	    try {
	      common.parsePath(path, true);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Derive a key from a derivation path.
	   * @param {String} path
	   * @returns {HDPrivateKey}
	   * @throws Error if `path` is not a valid path.
	   */

	  derivePath(path) {
	    const indexes = common.parsePath(path, true);
	    let key = this;
	    for (const index of indexes) key = key.derive(index);
	    return key;
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  equals(obj) {
	    assert(HDPrivateKey.isHDPrivateKey(obj));
	    return this.depth === obj.depth && this.parentFingerPrint === obj.parentFingerPrint && this.childIndex === obj.childIndex && this.chainCode.equals(obj.chainCode) && this.privateKey.equals(obj.privateKey);
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  compare(key) {
	    assert(HDPrivateKey.isHDPrivateKey(key));
	    let cmp = this.depth - key.depth;
	    if (cmp !== 0) return cmp;
	    cmp = this.parentFingerPrint - key.parentFingerPrint;
	    if (cmp !== 0) return cmp;
	    cmp = this.childIndex - key.childIndex;
	    if (cmp !== 0) return cmp;
	    cmp = this.chainCode.compare(key.chainCode);
	    if (cmp !== 0) return cmp;
	    cmp = this.privateKey.compare(key.privateKey);
	    if (cmp !== 0) return cmp;
	    return 0;
	  }

	  /**
	   * Inject properties from seed.
	   * @private
	   * @param {Buffer} seed
	   */

	  fromSeed(seed) {
	    assert(Buffer.isBuffer(seed));
	    if (seed.length * 8 < common.MIN_ENTROPY || seed.length * 8 > common.MAX_ENTROPY) {
	      throw new Error('Entropy not in range.');
	    }
	    const hash = sha512.mac(seed, SEED_SALT);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);

	    // Only a 1 in 2^127 chance of happening.
	    if (!secp256k1.privateKeyVerify(left)) throw new Error('Master private key is invalid.');
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = right;
	    this.privateKey = left;
	    this.publicKey = secp256k1.publicKeyCreate(left, true);
	    return this;
	  }

	  /**
	   * Instantiate an hd private key from a 512 bit seed.
	   * @param {Buffer} seed
	   * @returns {HDPrivateKey}
	   */

	  static fromSeed(seed) {
	    return new this().fromSeed(seed);
	  }

	  /**
	   * Inject properties from a mnemonic.
	   * @private
	   * @param {Mnemonic} mnemonic
	   * @param {String?} passphrase
	   */

	  fromMnemonic(mnemonic, passphrase) {
	    assert(mnemonic instanceof Mnemonic);
	    return this.fromSeed(mnemonic.toSeed(passphrase));
	  }

	  /**
	   * Instantiate an hd private key from a mnemonic.
	   * @param {Mnemonic} mnemonic
	   * @param {String?} passphrase
	   * @returns {HDPrivateKey}
	   */

	  static fromMnemonic(mnemonic, passphrase) {
	    return new this().fromMnemonic(mnemonic, passphrase);
	  }

	  /**
	   * Inject properties from a mnemonic.
	   * @private
	   * @param {String} mnemonic
	   */

	  fromPhrase(phrase) {
	    const mnemonic = Mnemonic.fromPhrase(phrase);
	    this.fromMnemonic(mnemonic);
	    return this;
	  }

	  /**
	   * Instantiate an hd private key from a phrase.
	   * @param {String} phrase
	   * @returns {HDPrivateKey}
	   */

	  static fromPhrase(phrase) {
	    return new this().fromPhrase(phrase);
	  }

	  /**
	   * Inject properties from privateKey and entropy.
	   * @private
	   * @param {Buffer} key
	   * @param {Buffer} entropy
	   */

	  fromKey(key, entropy) {
	    assert(Buffer.isBuffer(key) && key.length === 32);
	    assert(Buffer.isBuffer(entropy) && entropy.length === 32);
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = entropy;
	    this.privateKey = key;
	    this.publicKey = secp256k1.publicKeyCreate(key, true);
	    return this;
	  }

	  /**
	   * Create an hd private key from a key and entropy bytes.
	   * @param {Buffer} key
	   * @param {Buffer} entropy
	   * @returns {HDPrivateKey}
	   */

	  static fromKey(key, entropy) {
	    return new this().fromKey(key, entropy);
	  }

	  /**
	   * Generate an hd private key.
	   * @returns {HDPrivateKey}
	   */

	  static generate() {
	    const key = secp256k1.privateKeyGenerate();
	    const entropy = random.randomBytes(32);
	    return HDPrivateKey.fromKey(key, entropy);
	  }

	  /**
	   * Inject properties from base58 key.
	   * @private
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   */

	  fromBase58(xkey, network) {
	    assert(typeof xkey === 'string');
	    return this.fromRaw(base58.decode(xkey), network);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   */

	  fromReader(br, network) {
	    const version = br.readU32BE();
	    Network.fromPrivate(version, network);
	    this.depth = br.readU8();
	    this.parentFingerPrint = br.readU32BE();
	    this.childIndex = br.readU32BE();
	    this.chainCode = br.readBytes(32);
	    assert(br.readU8() === 0);
	    this.privateKey = br.readBytes(32);
	    this.publicKey = secp256k1.publicKeyCreate(this.privateKey, true);
	    br.verifyChecksum(hash256.digest);
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   */

	  fromRaw(data, network) {
	    return this.fromReader(bio.read(data), network);
	  }

	  /**
	   * Serialize key to a base58 string.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return 82;
	  }

	  /**
	   * Write the key to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {(Network|NetworkType)?} network
	   */

	  toWriter(bw, network) {
	    network = Network.get(network);
	    bw.writeU32BE(network.keyPrefix.xprivkey);
	    bw.writeU8(this.depth);
	    bw.writeU32BE(this.parentFingerPrint);
	    bw.writeU32BE(this.childIndex);
	    bw.writeBytes(this.chainCode);
	    bw.writeU8(0);
	    bw.writeBytes(this.privateKey);
	    bw.writeChecksum(hash256.digest);
	    return bw;
	  }

	  /**
	   * Serialize the key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Buffer}
	   */

	  toRaw(network) {
	    return this.toWriter(bio.write(82), network).render();
	  }

	  /**
	   * Instantiate an HD private key from a base58 string.
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromBase58(xkey, network) {
	    return new this().fromBase58(xkey, network);
	  }

	  /**
	   * Instantiate key from buffer reader.
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromReader(br, network) {
	    return new this().fromReader(br, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Convert key to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      xprivkey: this.xprivkey(network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   * @param {Network?} network
	   */

	  fromJSON(json, network) {
	    assert(json.xprivkey, 'Could not handle key JSON.');
	    this.fromBase58(json.xprivkey, network);
	    return this;
	  }

	  /**
	   * Instantiate an HDPrivateKey from a jsonified key object.
	   * @param {Object} json - The jsonified key object.
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromJSON(json, network) {
	    return new this().fromJSON(json, network);
	  }

	  /**
	   * Test whether an object is an HDPrivateKey.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHDPrivateKey(obj) {
	    return obj instanceof HDPrivateKey;
	  }
	}

	/*
	 * Expose
	 */

	_private = HDPrivateKey;
	return _private;
}

/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredHd$1;

function requireHd$1 () {
	if (hasRequiredHd$1) return hd$1;
	hasRequiredHd$1 = 1;
	(function (exports) {

		const assert = requireAssert$1();
		const common = requireCommon();
		const Mnemonic = requireMnemonic();
		const HDPrivateKey = require_private();
		const HDPublicKey = require_public();
		const wordlist = requireWordlist();

		/**
		 * @exports hd
		 */

		const HD = exports;

		/**
		 * Instantiate an HD key (public or private) from an base58 string.
		 * @param {Base58String} xkey
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromBase58 = function fromBase58(xkey, network) {
		  if (HDPrivateKey.isBase58(xkey)) return HDPrivateKey.fromBase58(xkey, network);
		  return HDPublicKey.fromBase58(xkey, network);
		};

		/**
		 * Generate an {@link HDPrivateKey}.
		 * @param {Object} options
		 * @param {Buffer?} options.privateKey
		 * @param {Buffer?} options.entropy
		 * @returns {HDPrivateKey}
		 */

		HD.generate = function generate() {
		  return HDPrivateKey.generate();
		};

		/**
		 * Generate an {@link HDPrivateKey} from a seed.
		 * @param {Object|Mnemonic|Buffer} options - seed,
		 * mnemonic, mnemonic options.
		 * @returns {HDPrivateKey}
		 */

		HD.fromSeed = function fromSeed(options) {
		  return HDPrivateKey.fromSeed(options);
		};

		/**
		 * Instantiate an hd private key from a mnemonic.
		 * @param {Mnemonic|Object} mnemonic
		 * @returns {HDPrivateKey}
		 */

		HD.fromMnemonic = function fromMnemonic(options) {
		  return HDPrivateKey.fromMnemonic(options);
		};

		/**
		 * Instantiate an HD key from a jsonified key object.
		 * @param {Object} json - The jsonified transaction object.
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromJSON = function fromJSON(json, network) {
		  if (json.xprivkey) return HDPrivateKey.fromJSON(json, network);
		  return HDPublicKey.fromJSON(json, network);
		};

		/**
		 * Instantiate an HD key from serialized data.
		 * @param {Buffer} data
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromRaw = function fromRaw(data, network) {
		  if (HDPrivateKey.isRaw(data, network)) return HDPrivateKey.fromRaw(data, network);
		  return HDPublicKey.fromRaw(data, network);
		};

		/**
		 * Generate an hdkey from any number of options.
		 * @param {Object|Mnemonic|Buffer} options - mnemonic, mnemonic
		 * options, seed, or base58 key.
		 * @param {(Network|NetworkType)?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.from = function from(options, network) {
		  assert(options, 'Options required.');
		  if (HD.isHD(options)) return options;
		  if (HD.isBase58(options, network)) return HD.fromBase58(options, network);
		  if (HD.isRaw(options, network)) return HD.fromRaw(options, network);
		  if (options && typeof options === 'object') return HD.fromMnemonic(options);
		  throw new Error('Cannot create HD key from bad options.');
		};

		/**
		 * Test whether an object is in the form of a base58 hd key.
		 * @param {String} data
		 * @param {Network?} network
		 * @returns {Boolean}
		 */

		HD.isBase58 = function isBase58(data, network) {
		  return HDPrivateKey.isBase58(data, network) || HDPublicKey.isBase58(data, network);
		};

		/**
		 * Test whether an object is in the form of a serialized hd key.
		 * @param {Buffer} data
		 * @param {Network?} network
		 * @returns {NetworkType}
		 */

		HD.isRaw = function isRaw(data, network) {
		  return HDPrivateKey.isRaw(data, network) || HDPublicKey.isRaw(data, network);
		};

		/**
		 * Test whether an object is an HD key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isHD = function isHD(obj) {
		  return HDPrivateKey.isHDPrivateKey(obj) || HDPublicKey.isHDPublicKey(obj);
		};

		/**
		 * Test whether an object is an HD private key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isPrivate = function isPrivate(obj) {
		  return HDPrivateKey.isHDPrivateKey(obj);
		};

		/**
		 * Test whether an object is an HD public key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isPublic = function isPublic(obj) {
		  return HDPublicKey.isHDPublicKey(obj);
		};

		/*
		 * Expose
		 */

		HD.common = common;
		HD.HD = HD;
		HD.Mnemonic = Mnemonic;
		HD.PrivateKey = HDPrivateKey;
		HD.PublicKey = HDPublicKey;
		HD.HDPrivateKey = HDPrivateKey;
		HD.HDPublicKey = HDPublicKey;
		HD.wordlist = wordlist; 
	} (hd$1));
	return hd$1;
}

/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hd;
var hasRequiredHd;

function requireHd () {
	if (hasRequiredHd) return hd;
	hasRequiredHd = 1;

	hd = requireHd$1();
	return hd;
}

var primitives = {};

/*!
 * invitem.js - inv item object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var invitem;
var hasRequiredInvitem;

function requireInvitem () {
	if (hasRequiredInvitem) return invitem;
	hasRequiredInvitem = 1;

	const bio = requireBufio();
	const util = requireUtil();

	/**
	 * Inv Item
	 * @alias module:primitives.InvItem
	 * @constructor
	 * @property {InvType} type
	 * @property {Hash} hash
	 */

	class InvItem {
	  /**
	   * Create an inv item.
	   * @constructor
	   * @param {Number} type
	   * @param {Hash} hash
	   */

	  constructor(type, hash) {
	    this.type = type;
	    this.hash = hash;
	  }

	  /**
	   * Write inv item to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  getSize() {
	    return 36;
	  }

	  /**
	   * Write inv item to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeU32(this.type);
	    bw.writeHash(this.hash);
	    return bw;
	  }

	  /**
	   * Serialize inv item.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.toWriter(bio.write(36)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.type = br.readU32();
	    this.hash = br.readHash();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate inv item from buffer reader.
	   * @param {BufferReader} br
	   * @returns {InvItem}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate inv item from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc
	   * @returns {InvItem}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether the inv item is a block.
	   * @returns {Boolean}
	   */

	  isBlock() {
	    switch (this.type) {
	      case InvItem.types.BLOCK:
	      case InvItem.types.FILTERED_BLOCK:
	      case InvItem.types.CMPCT_BLOCK:
	        return true;
	      default:
	        return false;
	    }
	  }

	  /**
	   * Test whether the inv item is a tx.
	   * @returns {Boolean}
	   */

	  isTX() {
	    switch (this.type) {
	      case InvItem.types.TX:
	        return true;
	      default:
	        return false;
	    }
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }
	}

	/**
	 * Inv types.
	 * @enum {Number}
	 * @default
	 */

	InvItem.types = {
	  TX: 1,
	  BLOCK: 2,
	  FILTERED_BLOCK: 3,
	  CMPCT_BLOCK: 4
	};

	/**
	 * Inv types by value.
	 * @const {Object}
	 */

	InvItem.typesByVal = {
	  1: 'TX',
	  2: 'BLOCK',
	  3: 'FILTERED_BLOCK',
	  4: 'CMPCT_BLOCK'
	};

	/*
	 * Expose
	 */

	invitem = InvItem;
	return invitem;
}

/*!
 * abstractblock.js - abstract block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var abstractblock;
var hasRequiredAbstractblock;

function requireAbstractblock () {
	if (hasRequiredAbstractblock) return abstractblock;
	hasRequiredAbstractblock = 1;

	const assert = requireAssert$1();
	const hash256 = requireHash256();
	const bio = requireBufio();
	const util = requireUtil();
	const InvItem = requireInvitem();
	const consensus = requireConsensus();

	/**
	 * Abstract Block
	 * The class which all block-like objects inherit from.
	 * @alias module:primitives.AbstractBlock
	 * @abstract
	 * @property {Number} version
	 * @property {Hash} prevBlock
	 * @property {Hash} merkleRoot
	 * @property {Number} time
	 * @property {Number} bits
	 * @property {Number} nonce
	 */

	class AbstractBlock {
	  /**
	   * Create an abstract block.
	   * @constructor
	   */

	  constructor() {
	    this.version = 1;
	    this.prevBlock = consensus.ZERO_HASH;
	    this.merkleRoot = consensus.ZERO_HASH;
	    this.time = 0;
	    this.bits = 0;
	    this.nonce = 0;
	    this.mutable = false;
	    this._hash = null;
	    this._hhash = null;
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  parseOptions(options) {
	    assert(options, 'Block data is required.');
	    assert(options.version >>> 0 === options.version);
	    assert(Buffer.isBuffer(options.prevBlock));
	    assert(Buffer.isBuffer(options.merkleRoot));
	    assert(options.time >>> 0 === options.time);
	    assert(options.bits >>> 0 === options.bits);
	    assert(options.nonce >>> 0 === options.nonce);
	    this.version = options.version;
	    this.prevBlock = options.prevBlock;
	    this.merkleRoot = options.merkleRoot;
	    this.time = options.time;
	    this.bits = options.bits;
	    this.nonce = options.nonce;
	    if (options.mutable != null) {
	      assert(typeof options.mutable === 'boolean');
	      this.mutable = options.mutable;
	    }
	    return this;
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  parseJSON(json) {
	    assert(json, 'Block data is required.');
	    assert(json.version >>> 0 === json.version);
	    assert(typeof json.prevBlock === 'string');
	    assert(typeof json.merkleRoot === 'string');
	    assert(json.time >>> 0 === json.time);
	    assert(json.bits >>> 0 === json.bits);
	    assert(json.nonce >>> 0 === json.nonce);
	    this.version = json.version;
	    this.prevBlock = util.fromRev(json.prevBlock);
	    this.merkleRoot = util.fromRev(json.merkleRoot);
	    this.time = json.time;
	    this.bits = json.bits;
	    this.nonce = json.nonce;
	    return this;
	  }

	  /**
	   * Test whether the block is a memblock.
	   * @returns {Boolean}
	   */

	  isMemory() {
	    return false;
	  }

	  /**
	   * Clear any cached values (abstract).
	   */

	  _refresh() {
	    this._hash = null;
	    this._hhash = null;
	  }

	  /**
	   * Clear any cached values.
	   */

	  refresh() {
	    return this._refresh();
	  }

	  /**
	   * Hash the block headers.
	   * @param {String?} enc - Can be `'hex'` or `null`.
	   * @returns {Hash|Buffer} hash
	   */

	  hash(enc) {
	    let h = this._hash;
	    if (!h) {
	      h = hash256.digest(this.toHead());
	      if (!this.mutable) this._hash = h;
	    }
	    if (enc === 'hex') {
	      let hex = this._hhash;
	      if (!hex) {
	        hex = h.toString('hex');
	        if (!this.mutable) this._hhash = hex;
	      }
	      h = hex;
	    }
	    return h;
	  }

	  /**
	   * Serialize the block headers.
	   * @returns {Buffer}
	   */

	  toHead() {
	    return this.writeHead(bio.write(80)).render();
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromHead(data) {
	    return this.readHead(bio.read(data));
	  }

	  /**
	   * Serialize the block headers.
	   * @param {BufferWriter} bw
	   */

	  writeHead(bw) {
	    bw.writeU32(this.version);
	    bw.writeHash(this.prevBlock);
	    bw.writeHash(this.merkleRoot);
	    bw.writeU32(this.time);
	    bw.writeU32(this.bits);
	    bw.writeU32(this.nonce);
	    return bw;
	  }

	  /**
	   * Parse the block headers.
	   * @param {BufferReader} br
	   */

	  readHead(br) {
	    this.version = br.readU32();
	    this.prevBlock = br.readHash();
	    this.merkleRoot = br.readHash();
	    this.time = br.readU32();
	    this.bits = br.readU32();
	    this.nonce = br.readU32();
	    return this;
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verify() {
	    if (!this.verifyPOW()) return false;
	    if (!this.verifyBody()) return false;
	    return true;
	  }

	  /**
	   * Verify proof-of-work.
	   * @returns {Boolean}
	   */

	  verifyPOW() {
	    return consensus.verifyPOW(this.hash(), this.bits);
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    throw new Error('Abstract method.');
	  }

	  /**
	   * Get little-endian block hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash());
	  }

	  /**
	   * Convert the block to an inv item.
	   * @returns {InvItem}
	   */

	  toInv() {
	    return new InvItem(InvItem.types.BLOCK, this.hash());
	  }
	}

	/*
	 * Expose
	 */

	abstractblock = AbstractBlock;
	return abstractblock;
}

var merkle = {};

/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */

var hasRequiredMerkle;

function requireMerkle () {
	if (hasRequiredMerkle) return merkle;
	hasRequiredMerkle = 1;

	const assert = requireAssert();

	// Notes about unbalanced merkle trees:
	//
	// Bitcoin hashes odd nodes with themselves,
	// allowing an attacker to add a duplicate
	// TXID, creating an even number of leaves
	// and computing the same root (CVE-2012-2459).
	// In contrast, RFC 6962 simply propagates
	// odd nodes up.
	//
	// RFC 6962:
	//
	//              R
	//             / \
	//            /   \
	//           /     \
	//          /       \
	//         /         \
	//        k           j <-- same as below
	//       / \          |
	//      /   \         |
	//     /     \        |
	//    h       i       j
	//   / \     / \     / \
	//  a   b   c   d   e   f
	//
	// Bitcoin Behavior:
	//
	//              R
	//             / \
	//            /   \
	//           /     \
	//          /       \
	//         /         \
	//        k           l <-- HASH(j || j)
	//       / \          |
	//      /   \         |
	//     /     \        |
	//    h       i       j
	//   / \     / \     / \
	//  a   b   c   d   e   f
	//
	// This creates a situation where these leaves:
	//
	//        R
	//       / \
	//      /   \
	//     /     \
	//    d       e <-- HASH(c || c)
	//   / \     / \
	//  a   b   c   c
	//
	// Compute the same root as:
	//
	//       R
	//      / \
	//     /   \
	//    d     e <-- HASH(c || c)
	//   / \    |
	//  a   b   c
	//
	// Why does this matter? Duplicate TXIDs are
	// invalid right? They're spending the same
	// inputs! The problem arises in certain
	// implementation optimizations which may
	// mark a block hash invalid. In other words,
	// an invalid block shares the same block
	// hash as a valid one!
	//
	// See:
	//   https://tools.ietf.org/html/rfc6962#section-2.1
	//   https://nvd.nist.gov/vuln/detail/CVE-2012-2459
	//   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459
	//   https://bitcointalk.org/?topic=81749

	/**
	 * Build a merkle tree from leaves.
	 * @param {Object} alg
	 * @param {Buffer[]} leaves
	 * @returns {Array} [nodes, malleated]
	 */

	function createTree(alg, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Array.isArray(leaves));
	  const nodes = new Array(leaves.length);
	  for (let i = 0; i < leaves.length; i++) nodes[i] = leaves[i];
	  let size = nodes.length;
	  let malleated = false;
	  let i = 0;
	  if (size === 0) {
	    nodes.push(alg.zero);
	    return [nodes, malleated];
	  }
	  while (size > 1) {
	    for (let j = 0; j < size; j += 2) {
	      const k = Math.min(j + 1, size - 1);
	      const left = nodes[i + j];
	      const right = nodes[i + k];
	      if (k === j + 1 && k + 1 === size && left.equals(right)) {
	        malleated = true;
	      }
	      const hash = alg.root(left, right);
	      nodes.push(hash);
	    }
	    i += size;
	    size = size + 1 >>> 1;
	  }
	  return [nodes, malleated];
	}

	/**
	 * Calculate merkle root from leaves.
	 * @param {Object} alg
	 * @param {Buffer[]} leaves
	 * @returns {Array} [root, malleated]
	 */

	function createRoot(alg, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Array.isArray(leaves));
	  const [nodes, malleated] = createTree(alg, leaves);
	  const root = nodes[nodes.length - 1];
	  return [root, malleated];
	}

	/**
	 * Collect a merkle branch from vector index.
	 * @param {Object} alg
	 * @param {Number} index
	 * @param {Buffer[]} leaves
	 * @returns {Buffer[]} branch
	 */

	function createBranch(alg, index, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert(index >>> 0 === index);
	  assert(Array.isArray(leaves));
	  assert(index < leaves.length);
	  let size = leaves.length;
	  const [nodes] = createTree(alg, leaves);
	  const branch = [];
	  let i = 0;
	  while (size > 1) {
	    const j = Math.min(index ^ 1, size - 1);
	    branch.push(nodes[i + j]);
	    index >>>= 1;
	    i += size;
	    size = size + 1 >>> 1;
	  }
	  return branch;
	}

	/**
	 * Derive merkle root from branch.
	 * @param {Object} alg
	 * @param {Buffer} hash
	 * @param {Buffer[]} branch
	 * @param {Number} index
	 * @returns {Buffer} root
	 */

	function deriveRoot(alg, hash, branch, index) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Buffer.isBuffer(hash));
	  assert(Array.isArray(branch));
	  assert(index >>> 0 === index);
	  let root = hash;
	  for (const hash of branch) {
	    if (index & 1 && hash.equals(root)) return alg.zero;
	    if (index & 1) root = alg.root(hash, root);else root = alg.root(root, hash);
	    index >>>= 1;
	  }
	  return root;
	}

	/*
	 * Expose
	 */

	merkle.createTree = createTree;
	merkle.createRoot = createRoot;
	merkle.createBranch = createBranch;
	merkle.deriveRoot = deriveRoot;
	return merkle;
}

/*!
 * input.js - input object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const Network = requireNetwork();
	const Script = requireScript$1();
	const Outpoint = requireOutpoint();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Input
	 * Represents a transaction input.
	 * @alias module:primitives.Input
	 * @property {Outpoint} prevout - Outpoint.
	 * @property {Script} script - Input script / scriptSig.
	 * @property {Number} sequence - nSequence.
	 */

	class Input {
	  /**
	   * Create transaction input.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    this.prevout = new Outpoint();
	    this.script = new Script();
	    this.sequence = 0xffffffff;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Input data is required.');
	    this.prevout.fromOptions(options.prevout);
	    if (options.script) this.script.fromOptions(options.script);
	    if (options.sequence != null) {
	      assert(options.sequence >>> 0 === options.sequence, 'Sequence must be a uint32.');
	      this.sequence = options.sequence;
	    }
	    return this;
	  }

	  /**
	   * Instantiate an Input from options object.
	   * @param {Object} options
	   * @returns {Input}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the input.
	   * @returns {Input}
	   */

	  clone() {
	    const input = new this.constructor();
	    input.prevout = this.prevout;
	    input.script.inject(this.script);
	    input.sequence = this.sequence;
	    return input;
	  }

	  /**
	   * Test equality against another input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  equals(input) {
	    assert(Input.isInput(input));
	    return this.prevout.equals(input.prevout);
	  }

	  /**
	   * Compare against another input (BIP69).
	   * @param {Input} input
	   * @returns {Number}
	   */

	  compare(input) {
	    assert(Input.isInput(input));
	    return this.prevout.compare(input.prevout);
	  }

	  /**
	   * Get the previous output script type as a string.
	   * Will "guess" based on the input script and/or
	   * witness if coin is not available.
	   * @param {Coin?} coin
	   * @returns {ScriptType} type
	   */

	  getType(coin) {
	    if (this.isCoinbase()) return 'coinbase';
	    if (coin) return coin.getType();
	    const type = this.script.getInputType();
	    return Script.typesByVal[type].toLowerCase();
	  }

	  /**
	   * Get the redeem script.
	   * @param {Coin?} coin
	   * @returns {Script?} Redeem script.
	   */

	  getRedeem(coin) {
	    if (this.isCoinbase()) return null;
	    if (!coin) {
	      if (this.script.isScripthashInput()) return this.script.getRedeem();
	      return null;
	    }
	    let prev = coin.script;
	    let redeem = null;
	    if (prev.isScripthash()) {
	      prev = this.script.getRedeem();
	      redeem = prev;
	    }
	    return redeem;
	  }

	  /**
	   * Get the redeem script type.
	   * @param {Coin?} coin
	   * @returns {String} subtype
	   */

	  getSubtype(coin) {
	    if (this.isCoinbase()) return null;
	    const redeem = this.getRedeem(coin);
	    if (!redeem) return null;
	    const type = redeem.getType();
	    return Script.typesByVal[type].toLowerCase();
	  }

	  /**
	   * Get the previous output script's address. Will "guess"
	   * based on the input script and/or witness if coin
	   * is not available.
	   * @param {Coin?} coin
	   * @returns {Address?} addr
	   */

	  getAddress(coin) {
	    if (this.isCoinbase()) return null;
	    if (coin) return coin.getAddress();
	    if (this.script.code.length > 0) return this.script.getInputAddress();
	    return null;
	  }

	  /**
	   * Get the address hash.
	   * @param {Coin?} coin
	   * @param {String?} enc
	   * @returns {Hash} hash
	   */

	  getHash(coin, enc) {
	    const addr = this.getAddress(coin);
	    if (!addr) return null;
	    return addr.getHash(enc);
	  }

	  /**
	   * Test to see if nSequence is equal to uint32max.
	   * @returns {Boolean}
	   */

	  isFinal() {
	    return this.sequence === 0xffffffff;
	  }

	  /**
	   * Test to see if nSequence is less than 0xfffffffe.
	   * @returns {Boolean}
	   */

	  isRBF() {
	    return this.sequence < 0xfffffffe;
	  }

	  /**
	   * Test to see if outpoint is null.
	   * @returns {Boolean}
	   */

	  isCoinbase() {
	    return this.prevout.isNull();
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @param {Coin?} coin
	   * @returns {Object}
	   */

	  format(coin) {
	    return {
	      type: this.getType(coin),
	      subtype: this.getSubtype(coin),
	      address: this.getAddress(coin),
	      script: this.script,
	      redeem: this.getRedeem(coin),
	      sequence: this.sequence,
	      prevout: this.prevout,
	      coin: coin || null
	    };
	  }

	  /**
	   * Convert the input to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON(network, coin) {
	    return this.getJSON();
	  }

	  /**
	   * Convert the input to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {Coin} coin
	   * @returns {Object}
	   */

	  getJSON(network, coin) {
	    network = Network.get(network);
	    let addr;
	    if (!coin) {
	      addr = this.getAddress();
	      if (addr) addr = addr.toString(network);
	    }
	    return {
	      prevout: this.prevout.toJSON(),
	      script: this.script.toJSON(),
	      sequence: this.sequence,
	      address: addr,
	      coin: coin ? coin.getJSON(network, true) : undefined
	    };
	  }

	  /**
	   * Inject properties from a JSON object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Input data is required.');
	    assert(json.sequence >>> 0 === json.sequence, 'Sequence must be a uint32.');
	    this.prevout.fromJSON(json.prevout);
	    this.script.fromJSON(json.script);
	    this.sequence = json.sequence;
	    return this;
	  }

	  /**
	   * Instantiate an Input from a jsonified input object.
	   * @param {Object} json - The jsonified input object.
	   * @returns {Input}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate size of serialized input.
	   * @returns {Number}
	   */

	  getSize() {
	    return 40 + this.script.getVarSize();
	  }

	  /**
	   * Serialize the input.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Write the input to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.prevout.toWriter(bw);
	    bw.writeVarBytes(this.script.toRaw());
	    bw.writeU32(this.sequence);
	    return bw;
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.prevout.fromReader(br);
	    this.script.fromRaw(br.readVarBytes());
	    this.sequence = br.readU32();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate an input from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Input}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate an input from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Input}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from outpoint.
	   * @private
	   * @param {Outpoint} outpoint
	   */

	  fromOutpoint(outpoint) {
	    assert(Buffer.isBuffer(outpoint.hash));
	    assert(typeof outpoint.index === 'number');
	    this.prevout.hash = outpoint.hash;
	    this.prevout.index = outpoint.index;
	    return this;
	  }

	  /**
	   * Instantiate input from outpoint.
	   * @param {Outpoint}
	   * @returns {Input}
	   */

	  static fromOutpoint(outpoint) {
	    return new this().fromOutpoint(outpoint);
	  }

	  /**
	   * Inject properties from coin.
	   * @private
	   * @param {Coin} coin
	   */

	  fromCoin(coin) {
	    assert(Buffer.isBuffer(coin.hash));
	    assert(typeof coin.index === 'number');
	    this.prevout.hash = coin.hash;
	    this.prevout.index = coin.index;
	    return this;
	  }

	  /**
	   * Instantiate input from coin.
	   * @param {Coin}
	   * @returns {Input}
	   */

	  static fromCoin(coin) {
	    return new this().fromCoin(coin);
	  }

	  /**
	   * Inject properties from transaction.
	   * @private
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index) {
	    assert(tx);
	    assert(typeof index === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.prevout.hash = tx.hash();
	    this.prevout.index = index;
	    return this;
	  }

	  /**
	   * Instantiate input from tx.
	   * @param {TX} tx
	   * @param {Number} index
	   * @returns {Input}
	   */

	  static fromTX(tx, index) {
	    return new this().fromTX(tx, index);
	  }

	  /**
	   * Test an object to see if it is an Input.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isInput(obj) {
	    return obj instanceof Input;
	  }
	}

	/*
	 * Expose
	 */

	input = Input;
	return input;
}

/*!
 * tx.js - transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var tx;
var hasRequiredTx;

function requireTx () {
	if (hasRequiredTx) return tx;
	hasRequiredTx = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const hash256 = requireHash256();
	const secp256k1 = requireSecp256k1();
	const {
	  BufferSet
	} = requireBufferMap();
	const util = requireUtil();
	const Amount = requireAmount();
	const Network = requireNetwork();
	const Script = requireScript$1();
	const SLP = requireSlp();
	const Input = requireInput();
	const Output = requireOutput();
	const Outpoint = requireOutpoint();
	const InvItem = requireInvitem();
	const consensus = requireConsensus();
	const policy = requirePolicy();
	const ScriptError = requireScripterror();
	const {
	  encoding
	} = bio;
	const {
	  hashType
	} = Script;
	const common = requireCommon$1();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * TX
	 * A static transaction object.
	 * @alias module:primitives.TX
	 * @property {Number} version
	 * @property {Input[]} inputs
	 * @property {Output[]} outputs
	 * @property {Number} locktime
	 * @property {SlpTokenRecord?} slpToken
	 */

	class TX {
	  /**
	   * Create a transaction.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.version = 1;
	    this.inputs = [];
	    this.outputs = [];
	    this.locktime = 0;
	    this.mutable = false;
	    this._hash = null;
	    this._hhash = null;
	    this._raw = null;
	    this._offset = -1;
	    this._block = false;
	    this._size = -1;
	    this._sigops = -1;
	    this._hashPrevouts = null;
	    this._hashSequence = null;
	    this._hashOutputs = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'TX data is required.');
	    if (options.version != null) {
	      assert(options.version >>> 0 === options.version, 'Version must be a uint32.');
	      this.version = options.version;
	    }
	    if (options.inputs) {
	      assert(Array.isArray(options.inputs), 'Inputs must be an array.');
	      for (const input of options.inputs) this.inputs.push(new Input(input));
	    }
	    if (options.outputs) {
	      assert(Array.isArray(options.outputs), 'Outputs must be an array.');
	      for (const output of options.outputs) this.outputs.push(new Output(output));
	    }
	    if (options.locktime != null) {
	      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');
	      this.locktime = options.locktime;
	    }
	    if (options.slpToken) {
	      if (options.slpToken.constructor === SLP.TokenRecord().constructor) {
	        this.slpToken = options.slpToken;
	      }
	    }
	    return this;
	  }

	  /**
	   * Instantiate TX from options object.
	   * @param {Object} options
	   * @returns {TX}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the transaction.
	   * @returns {TX}
	   */

	  clone() {
	    return new this.constructor().inject(this);
	  }

	  /**
	   * Inject properties from tx.
	   * Used for cloning.
	   * @private
	   * @param {TX} tx
	   * @returns {TX}
	   */

	  inject(tx) {
	    this.version = tx.version;
	    for (const input of tx.inputs) this.inputs.push(input.clone());
	    for (const output of tx.outputs) this.outputs.push(output.clone());
	    this.locktime = tx.locktime;
	    return this;
	  }

	  /**
	   * Clear any cached values.
	   */

	  refresh() {
	    this._hash = null;
	    this._hhash = null;
	    this._raw = null;
	    this._size = -1;
	    this._offset = -1;
	    this._block = false;
	    this._sigops = -1;
	    this._hashPrevouts = null;
	    this._hashSequence = null;
	    this._hashOutputs = null;
	  }

	  /**
	   * Hash the transaction with the non-witness serialization.
	   * @param {String?} enc - Can be `'hex'` or `null`.
	   * @returns {Hash|Buffer} hash
	   */

	  hash(enc) {
	    let h = this._hash;
	    if (!h) {
	      h = hash256.digest(this.toRaw());
	      if (!this.mutable) this._hash = h;
	    }
	    if (enc === 'hex') {
	      let hex = this._hhash;
	      if (!hex) {
	        hex = h.toString('hex');
	        if (!this.mutable) this._hhash = hex;
	      }
	      h = hex;
	    }
	    return h;
	  }

	  /**
	   * Serialize the transaction. Note
	   * that this is cached.
	   * @returns {Buffer} Serialized transaction.
	   */

	  toRaw() {
	    return this.frame().data;
	  }

	  /**
	   * Write the transaction to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {Boolean} block
	   */

	  toWriter(bw, block) {
	    if (this.mutable) return this.writeNormal(bw);
	    if (block) {
	      this._offset = bw.offset;
	      this._block = true;
	    }
	    bw.writeBytes(this.toRaw());
	    return bw;
	  }

	  /**
	   * Serialize the transaction. Note
	   * that this is cached.
	   * @private
	   * @returns {RawTX}
	   */

	  frame() {
	    if (this.mutable) {
	      assert(!this._raw);
	      return this.frameNormal();
	    }
	    if (this._raw) {
	      assert(this._size >= 0);
	      const raw = new RawTX(this._size);
	      raw.data = this._raw;
	      return raw;
	    }
	    const raw = this.frameNormal();
	    this._raw = raw.data;
	    this._size = raw.size;
	    return raw;
	  }

	  /**
	   * Return the offset and size of the transaction. Useful
	   * when the transaction is deserialized within a block.
	   * @returns {Object} contains `size` and `offset`.
	   */

	  getPosition() {
	    if (!(this._block && this._offset > 80)) console.log(this);
	    assert(this._block && this._offset > 80, 'Position not available.');
	    return {
	      offset: this._offset,
	      size: this._size
	    };
	  }

	  /**
	   * Calculate the real size of the transaction.
	   * @returns {Number} size
	   */

	  getSize() {
	    if (this.mutable) return this.getNormalSizes().size;
	    return this.frame().size;
	  }

	  /**
	   * Get the signature hash of the transaction for signing verifying.
	   * @param {Number} index - Index of input being signed/verified.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {SighashType} type - Sighash type.
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature hash.
	   */

	  signatureHash(index, prev, value, type, flags) {
	    assert(index >= 0 && index < this.inputs.length);
	    assert(prev instanceof Script);
	    assert(typeof value === 'number');
	    assert(typeof type === 'number');
	    if (flags == null) flags = Script.flags.STANDARD_VERIFY_FLAGS;
	    if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {
	      const newForkValue = common.getHashTypeForkValue(type) ^ 0xdead;
	      type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);
	    }
	    if (type & Script.hashType.SIGHASH_FORKID && flags & Script.flags.VERIFY_SIGHASH_FORKID) {
	      return this.signatureHashV1(index, prev, value, type);
	    }
	    return this.signatureHashV0(index, prev, type);
	  }

	  /**
	   * Legacy sighashing -- O(n^2).
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {SighashType} type
	   * @returns {Buffer}
	   */

	  signatureHashV0(index, prev, type) {
	    if ((type & 0x1f) === hashType.SINGLE) {
	      // Bitcoind used to return 1 as an error code:
	      // it ended up being treated like a hash.
	      if (index >= this.outputs.length) {
	        const hash = Buffer.alloc(32, 0x00);
	        hash[0] = 0x01;
	        return hash;
	      }
	    }

	    // Remove all code separators.
	    prev = prev.removeSeparators();

	    // Calculate buffer size.
	    const size = this.hashSize(index, prev, type);
	    const bw = bio.pool(size);
	    bw.writeU32(this.version);

	    // Serialize inputs.
	    if (type & hashType.ANYONECANPAY) {
	      // Serialize only the current
	      // input if ANYONECANPAY.
	      const input = this.inputs[index];

	      // Count.
	      bw.writeVarint(1);

	      // Outpoint.
	      input.prevout.toWriter(bw);

	      // Replace script with previous
	      // output script if current index.
	      bw.writeVarBytes(prev.toRaw());
	      bw.writeU32(input.sequence);
	    } else {
	      bw.writeVarint(this.inputs.length);
	      for (let i = 0; i < this.inputs.length; i++) {
	        const input = this.inputs[i];

	        // Outpoint.
	        input.prevout.toWriter(bw);

	        // Replace script with previous
	        // output script if current index.
	        if (i === index) {
	          bw.writeVarBytes(prev.toRaw());
	          bw.writeU32(input.sequence);
	          continue;
	        }

	        // Script is null.
	        bw.writeVarint(0);

	        // Sequences are 0 if NONE or SINGLE.
	        switch (type & 0x1f) {
	          case hashType.NONE:
	          case hashType.SINGLE:
	            bw.writeU32(0);
	            break;
	          default:
	            bw.writeU32(input.sequence);
	            break;
	        }
	      }
	    }

	    // Serialize outputs.
	    switch (type & 0x1f) {
	      case hashType.NONE:
	        {
	          // No outputs if NONE.
	          bw.writeVarint(0);
	          break;
	        }
	      case hashType.SINGLE:
	        {
	          const output = this.outputs[index];

	          // Drop all outputs after the
	          // current input index if SINGLE.
	          bw.writeVarint(index + 1);
	          for (let i = 0; i < index; i++) {
	            // Null all outputs not at
	            // current input index.
	            bw.writeI64(-1);
	            bw.writeVarint(0);
	          }

	          // Regular serialization
	          // at current input index.
	          output.toWriter(bw);
	          break;
	        }
	      default:
	        {
	          // Regular output serialization if ALL.
	          bw.writeVarint(this.outputs.length);
	          for (const output of this.outputs) output.toWriter(bw);
	          break;
	        }
	    }
	    bw.writeU32(this.locktime);

	    // Append the hash type.
	    bw.writeU32(type);
	    return hash256.digest(bw.render());
	  }

	  /**
	   * Calculate sighash size.
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Number} type
	   * @returns {Number}
	   */

	  hashSize(index, prev, type) {
	    let size = 0;
	    size += 4;
	    if (type & hashType.ANYONECANPAY) {
	      size += 1;
	      size += 36;
	      size += prev.getVarSize();
	      size += 4;
	    } else {
	      size += encoding.sizeVarint(this.inputs.length);
	      size += 41 * (this.inputs.length - 1);
	      size += 36;
	      size += prev.getVarSize();
	      size += 4;
	    }
	    switch (type & 0x1f) {
	      case hashType.NONE:
	        size += 1;
	        break;
	      case hashType.SINGLE:
	        size += encoding.sizeVarint(index + 1);
	        size += 9 * index;
	        size += this.outputs[index].getSize();
	        break;
	      default:
	        size += encoding.sizeVarint(this.outputs.length);
	        for (const output of this.outputs) size += output.getSize();
	        break;
	    }
	    size += 8;
	    return size;
	  }

	  /**
	   * Witness sighashing -- O(n).
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Amount} value
	   * @param {SighashType} type
	   * @returns {Buffer}
	   */

	  signatureHashV1(index, prev, value, type) {
	    const input = this.inputs[index];
	    let prevouts = consensus.ZERO_HASH;
	    let sequences = consensus.ZERO_HASH;
	    let outputs = consensus.ZERO_HASH;
	    if (!(type & hashType.ANYONECANPAY)) {
	      if (this._hashPrevouts) {
	        prevouts = this._hashPrevouts;
	      } else {
	        const bw = bio.pool(this.inputs.length * 36);
	        for (const input of this.inputs) input.prevout.toWriter(bw);
	        prevouts = hash256.digest(bw.render());
	        if (!this.mutable) this._hashPrevouts = prevouts;
	      }
	    }
	    if (!(type & hashType.ANYONECANPAY) && (type & 0x1f) !== hashType.SINGLE && (type & 0x1f) !== hashType.NONE) {
	      if (this._hashSequence) {
	        sequences = this._hashSequence;
	      } else {
	        const bw = bio.pool(this.inputs.length * 4);
	        for (const input of this.inputs) bw.writeU32(input.sequence);
	        sequences = hash256.digest(bw.render());
	        if (!this.mutable) this._hashSequence = sequences;
	      }
	    }
	    if ((type & 0x1f) !== hashType.SINGLE && (type & 0x1f) !== hashType.NONE) {
	      if (this._hashOutputs) {
	        outputs = this._hashOutputs;
	      } else {
	        let size = 0;
	        for (const output of this.outputs) size += output.getSize();
	        const bw = bio.pool(size);
	        for (const output of this.outputs) output.toWriter(bw);
	        outputs = hash256.digest(bw.render());
	        if (!this.mutable) this._hashOutputs = outputs;
	      }
	    } else if ((type & 0x1f) === hashType.SINGLE) {
	      if (index < this.outputs.length) {
	        const output = this.outputs[index];
	        outputs = hash256.digest(output.toRaw());
	      }
	    }
	    const size = 156 + prev.getVarSize();
	    const bw = bio.pool(size);
	    bw.writeU32(this.version);
	    bw.writeBytes(prevouts);
	    bw.writeBytes(sequences);
	    bw.writeHash(input.prevout.hash);
	    bw.writeU32(input.prevout.index);
	    bw.writeVarBytes(prev.toRaw());
	    bw.writeI64(value);
	    bw.writeU32(input.sequence);
	    bw.writeBytes(outputs);
	    bw.writeU32(this.locktime);
	    bw.writeU32(type);
	    return hash256.digest(bw.render());
	  }

	  /**
	   * Verify signature.
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Amount} value
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @param {Number} flags
	   * @returns {Boolean}
	   */

	  checksig(index, prev, value, sig, key, flags) {
	    if (sig.length === 0) return false;
	    const type = sig[sig.length - 1];
	    const hash = this.signatureHash(index, prev, value, type, flags);
	    let res;
	    if (common.isSchnorr(sig)) {
	      res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key);
	    } else {
	      res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);
	    }
	    return res;
	  }

	  /**
	   * Create a signature suitable for inserting into scriptSigs.
	   * @param {Number} index - Index of input being signed.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {Buffer} key
	   * @param {SighashType} type
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature in SCHNORR / DER format.
	   */

	  signature(index, prev, value, key, type, flags) {
	    let sig;
	    if (type == null) type = hashType.ALL;
	    if (flags == null) flags = Script.flags.VERIFY_SIGHASH_FORKID;
	    const hash = this.signatureHash(index, prev, value, type, flags);
	    const DER = secp256k1.signDER(hash, key);
	    const SCHNORR = secp256k1.schnorrSign(hash, key);
	    if (common.isSchnorr(SCHNORR)) {
	      sig = SCHNORR;
	    } else {
	      sig = DER;
	    }
	    const bw = bio.write(sig.length + 1);
	    bw.writeBytes(sig);
	    bw.writeU8(type);
	    return bw.render();
	  }

	  /**
	   * Create a signature suitable for inserting into scriptSigs.
	   * @param {Number} index - Index of input being signed.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {Buffer} key
	   * @param {SighashType} type
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature in Schnorr format.
	   */

	  schnorrSignature(index, prev, value, key, type, flags) {
	    if (type == null) type = hashType.ALL;
	    if (flags == null) flags = Script.flags.VERIFY_SIGHASH_FORKID;
	    const hash = this.signatureHash(index, prev, value, type, flags);
	    const sig = secp256k1.schnorrSign(hash, key);
	    const bw = bio.write(sig.length + 1);
	    bw.writeBytes(sig);
	    bw.writeU8(type);
	    return bw.render();
	  }

	  /**
	   * Verify all transaction inputs.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @throws {ScriptError} on invalid inputs
	   */

	  check(view, flags) {
	    if (this.inputs.length === 0) throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');
	    if (this.isCoinbase()) return;
	    for (let i = 0; i < this.inputs.length; i++) {
	      const {
	        prevout
	      } = this.inputs[i];
	      const coin = view.getOutput(prevout);
	      if (!coin) throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');
	      this.checkInput(i, coin, flags);
	    }
	  }

	  /**
	   * Verify a transaction input.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @throws {ScriptError} on invalid input
	   */

	  checkInput(index, coin, flags) {
	    const input = this.inputs[index];
	    assert(input, 'Input does not exist.');
	    assert(coin, 'No coin passed.');
	    Script.verify(input.script, null, coin.script, this, index, coin.value, flags);
	  }

	  /**
	   * Verify the transaction inputs on the worker pool
	   * (if workers are enabled).
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async checkAsync(view, flags, pool) {
	    if (this.inputs.length === 0) throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');
	    if (this.isCoinbase()) return;
	    if (!pool) {
	      this.check(view, flags);
	      return;
	    }
	    await pool.check(this, view, flags);
	  }

	  /**
	   * Verify a transaction input asynchronously.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async checkInputAsync(index, coin, flags, pool) {
	    const input = this.inputs[index];
	    assert(input, 'Input does not exist.');
	    assert(coin, 'No coin passed.');
	    if (!pool) {
	      this.checkInput(index, coin, flags);
	      return;
	    }
	    await pool.checkInput(this, index, coin, flags);
	  }

	  /**
	   * Verify all transaction inputs.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @returns {Boolean} Whether the inputs are valid.
	   */

	  verify(view, flags) {
	    try {
	      this.check(view, flags);
	    } catch (e) {
	      if (e.type === 'ScriptError') return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify a transaction input.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @returns {Boolean} Whether the input is valid.
	   */

	  verifyInput(index, coin, flags) {
	    try {
	      this.checkInput(index, coin, flags);
	    } catch (e) {
	      if (e.type === 'ScriptError') return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify the transaction inputs on the worker pool
	   * (if workers are enabled).
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async verifyAsync(view, flags, pool) {
	    try {
	      await this.checkAsync(view, flags, pool);
	    } catch (e) {
	      if (e.type === 'ScriptError') return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify a transaction input asynchronously.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async verifyInputAsync(index, coin, flags, pool) {
	    try {
	      await this.checkInput(index, coin, flags, pool);
	    } catch (e) {
	      if (e.type === 'ScriptError') return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Test whether the transaction is a coinbase
	   * by examining the inputs.
	   * @returns {Boolean}
	   */

	  isCoinbase() {
	    return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
	  }

	  /**
	   * Test whether the transaction is replaceable.
	   * @returns {Boolean}
	   */

	  isRBF() {
	    // Core doesn't do this, but it should:
	    if (this.version === 2) return false;
	    for (const input of this.inputs) {
	      if (input.isRBF()) return true;
	    }
	    return false;
	  }

	  /**
	   * Calculate the fee for the transaction.
	   * @param {CoinView} view
	   * @returns {Amount} fee (zero if not all coins are available).
	   */

	  getFee(view) {
	    if (!this.hasCoins(view)) return 0;
	    return this.getInputValue(view) - this.getOutputValue();
	  }

	  /**
	   * Calculate the total input value.
	   * @param {CoinView} view
	   * @returns {Amount} value
	   */

	  getInputValue(view) {
	    let total = 0;
	    for (const {
	      prevout
	    } of this.inputs) {
	      const coin = view.getOutput(prevout);
	      if (!coin) return 0;
	      total += coin.value;
	    }
	    return total;
	  }

	  /**
	   * Calculate the total output value.
	   * @returns {Amount} value
	   */

	  getOutputValue() {
	    let total = 0;
	    for (const output of this.outputs) total += output.value;
	    return total;
	  }

	  /**
	   * Get all input addresses.
	   * @private
	   * @param {CoinView} view
	   * @returns {Array} [addrs, table]
	   */

	  _getInputAddresses(view) {
	    const table = new BufferSet();
	    const addrs = [];
	    if (this.isCoinbase()) return [addrs, table];
	    for (const input of this.inputs) {
	      const coin = view ? view.getOutputFor(input) : null;
	      const addr = input.getAddress(coin);
	      if (!addr) continue;
	      const hash = addr.getHash();
	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }
	    return [addrs, table];
	  }

	  /**
	   * Get all output addresses.
	   * @private
	   * @returns {Array} [addrs, table]
	   */

	  _getOutputAddresses() {
	    const table = new BufferSet();
	    const addrs = [];
	    for (const output of this.outputs) {
	      const addr = output.getAddress();
	      if (!addr) continue;
	      const hash = addr.getHash();
	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }
	    return [addrs, table];
	  }

	  /**
	   * Get all addresses.
	   * @private
	   * @param {CoinView} view
	   * @returns {Array} [addrs, table]
	   */

	  _getAddresses(view) {
	    const [addrs, table] = this._getInputAddresses(view);
	    const output = this.getOutputAddresses();
	    for (const addr of output) {
	      const hash = addr.getHash();
	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }
	    return [addrs, table];
	  }

	  /**
	   * Get all input addresses.
	   * @param {CoinView|null} view
	   * @returns {Address[]} addresses
	   */

	  getInputAddresses(view) {
	    const [addrs] = this._getInputAddresses(view);
	    return addrs;
	  }

	  /**
	   * Get all output addresses.
	   * @returns {Address[]} addresses
	   */

	  getOutputAddresses() {
	    const [addrs] = this._getOutputAddresses();
	    return addrs;
	  }

	  /**
	   * Get all addresses.
	   * @param {CoinView|null} view
	   * @returns {Address[]} addresses
	   */

	  getAddresses(view) {
	    const [addrs] = this._getAddresses(view);
	    return addrs;
	  }

	  /**
	   * Get all input address hashes.
	   * @param {CoinView|null} view
	   * @returns {Hash[]} hashes
	   */

	  getInputHashes(view, enc) {
	    const [, table] = this._getInputAddresses(view);
	    if (enc !== 'hex') return table.toArray();
	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Get all output address hashes.
	   * @returns {Hash[]} hashes
	   */

	  getOutputHashes(enc) {
	    const [, table] = this._getOutputAddresses();
	    if (enc !== 'hex') return table.toArray();
	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Get all address hashes.
	   * @param {CoinView|null} view
	   * @returns {Hash[]} hashes
	   */

	  getHashes(view, enc) {
	    const [, table] = this._getAddresses(view);
	    if (enc !== 'hex') return table.toArray();
	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Test whether the transaction has
	   * all coins available.
	   * @param {CoinView} view
	   * @returns {Boolean}
	   */

	  hasCoins(view) {
	    if (this.inputs.length === 0) return false;
	    for (const {
	      prevout
	    } of this.inputs) {
	      if (!view.hasEntry(prevout)) return false;
	    }
	    return true;
	  }

	  /**
	   * Check finality of transaction by examining
	   * nLocktime and nSequence values.
	   * @example
	   * tx.isFinal(chain.height + 1, network.now());
	   * @param {Number} height - Height at which to test. This
	   * is usually the chain height, or the chain height + 1
	   * when the transaction entered the mempool.
	   * @param {Number} time - Time at which to test. This is
	   * usually the chain tip's parent's median time, or the
	   * time at which the transaction entered the mempool. If
	   * MEDIAN_TIME_PAST is enabled this will be the median
	   * time of the chain tip's previous entry's median time.
	   * @returns {Boolean}
	   */

	  isFinal(height, time) {
	    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;
	    if (this.locktime === 0) return true;
	    if (this.locktime < (this.locktime < THRESHOLD ? height : time)) return true;
	    for (const input of this.inputs) {
	      if (input.sequence !== 0xffffffff) return false;
	    }
	    return true;
	  }

	  /**
	   * Verify the absolute locktime of a transaction.
	   * Called by OP_CHECKLOCKTIMEVERIFY.
	   * @param {Number} index - Index of input being verified.
	   * @param {Number} predicate - Locktime to verify against.
	   * @returns {Boolean}
	   */

	  verifyLocktime(index, predicate) {
	    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;
	    const input = this.inputs[index];
	    assert(input, 'Input does not exist.');
	    assert(predicate >= 0, 'Locktime must be non-negative.');

	    // Locktimes must be of the same type (blocks or seconds).
	    if (this.locktime < THRESHOLD !== predicate < THRESHOLD) return false;
	    if (predicate > this.locktime) return false;
	    if (input.sequence === 0xffffffff) return false;
	    return true;
	  }

	  /**
	   * Verify the relative locktime of an input.
	   * Called by OP_CHECKSEQUENCEVERIFY.
	   * @param {Number} index - Index of input being verified.
	   * @param {Number} predicate - Relative locktime to verify against.
	   * @returns {Boolean}
	   */

	  verifySequence(index, predicate) {
	    const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;
	    const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;
	    const MASK = consensus.SEQUENCE_MASK;
	    const input = this.inputs[index];
	    assert(input, 'Input does not exist.');
	    assert(predicate >= 0, 'Locktime must be non-negative.');

	    // For future softfork capability.
	    if (predicate & DISABLE_FLAG) return true;

	    // Version must be >=2.
	    if (this.version < 2) return false;

	    // Cannot use the disable flag without
	    // the predicate also having the disable
	    // flag (for future softfork capability).
	    if (input.sequence & DISABLE_FLAG) return false;

	    // Locktimes must be of the same type (blocks or seconds).
	    if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG)) return false;
	    if ((predicate & MASK) > (input.sequence & MASK)) return false;
	    return true;
	  }

	  /**
	   * Calculate legacy (inaccurate) sigop count.
	   * @returns {Number} sigop count
	   */

	  getLegacySigops() {
	    if (this._sigops !== -1) return this._sigops;
	    let total = 0;
	    for (const input of this.inputs) total += input.script.getSigops(false);
	    for (const output of this.outputs) total += output.script.getSigops(false);
	    if (!this.mutable) this._sigops = total;
	    return total;
	  }

	  /**
	   * Calculate accurate sigop count, taking into account redeem scripts.
	   * @param {CoinView} view
	   * @param {VerifyFlags} flags
	   * @returns {Number} sigop count
	   */

	  getScripthashSigops(view, flags) {
	    if (this.isCoinbase()) return 0;
	    let total = 0;
	    for (const input of this.inputs) {
	      const coin = view.getOutputFor(input);
	      if (!coin) continue;
	      if (!coin.script.isScripthash()) continue;
	      total += coin.script.getScripthashSigops(input.script, flags);
	    }
	    return total;
	  }

	  /**
	   * Calculate sigops count.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Number} sigop count
	   */

	  getSigopsCount(view, flags) {
	    if (flags === null) flags = Script.flags.STANDARD_VERIFY_FLAGS;
	    let cost = this.getLegacySigops();
	    if (flags & Script.flags.VERIFY_P2SH) cost += this.getScripthashSigops(view, flags);
	    return cost;
	  }

	  /**
	   * Calculate sigop count.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Number} sigop count
	   */

	  getSigops(view, flags) {
	    return this.getSigopsCount(view, flags);
	  }

	  /**
	   * Non-contextual sanity checks for the transaction.
	   * Will mostly verify coin and output values.
	   * @see CheckTransaction()
	   * @returns {Array} [result, reason, score]
	   */

	  isSane() {
	    const [valid] = this.checkSanity();
	    return valid;
	  }

	  /**
	   * Non-contextual sanity checks for the transaction.
	   * Will mostly verify coin and output values.
	   * @see CheckTransaction()
	   * @returns {Array} [valid, reason, score]
	   */

	  checkSanity() {
	    if (this.inputs.length === 0) return [false, 'bad-txns-vin-empty', 100];
	    if (this.outputs.length === 0) return [false, 'bad-txns-vout-empty', 100];
	    if (this.getSize() > consensus.MAX_TX_SIZE) return [false, 'bad-txns-oversize', 100];
	    let total = 0;
	    for (const output of this.outputs) {
	      if (output.value < 0) return [false, 'bad-txns-vout-negative', 100];
	      if (output.value > consensus.MAX_MONEY) return [false, 'bad-txns-vout-toolarge', 100];
	      total += output.value;
	      if (total < 0 || total > consensus.MAX_MONEY) return [false, 'bad-txns-txouttotal-toolarge', 100];
	    }
	    const prevout = new BufferSet();
	    for (const input of this.inputs) {
	      const key = input.prevout.toKey();
	      if (prevout.has(key)) return [false, 'bad-txns-inputs-duplicate', 100];
	      prevout.add(key);
	    }
	    if (this.isCoinbase()) {
	      const size = this.inputs[0].script.getSize();
	      if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE) return [false, 'bad-cb-length', 100];
	    } else {
	      for (const input of this.inputs) {
	        if (input.prevout.isNull()) return [false, 'bad-txns-prevout-null', 10];
	      }
	    }
	    return [true, 'valid', 0];
	  }

	  /**
	   * Non-contextual checks to determine whether the
	   * transaction has all standard output script
	   * types and standard input script size with only
	   * pushdatas in the code.
	   * Will mostly verify coin and output values.
	   * @see IsStandardTx()
	   * @returns {Array} [valid, reason, score]
	   */

	  isStandard() {
	    const [valid] = this.checkStandard();
	    return valid;
	  }

	  /**
	   * Non-contextual checks to determine whether the
	   * transaction has all standard output script
	   * types and standard input script size with only
	   * pushdatas in the code.
	   * Will mostly verify coin and output values.
	   * @see IsStandardTx()
	   * @returns {Array} [valid, reason, score]
	   */

	  checkStandard() {
	    if (this.version < 1 || this.version > policy.MAX_TX_VERSION) return [false, 'version', 0];

	    // MAX_STANDARD_TX_SIZE
	    if (this.getSize() >= policy.MAX_TX_SIZE) return [false, 'tx-size', 0];
	    for (const input of this.inputs) {
	      if (input.script.getSize() > 1650) return [false, 'scriptsig-size', 0];
	      if (!input.script.isPushOnly()) return [false, 'scriptsig-not-pushonly', 0];
	    }
	    let nulldata = 0;
	    for (const output of this.outputs) {
	      if (!output.script.isStandard()) return [false, 'scriptpubkey', 0];
	      if (output.script.isNulldata()) {
	        nulldata++;
	        continue;
	      }
	      if (output.script.isMultisig() && !policy.BARE_MULTISIG) return [false, 'bare-multisig', 0];
	      if (output.isDust(policy.MIN_RELAY)) return [false, 'dust', 0];
	    }
	    if (nulldata > 1) return [false, 'multi-op-return', 0];
	    return [true, 'valid', 0];
	  }

	  /**
	   * Perform contextual checks to verify coin and input
	   * script standardness (including the redeem script).
	   * @see AreInputsStandard()
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Boolean}
	   */

	  hasStandardInputs(view) {
	    if (this.isCoinbase()) return true;
	    for (const input of this.inputs) {
	      const coin = view.getOutputFor(input);
	      if (!coin) return false;
	      if (coin.script.isPubkeyhash()) continue;
	      if (coin.script.isScripthash()) {
	        const redeem = input.script.getRedeem();
	        if (!redeem) return false;
	        if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS) return false;
	        continue;
	      }
	      if (coin.script.isUnknown()) return false;
	    }
	    return true;
	  }

	  /**
	   * Perform contextual checks to verify input, output,
	   * and fee values, as well as coinbase spend maturity
	   * (coinbases can only be spent 100 blocks or more
	   * after they're created). Note that this function is
	   * consensus critical.
	   * @param {CoinView} view
	   * @param {Number} height - Height at which the
	   * transaction is being spent. In the mempool this is
	   * the chain height plus one at the time it entered the pool.
	   * @returns {Boolean}
	   */

	  verifyInputs(view, height) {
	    const [fee] = this.checkInputs(view, height);
	    return fee !== -1;
	  }

	  /**
	   * Perform contextual checks to verify input, output,
	   * and fee values, as well as coinbase spend maturity
	   * (coinbases can only be spent 100 blocks or more
	   * after they're created). Note that this function is
	   * consensus critical.
	   * @param {CoinView} view
	   * @param {Number} height - Height at which the
	   * transaction is being spent. In the mempool this is
	   * the chain height plus one at the time it entered the pool.
	   * @returns {Array} [fee, reason, score]
	   */

	  checkInputs(view, height) {
	    assert(typeof height === 'number');
	    let total = 0;
	    for (const {
	      prevout
	    } of this.inputs) {
	      const entry = view.getEntry(prevout);
	      if (!entry) return [-1, 'bad-txns-inputs-missingorspent', 0];
	      if (entry.coinbase) {
	        if (height - entry.height < consensus.COINBASE_MATURITY) return [-1, 'bad-txns-premature-spend-of-coinbase', 0];
	      }
	      const coin = view.getOutput(prevout);
	      assert(coin);
	      if (coin.value < 0 || coin.value > consensus.MAX_MONEY) return [-1, 'bad-txns-inputvalues-outofrange', 100];
	      total += coin.value;
	      if (total < 0 || total > consensus.MAX_MONEY) return [-1, 'bad-txns-inputvalues-outofrange', 100];
	    }

	    // Overflows already checked in `isSane()`.
	    const value = this.getOutputValue();
	    if (total < value) return [-1, 'bad-txns-in-belowout', 100];
	    const fee = total - value;
	    if (fee < 0) return [-1, 'bad-txns-fee-negative', 100];
	    if (fee > consensus.MAX_MONEY) return [-1, 'bad-txns-fee-outofrange', 100];
	    return [fee, 'valid', 0];
	  }

	  /**
	   * Calculate the modified size of the transaction. This
	   * is used in the mempool for calculating priority.
	   * @param {Number?} size - The size to modify. If not present,
	   * virtual size will be used.
	   * @returns {Number} Modified size.
	   */

	  getModifiedSize(size) {
	    if (size == null) size = this.getSize();
	    for (const input of this.inputs) {
	      const offset = 41 + Math.min(110, input.script.getSize());
	      if (size > offset) size -= offset;
	    }
	    return size;
	  }

	  /**
	   * Calculate the transaction priority.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @param {Number?} size - Size to calculate priority
	   * based on. If not present, virtual size will be used.
	   * @returns {Number}
	   */

	  getPriority(view, height, size) {
	    assert(typeof height === 'number', 'Must pass in height.');
	    if (this.isCoinbase()) return 0;
	    if (size == null) size = this.getSize();
	    let sum = 0;
	    for (const {
	      prevout
	    } of this.inputs) {
	      const coin = view.getOutput(prevout);
	      if (!coin) continue;
	      const coinHeight = view.getHeight(prevout);
	      if (coinHeight === -1) continue;
	      if (coinHeight <= height) {
	        const age = height - coinHeight;
	        sum += coin.value * age;
	      }
	    }
	    return Math.floor(sum / size);
	  }

	  /**
	   * Calculate the transaction's on-chain value.
	   * @param {CoinView} view
	   * @returns {Number}
	   */

	  getChainValue(view) {
	    if (this.isCoinbase()) return 0;
	    let value = 0;
	    for (const {
	      prevout
	    } of this.inputs) {
	      const coin = view.getOutput(prevout);
	      if (!coin) continue;
	      const height = view.getHeight(prevout);
	      if (height === -1) continue;
	      value += coin.value;
	    }
	    return value;
	  }

	  /**
	   * Determine whether the transaction is above the
	   * free threshold in priority. A transaction which
	   * passed this test is most likely relayable
	   * without a fee.
	   * @param {CoinView} view
	   * @param {Number?} height - If not present, tx
	   * height or network height will be used.
	   * @param {Number?} size - If not present, modified
	   * size will be calculated and used.
	   * @returns {Boolean}
	   */

	  isFree(view, height, size) {
	    const priority = this.getPriority(view, height, size);
	    return priority > policy.FREE_THRESHOLD;
	  }

	  /**
	   * Calculate minimum fee in order for the transaction
	   * to be relayable (not the constant min relay fee).
	   * @param {Number?} size - If not present, max size
	   * estimation will be calculated and used.
	   * @param {Rate?} rate - Rate of satoshi per kB.
	   * @returns {Amount} fee
	   */

	  getMinFee(size, rate) {
	    if (size == null) size = this.getSize();
	    return policy.getMinFee(size, rate);
	  }

	  /**
	   * Calculate the minimum fee in order for the transaction
	   * to be relayable, but _round to the nearest kilobyte
	   * when taking into account size.
	   * @param {Number?} size - If not present, max size
	   * estimation will be calculated and used.
	   * @param {Rate?} rate - Rate of satoshi per kB.
	   * @returns {Amount} fee
	   */

	  getRoundFee(size, rate) {
	    if (size == null) size = this.getSize();
	    return policy.getRoundFee(size, rate);
	  }

	  /**
	   * Calculate the transaction's rate based on size
	   * and fees. Size will be calculated if not present.
	   * @param {CoinView} view
	   * @param {Number?} size
	   * @returns {Rate}
	   */

	  getRate(view, size) {
	    const fee = this.getFee(view);
	    if (fee < 0) return 0;
	    if (size == null) size = this.getSize();
	    return policy.getRate(size, fee);
	  }

	  /**
	   * Get all unique outpoint hashes.
	   * @returns {Hash[]} Outpoint hashes.
	   */

	  getPrevout() {
	    if (this.isCoinbase()) return [];
	    const prevout = new BufferSet();
	    for (const input of this.inputs) prevout.add(input.prevout.hash);
	    return prevout.toArray();
	  }

	  /**
	   * Test a transaction against a bloom filter using
	   * the BIP37 matching algorithm. Note that this may
	   * update the filter depending on what the `update`
	   * value is.
	   * @see "Filter matching algorithm":
	   * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
	   * @param {BloomFilter} filter
	   * @returns {Boolean} True if the transaction matched.
	   */

	  isWatched(filter) {
	    let found = false;

	    // 1. Test the tx hash
	    if (filter.test(this.hash())) found = true;

	    // 2. Test data elements in output scripts
	    //    (may need to update filter on match)
	    for (let i = 0; i < this.outputs.length; i++) {
	      const output = this.outputs[i];
	      // Test the output script
	      if (output.script.test(filter)) {
	        if (filter.update === 1 /* ALL */) {
	          const prevout = Outpoint.fromTX(this, i);
	          filter.add(prevout.toRaw());
	        } else if (filter.update === 2 /* PUBKEY_ONLY */) {
	          if (output.script.isPubkey() || output.script.isMultisig()) {
	            const prevout = Outpoint.fromTX(this, i);
	            filter.add(prevout.toRaw());
	          }
	        }
	        found = true;
	      }
	    }
	    if (found) return found;

	    // 3. Test prev_out structure
	    // 4. Test data elements in input scripts
	    for (const input of this.inputs) {
	      const prevout = input.prevout;

	      // Test the COutPoint structure
	      if (filter.test(prevout.toRaw())) return true;

	      // Test the input script
	      if (input.script.test(filter)) return true;
	    }

	    // 5. No match
	    return false;
	  }

	  /**
	   * Get little-endian tx hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash());
	  }

	  /**
	   * Get little-endian tx hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Convert the tx to an inv item.
	   * @returns {InvItem}
	   */

	  toInv() {
	    return new InvItem(InvItem.types.TX, this.hash());
	  }

	  /**
	   * Inspect the transaction and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the transaction and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {ChainEntry} entry
	   * @param {Number} index
	   * @returns {Object}
	   */

	  format(view, entry, index) {
	    let rate = 0;
	    let fee = 0;
	    let height = -1;
	    let block = null;
	    let time = 0;
	    let date = null;
	    if (view) {
	      fee = this.getFee(view);
	      rate = this.getRate(view);

	      // Rate can exceed 53 bits in testing.
	      if (!Number.isSafeInteger(rate)) rate = 0;
	    }
	    if (entry) {
	      height = entry.height;
	      block = util.revHex(entry.hash);
	      time = entry.time;
	      date = util.date(time);
	    }
	    if (index == null) index = -1;
	    const hr = {
	      hash: this.txid(),
	      size: this.getSize(),
	      value: Amount.btc(this.getOutputValue()),
	      fee: Amount.btc(fee),
	      rate: Amount.btc(rate),
	      minFee: Amount.btc(this.getMinFee()),
	      height: height,
	      block: block,
	      time: time,
	      date: date,
	      index: index,
	      version: this.version,
	      inputs: this.inputs.map(input => {
	        const coin = view ? view.getOutputFor(input) : null;
	        return input.format(coin);
	      }),
	      outputs: this.outputs,
	      locktime: this.locktime
	    };
	    if (this.slpToken) {
	      return {
	        ...hr,
	        slpToken: this.slpToken
	      };
	    }
	    return hr;
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {ChainEntry} entry
	   * @param {Number} index
	   * @returns {Object}
	   */

	  getJSON(network, view, entry, index) {
	    let rate, fee, height, block, time, date;
	    if (view) {
	      fee = this.getFee(view);
	      rate = this.getRate(view);

	      // Rate can exceed 53 bits in testing.
	      if (!Number.isSafeInteger(rate)) rate = 0;
	    }
	    if (entry) {
	      height = entry.height;
	      block = util.revHex(entry.hash);
	      time = entry.time;
	      date = util.date(time);
	    }
	    network = Network.get(network);
	    const json = {
	      hash: this.txid(),
	      fee: fee,
	      rate: rate,
	      mtime: util.now(),
	      height: height,
	      block: block,
	      time: time,
	      date: date,
	      index: index,
	      version: this.version,
	      inputs: this.inputs.map(input => {
	        const coin = view ? view.getCoinFor(input) : null;
	        return input.getJSON(network, coin);
	      }),
	      outputs: this.outputs.map(output => {
	        return output.getJSON(network);
	      }),
	      locktime: this.locktime,
	      hex: this.toRaw().toString('hex')
	    };
	    if (this.slpToken) {
	      return {
	        ...json,
	        slpToken: this.slpToken.getJSON()
	      };
	    }
	    return json;
	  }

	  /**
	   * Inject properties from a json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'TX data is required.');
	    assert(json.version >>> 0 === json.version, 'Version must be a uint32.');
	    assert(Array.isArray(json.inputs), 'Inputs must be an array.');
	    assert(Array.isArray(json.outputs), 'Outputs must be an array.');
	    assert(json.locktime >>> 0 === json.locktime, 'Locktime must be a uint32.');
	    this.version = json.version;
	    for (const input of json.inputs) this.inputs.push(Input.fromJSON(input));
	    for (const output of json.outputs) this.outputs.push(Output.fromJSON(output));
	    this.locktime = json.locktime;
	    if (json.slpToken) this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken);
	    return this;
	  }

	  /**
	   * Instantiate a transaction from a
	   * jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {TX}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Instantiate a transaction from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {TX}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Instantiate a transaction from a buffer reader.
	   * @param {BufferReader} br
	   * @param {Boolean} block
	   * @returns {TX}
	   */

	  static fromReader(br, block) {
	    return new this().fromReader(br, block);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   * @param {Boolean} block
	   */

	  fromReader(br, block) {
	    const start = br.start();
	    this.version = br.readU32();
	    const inCount = br.readVarint();
	    for (let i = 0; i < inCount; i++) this.inputs.push(Input.fromReader(br));
	    const outCount = br.readVarint();
	    for (let i = 0; i < outCount; i++) this.outputs.push(Output.fromReader(br));
	    this.locktime = br.readU32();
	    if (block) {
	      this._offset = start;
	      this._block = true;
	    }
	    if (!this.mutable) {
	      this._raw = br.endData();
	      this._size = this._raw.length;
	    } else {
	      br.end();
	    }
	    return this;
	  }

	  /**
	   * Serialize transaction without witness.
	   * @private
	   * @returns {RawTX}
	   */

	  frameNormal() {
	    const raw = this.getNormalSizes();
	    const bw = bio.write(raw.size);
	    this.writeNormal(bw);
	    raw.data = bw.render();
	    return raw;
	  }

	  /**
	   * Serialize transaction without witness.
	   * @private
	   * @param {BufferWriter} bw
	   * @returns {RawTX}
	   */

	  writeNormal(bw) {
	    if (this.inputs.length === 0 && this.outputs.length !== 0) throw new Error('Cannot serialize zero-input tx.');
	    bw.writeU32(this.version);
	    bw.writeVarint(this.inputs.length);
	    for (const input of this.inputs) input.toWriter(bw);
	    bw.writeVarint(this.outputs.length);
	    for (const output of this.outputs) output.toWriter(bw);
	    bw.writeU32(this.locktime);
	    return bw;
	  }

	  /**
	   * Calculate the real size of the transaction
	   * without the witness vector.
	   * @returns {RawTX}
	   */

	  getNormalSizes() {
	    let base = 0;
	    base += 4;
	    base += encoding.sizeVarint(this.inputs.length);
	    for (const input of this.inputs) base += input.getSize();
	    base += encoding.sizeVarint(this.outputs.length);
	    for (const output of this.outputs) base += output.getSize();
	    base += 4;
	    return new RawTX(base, 0);
	  }

	  /**
	   * Test whether an object is a TX.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isTX(obj) {
	    return obj instanceof TX;
	  }
	}

	/*
	 * Helpers
	 */

	class RawTX {
	  constructor(size) {
	    this.data = null;
	    this.size = size;
	  }
	}

	/*
	 * Expose
	 */

	tx = TX;
	return tx;
}

/*!
 * headers.js - headers object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var headers;
var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;

	const bio = requireBufio();
	const util = requireUtil();
	const AbstractBlock = requireAbstractblock();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Headers
	 * Represents block headers obtained
	 * from the network via `headers`.
	 * @alias module:primitives.Headers
	 * @extends AbstractBlock
	 */

	class Headers extends AbstractBlock {
	  /**
	   * Create headers.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();
	    if (options) this.parseOptions(options);
	  }

	  /**
	   * Perform non-contextual
	   * verification on the headers.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    return true;
	  }

	  /**
	   * Get size of the headers.
	   * @returns {Number}
	   */

	  getSize() {
	    return 81;
	  }

	  /**
	   * Serialize the headers to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.writeHead(bw);
	    bw.writeVarint(0);
	    return bw;
	  }

	  /**
	   * Serialize the headers.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {Buffer} data
	   */

	  fromReader(br) {
	    this.readHead(br);
	    br.readVarint();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate headers from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Headers}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate headers from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Headers}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Instantiate headers from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Headers}
	   */

	  static fromHead(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromHead(data);
	  }

	  /**
	   * Instantiate headers from a chain entry.
	   * @param {ChainEntry} entry
	   * @returns {Headers}
	   */

	  static fromEntry(entry) {
	    const headers = new this();
	    headers.version = entry.version;
	    headers.prevBlock = entry.prevBlock;
	    headers.merkleRoot = entry.merkleRoot;
	    headers.time = entry.time;
	    headers.bits = entry.bits;
	    headers.nonce = entry.nonce;
	    headers._hash = entry.hash;
	    headers._hhash = entry.hash;
	    return headers;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return this;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @param {Block|MerkleBlock} block
	   * @returns {Headers}
	   */

	  static fromBlock(block) {
	    const headers = new this(block);
	    headers._hash = block._hash;
	    headers._hhash = block._hhash;
	    return headers;
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  getJSON(network, view, height) {
	    return {
	      hash: this.rhash(),
	      height: height,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    this.parseJSON(json);
	    return this;
	  }

	  /**
	   * Instantiate a merkle block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {Headers}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inspect the headers and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the headers and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce
	    };
	  }

	  /**
	   * Test an object to see if it is a Headers object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHeaders(obj) {
	    return obj instanceof Headers;
	  }
	}

	/*
	 * Expose
	 */

	headers = Headers;
	return headers;
}

/*!
 * merkleblock.js - merkleblock object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var merkleblock;
var hasRequiredMerkleblock;

function requireMerkleblock () {
	if (hasRequiredMerkleblock) return merkleblock;
	hasRequiredMerkleblock = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  BufferMap,
	  BufferSet
	} = requireBufferMap();
	const util = requireUtil();
	const hash256 = requireHash256();
	const consensus = requireConsensus();
	const AbstractBlock = requireAbstractblock();
	const Headers = requireHeaders();
	const DUMMY = Buffer.from([0]);
	const {
	  encoding
	} = bio;
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Merkle Block
	 * Represents a merkle (filtered) block.
	 * @alias module:primitives.MerkleBlock
	 * @extends AbstractBlock
	 */

	class MerkleBlock extends AbstractBlock {
	  /**
	   * Create a merkle block.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();
	    this.txs = [];
	    this.hashes = [];
	    this.flags = DUMMY;
	    this.totalTX = 0;
	    this._tree = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    this.parseOptions(options);
	    assert(options, 'MerkleBlock data is required.');
	    assert(Array.isArray(options.hashes));
	    assert(Buffer.isBuffer(options.flags));
	    assert(options.totalTX >>> 0 === options.totalTX);
	    if (options.hashes) {
	      for (const hash of options.hashes) {
	        assert(Buffer.isBuffer(hash));
	        this.hashes.push(hash);
	      }
	    }
	    if (options.flags) {
	      assert(Buffer.isBuffer(options.flags));
	      this.flags = options.flags;
	    }
	    if (options.totalTX != null) {
	      assert(options.totalTX >>> 0 === options.totalTX);
	      this.totalTX = options.totalTX;
	    }
	    return this;
	  }

	  /**
	   * Instantiate merkle block from options object.
	   * @param {Object} options
	   * @returns {MerkleBlock}
	   */

	  static fromOptions(data) {
	    return new this().fromOptions(data);
	  }

	  /**
	   * Clear any cached values.
	   * @param {Boolean?} all - Clear transactions.
	   */

	  refresh(all) {
	    this._refresh();
	    this._tree = null;
	    if (!all) return;
	    for (const tx of this.txs) tx.refresh();
	  }

	  /**
	   * Test the block's _matched_ transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  hasTX(hash) {
	    return this.indexOf(hash) !== -1;
	  }

	  /**
	   * Test the block's _matched_ transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Number} Index.
	   */

	  indexOf(hash) {
	    const tree = this.getTree();
	    const index = tree.map.get(hash);
	    if (index == null) return -1;
	    return index;
	  }

	  /**
	   * Verify the partial merkletree.
	   * @private
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    const [valid] = this.checkBody();
	    return valid;
	  }

	  /**
	   * Verify the partial merkletree.
	   * @private
	   * @returns {Array} [valid, reason, score]
	   */

	  checkBody() {
	    const tree = this.getTree();
	    if (!tree.root.equals(this.merkleRoot)) return [false, 'bad-txnmrklroot', 100];
	    return [true, 'valid', 0];
	  }

	  /**
	   * Extract the matches from partial merkle
	   * tree and calculate merkle root.
	   * @returns {Object}
	   */

	  getTree() {
	    if (!this._tree) {
	      try {
	        this._tree = this.extractTree();
	      } catch (e) {
	        this._tree = new PartialTree();
	      }
	    }
	    return this._tree;
	  }

	  /**
	   * Extract the matches from partial merkle
	   * tree and calculate merkle root.
	   * @private
	   * @returns {Object}
	   */

	  extractTree() {
	    const matches = [];
	    const indexes = [];
	    const map = new BufferMap();
	    const hashes = this.hashes;
	    const flags = this.flags;
	    const totalTX = this.totalTX;
	    let bitsUsed = 0;
	    let hashUsed = 0;
	    let failed = false;
	    let height = 0;
	    const width = height => {
	      return totalTX + (1 << height) - 1 >>> height;
	    };
	    const traverse = (height, pos) => {
	      if (bitsUsed >= flags.length * 8) {
	        failed = true;
	        return consensus.ZERO_HASH;
	      }
	      const parent = flags[bitsUsed / 8 | 0] >>> bitsUsed % 8 & 1;
	      bitsUsed += 1;
	      if (height === 0 || !parent) {
	        if (hashUsed >= hashes.length) {
	          failed = true;
	          return consensus.ZERO_HASH;
	        }
	        const hash = hashes[hashUsed];
	        hashUsed += 1;
	        if (height === 0 && parent) {
	          matches.push(hash);
	          indexes.push(pos);
	          map.set(hash, pos);
	        }
	        return hash;
	      }
	      const left = traverse(height - 1, pos * 2);
	      let right;
	      if (pos * 2 + 1 < width(height - 1)) {
	        right = traverse(height - 1, pos * 2 + 1);
	        if (right.equals(left)) failed = true;
	      } else {
	        right = left;
	      }
	      return hash256.root(left, right);
	    };
	    if (totalTX === 0) throw new Error('Zero transactions.');

	    // FIXME: Track the maximum block size we've seen and use it here.

	    if (hashes.length > totalTX) throw new Error('Too many hashes.');
	    if (flags.length * 8 < hashes.length) throw new Error('Flags too small.');
	    while (width(height) > 1) height += 1;
	    const root = traverse(height, 0);
	    if (failed) throw new Error('Mutated merkle tree.');
	    if (((bitsUsed + 7) / 8 | 0) !== flags.length) throw new Error('Too many flag bits.');
	    if (hashUsed !== hashes.length) throw new Error('Incorrect number of hashes.');
	    return new PartialTree(root, matches, indexes, map);
	  }

	  /**
	   * Extract the coinbase height (always -1).
	   * @returns {Number}
	   */

	  getCoinbaseHeight() {
	    return -1;
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      totalTX: this.totalTX,
	      hashes: this.hashes.map(hash => {
	        return hash.toString('hex');
	      }),
	      flags: this.flags,
	      map: this.getTree().map,
	      txs: this.txs.length
	    };
	  }

	  /**
	   * Get merkleblock size.
	   * @returns {Number} Size.
	   */

	  getSize() {
	    let size = 0;
	    size += 80;
	    size += 4;
	    size += encoding.sizeVarint(this.hashes.length);
	    size += this.hashes.length * 32;
	    size += encoding.sizeVarint(this.flags.length);
	    size += this.flags.length;
	    return size;
	  }

	  /**
	   * Write the merkleblock to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.writeHead(bw);
	    bw.writeU32(this.totalTX);
	    bw.writeVarint(this.hashes.length);
	    for (const hash of this.hashes) bw.writeHash(hash);
	    bw.writeVarBytes(this.flags);
	    return bw;
	  }

	  /**
	   * Serialize the merkleblock.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.readHead(br);
	    this.totalTX = br.readU32();
	    const count = br.readVarint();
	    for (let i = 0; i < count; i++) this.hashes.push(br.readHash());
	    this.flags = br.readVarBytes();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a merkleblock from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {MerkleBlock}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a merkleblock from a serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {MerkleBlock}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  getJSON(network, view, height) {
	    return {
	      hash: this.rhash(),
	      height: height,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      totalTX: this.totalTX,
	      hashes: this.hashes.map(hash => {
	        return util.revHex(hash);
	      }),
	      flags: this.flags.toString('hex')
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'MerkleBlock data is required.');
	    assert(Array.isArray(json.hashes));
	    assert(typeof json.flags === 'string');
	    assert(json.totalTX >>> 0 === json.totalTX);
	    this.parseJSON(json);
	    for (const hash of json.hashes) this.hashes.push(util.fromRev(hash));
	    this.flags = Buffer.from(json.flags, 'hex');
	    this.totalTX = json.totalTX;
	    return this;
	  }

	  /**
	   * Instantiate a merkle block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {MerkleBlock}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Create a merkleblock from a {@link Block} object, passing
	   * it through a filter first. This will build the partial
	   * merkle tree.
	   * @param {Block} block
	   * @param {Bloom} filter
	   * @returns {MerkleBlock}
	   */

	  static fromBlock(block, filter) {
	    const matches = [];
	    for (const tx of block.txs) matches.push(tx.isWatched(filter) ? 1 : 0);
	    return this.fromMatches(block, matches);
	  }

	  /**
	   * Create a merkleblock from an array of txids.
	   * This will build the partial merkle tree.
	   * @param {Block} block
	   * @param {Hash[]} hashes
	   * @returns {MerkleBlock}
	   */

	  static fromHashes(block, hashes) {
	    const filter = new BufferSet();
	    for (const hash of hashes) filter.add(hash);
	    const matches = [];
	    for (const tx of block.txs) {
	      const hash = tx.hash();
	      matches.push(filter.has(hash) ? 1 : 0);
	    }
	    return this.fromMatches(block, matches);
	  }

	  /**
	   * Create a merkleblock from an array of matches.
	   * This will build the partial merkle tree.
	   * @param {Block} block
	   * @param {Number[]} matches
	   * @returns {MerkleBlock}
	   */

	  static fromMatches(block, matches) {
	    const txs = [];
	    const leaves = [];
	    const bits = [];
	    const hashes = [];
	    const totalTX = block.txs.length;
	    let height = 0;
	    const width = height => {
	      return totalTX + (1 << height) - 1 >>> height;
	    };
	    const hash = (height, pos, leaves) => {
	      if (height === 0) return leaves[pos];
	      const left = hash(height - 1, pos * 2, leaves);
	      let right;
	      if (pos * 2 + 1 < width(height - 1)) right = hash(height - 1, pos * 2 + 1, leaves);else right = left;
	      return hash256.root(left, right);
	    };
	    const traverse = (height, pos, leaves, matches) => {
	      let parent = 0;
	      for (let p = pos << height; p < pos + 1 << height && p < totalTX; p++) parent |= matches[p];
	      bits.push(parent);
	      if (height === 0 || !parent) {
	        hashes.push(hash(height, pos, leaves));
	        return;
	      }
	      traverse(height - 1, pos * 2, leaves, matches);
	      if (pos * 2 + 1 < width(height - 1)) traverse(height - 1, pos * 2 + 1, leaves, matches);
	    };
	    for (let i = 0; i < block.txs.length; i++) {
	      const tx = block.txs[i];
	      if (matches[i]) txs.push(tx);
	      leaves.push(tx.hash());
	    }
	    while (width(height) > 1) height += 1;
	    traverse(height, 0, leaves, matches);
	    const flags = Buffer.allocUnsafe((bits.length + 7) / 8 | 0);
	    flags.fill(0);
	    for (let p = 0; p < bits.length; p++) flags[p / 8 | 0] |= bits[p] << p % 8;
	    const merkle = new this();
	    merkle._hash = block._hash;
	    merkle._hhash = block._hhash;
	    merkle.version = block.version;
	    merkle.prevBlock = block.prevBlock;
	    merkle.merkleRoot = block.merkleRoot;
	    merkle.time = block.time;
	    merkle.bits = block.bits;
	    merkle.nonce = block.nonce;
	    merkle.totalTX = totalTX;
	    merkle.hashes = hashes;
	    merkle.flags = flags;
	    merkle.txs = txs;
	    return merkle;
	  }

	  /**
	   * Test whether an object is a MerkleBlock.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMerkleBlock(obj) {
	    return obj instanceof MerkleBlock;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }
	}

	/*
	 * Helpers
	 */

	class PartialTree {
	  constructor(root, matches, indexes, map) {
	    this.root = root || consensus.ZERO_HASH;
	    this.matches = matches || [];
	    this.indexes = indexes || [];
	    this.map = map || new BufferMap();
	  }
	}

	/*
	 * Expose
	 */

	merkleblock = MerkleBlock;
	return merkleblock;
}

/*!
 * block.js - block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var block;
var hasRequiredBlock;

function requireBlock () {
	if (hasRequiredBlock) return block;
	hasRequiredBlock = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const {
	  BufferSet
	} = requireBufferMap();
	const hash256 = requireHash256();
	const merkle = requireMerkle();
	const consensus = requireConsensus();
	const AbstractBlock = requireAbstractblock();
	const TX = requireTx();
	const MerkleBlock = requireMerkleblock();
	const Headers = requireHeaders();
	const Network = requireNetwork();
	const util = requireUtil();
	const {
	  encoding
	} = bio;
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * Block
	 * Represents a full block.
	 * @alias module:primitives.Block
	 * @extends AbstractBlock
	 */

	class Block extends AbstractBlock {
	  /**
	   * Create a block.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();
	    this.txs = [];
	    this._raw = null;
	    this._size = -1;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    this.parseOptions(options);
	    if (options.txs) {
	      assert(Array.isArray(options.txs));
	      for (const tx of options.txs) {
	        assert(tx instanceof TX);
	        this.txs.push(tx);
	      }
	    }
	    return this;
	  }

	  /**
	   * Instantiate block from options.
	   * @param {Object} options
	   * @returns {Block}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clear any cached values.
	   * @param {Boolean?} all - Clear transactions.
	   */

	  refresh(all) {
	    this._refresh();
	    this._raw = null;
	    this._size = -1;
	    if (!all) return this;
	    for (const tx of this.txs) tx.refresh();
	    return this;
	  }

	  /**
	   * Serialize the block.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.frame().data;
	  }

	  /**
	   * Check if block has been serialized.
	   * @returns {Buffer}
	   */

	  hasRaw() {
	    return Boolean(this._raw);
	  }

	  /**
	   * Serialize the block.
	   * @returns {Buffer}
	   */

	  toNormal() {
	    return this.toRaw();
	  }

	  /**
	   * Serialize the block.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.mutable) return this.writeNormal(bw);
	    const raw = this.frame();
	    bw.writeBytes(raw.data);
	    return bw;
	  }

	  /**
	   * Serialize the block.
	   * @param {BufferWriter} bw
	   */

	  toNormalWriter(bw) {
	    return this.toWriter(bw);
	  }

	  /**
	   * Get the raw block serialization.
	   * @private
	   * @returns {RawBlock}
	   */

	  frame() {
	    if (this.mutable) {
	      assert(!this._raw);
	      return this.frameNormal();
	    }
	    if (this._raw) {
	      assert(this._size >= 0);
	      const raw = new RawBlock(this._size);
	      raw.data = this._raw;
	      return raw;
	    }
	    const raw = this.frameNormal();
	    this._raw = raw.data;
	    this._size = raw.size;
	    return raw;
	  }

	  /**
	   * Calculate real block size.
	   * @returns {Object} Contains `size`
	   */

	  getSize() {
	    if (this.mutable) return this.getNormalSizes().size;
	    return this.frame().size;
	  }

	  /**
	   * Test the block's transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  hasTX(hash) {
	    return this.indexOf(hash) !== -1;
	  }

	  /**
	   * Find the index of a transaction in the block.
	   * @param {Hash} hash
	   * @returns {Number} index (-1 if not present).
	   */

	  indexOf(hash) {
	    for (let i = 0; i < this.txs.length; i++) {
	      const tx = this.txs[i];
	      if (tx.hash().equals(hash)) return i;
	    }
	    return -1;
	  }

	  /**
	   * Calculate merkle root. Returns null
	   * if merkle tree has been malleated.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Hash|null}
	   */

	  createMerkleRoot(enc) {
	    const leaves = [];
	    for (const tx of this.txs) leaves.push(tx.hash());
	    const [root, malleated] = merkle.createRoot(hash256, leaves);
	    if (malleated) return null;
	    return enc === 'hex' ? root.toString('hex') : root;
	  }

	  /**
	   * Retrieve the merkle root from the block header.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  getMerkleRoot(enc) {
	    if (enc === 'hex') return this.merkleRoot.toString('hex');
	    return this.merkleRoot;
	  }

	  /**
	   * Do non-contextual verification on the block. Including checking the block
	   * size, the coinbase and the merkle root. This is consensus-critical.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    const [valid] = this.checkBody();
	    return valid;
	  }

	  /**
	   * Do non-contextual verification on the block. Including checking the block
	   * size, the coinbase and the merkle root. This is consensus-critical.
	   * @param {Boolean?} skipSigops
	   * @returns {Array} [valid, reason, score]
	   */

	  checkBody(skipSigops) {
	    // Check base size.
	    //  MIN_TRANSACTION_SIZE = 100;
	    if (this.txs.length === 0 || this.txs.length > consensus.MAX_FORK_BLOCK_SIZE / 10 || this.getSize() > consensus.MAX_FORK_BLOCK_SIZE) {
	      return [false, 'bad-blk-length', 100];
	    }

	    // First TX must be a coinbase.
	    if (this.txs.length === 0 || !this.txs[0].isCoinbase()) return [false, 'bad-cb-missing', 100];

	    // Check merkle root.
	    const root = this.createMerkleRoot();

	    // If the merkle is mutated,
	    // we have duplicate txs.
	    if (!root) return [false, 'bad-txns-duplicate', 100];
	    if (!this.merkleRoot.equals(root)) return [false, 'bad-txnmrklroot', 100];

	    // Test all transactions.
	    const size = this.getSize();
	    let sigops = 0;
	    for (let i = 0; i < this.txs.length; i++) {
	      const tx = this.txs[i];

	      // The rest of the txs must not be coinbases.
	      if (i > 0 && tx.isCoinbase()) return [false, 'bad-cb-multiple', 100];

	      // Sanity checks.
	      const [valid, reason, score] = tx.checkSanity();
	      if (!valid) return [valid, reason, score];

	      // Count legacy sigops (do not count scripthash).
	      sigops += tx.getLegacySigops();
	      if (!skipSigops && sigops > consensus.maxBlockSigops(size)) return [false, 'bad-blk-sigops', 100];
	    }
	    return [true, 'valid', 0];
	  }

	  /**
	   * Retrieve the coinbase height from the coinbase input script.
	   * @returns {Number} height (-1 if not present).
	   */

	  getCoinbaseHeight() {
	    if (this.version < 2) return -1;
	    if (this.txs.length === 0) return -1;
	    const coinbase = this.txs[0];
	    if (coinbase.inputs.length === 0) return -1;
	    return coinbase.inputs[0].script.getCoinbaseHeight();
	  }

	  /**
	   * Get the "claimed" reward by the coinbase.
	   * @returns {Amount} claimed
	   */

	  getClaimed() {
	    assert(this.txs.length > 0);
	    assert(this.txs[0].isCoinbase());
	    return this.txs[0].getOutputValue();
	  }

	  /**
	   * Get all unique outpoint hashes in the
	   * block. Coinbases are ignored.
	   * @returns {Hash[]} Outpoint hashes.
	   */

	  getPrevout() {
	    const prevout = new BufferSet();
	    for (let i = 1; i < this.txs.length; i++) {
	      const tx = this.txs[i];
	      for (const input of tx.inputs) prevout.add(input.prevout.hash);
	    }
	    return prevout.toArray();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      size: this.getSize(),
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      txs: this.txs.map((tx, i) => {
	        return tx.format(view, null, i);
	      })
	    };
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @param {Number} depth
	   * @returns {Object}
	   */

	  getJSON(network, view, height, depth) {
	    network = Network.get(network);
	    return {
	      hash: this.rhash(),
	      height: height,
	      depth: depth,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      txs: this.txs.map((tx, i) => {
	        return tx.getJSON(network, view, null, i);
	      })
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Block data is required.');
	    assert(Array.isArray(json.txs));
	    this.parseJSON(json);
	    for (const tx of json.txs) this.txs.push(TX.fromJSON(tx));
	    return this;
	  }

	  /**
	   * Instantiate a block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {Block}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromReader(br) {
	    br.start();
	    this.readHead(br);
	    const count = br.readVarint();
	    for (let i = 0; i < count; i++) {
	      const tx = TX.fromReader(br, true);
	      this.txs.push(tx);
	    }
	    if (!this.mutable) {
	      this._raw = br.endData();
	      this._size = this._raw.length;
	    }
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a block from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Block}
	   */

	  static fromReader(data) {
	    return new this().fromReader(data);
	  }

	  /**
	   * Instantiate a block from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Block}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the Block to a MerkleBlock.
	   * @param {Bloom} filter - Bloom filter for transactions
	   * to match. The merkle block will contain only the
	   * matched transactions.
	   * @returns {MerkleBlock}
	   */

	  toMerkle(filter) {
	    return MerkleBlock.fromBlock(this, filter);
	  }

	  /**
	   * Serialze block data.
	   * @private
	   * @param {BufferWriter?} writer
	   * @returns {Buffer}
	   */

	  writeNormal(bw) {
	    this.writeHead(bw);
	    bw.writeVarint(this.txs.length);
	    for (const tx of this.txs) tx.toWriter(bw);
	    return bw;
	  }

	  /**
	   * Serialze block data.
	   * @private
	   * @param {BufferWriter?} writer
	   * @returns {Buffer}
	   */

	  frameNormal() {
	    const raw = this.getNormalSizes();
	    const bw = bio.write(raw.size);
	    this.writeNormal(bw);
	    raw.data = bw.render();
	    return raw;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }

	  /**
	   * Get real block size.
	   * @returns {RawBlock}
	   */

	  getNormalSizes() {
	    let size = 0;
	    size += 80;
	    size += encoding.sizeVarint(this.txs.length);
	    for (const tx of this.txs) size += tx.getSize();
	    return new RawBlock(size, 0);
	  }

	  /**
	   * Test whether an object is a Block.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isBlock(obj) {
	    return obj instanceof Block;
	  }
	}

	/*
	 * Helpers
	 */

	class RawBlock {
	  constructor(size) {
	    this.data = null;
	    this.size = size;
	  }
	}

	/*
	 * Expose
	 */

	block = Block;
	return block;
}

/*!
 * keyring.js - keyring object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var keyring;
var hasRequiredKeyring;

function requireKeyring () {
	if (hasRequiredKeyring) return keyring;
	hasRequiredKeyring = 1;

	const assert = requireAssert$1();
	const {
	  base58
	} = requireBstring();
	const bio = requireBufio();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const Network = requireNetwork();
	const Script = requireScript$1();
	const Address = requireAddress();
	const Output = requireOutput();
	const secp256k1 = requireSecp256k1();
	const {
	  encoding
	} = bio;
	const {
	  inspectSymbol
	} = requireUtils();

	/*
	 * Constants
	 */

	const ZERO_KEY = Buffer.alloc(33, 0x00);

	/**
	 * Key Ring
	 * Represents a key ring which amounts to an address.
	 * @alias module:primitives.KeyRing
	 */

	class KeyRing {
	  /**
	   * Create a key ring.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    this.nested = false;
	    this.publicKey = ZERO_KEY;
	    this.privateKey = null;
	    this.script = null;
	    this._keyHash = null;
	    this._keyAddress = null;
	    this._scriptHash160 = null;
	    this._scriptAddress = null;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    let key = toKey(options);
	    if (Buffer.isBuffer(key)) return this.fromKey(key);
	    key = toKey(options.key);
	    if (options.publicKey) key = toKey(options.publicKey);
	    if (options.privateKey) key = toKey(options.privateKey);
	    const script = options.script;
	    const compress = options.compressed;
	    if (script) return this.fromScript(key, script, compress);
	    return this.fromKey(key, compress);
	  }

	  /**
	   * Instantiate key ring from options.
	   * @param {Object} options
	   * @returns {KeyRing}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clear cached key/script hashes.
	   */

	  refresh() {
	    this._keyHash = null;
	    this._keyAddress = null;
	    this._scriptHash160 = null;
	    this._scriptAddress = null;
	  }

	  /**
	   * Inject data from private key.
	   * @private
	   * @param {Buffer} key
	   * @param {Boolean?} compress
	   */

	  fromPrivate(key, compress) {
	    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');
	    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');
	    this.privateKey = key;
	    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);
	    return this;
	  }

	  /**
	   * Instantiate keyring from a private key.
	   * @param {Buffer} key
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromPrivate(key, compress) {
	    return new this().fromPrivate(key, compress);
	  }

	  /**
	   * Inject data from public key.
	   * @private
	   * @param {Buffer} key
	   */

	  fromPublic(key) {
	    assert(Buffer.isBuffer(key), 'Public key must be a buffer.');
	    assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');
	    this.publicKey = key;
	    return this;
	  }

	  /**
	   * Generate a keyring.
	   * @private
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  generate(compress) {
	    const key = secp256k1.privateKeyGenerate();
	    return this.fromKey(key, compress);
	  }

	  /**
	   * Generate a keyring.
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static generate(compress) {
	    return new this().generate(compress);
	  }

	  /**
	   * Instantiate keyring from a public key.
	   * @param {Buffer} publicKey
	   * @returns {KeyRing}
	   */

	  static fromPublic(key) {
	    return new this().fromPublic(key);
	  }

	  /**
	   * Inject data from public key.
	   * @private
	   * @param {Buffer} privateKey
	   * @param {Boolean?} compress
	   */

	  fromKey(key, compress) {
	    assert(Buffer.isBuffer(key), 'Key must be a buffer.');
	    if (key.length === 32) return this.fromPrivate(key, compress !== false);
	    return this.fromPublic(key);
	  }

	  /**
	   * Instantiate keyring from a public key.
	   * @param {Buffer} publicKey
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromKey(key, compress) {
	    return new this().fromKey(key, compress);
	  }

	  /**
	   * Inject data from script.
	   * @private
	   * @param {Buffer} key
	   * @param {Script} script
	   * @param {Boolean?} compress
	   */

	  fromScript(key, script, compress) {
	    assert(script instanceof Script, 'Non-script passed into KeyRing.');
	    this.fromKey(key, compress);
	    this.script = script;
	    return this;
	  }

	  /**
	   * Instantiate keyring from script.
	   * @param {Buffer} key
	   * @param {Script} script
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromScript(key, script, compress) {
	    return new this().fromScript(key, script, compress);
	  }

	  /**
	   * Get ith public key from multisig script.
	   * @private
	   * @param {Script} script
	   * @param {Number} i
	   * @returns {KeyRing}
	   */

	  fromMultisigScript(script, i) {
	    assert(script instanceof Script, 'Non-script passed.');
	    assert(script.isMultisig(), 'Script must be multisig');
	    const n = script.getSmall(-2);
	    assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');
	    this.fromKey(script.code[i].toData());
	    return this;
	  }

	  /**
	   * Instantiate keyring from ith key in multisig script.
	   * @param {Script} script
	   * @param {Number} i
	   * @returns {KeyRing}
	   */

	  static fromMultisigScript(script, i) {
	    return new this().fromMultisigScript(script, i);
	  }

	  /**
	   * Calculate WIF serialization size.
	   * @returns {Number}
	   */

	  getSecretSize() {
	    let size = 0;
	    size += 1;
	    size += this.privateKey.length;
	    if (this.publicKey.length === 33) size += 1;
	    size += 4;
	    return size;
	  }

	  /**
	   * Convert key to a CBitcoinSecret.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toSecret(network) {
	    const size = this.getSecretSize();
	    const bw = bio.write(size);
	    assert(this.privateKey, 'Cannot serialize without private key.');
	    network = Network.get(network);
	    bw.writeU8(network.keyPrefix.privkey);
	    bw.writeBytes(this.privateKey);
	    if (this.publicKey.length === 33) bw.writeU8(1);
	    bw.writeChecksum(hash256.digest);
	    return base58.encode(bw.render());
	  }

	  /**
	   * Inject properties from serialized CBitcoinSecret.
	   * @private
	   * @param {Base58String} secret
	   * @param {(Network|NetworkType)?} network
	   */

	  fromSecret(data, network) {
	    const br = bio.read(base58.decode(data), true);
	    const version = br.readU8();
	    Network.fromWIF(version, network);
	    const key = br.readBytes(32);
	    let compress = false;
	    if (br.left() > 4) {
	      assert(br.readU8() === 1, 'Bad compression flag.');
	      compress = true;
	    }
	    br.verifyChecksum(hash256.digest);
	    return this.fromPrivate(key, compress);
	  }

	  /**
	   * Instantiate a keyring from a serialized CBitcoinSecret.
	   * @param {Base58String} secret
	   * @param {(Network|NetworkType)?} network
	   * @returns {KeyRing}
	   */

	  static fromSecret(data, network) {
	    return new this().fromSecret(data, network);
	  }

	  /**
	   * Get private key.
	   * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
	   * @returns {Buffer} Private key.
	   */

	  getPrivateKey(enc, network) {
	    if (!this.privateKey) return null;
	    if (enc === 'base58') return this.toSecret(network);
	    if (enc === 'hex') return this.privateKey.toString('hex');
	    return this.privateKey;
	  }

	  /**
	   * Get public key.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getPublicKey(enc) {
	    if (enc === 'base58') return base58.encode(this.publicKey);
	    if (enc === 'hex') return this.publicKey.toString('hex');
	    return this.publicKey;
	  }

	  /**
	   * Get redeem script.
	   * @returns {Script}
	   */

	  getScript() {
	    return this.script;
	  }

	  /**
	   * Get scripthash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getScriptHash(enc) {
	    return this.getScriptHash160(enc);
	  }

	  /**
	   * Get ripemd160 scripthash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getScriptHash160(enc) {
	    if (!this.script) return null;
	    if (!this._scriptHash160) this._scriptHash160 = this.script.hash160();
	    return enc === 'hex' ? this._scriptHash160.toString('hex') : this._scriptHash160;
	  }

	  /**
	   * Get scripthash address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getScriptAddress(enc, network) {
	    if (!this.script) return null;
	    if (!this._scriptAddress) {
	      const hash = this.getScriptHash160();
	      const addr = Address.fromScripthash(hash);
	      this._scriptAddress = addr;
	    }
	    if (enc === 'base58') return this._scriptAddress.toBase58(network);
	    if (enc === 'string') return this._scriptAddress.toString(network);
	    return this._scriptAddress;
	  }

	  /**
	   * Get public key hash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getKeyHash(enc) {
	    if (!this._keyHash) this._keyHash = hash160.digest(this.publicKey);
	    return enc === 'hex' ? this._keyHash.toString('hex') : this._keyHash;
	  }

	  /**
	   * Get pubkeyhash address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getKeyAddress(enc, network) {
	    if (!this._keyAddress) {
	      const hash = this.getKeyHash();
	      const addr = Address.fromPubkeyhash(hash);
	      this._keyAddress = addr;
	    }
	    if (enc === 'base58') return this._keyAddress.toBase58(network);
	    if (enc === 'string') return this._keyAddress.toString(network);
	    return this._keyAddress;
	  }

	  /**
	   * Get hash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getHash(enc) {
	    if (this.script) return this.getScriptHash(enc);
	    return this.getKeyHash(enc);
	  }

	  /**
	   * Get base58 address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getAddress(enc, network) {
	    if (this.script) return this.getScriptAddress(enc, network);
	    return this.getKeyAddress(enc, network);
	  }

	  /**
	   * Test an address hash against hash.
	   * @param {Buffer} hash
	   * @returns {Boolean}
	   */

	  ownHash(hash) {
	    if (!hash) return false;
	    if (hash.equals(this.getKeyHash())) return true;
	    if (this.script) {
	      if (hash.equals(this.getScriptHash())) return true;
	    }
	    return false;
	  }

	  /**
	   * Check whether transaction output belongs to this address.
	   * @param {TX|Output} tx - Transaction or Output.
	   * @param {Number?} index - Output index.
	   * @returns {Boolean}
	   */

	  ownOutput(tx, index) {
	    let output;
	    if (tx instanceof Output) {
	      output = tx;
	    } else {
	      output = tx.outputs[index];
	      assert(output, 'Output does not exist.');
	    }
	    return this.ownHash(output.getHash());
	  }

	  /**
	   * Test a hash against script hashes to
	   * find the correct redeem script, if any.
	   * @param {Buffer} hash
	   * @returns {Script|null}
	   */

	  getRedeem(hash) {
	    if (this.script) {
	      if (hash.equals(this.getScriptHash160())) return this.script;
	    }
	    return null;
	  }

	  /**
	   * Sign a message.
	   * @param {Buffer} msg
	   * @returns {Buffer} Signature in DER format.
	   */

	  sign(msg) {
	    assert(this.privateKey, 'Cannot sign without private key.');
	    return secp256k1.signDER(msg, this.privateKey);
	  }

	  /**
	   * Sign a message.
	   * @param {Buffer} msg
	   * @returns {Buffer} Signature in Schnorr format.
	   */

	  signSchnorr(msg) {
	    assert(this.privateKey, 'Cannot sign without private key.');
	    return secp256k1.schnorrSign(msg, this.privateKey);
	  }

	  /**
	   * Verify a message.
	   * @param {Buffer} msg
	   * @param {Buffer} sig - Signature in DER format.
	   * @returns {Boolean}
	   */

	  verify(msg, sig) {
	    return secp256k1.verifyDER(msg, sig, this.publicKey);
	  }

	  /**
	   * Verify a message.
	   * @param {Buffer} msg
	   * @param {Buffer} sig - Signature in Schnorr format.
	   * @returns {Boolean}
	   */

	  verifySchnorr(msg, sig) {
	    return secp256k1.schnorrVerify(msg, sig, this.publicKey);
	  }

	  /**
	   * Get witness program version.
	   * @returns {Number}
	   */

	  getVersion() {
	    return -1;
	  }

	  /**
	   * Get address type.
	   * @returns {ScriptType}
	   */

	  getType() {
	    if (this.script) return Address.types.SCRIPTHASH;
	    return Address.types.PUBKEYHASH;
	  }

	  /**
	   * Inspect keyring.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.toJSON();
	  }

	  /**
	   * Convert an KeyRing to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      publicKey: this.publicKey.toString('hex'),
	      script: this.script ? this.script.toRaw().toString('hex') : null,
	      type: Address.typesByVal[this.getType()].toLowerCase(),
	      address: this.getAddress('string', network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json);
	    assert(typeof json.publicKey === 'string');
	    assert(!json.script || typeof json.script === 'string');
	    this.publicKey = Buffer.from(json.publicKey, 'hex');
	    if (json.script) this.script = Buffer.from(json.script, 'hex');
	    return this;
	  }

	  /**
	   * Instantiate an KeyRing from a jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {KeyRing}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += 1;
	    if (this.privateKey) {
	      size += encoding.sizeVarBytes(this.privateKey);
	      size += 1;
	    } else {
	      size += encoding.sizeVarBytes(this.publicKey);
	    }
	    size += this.script ? this.script.getVarSize() : 1;
	    return size;
	  }

	  /**
	   * Write the keyring to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    const field = 0;

	    // we don't use field for now,
	    // we can use this for flags different
	    // flags in the future.
	    bw.writeU8(field);
	    if (this.privateKey) {
	      bw.writeVarBytes(this.privateKey);
	      bw.writeU8(this.publicKey.length === 33 ? 1 : 0);
	    } else {
	      bw.writeVarBytes(this.publicKey);
	    }
	    if (this.script) bw.writeVarBytes(this.script.toRaw());else bw.writeVarint(0);
	    return bw;
	  }

	  /**
	   * Serialize the keyring.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    // we are not interested in flags.
	    br.readU8();
	    const key = br.readVarBytes();
	    if (key.length === 32) {
	      const compress = br.readU8() === 1;
	      this.privateKey = key;
	      this.publicKey = secp256k1.publicKeyCreate(key, compress);
	    } else {
	      this.publicKey = key;
	      assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');
	    }
	    const script = br.readVarBytes();
	    if (script.length > 0) this.script = Script.fromRaw(script);
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a keyring from buffer reader.
	   * @param {BufferReader} br
	   * @returns {KeyRing}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a keyring from serialized data.
	   * @param {Buffer} data
	   * @returns {KeyRing}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object is a KeyRing.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isKeyRing(obj) {
	    return obj instanceof KeyRing;
	  }
	}

	/*
	 * Helpers
	 */

	function toKey(opt) {
	  if (!opt) return opt;
	  if (opt.privateKey) return opt.privateKey;
	  if (opt.publicKey) return opt.publicKey;
	  return opt;
	}

	/*
	 * Expose
	 */

	keyring = KeyRing;
	return keyring;
}

/*!
 * memblock.js - memblock block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var memblock;
var hasRequiredMemblock;

function requireMemblock () {
	if (hasRequiredMemblock) return memblock;
	hasRequiredMemblock = 1;

	const bio = requireBufio();
	const AbstractBlock = requireAbstractblock();
	const Block = requireBlock();
	const Headers = requireHeaders();
	const Script = requireScript$1();
	const DUMMY = Buffer.alloc(0);

	/**
	 * Mem Block
	 * A block object which is essentially a "placeholder"
	 * for a full {@link Block} object. The v8 garbage
	 * collector's head will explode if there is too much
	 * data on the javascript heap. Blocks can currently
	 * be up to 1mb in size. In the future, they may be
	 * 2mb, 8mb, or maybe 20mb, who knows? A MemBlock
	 * is an optimization in Bcoin which defers parsing of
	 * the serialized transactions (the block Buffer) until
	 * the block has passed through the chain queue and
	 * is about to enter the chain. This keeps a lot data
	 * off of the javascript heap for most of the time a
	 * block even exists in memory, and manages to keep a
	 * lot of strain off of the garbage collector. Having
	 * 500mb of blocks on the js heap would not be a good
	 * thing.
	 * @alias module:primitives.MemBlock
	 * @extends AbstractBlock
	 */

	class MemBlock extends AbstractBlock {
	  /**
	   * Create a mem block.
	   * @constructor
	   */

	  constructor() {
	    super();
	    this._raw = DUMMY;
	  }

	  /**
	   * Test whether the block is a memblock.
	   * @returns {Boolean}
	   */

	  isMemory() {
	    return true;
	  }

	  /**
	   * Serialize the block headers.
	   * @returns {Buffer}
	   */

	  toHead() {
	    return this._raw.slice(0, 80);
	  }

	  /**
	   * Get the full block size.
	   * @returns {Number}
	   */

	  getSize() {
	    return this._raw.length;
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    return true;
	  }

	  /**
	   * Retrieve the coinbase height
	   * from the coinbase input script.
	   * @returns {Number} height (-1 if not present).
	   */

	  getCoinbaseHeight() {
	    if (this.version < 2) return -1;
	    try {
	      return this.parseCoinbaseHeight();
	    } catch (e) {
	      return -1;
	    }
	  }

	  /**
	   * Parse the coinbase height
	   * from the coinbase input script.
	   * @private
	   * @returns {Number} height (-1 if not present).
	   */

	  parseCoinbaseHeight() {
	    const br = bio.read(this._raw, true);
	    br.seek(80);
	    const txCount = br.readVarint();
	    if (txCount === 0) return -1;
	    br.seek(4);
	    let inCount = br.readVarint();
	    if (inCount === 0) {
	      if (br.readU8() !== 0) inCount = br.readVarint();
	    }
	    if (inCount === 0) return -1;
	    br.seek(36);
	    const script = br.readVarBytes();
	    return Script.getCoinbaseHeight(script);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    const br = bio.read(data, true);
	    this.readHead(br);
	    this._raw = br.data;
	    return this;
	  }

	  /**
	   * Insantiate a memblock from serialized data.
	   * @param {Buffer} data
	   * @returns {MemBlock}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Return serialized block data.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this._raw;
	  }

	  /**
	   * Parse the serialized block data
	   * and create an actual {@link Block}.
	   * @returns {Block}
	   * @throws Parse error
	   */

	  toBlock() {
	    const block = Block.fromRaw(this._raw);
	    block._hash = this._hash;
	    block._hhash = this._hhash;
	    return block;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }

	  /**
	   * Test whether an object is a MemBlock.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMemBlock(obj) {
	    return obj instanceof MemBlock;
	  }
	}

	/*
	 * Expose
	 */

	memblock = MemBlock;
	return memblock;
}

var mtx = {exports: {}};

/*!
 * mtx.js - mutable transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredMtx;

function requireMtx () {
	if (hasRequiredMtx) return mtx.exports;
	hasRequiredMtx = 1;
	(function (module, exports) {

		const assert = requireAssert$1();
		const {
		  encoding
		} = requireBufio();
		const {
		  BufferMap
		} = requireBufferMap();
		const Script = requireScript$1();
		const TX = requireTx();
		const Input = requireInput();
		const Output = requireOutput();
		const Coin = requireCoin();
		const Outpoint = requireOutpoint();
		const CoinView = requireCoinview();
		const Address = requireAddress();
		const consensus = requireConsensus();
		const policy = requirePolicy();
		const Amount = requireAmount();
		const Stack = requireStack();
		const util = requireUtil();
		const {
		  inspectSymbol
		} = requireUtils();

		/**
		 * MTX
		 * A mutable transaction object.
		 * @alias module:primitives.MTX
		 * @extends TX
		 * @property {Number} changeIndex
		 * @property {CoinView} view
		 */

		class MTX extends TX {
		  /**
		   * Create a mutable transaction.
		   * @alias module:primitives.MTX
		   * @constructor
		   * @param {Object} options
		   */

		  constructor(options) {
		    super();
		    this.mutable = true;
		    this.changeIndex = -1;
		    this.view = new CoinView();
		    if (options) this.fromOptions(options);
		  }

		  /**
		   * Inject properties from options object.
		   * @private
		   * @param {Object} options
		   */

		  fromOptions(options) {
		    if (options.version != null) {
		      assert(options.version >>> 0 === options.version, 'Version must a be uint32.');
		      this.version = options.version;
		    }
		    if (options.inputs) {
		      assert(Array.isArray(options.inputs), 'Inputs must be an array.');
		      for (const input of options.inputs) this.addInput(input);
		    }
		    if (options.outputs) {
		      assert(Array.isArray(options.outputs), 'Outputs must be an array.');
		      for (const output of options.outputs) this.addOutput(output);
		    }
		    if (options.locktime != null) {
		      assert(options.locktime >>> 0 === options.locktime, 'Locktime must be a uint32.');
		      this.locktime = options.locktime;
		    }
		    if (options.changeIndex != null) {
		      if (options.changeIndex !== -1) {
		        assert(options.changeIndex >>> 0 === options.changeIndex, 'Change index must be a uint32.');
		        this.changeIndex = options.changeIndex;
		      } else {
		        this.changeIndex = -1;
		      }
		    }
		    return this;
		  }

		  /**
		   * Instantiate MTX from options.
		   * @param {Object} options
		   * @returns {MTX}
		   */

		  static fromOptions(options) {
		    return new this().fromOptions(options);
		  }

		  /**
		   * Clone the transaction. Note that
		   * this will not carry over the view.
		   * @returns {MTX}
		   */

		  clone() {
		    const mtx = new this.constructor();
		    mtx.inject(this);
		    mtx.changeIndex = this.changeIndex;
		    return mtx;
		  }

		  /**
		   * Add an input to the transaction.
		   * @param {Input|Object} options
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addInput({ prevout: { hash: ... }, script: ... });
		   * mtx.addInput(new Input());
		   */

		  addInput(options) {
		    const input = Input.fromOptions(options);
		    this.inputs.push(input);
		    return input;
		  }

		  /**
		   * Add an outpoint as an input.
		   * @param {Outpoint|Object} outpoint
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addOutpoint({ hash: ..., index: 0 });
		   * mtx.addOutpoint(new Outpoint(hash, index));
		   */

		  addOutpoint(outpoint) {
		    const prevout = Outpoint.fromOptions(outpoint);
		    const input = Input.fromOutpoint(prevout);
		    this.inputs.push(input);
		    return input;
		  }

		  /**
		   * Add a coin as an input. Note that this will
		   * add the coin to the internal coin viewpoint.
		   * @param {Coin} coin
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addCoin(Coin.fromTX(tx, 0, -1));
		   */

		  addCoin(coin) {
		    assert(coin instanceof Coin, 'Cannot add non-coin.');
		    const input = Input.fromCoin(coin);
		    this.inputs.push(input);
		    this.view.addCoin(coin);
		    return input;
		  }

		  /**
		   * Add a transaction as an input. Note that
		   * this will add the coin to the internal
		   * coin viewpoint.
		   * @param {TX} tx
		   * @param {Number} index
		   * @param {Number?} height
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addTX(tx, 0);
		   */

		  addTX(tx, index, height) {
		    assert(tx instanceof TX, 'Cannot add non-transaction.');
		    if (height == null) height = -1;
		    const input = Input.fromTX(tx, index);
		    this.inputs.push(input);
		    this.view.addIndex(tx, index, height);
		    return input;
		  }

		  /**
		   * Add an output.
		   * @param {Address|Script|Output|Object} script - Script or output options.
		   * @param {Amount?} value
		   * @returns {Output}
		   *
		   * @example
		   * mtx.addOutput(new Output());
		   * mtx.addOutput({ address: ..., value: 100000 });
		   * mtx.addOutput(address, 100000);
		   * mtx.addOutput(script, 100000);
		   */

		  addOutput(script, value) {
		    let output;
		    if (value != null) output = Output.fromScript(script, value);else output = Output.fromOptions(script);
		    this.outputs.push(output);
		    return output;
		  }

		  /**
		   * Verify all transaction inputs.
		   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
		   * @returns {Boolean} Whether the inputs are valid.
		   * @throws {ScriptError} on invalid inputs
		   */

		  check(flags) {
		    return super.check(this.view, flags);
		  }

		  /**
		   * Verify the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  checkAsync(flags, pool) {
		    return super.checkAsync(this.view, flags, pool);
		  }

		  /**
		   * Verify all transaction inputs.
		   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
		   * @returns {Boolean} Whether the inputs are valid.
		   */

		  verify(flags) {
		    try {
		      this.check(flags);
		    } catch (e) {
		      if (e.type === 'ScriptError') return false;
		      throw e;
		    }
		    return true;
		  }

		  /**
		   * Verify the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async verifyAsync(flags, pool) {
		    try {
		      await this.checkAsync(flags, pool);
		    } catch (e) {
		      if (e.type === 'ScriptError') return false;
		      throw e;
		    }
		    return true;
		  }

		  /**
		   * Calculate the fee for the transaction.
		   * @returns {Amount} fee (zero if not all coins are available).
		   */

		  getFee() {
		    return super.getFee(this.view);
		  }

		  /**
		   * Calculate the total input value.
		   * @returns {Amount} value
		   */

		  getInputValue() {
		    return super.getInputValue(this.view);
		  }

		  /**
		   * Get all input addresses.
		   * @returns {Address[]} addresses
		   */

		  getInputAddresses() {
		    return super.getInputAddresses(this.view);
		  }

		  /**
		   * Get all addresses.
		   * @returns {Address[]} addresses
		   */

		  getAddresses() {
		    return super.getAddresses(this.view);
		  }

		  /**
		   * Get all input address hashes.
		   * @returns {Hash[]} hashes
		   */

		  getInputHashes(enc) {
		    return super.getInputHashes(this.view, enc);
		  }

		  /**
		   * Get all address hashes.
		   * @returns {Hash[]} hashes
		   */

		  getHashes(enc) {
		    return super.getHashes(this.view, enc);
		  }

		  /**
		   * Test whether the transaction has
		   * all coins available/filled.
		   * @returns {Boolean}
		   */

		  hasCoins() {
		    return super.hasCoins(this.view);
		  }

		  /**
		   * Calculate virtual sigop count.
		   * @param {VerifyFlags?} flags
		   * @returns {Number} sigop count
		   */

		  getSigops(flags) {
		    return super.getSigops(this.view, flags);
		  }

		  /**
		   *  Calculate sigops count.
		   *  @param {CoinView} view
		   *  @param {VerifyFlags?} flags
		   *  @returns {Number} sigop count
		   */

		  getSigopsCount(flags) {
		    return super.getSigopsCount(this.view, flags);
		  }

		  /**
		   * Perform contextual checks to verify input, output,
		   * and fee values, as well as coinbase spend maturity
		   * (coinbases can only be spent 100 blocks or more
		   * after they're created). Note that this function is
		   * consensus critical.
		   * @param {Number} height - Height at which the
		   * transaction is being spent. In the mempool this is
		   * the chain height plus one at the time it entered the pool.
		   * @returns {Boolean}
		   */

		  verifyInputs(height) {
		    const [fee] = this.checkInputs(height);
		    return fee !== -1;
		  }

		  /**
		   * Perform contextual checks to verify input, output,
		   * and fee values, as well as coinbase spend maturity
		   * (coinbases can only be spent 100 blocks or more
		   * after they're created). Note that this function is
		   * consensus critical.
		   * @param {Number} height - Height at which the
		   * transaction is being spent. In the mempool this is
		   * the chain height plus one at the time it entered the pool.
		   * @returns {Array} [fee, reason, score]
		   */

		  checkInputs(height) {
		    return super.checkInputs(this.view, height);
		  }

		  /**
		   * Build input script (or witness) templates (with
		   * OP_0 in place of signatures).
		   * @param {Number} index - Input index.
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring
		   * @returns {Boolean} Whether the script was able to be built.
		   */

		  scriptInput(index, coin, ring) {
		    const input = this.inputs[index];
		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');

		    // Don't bother with any below calculation
		    // if the output is already templated.
		    if (input.script.raw.length !== 0) return true;

		    // Get the previous output's script
		    const prev = coin.script;

		    // This is easily the hardest part about
		    // building a transaction with segwit:
		    // figuring out where the redeem script
		    // and witness redeem scripts go.
		    const sh = prev.getScripthash();
		    if (sh) {
		      const redeem = ring.getRedeem(sh);
		      if (!redeem) return false;

		      // Regular P2SH.
		      const vector = this.scriptVector(redeem, ring);
		      if (!vector) return false;
		      vector.push(redeem.toRaw());
		      input.script.fromStack(vector);
		      return true;
		    }
		    const vector = this.scriptVector(prev, ring);
		    if (!vector) return false;
		    input.script.fromStack(vector);
		    return true;
		  }

		  /**
		   * Build script for a single vector
		   * based on a previous script.
		   * @param {Script} prev
		   * @param {Buffer} ring
		   * @return {Stack}
		   */

		  scriptVector(prev, ring) {
		    // P2PK
		    const pk = prev.getPubkey();
		    if (pk) {
		      if (!pk.equals(ring.publicKey)) return null;
		      const stack = new Stack();
		      stack.pushInt(0);
		      return stack;
		    }

		    // P2PKH
		    const pkh = prev.getPubkeyhash();
		    if (pkh) {
		      if (!pkh.equals(ring.getKeyHash())) return null;
		      const stack = new Stack();
		      stack.pushInt(0);
		      stack.pushData(ring.publicKey);
		      return stack;
		    }

		    // Multisig
		    const [, n] = prev.getMultisig();
		    if (n !== -1) {
		      if (prev.indexOf(ring.publicKey) === -1) return null;

		      // Technically we should create m signature slots,
		      // but we create n signature slots so we can order
		      // the signatures properly.
		      const stack = new Stack();
		      stack.pushInt(0);

		      // Fill script with `n` signature slots.
		      for (let i = 0; i < n; i++) stack.pushInt(0);
		      return stack;
		    }
		    return null;
		  }

		  /**
		   * Sign a transaction input on the worker pool
		   * (if workers are enabled).
		   * @param {Number} index
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring
		   * @param {SighashType?} type
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async signInputAsync(index, coin, ring, type, pool) {
		    if (!pool) return this.signInput(index, coin, ring, type);
		    return await pool.signInput(this, index, coin, ring, type, pool);
		  }

		  /**
		   * Sign an input.
		   * @param {Number} index - Index of input being signed.
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring - Private key.
		   * @param {SighashType} type
		   * @returns {Boolean} Whether the input was able to be signed.
		   */

		  signInput(index, coin, ring, type) {
		    const input = this.inputs[index];
		    const key = ring.privateKey;
		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');

		    // Get the previous output's script
		    const value = coin.value;
		    let prev = coin.script;
		    const vector = input.script;
		    let redeem = false;
		    if (type == null) type = Script.hashType.ALL;
		    type |= Script.hashType.SIGHASH_FORKID;
		    const flags = Script.flags.VERIFY_SIGHASH_FORKID;

		    // Grab regular p2sh redeem script.
		    if (prev.isScripthash()) {
		      prev = input.script.getRedeem();
		      if (!prev) throw new Error('Input has not been templated.');
		      redeem = true;
		    }

		    // Create our signature.
		    const sig = this.signature(index, prev, value, key, type, flags);
		    if (redeem) {
		      const stack = vector.toStack();
		      const redeem = stack.pop();
		      const result = this.signVector(prev, stack, sig, ring);
		      if (!result) return false;
		      result.push(redeem);
		      vector.fromStack(result);
		      return true;
		    }
		    const stack = vector.toStack();
		    const result = this.signVector(prev, stack, sig, ring);
		    if (!result) return false;
		    vector.fromStack(result);
		    return true;
		  }

		  /**
		   * Add a signature to a vector
		   * based on a previous script.
		   * @param {Script} prev
		   * @param {Stack} vector
		   * @param {Buffer} sig
		   * @param {KeyRing} ring
		   * @return {Boolean}
		   */

		  signVector(prev, vector, sig, ring) {
		    // P2PK
		    const pk = prev.getPubkey();
		    if (pk) {
		      // Make sure the pubkey is ours.
		      if (!ring.publicKey.equals(pk)) return null;
		      if (vector.length === 0) throw new Error('Input has not been templated.');

		      // Already signed.
		      if (vector.get(0).length > 0) return vector;
		      vector.set(0, sig);
		      return vector;
		    }

		    // P2PKH
		    const pkh = prev.getPubkeyhash();
		    if (pkh) {
		      // Make sure the pubkey hash is ours.
		      if (!ring.getKeyHash().equals(pkh)) return null;
		      if (vector.length !== 2) throw new Error('Input has not been templated.');
		      if (vector.get(1).length === 0) throw new Error('Input has not been templated.');

		      // Already signed.
		      if (vector.get(0).length > 0) return vector;
		      vector.set(0, sig);
		      return vector;
		    }

		    // Multisig
		    const [m, n] = prev.getMultisig();
		    if (m !== -1) {
		      if (vector.length < 2) throw new Error('Input has not been templated.');
		      if (vector.get(0).length !== 0) throw new Error('Input has not been templated.');

		      // Too many signature slots. Abort.
		      if (vector.length - 1 > n) throw new Error('Input has not been templated.');

		      // Count the number of current signatures.
		      let total = 0;
		      for (let i = 1; i < vector.length; i++) {
		        const item = vector.get(i);
		        if (item.length > 0) total += 1;
		      }

		      // Signatures are already finalized.
		      if (total === m && vector.length - 1 === m) return vector;

		      // Add some signature slots for us to use if
		      // there was for some reason not enough.
		      while (vector.length - 1 < n) vector.pushInt(0);

		      // Grab the redeem script's keys to figure
		      // out where our key should go.
		      const keys = [];
		      for (const op of prev.code) {
		        if (op.data) keys.push(op.data);
		      }

		      // Find the key index so we can place
		      // the signature in the same index.
		      let keyIndex = -1;
		      for (let i = 0; i < keys.length; i++) {
		        const key = keys[i];
		        if (key.equals(ring.publicKey)) {
		          keyIndex = i;
		          break;
		        }
		      }

		      // Our public key is not in the prev_out
		      // script. We tried to sign a transaction
		      // that is not redeemable by us.
		      if (keyIndex === -1) return null;

		      // Offset key index by one to turn it into
		      // "sig index". Accounts for OP_0 byte at
		      // the start.
		      keyIndex += 1;

		      // Add our signature to the correct slot
		      // and increment the total number of
		      // signatures.
		      if (keyIndex < vector.length && total < m) {
		        if (vector.get(keyIndex).length === 0) {
		          vector.set(keyIndex, sig);
		          total += 1;
		        }
		      }

		      // All signatures added. Finalize.
		      if (total >= m) {
		        // Remove empty slots left over.
		        for (let i = vector.length - 1; i >= 1; i--) {
		          const item = vector.get(i);
		          if (item.length === 0) vector.remove(i);
		        }

		        // Remove signatures which are not required.
		        // This should never happen.
		        while (total > m) {
		          vector.pop();
		          total -= 1;
		        }

		        // Sanity checks.
		        assert(total === m);
		        assert(vector.length - 1 === m);
		      }
		      return vector;
		    }
		    return null;
		  }

		  /**
		   * Test whether the transaction is fully-signed.
		   * @returns {Boolean}
		   */

		  isSigned() {
		    for (let i = 0; i < this.inputs.length; i++) {
		      const {
		        prevout
		      } = this.inputs[i];
		      const coin = this.view.getOutput(prevout);
		      if (!coin) return false;
		      if (!this.isInputSigned(i, coin)) return false;
		    }
		    return true;
		  }

		  /**
		   * Test whether an input is fully-signed.
		   * @param {Number} index
		   * @param {Coin|Output} coin
		   * @returns {Boolean}
		   */

		  isInputSigned(index, coin) {
		    const input = this.inputs[index];
		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');
		    const vector = input.script;
		    let prev = coin.script;
		    let redeem = false;

		    // Grab redeem script if possible.
		    if (prev.isScripthash()) {
		      prev = input.script.getRedeem();
		      if (!prev) return false;
		      redeem = true;
		    }
		    const stack = vector.toStack();
		    if (redeem) stack.pop();
		    return this.isVectorSigned(prev, stack);
		  }

		  /**
		   * Test whether a vector is fully-signed.
		   * @param {Script} prev
		   * @param {Stack} vector
		   * @returns {Boolean}
		   */

		  isVectorSigned(prev, vector) {
		    if (prev.isPubkey()) {
		      if (vector.length !== 1) return false;
		      if (vector.get(0).length === 0) return false;
		      return true;
		    }
		    if (prev.isPubkeyhash()) {
		      if (vector.length !== 2) return false;
		      if (vector.get(0).length === 0) return false;
		      if (vector.get(1).length === 0) return false;
		      return true;
		    }
		    const [m] = prev.getMultisig();
		    if (m !== -1) {
		      // Ensure we have the correct number
		      // of required signatures.
		      if (vector.length - 1 !== m) return false;

		      // Ensure all members are signatures.
		      for (let i = 1; i < vector.length; i++) {
		        const item = vector.get(i);
		        if (item.length === 0) return false;
		      }
		      return true;
		    }
		    return false;
		  }

		  /**
		   * Build input scripts (or witnesses).
		   * @param {KeyRing} ring - Address used to sign. The address
		   * must be able to redeem the coin.
		   * @returns {Number} Number of inputs templated.
		   */

		  template(ring) {
		    if (Array.isArray(ring)) {
		      let total = 0;
		      for (const key of ring) total += this.template(key);
		      return total;
		    }
		    let total = 0;
		    for (let i = 0; i < this.inputs.length; i++) {
		      const {
		        prevout
		      } = this.inputs[i];
		      const coin = this.view.getOutput(prevout);
		      if (!coin) continue;
		      if (!ring.ownOutput(coin)) continue;

		      // Build script for input
		      if (!this.scriptInput(i, coin, ring)) continue;
		      total += 1;
		    }
		    return total;
		  }

		  /**
		   * Built input scripts (or witnesses) and sign the inputs.
		   * @param {KeyRing} ring - Address used to sign. The address
		   * must be able to redeem the coin.
		   * @param {SighashType} type
		   * @returns {Number} Number of inputs signed.
		   */

		  sign(ring, type) {
		    if (Array.isArray(ring)) {
		      let total = 0;
		      for (const key of ring) total += this.sign(key, type);
		      return total;
		    }
		    assert(ring.privateKey, 'No private key available.');
		    let total = 0;
		    for (let i = 0; i < this.inputs.length; i++) {
		      const {
		        prevout
		      } = this.inputs[i];
		      const coin = this.view.getOutput(prevout);
		      if (!coin) continue;
		      if (!ring.ownOutput(coin)) continue;

		      // Build script for input
		      if (!this.scriptInput(i, coin, ring)) continue;

		      // Sign input
		      if (!this.signInput(i, coin, ring, type)) continue;
		      total += 1;
		    }
		    return total;
		  }

		  /**
		   * Sign the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {KeyRing} ring
		   * @param {SighashType?} type
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async signAsync(ring, type, pool) {
		    if (!pool) return this.sign(ring, type);
		    return await pool.sign(this, ring, type);
		  }

		  /**
		   * Estimate maximum possible size.
		   * @param {Function?} estimate - Input script size estimator.
		   * @returns {Number}
		   */

		  async estimateSize(estimate) {
		    let total = 0;

		    // Calculate the size, minus the input scripts.
		    total += 4;
		    total += encoding.sizeVarint(this.inputs.length);
		    total += this.inputs.length * 40;
		    total += encoding.sizeVarint(this.outputs.length);
		    for (const output of this.outputs) total += output.getSize();
		    total += 4;

		    // Add size for signatures and public keys
		    for (const {
		      prevout
		    } of this.inputs) {
		      const coin = this.view.getOutput(prevout);

		      // We're out of luck here.
		      // Just assume it's a p2pkh.
		      if (!coin) {
		        total += 110;
		        continue;
		      }

		      // Previous output script.
		      const prev = coin.script;

		      // P2PK
		      if (prev.isPubkey()) {
		        // varint script size
		        total += 1;
		        // OP_PUSHDATA0 [signature]
		        total += 1 + 73;
		        continue;
		      }

		      // P2PKH
		      if (prev.isPubkeyhash()) {
		        // varint script size
		        total += 1;
		        // OP_PUSHDATA0 [signature]
		        total += 1 + 73;
		        // OP_PUSHDATA0 [key]
		        total += 1 + 33;
		        continue;
		      }
		      const [m] = prev.getMultisig();
		      if (m !== -1) {
		        let size = 0;
		        // Bare Multisig
		        // OP_0
		        size += 1;
		        // OP_PUSHDATA0 [signature] ...
		        size += (1 + 73) * m;
		        // varint len
		        size += encoding.sizeVarint(size);
		        total += size;
		        continue;
		      }

		      // Call out to the custom estimator.
		      if (estimate) {
		        const size = await estimate(prev);
		        if (size !== -1) {
		          total += size;
		          continue;
		        }
		      }

		      // P2SH
		      if (prev.isScripthash()) {
		        // varint size
		        total += 1;
		        // 2-of-3 multisig input
		        total += 149;
		        continue;
		      }

		      // Unknown.
		      total += 110;
		    }
		    return total;
		  }

		  /**
		   * Select necessary coins based on total output value.
		   * @param {Coin[]} coins
		   * @param {Object?} options
		   * @returns {CoinSelection}
		   * @throws on not enough funds available.
		   */

		  selectCoins(coins, options) {
		    const selector = new CoinSelector(this, options);
		    return selector.select(coins);
		  }

		  /**
		   * Attempt to subtract a fee from a single output.
		   * @param {Number} index
		   * @param {Amount} fee
		   */

		  subtractIndex(index, fee) {
		    assert(typeof index === 'number');
		    assert(typeof fee === 'number');
		    const output = this.outputs[index];
		    if (!output) throw new Error('Subtraction index does not exist.');
		    if (output.value < fee + output.getDustThreshold()) throw new Error('Could not subtract fee.');
		    output.value -= fee;
		  }

		  /**
		   * Attempt to subtract a fee from all outputs evenly.
		   * @param {Amount} fee
		   */

		  subtractFee(fee) {
		    assert(typeof fee === 'number');
		    let outputs = 0;
		    for (const output of this.outputs) {
		      // Ignore nulldatas and
		      // other OP_RETURN scripts.
		      if (output.script.isUnspendable()) continue;
		      outputs += 1;
		    }
		    if (outputs === 0) throw new Error('Could not subtract fee.');
		    const left = fee % outputs;
		    const share = (fee - left) / outputs;

		    // First pass, remove even shares.
		    for (const output of this.outputs) {
		      if (output.script.isUnspendable()) continue;
		      if (output.value < share + output.getDustThreshold()) throw new Error('Could not subtract fee.');
		      output.value -= share;
		    }

		    // Second pass, remove the remainder
		    // for the one unlucky output.
		    for (const output of this.outputs) {
		      if (output.script.isUnspendable()) continue;
		      if (output.value >= left + output.getDustThreshold()) {
		        output.value -= left;
		        return;
		      }
		    }
		    throw new Error('Could not subtract fee.');
		  }

		  /**
		   * Select coins and fill the inputs.
		   * @param {Coin[]} coins
		   * @param {Object} options - See {@link MTX#selectCoins} options.
		   * @returns {CoinSelector}
		   */

		  async fund(coins, options) {
		    assert(options, 'Options are required.');
		    assert(options.changeAddress, 'Change address is required.');
		    assert(this.inputs.length === 0, 'TX is already funded.');

		    // Select necessary coins.
		    const select = await this.selectCoins(coins, options);

		    // Add coins to transaction.
		    for (const coin of select.chosen) this.addCoin(coin);

		    // Attempt to subtract fee.
		    if (select.subtractFee) {
		      const index = select.subtractIndex;
		      if (index !== -1) this.subtractIndex(index, select.fee);else this.subtractFee(select.fee);
		    }

		    // Add a change output.
		    const output = new Output();
		    output.value = select.change;
		    output.script.fromAddress(select.changeAddress);
		    if (output.isDust(policy.MIN_RELAY)) {
		      // Do nothing. Change is added to fee.
		      this.changeIndex = -1;
		      assert.strictEqual(this.getFee(), select.fee + select.change);
		    } else {
		      this.outputs.push(output);
		      this.changeIndex = this.outputs.length - 1;
		      assert.strictEqual(this.getFee(), select.fee);
		    }
		    return select;
		  }

		  /**
		   * Sort inputs and outputs according to BIP69.
		   * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
		   */

		  sortMembers() {
		    let changeOutput = null;
		    if (this.changeIndex !== -1) {
		      changeOutput = this.outputs[this.changeIndex];
		      assert(changeOutput);
		    }
		    this.inputs.sort(sortInputs);
		    this.outputs.sort(sortOutputs);
		    if (this.changeIndex !== -1) {
		      this.changeIndex = this.outputs.indexOf(changeOutput);
		      assert(this.changeIndex !== -1);
		    }
		  }

		  /**
		   * Avoid fee sniping.
		   * @param {Number} - Current chain height.
		   * @see bitcoin/src/wallet/wallet.cpp
		   */

		  avoidFeeSniping(height) {
		    assert(typeof height === 'number', 'Must pass in height.');
		    if ((Math.random() * 10 | 0) === 0) {
		      height -= Math.random() * 100 | 0;
		      if (height < 0) height = 0;
		    }
		    this.setLocktime(height);
		  }

		  /**
		   * Set locktime and sequences appropriately.
		   * @param {Number} locktime
		   */

		  setLocktime(locktime) {
		    assert(locktime >>> 0 === locktime, 'Locktime must be a uint32.');
		    assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');
		    for (const input of this.inputs) {
		      if (input.sequence === 0xffffffff) input.sequence = 0xfffffffe;
		    }
		    this.locktime = locktime;
		  }

		  /**
		   * Set sequence locktime.
		   * @param {Number} index - Input index.
		   * @param {Number} locktime
		   * @param {Boolean?} seconds
		   */

		  setSequence(index, locktime, seconds) {
		    const input = this.inputs[index];
		    assert(input, 'Input does not exist.');
		    assert(locktime >>> 0 === locktime, 'Locktime must be a uint32.');
		    this.version = 2;
		    if (seconds) {
		      locktime >>>= consensus.SEQUENCE_GRANULARITY;
		      locktime &= consensus.SEQUENCE_MASK;
		      locktime |= consensus.SEQUENCE_TYPE_FLAG;
		    } else {
		      locktime &= consensus.SEQUENCE_MASK;
		    }
		    input.sequence = locktime;
		  }

		  /**
		   * Inspect the transaction.
		   * @returns {Object}
		   */

		  [inspectSymbol]() {
		    return this.format();
		  }

		  /**
		   * Inspect the transaction.
		   * @returns {Object}
		   */

		  format() {
		    return super.format(this.view);
		  }

		  /**
		   * Convert transaction to JSON.
		   * @returns {Object}
		   */

		  toJSON() {
		    return super.toJSON(null, this.view);
		  }

		  /**
		   * Convert transaction to JSON.
		   * @param {Network} network
		   * @returns {Object}
		   */

		  getJSON(network) {
		    return super.getJSON(network, this.view);
		  }

		  /**
		   * Inject properties from a json object
		   * @param {Object} json
		   */

		  fromJSON(json) {
		    super.fromJSON(json);
		    for (let i = 0; i < json.inputs.length; i++) {
		      const input = json.inputs[i];
		      const {
		        prevout
		      } = input;
		      if (!input.coin) continue;
		      const coin = Coin.fromJSON(input.coin);
		      coin.hash = util.fromRev(prevout.hash);
		      coin.index = prevout.index;
		      this.view.addCoin(coin);
		    }
		    return this;
		  }

		  /**
		   * Instantiate a transaction from a
		   * jsonified transaction object.
		   * @param {Object} json - The jsonified transaction object.
		   * @returns {MTX}
		   */

		  static fromJSON(json) {
		    return new this().fromJSON(json);
		  }

		  /**
		   * Instantiate a transaction from a buffer reader.
		   * @param {BufferReader} br
		   * @returns {MTX}
		   */

		  static fromReader(br) {
		    return new this().fromReader(br);
		  }

		  /**
		   * Instantiate a transaction from a serialized Buffer.
		   * @param {Buffer} data
		   * @param {String?} enc - Encoding, can be `'hex'` or null.
		   * @returns {MTX}
		   */

		  static fromRaw(data, enc) {
		    if (typeof data === 'string') data = Buffer.from(data, enc);
		    return new this().fromRaw(data);
		  }

		  /**
		   * Convert the MTX to a TX.
		   * @returns {TX}
		   */

		  toTX() {
		    return new TX().inject(this);
		  }

		  /**
		   * Convert the MTX to a TX.
		   * @returns {Array} [tx, view]
		   */

		  commit() {
		    return [this.toTX(), this.view];
		  }

		  /**
		   * Instantiate MTX from TX.
		   * @param {TX} tx
		   * @returns {MTX}
		   */

		  static fromTX(tx) {
		    return new this().inject(tx);
		  }

		  /**
		   * Test whether an object is an MTX.
		   * @param {Object} obj
		   * @returns {Boolean}
		   */

		  static isMTX(obj) {
		    return obj instanceof MTX;
		  }
		}

		/**
		 * Coin Selector
		 * @alias module:primitives.CoinSelector
		 */

		class CoinSelector {
		  /**
		   * Create a coin selector.
		   * @constructor
		   * @param {TX} tx
		   * @param {Object?} options
		   */

		  constructor(tx, options) {
		    this.tx = tx.clone();
		    this.coins = [];
		    this.outputValue = 0;
		    this.index = 0;
		    this.chosen = [];
		    this.change = 0;
		    this.fee = CoinSelector.MIN_FEE;
		    this.selection = 'value';
		    this.subtractFee = false;
		    this.subtractIndex = -1;
		    this.height = -1;
		    this.depth = -1;
		    this.hardFee = -1;
		    this.rate = CoinSelector.FEE_RATE;
		    this.maxFee = -1;
		    this.round = false;
		    this.changeAddress = null;
		    this.inputs = new BufferMap();

		    // Needed for size estimation.
		    this.estimate = null;
		    this.injectInputs();
		    if (options) this.fromOptions(options);
		  }

		  /**
		   * Initialize selector options.
		   * @param {Object} options
		   * @private
		   */

		  fromOptions(options) {
		    if (options.selection) {
		      assert(typeof options.selection === 'string');
		      this.selection = options.selection;
		    }
		    if (options.subtractFee != null) {
		      if (typeof options.subtractFee === 'number') {
		        assert(Number.isSafeInteger(options.subtractFee));
		        assert(options.subtractFee >= -1);
		        this.subtractIndex = options.subtractFee;
		        this.subtractFee = this.subtractIndex !== -1;
		      } else {
		        assert(typeof options.subtractFee === 'boolean');
		        this.subtractFee = options.subtractFee;
		      }
		    }
		    if (options.subtractIndex != null) {
		      assert(Number.isSafeInteger(options.subtractIndex));
		      assert(options.subtractIndex >= -1);
		      this.subtractIndex = options.subtractIndex;
		      this.subtractFee = this.subtractIndex !== -1;
		    }
		    if (options.height != null) {
		      assert(Number.isSafeInteger(options.height));
		      assert(options.height >= -1);
		      this.height = options.height;
		    }
		    if (options.confirmations != null) {
		      assert(Number.isSafeInteger(options.confirmations));
		      assert(options.confirmations >= -1);
		      this.depth = options.confirmations;
		    }
		    if (options.depth != null) {
		      assert(Number.isSafeInteger(options.depth));
		      assert(options.depth >= -1);
		      this.depth = options.depth;
		    }
		    if (options.hardFee != null) {
		      assert(Number.isSafeInteger(options.hardFee));
		      assert(options.hardFee >= -1);
		      this.hardFee = options.hardFee;
		    }
		    if (options.rate != null) {
		      assert(Number.isSafeInteger(options.rate));
		      assert(options.rate >= 0);
		      this.rate = options.rate;
		    }
		    if (options.maxFee != null) {
		      assert(Number.isSafeInteger(options.maxFee));
		      assert(options.maxFee >= -1);
		      this.maxFee = options.maxFee;
		    }
		    if (options.round != null) {
		      assert(typeof options.round === 'boolean');
		      this.round = options.round;
		    }
		    if (options.changeAddress) {
		      const addr = options.changeAddress;
		      if (typeof addr === 'string') {
		        this.changeAddress = Address.fromString(addr);
		      } else {
		        assert(addr instanceof Address);
		        this.changeAddress = addr;
		      }
		    }
		    if (options.estimate) {
		      assert(typeof options.estimate === 'function');
		      this.estimate = options.estimate;
		    }
		    if (options.inputs) {
		      assert(Array.isArray(options.inputs));
		      for (let i = 0; i < options.inputs.length; i++) {
		        const prevout = options.inputs[i];
		        assert(prevout && typeof prevout === 'object');
		        const {
		          hash,
		          index
		        } = prevout;
		        assert(Buffer.isBuffer(hash));
		        assert(typeof index === 'number');
		        this.inputs.set(Outpoint.toKey(hash, index), i);
		      }
		    }
		    return this;
		  }

		  /**
		   * Attempt to inject existing inputs.
		   * @private
		   */

		  injectInputs() {
		    if (this.tx.inputs.length > 0) {
		      for (let i = 0; i < this.tx.inputs.length; i++) {
		        const {
		          prevout
		        } = this.tx.inputs[i];
		        this.inputs.set(prevout.toKey(), i);
		      }
		    }
		  }

		  /**
		   * Initialize the selector with coins to select from.
		   * @param {Coin[]} coins
		   */

		  init(coins) {
		    this.coins = coins.slice();
		    this.outputValue = this.tx.getOutputValue();
		    this.index = 0;
		    this.chosen = [];
		    this.change = 0;
		    this.fee = CoinSelector.MIN_FEE;
		    this.tx.inputs.length = 0;
		    switch (this.selection) {
		      case 'all':
		      case 'random':
		        this.coins.sort(sortRandom);
		        break;
		      case 'age':
		        this.coins.sort(sortAge);
		        break;
		      case 'value':
		        this.coins.sort(sortValue);
		        break;
		      default:
		        throw new FundingError(`Bad selection type: ${this.selection}.`);
		    }
		  }

		  /**
		   * Calculate total value required.
		   * @returns {Amount}
		   */

		  total() {
		    if (this.subtractFee) return this.outputValue;
		    return this.outputValue + this.fee;
		  }

		  /**
		   * Test whether the selector has
		   * completely funded the transaction.
		   * @returns {Boolean}
		   */

		  isFull() {
		    return this.tx.getInputValue() >= this.total();
		  }

		  /**
		   * Test whether a coin is spendable
		   * with regards to the options.
		   * @param {Coin} coin
		   * @returns {Boolean}
		   */

		  isSpendable(coin) {
		    if (this.tx.view.hasEntry(coin)) return false;
		    if (this.height === -1) return true;
		    if (coin.coinbase) {
		      if (coin.height === -1) return false;
		      if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY) return false;
		      return true;
		    }
		    if (this.depth === -1) return true;
		    const depth = coin.getDepth(this.height);
		    if (depth < this.depth) return false;
		    return true;
		  }

		  /**
		   * Get the current fee based on a size.
		   * @param {Number} size
		   * @returns {Amount}
		   */

		  getFee(size) {
		    // This is mostly here for testing.
		    // i.e. A fee rounded to the nearest
		    // kb is easier to predict ahead of time.
		    if (this.round) {
		      const fee = policy.getRoundFee(size, this.rate);
		      return Math.min(fee, CoinSelector.MAX_FEE);
		    }
		    const fee = policy.getMinFee(size, this.rate);
		    return Math.min(fee, CoinSelector.MAX_FEE);
		  }

		  /**
		   * Fund the transaction with more
		   * coins if the `output value + fee`
		   * total was updated.
		   */

		  fund() {
		    // Ensure all preferred inputs first.
		    if (this.inputs.size > 0) {
		      const coins = [];
		      for (let i = 0; i < this.inputs.size; i++) coins.push(null);
		      for (const coin of this.coins) {
		        const {
		          hash,
		          index
		        } = coin;
		        const key = Outpoint.toKey(hash, index);
		        const i = this.inputs.get(key);
		        if (i != null) {
		          coins[i] = coin;
		          this.inputs.delete(key);
		        }
		      }
		      if (this.inputs.size > 0) throw new Error('Could not resolve preferred inputs.');
		      for (const coin of coins) {
		        this.tx.addCoin(coin);
		        this.chosen.push(coin);
		      }
		    }
		    while (this.index < this.coins.length) {
		      const coin = this.coins[this.index++];
		      if (!this.isSpendable(coin)) continue;
		      this.tx.addCoin(coin);
		      this.chosen.push(coin);
		      if (this.selection === 'all') continue;
		      if (this.isFull()) break;
		    }
		  }

		  /**
		   * Initiate selection from `coins`.
		   * @param {Coin[]} coins
		   * @returns {CoinSelector}
		   */

		  async select(coins) {
		    this.init(coins);
		    if (this.hardFee !== -1) {
		      this.selectHard();
		    } else {
		      // This is potentially asynchronous:
		      // it may invoke the size estimator
		      // required for redeem scripts (we
		      // may be calling out to a wallet
		      // or something similar).
		      await this.selectEstimate();
		    }
		    if (!this.isFull()) {
		      // Still failing to get enough funds.
		      throw new FundingError('Not enough funds.', this.tx.getInputValue(), this.total());
		    }

		    // How much money is left after filling outputs.
		    this.change = this.tx.getInputValue() - this.total();
		    return this;
		  }

		  /**
		   * Initialize selection based on size estimate.
		   */

		  async selectEstimate() {
		    // Set minimum fee and do
		    // an initial round of funding.
		    this.fee = CoinSelector.MIN_FEE;
		    this.fund();

		    // Add dummy output for change.
		    const change = new Output();
		    if (this.changeAddress) {
		      change.script.fromAddress(this.changeAddress);
		    } else {
		      // In case we don't have a change address,
		      // we use a fake p2pkh output to gauge size.
		      change.script.fromPubkeyhash(Buffer.allocUnsafe(20));
		    }
		    this.tx.outputs.push(change);

		    // Keep recalculating the fee and funding
		    // until we reach some sort of equilibrium.
		    do {
		      const size = await this.tx.estimateSize(this.estimate);
		      this.fee = this.getFee(size);
		      if (this.maxFee > 0 && this.fee > this.maxFee) throw new FundingError('Fee is too high.');

		      // Failed to get enough funds, add more coins.
		      if (!this.isFull()) this.fund();
		    } while (!this.isFull() && this.index < this.coins.length);
		  }

		  /**
		   * Initiate selection based on a hard fee.
		   */

		  selectHard() {
		    this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);
		    this.fund();
		  }
		}

		/**
		 * Default fee rate
		 * for coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.FEE_RATE = 10000;

		/**
		 * Minimum fee to start with
		 * during coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.MIN_FEE = 10000;

		/**
		 * Maximum fee to allow
		 * after coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.MAX_FEE = consensus.COIN / 10;

		/**
		 * Funding Error
		 * An error thrown from the coin selector.
		 * @ignore
		 * @extends Error
		 * @property {String} message - Error message.
		 * @property {Amount} availableFunds
		 * @property {Amount} requiredFunds
		 */

		class FundingError extends Error {
		  /**
		   * Create a funding error.
		   * @constructor
		   * @param {String} msg
		   * @param {Amount} available
		   * @param {Amount} required
		   */

		  constructor(msg, available, required) {
		    super();
		    this.type = 'FundingError';
		    this.message = msg;
		    this.availableFunds = -1;
		    this.requiredFunds = -1;
		    if (available != null) {
		      this.message += ` (available=${Amount.btc(available)},`;
		      this.message += ` required=${Amount.btc(required)})`;
		      this.availableFunds = available;
		      this.requiredFunds = required;
		    }
		    if (Error.captureStackTrace) Error.captureStackTrace(this, FundingError);
		  }
		}

		/*
		 * Helpers
		 */

		function sortAge(a, b) {
		  a = a.height === -1 ? 0x7fffffff : a.height;
		  b = b.height === -1 ? 0x7fffffff : b.height;
		  return a - b;
		}
		function sortRandom(a, b) {
		  return Math.random() > 0.5 ? 1 : -1;
		}
		function sortValue(a, b) {
		  if (a.height === -1 && b.height !== -1) return 1;
		  if (a.height !== -1 && b.height === -1) return -1;
		  return b.value - a.value;
		}
		function sortInputs(a, b) {
		  return a.compare(b);
		}
		function sortOutputs(a, b) {
		  return a.compare(b);
		}

		/*
		 * Expose
		 */

		exports = MTX;
		exports.MTX = MTX;
		exports.Selector = CoinSelector;
		exports.FundingError = FundingError;
		module.exports = exports; 
	} (mtx, mtx.exports));
	return mtx.exports;
}

/*!
 * txmeta.js - extended transaction object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var txmeta;
var hasRequiredTxmeta;

function requireTxmeta () {
	if (hasRequiredTxmeta) return txmeta;
	hasRequiredTxmeta = 1;

	const assert = requireAssert$1();
	const bio = requireBufio();
	const util = requireUtil();
	const TX = requireTx();
	const {
	  inspectSymbol
	} = requireUtils();

	/**
	 * TXMeta
	 * An extended transaction object.
	 * @alias module:primitives.TXMeta
	 */

	class TXMeta {
	  /**
	   * Create an extended transaction.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.tx = new TX();
	    this.mtime = util.now();
	    this.height = -1;
	    this.block = null;
	    this.time = 0;
	    this.index = -1;
	    if (options) this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    if (options.tx) {
	      assert(options.tx instanceof TX);
	      this.tx = options.tx;
	    }
	    if (options.mtime != null) {
	      assert(options.mtime >>> 0 === options.mtime);
	      this.mtime = options.mtime;
	    }
	    if (options.height != null) {
	      assert(Number.isSafeInteger(options.height));
	      this.height = options.height;
	    }
	    if (options.block !== undefined) {
	      assert(options.block == null || Buffer.isBuffer(options.block));
	      this.block = options.block;
	    }
	    if (options.time != null) {
	      assert(options.time >>> 0 === options.time);
	      this.time = options.time;
	    }
	    if (options.index != null) {
	      assert(Number.isSafeInteger(options.index));
	      this.index = options.index;
	    }
	    return this;
	  }

	  /**
	   * Instantiate TXMeta from options.
	   * @param {Object} options
	   * @returns {TXMeta}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromTX(tx, entry, index) {
	    this.tx = tx;
	    if (entry) {
	      this.height = entry.height;
	      this.block = entry.hash;
	      this.time = entry.time;
	      this.index = index;
	    }
	    return this;
	  }

	  /**
	   * Instantiate TXMeta from options.
	   * @param {Object} options
	   * @returns {TXMeta}
	   */

	  static fromTX(tx, entry, index) {
	    return new this().fromTX(tx, entry, index);
	  }

	  /**
	   * Inspect the transaction.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the transaction.
	   * @returns {Object}
	   */

	  format(view) {
	    const data = this.tx.format(view, null, this.index);
	    data.mtime = this.mtime;
	    data.height = this.height;
	    data.block = this.block ? util.revHex(this.block) : null;
	    data.time = this.time;
	    return data;
	  }

	  /**
	   * Convert transaction to JSON.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @returns {Object}
	   */

	  getJSON(network, view, chainHeight) {
	    const json = this.tx.getJSON(network, view, null, this.index);
	    json.mtime = this.mtime;
	    json.height = this.height;
	    json.block = this.block ? util.revHex(this.block) : null;
	    json.time = this.time;
	    json.confirmations = 0;
	    if (chainHeight != null && this.height !== -1) json.confirmations = chainHeight - this.height + 1;
	    return json;
	  }

	  /**
	   * Inject properties from a json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    this.tx.fromJSON(json);
	    assert(json.mtime >>> 0 === json.mtime);
	    assert(Number.isSafeInteger(json.height));
	    assert(!json.block || typeof json.block === 'string');
	    assert(json.time >>> 0 === json.time);
	    assert(Number.isSafeInteger(json.index));
	    this.mtime = json.mtime;
	    this.height = json.height;
	    this.block = util.fromRev(json.block);
	    this.index = json.index;
	    return this;
	  }

	  /**
	   * Instantiate a transaction from a
	   * jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {TX}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += this.tx.getSize();
	    size += 4;
	    if (this.block) {
	      size += 1;
	      size += 32;
	      size += 4 * 3;
	    } else {
	      size += 1;
	    }
	    return size;
	  }

	  /**
	   * Serialize a transaction to "extended format".
	   * This is the serialization format bcoin uses internally
	   * to store transactions in the database. The extended
	   * serialization includes the height, block hash, index,
	   * timestamp, and pending-since time.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    const bw = bio.write(size);
	    this.tx.toWriter(bw);
	    bw.writeU32(this.mtime);
	    if (this.block) {
	      bw.writeU8(1);
	      bw.writeHash(this.block);
	      bw.writeU32(this.height);
	      bw.writeU32(this.time);
	      bw.writeU32(this.index);
	    } else {
	      bw.writeU8(0);
	    }
	    return bw.render();
	  }

	  /**
	   * Inject properties from "extended" serialization format.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    const br = bio.read(data);
	    this.tx.fromReader(br);
	    this.mtime = br.readU32();
	    if (br.readU8() === 1) {
	      this.block = br.readHash();
	      this.height = br.readU32();
	      this.time = br.readU32();
	      this.index = br.readU32();
	      if (this.index === 0x7fffffff) this.index = -1;
	    }
	    return this;
	  }

	  /**
	   * Instantiate a transaction from a Buffer
	   * in "extended" serialization format.
	   * @param {Buffer} data
	   * @param {String?} enc - One of `"hex"` or `null`.
	   * @returns {TX}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string') data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object is an TXMeta.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isTXMeta(obj) {
	    return obj instanceof TXMeta;
	  }
	}

	/*
	 * Expose
	 */

	txmeta = TXMeta;
	return txmeta;
}

/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredPrimitives;

function requirePrimitives () {
	if (hasRequiredPrimitives) return primitives;
	hasRequiredPrimitives = 1;

	/**
	 * @module primitives
	 */
	primitives.AbstractBlock = requireAbstractblock();
	primitives.Address = requireAddress();
	primitives.Block = requireBlock();
	primitives.Coin = requireCoin();
	primitives.Headers = requireHeaders();
	primitives.Input = requireInput();
	primitives.InvItem = requireInvitem();
	primitives.KeyRing = requireKeyring();
	primitives.MemBlock = requireMemblock();
	primitives.MerkleBlock = requireMerkleblock();
	primitives.MTX = requireMtx();
	primitives.Outpoint = requireOutpoint();
	primitives.Output = requireOutput();
	primitives.TX = requireTx();
	primitives.TXMeta = requireTxmeta();
	return primitives;
}

var protocol = {};

var errors = {};

/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	/**
	 * @module protocol/errors
	 */
	const assert = requireAssert$1();

	/**
	 * Verify Error
	 * An error thrown during verification. Can be either
	 * a mempool transaction validation error or a blockchain
	 * block verification error. Ultimately used to send
	 * `reject` packets to peers.
	 * @extends Error
	 * @param {Block|TX} msg
	 * @param {String} code - Reject packet code.
	 * @param {String} reason - Reject packet reason.
	 * @param {Number} score - Ban score increase
	 * (can be -1 for no reject packet).
	 * @param {Boolean} malleated
	 */

	class VerifyError extends Error {
	  /**
	   * Create a verify error.
	   * @constructor
	   * @param {Block|TX} msg
	   * @param {String} code - Reject packet code.
	   * @param {String} reason - Reject packet reason.
	   * @param {Number} score - Ban score increase
	   * (can be -1 for no reject packet).
	   * @param {Boolean} malleated
	   */

	  constructor(msg, code, reason, score, malleated) {
	    super();
	    assert(typeof code === 'string');
	    assert(typeof reason === 'string');
	    assert(score >= 0);
	    this.type = 'VerifyError';
	    this.message = '';
	    this.code = code;
	    this.reason = reason;
	    this.score = score;
	    this.hash = msg.hash();
	    this.malleated = malleated || false;
	    this.message = `Verification failure: ${reason}` + ` (code=${code} score=${score} hash=${msg.rhash()})`;
	    if (Error.captureStackTrace) Error.captureStackTrace(this, VerifyError);
	  }
	}

	/*
	 * Expose
	 */

	errors.VerifyError = VerifyError;
	return errors;
}

/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredProtocol;

function requireProtocol () {
	if (hasRequiredProtocol) return protocol;
	hasRequiredProtocol = 1;

	/**
	 * @module protocol
	 */
	protocol.consensus = requireConsensus();
	protocol.errors = requireErrors();
	protocol.Network = requireNetwork();
	protocol.networks = requireNetworks();
	protocol.policy = requirePolicy();
	protocol.timedata = requireTimedata();
	return protocol;
}

var script = {};

/*!
 * sigcache.js - signature cache for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var sigcache;
var hasRequiredSigcache;

function requireSigcache () {
	if (hasRequiredSigcache) return sigcache;
	hasRequiredSigcache = 1;

	const assert = requireAssert$1();
	const {
	  BufferMap
	} = requireBufferMap();
	const secp256k1 = requireSecp256k1();

	/**
	 * Signature cache.
	 * @alias module:script.SigCache
	 * @property {Number} size
	 * @property {Hash[]} keys
	 * @property {Object} valid
	 */

	class SigCache {
	  /**
	   * Create a signature cache.
	   * @constructor
	   * @param {Number} [size=10000]
	   */

	  constructor(size) {
	    if (size == null) size = 10000;
	    assert(size >>> 0 === size);
	    this.size = size;
	    this.keys = [];
	    this.valid = new BufferMap();
	  }

	  /**
	   * Resize the sigcache.
	   * @param {Number} size
	   */

	  resize(size) {
	    assert(size >>> 0 === size);
	    this.size = size;
	    this.keys.length = 0;
	    this.valid.clear();
	  }

	  /**
	   * Add item to the sigcache.
	   * Potentially evict a random member.
	   * @param {Hash} msg - Sig hash.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   */

	  add(msg, sig, key) {
	    if (this.size === 0) return;
	    this.valid.set(msg, new SigCacheEntry(sig, key));
	    if (this.keys.length >= this.size) {
	      const i = Math.floor(Math.random() * this.keys.length);
	      const k = this.keys[i];
	      this.valid.delete(k);
	      this.keys[i] = msg;
	    } else {
	      this.keys.push(msg);
	    }
	  }

	  /**
	   * Test whether the sig exists.
	   * @param {Hash} msg - Sig hash.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  has(msg, sig, key) {
	    const entry = this.valid.get(msg);
	    if (!entry) return false;
	    return entry.equals(sig, key);
	  }

	  /**
	   * Verify a signature, testing
	   * it against the cache first.
	   * @param {Buffer} msg
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  verify(msg, sig, key) {
	    if (this.size === 0) return secp256k1.verifyDER(msg, sig, key);
	    if (this.has(msg, sig, key)) return true;
	    const result = secp256k1.verifyDER(msg, sig, key);
	    if (!result) return false;
	    this.add(msg, sig, key);
	    return true;
	  }

	  /**
	   * Verify a schnorr signature, testing
	   * it against the cache first.
	   * @param {Buffer} msg
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  verifySchnorr(msg, sig, key) {
	    if (this.size === 0) return secp256k1.schnorrVerify(msg, sig, key);
	    if (this.has(msg, sig, key)) return true;
	    const result = secp256k1.schnorrVerify(msg, sig, key);
	    if (!result) return false;
	    this.add(msg, sig, key);
	    return true;
	  }
	}

	/**
	 * Signature Cache Entry
	 * @ignore
	 * @property {Buffer} sig
	 * @property {Buffer} key
	 */

	class SigCacheEntry {
	  /**
	   * Create a cache entry.
	   * @constructor
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   */

	  constructor(sig, key) {
	    this.sig = Buffer.from(sig);
	    this.key = Buffer.from(key);
	  }

	  /**
	   * Compare an entry to a sig and key.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  equals(sig, key) {
	    return this.sig.equals(sig) && this.key.equals(key);
	  }
	}

	/*
	 * Expose
	 */

	sigcache = SigCache;
	return sigcache;
}

/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredScript;

function requireScript () {
	if (hasRequiredScript) return script;
	hasRequiredScript = 1;

	/**
	 * @module script
	 */
	script.common = requireCommon$1();
	script.Opcode = requireOpcode();
	script.Script = requireScript$1();
	script.ScriptError = requireScripterror();
	script.ScriptNum = requireScriptnum();
	script.sigcache = requireSigcache();
	script.Stack = requireStack();
	script.Metrics = requireMetrics();
	script.SLP = requireSlp();
	return script;
}

var bcrypto = {};

var aes$1 = {};

/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */

var aes;
var hasRequiredAes$1;

function requireAes$1 () {
	if (hasRequiredAes$1) return aes;
	hasRequiredAes$1 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const TE0 = new Uint32Array([0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a]);
	const TE1 = new Uint32Array([0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616]);
	const TE2 = new Uint32Array([0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16]);
	const TE3 = new Uint32Array([0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c]);
	const TD0 = new Uint32Array([0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742]);
	const TD1 = new Uint32Array([0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857]);
	const TD2 = new Uint32Array([0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8]);
	const TD3 = new Uint32Array([0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0]);
	const TD4 = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
	const RCON = new Uint32Array([0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000]);

	/**
	 * AES
	 */

	class AES {
	  constructor(bits = 256) {
	    assert(bits >>> 0 === bits);
	    this.bits = bits;
	    this.rounds = getRounds(bits);
	    this.key = null;
	    this.encKey = null;
	    this.decKey = null;
	  }
	  get blockSize() {
	    return 16;
	  }
	  init(key) {
	    assert(Buffer.isBuffer(key));
	    if (key.length !== this.bits >>> 3) throw new Error('Invalid key size.');
	    this.destroy();
	    this.key = Buffer.from(key);
	    this.encKey = null;
	    this.decKey = null;
	    return this;
	  }
	  createEncryptKey() {
	    if (!this.key) throw new Error('Cipher is not initialized.');
	    const ukey = this.key;
	    if (ukey.length !== this.bits >>> 3) throw new Error('Invalid key size.');
	    const key = new Uint32Array(60);
	    key[0] = readU32(ukey, 0);
	    key[1] = readU32(ukey, 4);
	    key[2] = readU32(ukey, 8);
	    key[3] = readU32(ukey, 12);
	    let p = 0;
	    let i = 0;
	    if (this.bits === 128) {
	      for (;;) {
	        const tmp = key[p + 3];
	        key[p + 4] = key[p] ^ TE2[tmp >>> 16 & 0xff] & 0xff000000 ^ TE3[tmp >>> 8 & 0xff] & 0x00ff0000 ^ TE0[tmp >>> 0 & 0xff] & 0x0000ff00 ^ TE1[tmp >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
	        key[p + 5] = key[p + 1] ^ key[p + 4];
	        key[p + 6] = key[p + 2] ^ key[p + 5];
	        key[p + 7] = key[p + 3] ^ key[p + 6];
	        i += 1;
	        if (i === 10) break;
	        p += 4;
	      }
	      return key;
	    }
	    key[p + 4] = readU32(ukey, 16);
	    key[p + 5] = readU32(ukey, 20);
	    if (this.bits === 192) {
	      for (;;) {
	        const tmp = key[p + 5];
	        key[p + 6] = key[p] ^ TE2[tmp >>> 16 & 0xff] & 0xff000000 ^ TE3[tmp >>> 8 & 0xff] & 0x00ff0000 ^ TE0[tmp >>> 0 & 0xff] & 0x0000ff00 ^ TE1[tmp >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
	        key[p + 7] = key[p + 1] ^ key[p + 6];
	        key[p + 8] = key[p + 2] ^ key[p + 7];
	        key[p + 9] = key[p + 3] ^ key[p + 8];
	        i += 1;
	        if (i === 8) break;
	        key[p + 10] = key[p + 4] ^ key[p + 9];
	        key[p + 11] = key[p + 5] ^ key[p + 10];
	        p += 6;
	      }
	      return key;
	    }
	    key[p + 6] = readU32(ukey, 24);
	    key[p + 7] = readU32(ukey, 28);
	    if (this.bits === 256) {
	      for (;;) {
	        let tmp = key[p + 7];
	        key[p + 8] = key[p] ^ TE2[tmp >>> 16 & 0xff] & 0xff000000 ^ TE3[tmp >>> 8 & 0xff] & 0x00ff0000 ^ TE0[tmp >>> 0 & 0xff] & 0x0000ff00 ^ TE1[tmp >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
	        key[p + 9] = key[p + 1] ^ key[p + 8];
	        key[p + 10] = key[p + 2] ^ key[p + 9];
	        key[p + 11] = key[p + 3] ^ key[p + 10];
	        i += 1;
	        if (i === 7) break;
	        tmp = key[p + 11];
	        key[p + 12] = key[p + 4] ^ TE2[tmp >>> 24 & 0xff] & 0xff000000 ^ TE3[tmp >>> 16 & 0xff] & 0x00ff0000 ^ TE0[tmp >>> 8 & 0xff] & 0x0000ff00 ^ TE1[tmp >>> 0 & 0xff] & 0x000000ff;
	        key[p + 13] = key[p + 5] ^ key[p + 12];
	        key[p + 14] = key[p + 6] ^ key[p + 13];
	        key[p + 15] = key[p + 7] ^ key[p + 14];
	        p += 8;
	      }
	      return key;
	    }
	    throw new Error('Bad key size.');
	  }
	  createDecryptKey() {
	    // First, start with an encryption schedule.
	    const key = this.createEncryptKey();
	    let p = 0;

	    // Invert the order of the round keys.
	    for (let i = 0, j = 4 * this.rounds; i < j; i += 4, j -= 4) {
	      let tmp = key[p + i + 0];
	      key[p + i + 0] = key[p + j + 0];
	      key[p + j + 0] = tmp;
	      tmp = key[p + i + 1];
	      key[p + i + 1] = key[p + j + 1];
	      key[p + j + 1] = tmp;
	      tmp = key[p + i + 2];
	      key[p + i + 2] = key[p + j + 2];
	      key[p + j + 2] = tmp;
	      tmp = key[p + i + 3];
	      key[p + i + 3] = key[p + j + 3];
	      key[p + j + 3] = tmp;
	    }

	    // Apply the inverse MixColumn transform to
	    // all round keys but the first and the last.
	    for (let i = 1; i < this.rounds; i++) {
	      p += 4;
	      key[p + 0] = TD0[TE1[key[p + 0] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 0] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 0] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 0] >>> 0 & 0xff] & 0xff];
	      key[p + 1] = TD0[TE1[key[p + 1] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 1] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 1] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 1] >>> 0 & 0xff] & 0xff];
	      key[p + 2] = TD0[TE1[key[p + 2] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 2] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 2] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 2] >>> 0 & 0xff] & 0xff];
	      key[p + 3] = TD0[TE1[key[p + 3] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 3] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 3] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 3] >>> 0 & 0xff] & 0xff];
	    }
	    return key;
	  }
	  getEncryptKey() {
	    if (!this.encKey) this.encKey = this.createEncryptKey();
	    return this.encKey;
	  }
	  getDecryptKey() {
	    if (!this.decKey) this.decKey = this.createDecryptKey();
	    return this.decKey;
	  }
	  encrypt(output, opos, input, ipos) {
	    const key = this.getEncryptKey();

	    // Map byte array block to cipher
	    // state and add initial round key.
	    let s0 = readU32(input, ipos + 0) ^ key[0];
	    let s1 = readU32(input, ipos + 4) ^ key[1];
	    let s2 = readU32(input, ipos + 8) ^ key[2];
	    let s3 = readU32(input, ipos + 12) ^ key[3];

	    // Nr - 1 full rounds
	    let r = this.rounds >>> 1;
	    let p = 0;
	    let t0, t1, t2, t3;
	    for (;;) {
	      t0 = TE0[s0 >>> 24 & 0xff] ^ TE1[s1 >>> 16 & 0xff] ^ TE2[s2 >>> 8 & 0xff] ^ TE3[s3 >>> 0 & 0xff] ^ key[p + 4];
	      t1 = TE0[s1 >>> 24 & 0xff] ^ TE1[s2 >>> 16 & 0xff] ^ TE2[s3 >>> 8 & 0xff] ^ TE3[s0 >>> 0 & 0xff] ^ key[p + 5];
	      t2 = TE0[s2 >>> 24 & 0xff] ^ TE1[s3 >>> 16 & 0xff] ^ TE2[s0 >>> 8 & 0xff] ^ TE3[s1 >>> 0 & 0xff] ^ key[p + 6];
	      t3 = TE0[s3 >>> 24 & 0xff] ^ TE1[s0 >>> 16 & 0xff] ^ TE2[s1 >>> 8 & 0xff] ^ TE3[s2 >>> 0 & 0xff] ^ key[p + 7];
	      p += 8;
	      r -= 1;
	      if (r === 0) break;
	      s0 = TE0[t0 >>> 24 & 0xff] ^ TE1[t1 >>> 16 & 0xff] ^ TE2[t2 >>> 8 & 0xff] ^ TE3[t3 >>> 0 & 0xff] ^ key[p + 0];
	      s1 = TE0[t1 >>> 24 & 0xff] ^ TE1[t2 >>> 16 & 0xff] ^ TE2[t3 >>> 8 & 0xff] ^ TE3[t0 >>> 0 & 0xff] ^ key[p + 1];
	      s2 = TE0[t2 >>> 24 & 0xff] ^ TE1[t3 >>> 16 & 0xff] ^ TE2[t0 >>> 8 & 0xff] ^ TE3[t1 >>> 0 & 0xff] ^ key[p + 2];
	      s3 = TE0[t3 >>> 24 & 0xff] ^ TE1[t0 >>> 16 & 0xff] ^ TE2[t1 >>> 8 & 0xff] ^ TE3[t2 >>> 0 & 0xff] ^ key[p + 3];
	    }

	    // Apply last round and map cipher
	    // state to byte array block.
	    s0 = TE2[t0 >>> 24 & 0xff] & 0xff000000 ^ TE3[t1 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t2 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t3 >>> 0 & 0xff] & 0x000000ff ^ key[p + 0];
	    s1 = TE2[t1 >>> 24 & 0xff] & 0xff000000 ^ TE3[t2 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t3 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t0 >>> 0 & 0xff] & 0x000000ff ^ key[p + 1];
	    s2 = TE2[t2 >>> 24 & 0xff] & 0xff000000 ^ TE3[t3 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t0 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t1 >>> 0 & 0xff] & 0x000000ff ^ key[p + 2];
	    s3 = TE2[t3 >>> 24 & 0xff] & 0xff000000 ^ TE3[t0 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t1 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t2 >>> 0 & 0xff] & 0x000000ff ^ key[p + 3];
	    writeU32(output, s0, opos + 0);
	    writeU32(output, s1, opos + 4);
	    writeU32(output, s2, opos + 8);
	    writeU32(output, s3, opos + 12);
	    return this;
	  }
	  decrypt(output, opos, input, ipos) {
	    const key = this.getDecryptKey();

	    // Map byte array block to cipher
	    // state and add initial round key.
	    let s0 = readU32(input, ipos + 0) ^ key[0];
	    let s1 = readU32(input, ipos + 4) ^ key[1];
	    let s2 = readU32(input, ipos + 8) ^ key[2];
	    let s3 = readU32(input, ipos + 12) ^ key[3];

	    // Nr - 1 full rounds
	    let r = this.rounds >>> 1;
	    let p = 0;
	    let t0, t1, t2, t3;
	    for (;;) {
	      t0 = TD0[s0 >>> 24 & 0xff] ^ TD1[s3 >>> 16 & 0xff] ^ TD2[s2 >>> 8 & 0xff] ^ TD3[s1 >>> 0 & 0xff] ^ key[p + 4];
	      t1 = TD0[s1 >>> 24 & 0xff] ^ TD1[s0 >>> 16 & 0xff] ^ TD2[s3 >>> 8 & 0xff] ^ TD3[s2 >>> 0 & 0xff] ^ key[p + 5];
	      t2 = TD0[s2 >>> 24 & 0xff] ^ TD1[s1 >>> 16 & 0xff] ^ TD2[s0 >>> 8 & 0xff] ^ TD3[s3 >>> 0 & 0xff] ^ key[p + 6];
	      t3 = TD0[s3 >>> 24 & 0xff] ^ TD1[s2 >>> 16 & 0xff] ^ TD2[s1 >>> 8 & 0xff] ^ TD3[s0 >>> 0 & 0xff] ^ key[p + 7];
	      p += 8;
	      r -= 1;
	      if (r === 0) break;
	      s0 = TD0[t0 >>> 24 & 0xff] ^ TD1[t3 >>> 16 & 0xff] ^ TD2[t2 >>> 8 & 0xff] ^ TD3[t1 >>> 0 & 0xff] ^ key[p + 0];
	      s1 = TD0[t1 >>> 24 & 0xff] ^ TD1[t0 >>> 16 & 0xff] ^ TD2[t3 >>> 8 & 0xff] ^ TD3[t2 >>> 0 & 0xff] ^ key[p + 1];
	      s2 = TD0[t2 >>> 24 & 0xff] ^ TD1[t1 >>> 16 & 0xff] ^ TD2[t0 >>> 8 & 0xff] ^ TD3[t3 >>> 0 & 0xff] ^ key[p + 2];
	      s3 = TD0[t3 >>> 24 & 0xff] ^ TD1[t2 >>> 16 & 0xff] ^ TD2[t1 >>> 8 & 0xff] ^ TD3[t0 >>> 0 & 0xff] ^ key[p + 3];
	    }

	    // Apply last round and map cipher
	    // state to byte array block.
	    s0 = TD4[t0 >>> 24 & 0xff] << 24 ^ TD4[t3 >>> 16 & 0xff] << 16 ^ TD4[t2 >>> 8 & 0xff] << 8 ^ TD4[t1 >>> 0 & 0xff] << 0 ^ key[p + 0];
	    s1 = TD4[t1 >>> 24 & 0xff] << 24 ^ TD4[t0 >>> 16 & 0xff] << 16 ^ TD4[t3 >>> 8 & 0xff] << 8 ^ TD4[t2 >>> 0 & 0xff] << 0 ^ key[p + 1];
	    s2 = TD4[t2 >>> 24 & 0xff] << 24 ^ TD4[t1 >>> 16 & 0xff] << 16 ^ TD4[t0 >>> 8 & 0xff] << 8 ^ TD4[t3 >>> 0 & 0xff] << 0 ^ key[p + 2];
	    s3 = TD4[t3 >>> 24 & 0xff] << 24 ^ TD4[t2 >>> 16 & 0xff] << 16 ^ TD4[t1 >>> 8 & 0xff] << 8 ^ TD4[t0 >>> 0 & 0xff] << 0 ^ key[p + 3];
	    writeU32(output, s0, opos + 0);
	    writeU32(output, s1, opos + 4);
	    writeU32(output, s2, opos + 8);
	    writeU32(output, s3, opos + 12);
	    return this;
	  }
	  destroy() {
	    if (this.key) {
	      for (let i = 0; i < this.key.length; i++) this.key[i] = 0;
	    }
	    if (this.encKey) {
	      for (let i = 0; i < 60; i++) this.encKey[i] = 0;
	    }
	    if (this.decKey) {
	      for (let i = 0; i < 60; i++) this.decKey[i] = 0;
	    }
	    this.key = null;
	    this.encKey = null;
	    this.decKey = null;
	    return this;
	  }
	}

	/*
	 * Helpers
	 */

	function getRounds(bits) {
	  switch (bits) {
	    case 128:
	      return 10;
	    case 192:
	      return 12;
	    case 256:
	      return 14;
	    default:
	      throw new Error('Bad key size.');
	  }
	}
	function readU32(data, off) {
	  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
	}
	function writeU32(dst, num, off) {
	  dst[off++] = num >>> 24;
	  dst[off++] = num >>> 16;
	  dst[off++] = num >>> 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	aes = AES;
	return aes;
}

var modes = {};

/*!
 * ghash.js - ghash for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */

var ghash;
var hasRequiredGhash;

function requireGhash () {
	if (hasRequiredGhash) return ghash;
	hasRequiredGhash = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const PADDING = Buffer.alloc(16, 0x00);
	const FINALIZED = -1;
	const REDUCTION = new Uint16Array([0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0, 0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0]);

	/**
	 * GHASH
	 */

	class GHASH {
	  constructor() {
	    this.state = new Uint32Array(4);
	    this.block = Buffer.alloc(16);
	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;
	    this.table = new Array(16);
	    for (let i = 0; i < 16; i++) this.table[i] = new Uint32Array(4);
	  }
	  init(key) {
	    assert(Buffer.isBuffer(key));
	    assert(key.length === 16);
	    for (let i = 0; i < 4; i++) this.state[i] = 0;
	    this.size = 0;
	    this.adLen = 0;
	    this.ctLen = 0;
	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++) this.table[i][j] = 0;
	    }
	    const x = new Uint32Array(4);
	    x[1] = readU32(key, 0);
	    x[0] = readU32(key, 4);
	    x[3] = readU32(key, 8);
	    x[2] = readU32(key, 12);
	    this.table[reverse(1)] = x;
	    for (let i = 2; i < 16; i += 2) {
	      this.table[reverse(i)] = this.double(this.table[reverse(i >>> 1)]);
	      this.table[reverse(i + 1)] = this.add(this.table[reverse(i)], x);
	    }
	    return this;
	  }
	  absorb(data) {
	    this._absorb(data, data.length);
	    return this;
	  }
	  _absorb(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');
	    let pos = this.size & 15;
	    let off = 0;
	    this.size += len;
	    if (pos > 0) {
	      let want = 16 - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < 16) return;
	      this.transform(this.block, 0);
	    }
	    while (len >= 16) {
	      this.transform(data, off);
	      off += 16;
	      len -= 16;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	  }
	  transform(block, off) {
	    this.state[1] ^= readU32(block, off + 0);
	    this.state[0] ^= readU32(block, off + 4);
	    this.state[3] ^= readU32(block, off + 8);
	    this.state[2] ^= readU32(block, off + 12);
	    this.mul(this.state);
	  }
	  pad() {
	    const pos = this.size & 15;
	    if (pos !== 0) this._absorb(PADDING, 16 - pos);
	  }
	  aad(data) {
	    assert(Buffer.isBuffer(data));
	    assert(this.ctLen === 0);
	    this.adLen += data.length;
	    return this.absorb(data);
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    if (data.length === 0) return this;
	    if (this.ctLen === 0) this.pad();
	    this.ctLen += data.length;
	    return this.absorb(data);
	  }
	  final() {
	    const out = Buffer.alloc(16);
	    this.pad();
	    const adLen = this.adLen * 8;
	    const ctLen = this.ctLen * 8;
	    this.state[1] ^= hi32(adLen);
	    this.state[0] ^= lo32(adLen);
	    this.state[3] ^= hi32(ctLen);
	    this.state[2] ^= lo32(ctLen);
	    this.mul(this.state);
	    writeU32(out, this.state[1], 0);
	    writeU32(out, this.state[0], 4);
	    writeU32(out, this.state[3], 8);
	    writeU32(out, this.state[2], 12);
	    for (let i = 0; i < 4; i++) this.state[i] = 0;
	    for (let i = 0; i < 16; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;
	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++) this.table[i][j] = 0;
	    }
	    return out;
	  }
	  destroy() {
	    for (let i = 0; i < 4; i++) this.state[i] = 0;
	    for (let i = 0; i < 16; i++) this.block[i] = 0;
	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;
	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++) this.table[i][j] = 0;
	    }
	  }
	  add(x, y) {
	    assert(x instanceof Uint32Array);
	    assert(x.length === 4);
	    assert(y instanceof Uint32Array);
	    assert(y.length === 4);
	    const z = new Uint32Array(4);
	    z[0] = x[0] ^ y[0];
	    z[1] = x[1] ^ y[1];
	    z[2] = x[2] ^ y[2];
	    z[3] = x[3] ^ y[3];
	    return z;
	  }
	  double(x) {
	    assert(x instanceof Uint32Array);
	    assert(x.length === 4);
	    const d = new Uint32Array(4);
	    const msb = (x[2] & 1) === 1;
	    let v;
	    d[3] = x[3];
	    d[2] = x[2];
	    v = d[3] & 1;
	    d[3] >>>= 1;
	    d[2] >>>= 1;
	    d[2] |= v << 31;
	    d[3] |= (x[0] & 1) << 31;
	    d[1] = x[1];
	    d[0] = x[0];
	    v = d[1] & 1;
	    d[1] >>>= 1;
	    d[0] >>>= 1;
	    d[0] |= v << 31;
	    if (msb) {
	      d[1] ^= 0xe1000000;
	      d[0] ^= 0x00000000;
	    }
	    return d;
	  }
	  mul(y) {
	    assert(y instanceof Uint32Array);
	    assert(y.length === 4);
	    const z = new Uint32Array(4);
	    const w = new Uint32Array(2);
	    let v, t;
	    for (let i = 0; i < 2; i++) {
	      w[0] = y[2];
	      w[1] = y[3];
	      if (i === 1) {
	        w[0] = y[0];
	        w[1] = y[1];
	      }
	      for (let j = 0; j < 64; j += 4) {
	        const msw = z[2] & 0x0f;
	        v = z[3] & 0x0f;
	        z[3] >>>= 4;
	        z[2] >>>= 4;
	        z[2] |= v << 28;
	        z[3] |= z[0] << 28;
	        v = z[1] & 0x0f;
	        z[1] >>>= 4;
	        z[0] >>>= 4;
	        z[0] |= v << 28;
	        z[1] ^= REDUCTION[msw] << 16;
	        t = this.table[w[0] & 0x0f];
	        z[0] ^= t[0];
	        z[1] ^= t[1];
	        z[2] ^= t[2];
	        z[3] ^= t[3];
	        v = w[1] & 0x0f;
	        w[1] >>>= 4;
	        w[0] >>>= 4;
	        w[0] |= v << 28;
	      }
	    }
	    y[0] = z[0];
	    y[1] = z[1];
	    y[2] = z[2];
	    y[3] = z[3];
	  }
	}

	/*
	 * Helpers
	 */

	function hi32(num) {
	  return num * (1 / 0x100000000) >>> 0;
	}
	function lo32(num) {
	  return num >>> 0;
	}
	function reverse(i) {
	  i = i << 2 & 0x0c | i >>> 2 & 0x03;
	  i = i << 1 & 0x0a | i >>> 1 & 0x05;
	  return i;
	}
	function readU32(data, off) {
	  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off++];
	}
	function writeU32(dst, num, off) {
	  dst[off++] = num >>> 24;
	  dst[off++] = num >>> 16;
	  dst[off++] = num >>> 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	ghash = GHASH;
	return ghash;
}

/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */

var hasRequiredModes;

function requireModes () {
	if (hasRequiredModes) return modes;
	hasRequiredModes = 1;

	const assert = requireAssert();
	const GHASH = requireGhash();

	/*
	 * Constants
	 */

	const EMPTY = Buffer.alloc(0);

	// Shifted by four.
	const polyTable = new Uint32Array([0x00001b,
	// 8
	0x000087,
	// 16
	0x000425,
	// 32
	0x000000, 0x000125,
	// 64
	0x000000, 0x000000, 0x000000, 0x080043 // 128
	]);

	/*
	 * Mode
	 */

	class Mode {
	  constructor(ctx) {
	    assert(ctx && typeof ctx.encrypt === 'function');
	    assert(typeof ctx.blockSize === 'number');
	    this.ctx = ctx;
	  }
	  get blockSize() {
	    return this.ctx.blockSize;
	  }
	  init(key, iv) {
	    throw new Error('Not implemented.');
	  }
	  update(data) {
	    throw new Error('Not implemented.');
	  }
	  crypt(output, input) {
	    throw new Error('Not implemented.');
	  }
	  final() {
	    throw new Error('Not implemented.');
	  }
	  destroy() {
	    throw new Error('Not implemented.');
	  }
	  setAutoPadding(padding) {
	    assert(typeof padding === 'boolean');
	    this._setAutoPadding(padding);
	    return this;
	  }
	  setAAD(data) {
	    assert(Buffer.isBuffer(data));
	    this._setAAD(data);
	    return this;
	  }
	  setCCM(msgLen, tagLen, aad) {
	    assert(msgLen >>> 0 === msgLen);
	    assert(tagLen >>> 0 === tagLen);
	    assert(aad == null || Buffer.isBuffer(aad));
	    this._setCCM(msgLen, tagLen, aad);
	    return this;
	  }
	  getAuthTag() {
	    return this._getAuthTag();
	  }
	  setAuthTag(tag) {
	    assert(Buffer.isBuffer(tag));
	    this._setAuthTag(tag);
	    return this;
	  }
	  _setAutoPadding(padding) {
	    throw new Error('Not available.');
	  }
	  _setAAD(data) {
	    throw new Error('Cipher is not authenticated.');
	  }
	  _setCCM(msgLen, tagLen, aad) {
	    throw new Error('Not available.');
	  }
	  _getAuthTag() {
	    throw new Error('Cipher is not authenticated.');
	  }
	  _setAuthTag(tag) {
	    throw new Error('Cipher is not authenticated.');
	  }
	}

	/**
	 * Block Mode
	 */

	class Block extends Mode {
	  constructor(ctx, unpad) {
	    super(ctx);
	    this.padding = true;
	    this.unpad = unpad;
	    this.block = Buffer.alloc(this.blockSize);
	    this.blockPos = -1;
	    this.last = null;
	    this.lastSize = 0;
	    if (unpad) this.last = Buffer.alloc(this.blockSize);
	  }
	  init(key, iv) {
	    if (iv == null) iv = EMPTY;
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));
	    this.ctx.init(key);
	    this.blockPos = 0;
	    this.lastSize = 0;
	    this._init(key, iv);
	    return this;
	  }
	  _updateSize(ilen) {
	    if (this.blockPos + ilen < this.blockSize) return 0;
	    let olen = 0;
	    if (this.unpad) olen += this.lastSize;
	    if (this.blockPos > 0) {
	      ilen -= this.blockSize - this.blockPos;
	      olen += this.blockSize;
	    }
	    if (ilen >= this.blockSize) olen += ilen - ilen % this.blockSize;
	    assert(olen >= this.blockSize);
	    return olen;
	  }
	  update(input) {
	    assert(Buffer.isBuffer(input));
	    if (this.blockPos === -1) throw new Error('Cipher is not initialized.');
	    const olen = this._updateSize(input.length);
	    const output = Buffer.alloc(olen);
	    if (this.blockPos + input.length < this.blockSize) {
	      this.blockPos += input.copy(this.block, this.blockPos, 0, input.length);
	      return output;
	    }
	    let ilen = input.length;
	    let ipos = 0;
	    let opos = 0;
	    if (this.unpad) opos += this.last.copy(output, opos, 0, this.lastSize);
	    if (this.blockPos > 0) {
	      const want = this.blockSize - this.blockPos;
	      ipos += input.copy(this.block, this.blockPos, ipos, ipos + want);
	      ilen -= want;
	      this._update(output, opos, this.block, 0);
	      opos += this.blockSize;
	      this.blockPos = 0;
	    }
	    while (ilen >= this.blockSize) {
	      this._update(output, opos, input, ipos);
	      ipos += this.blockSize;
	      ilen -= this.blockSize;
	      opos += this.blockSize;
	    }
	    if (ilen > 0) this.blockPos = input.copy(this.block, 0, ipos, ipos + ilen);
	    assert(opos === olen);
	    if (this.unpad) {
	      this.lastSize = output.copy(this.last, 0, olen - this.blockSize, olen);
	      return output.slice(0, olen - this.blockSize);
	    }
	    return output;
	  }
	  crypt(output, input) {
	    assert(Buffer.isBuffer(output));
	    assert(Buffer.isBuffer(input));
	    assert(output.length === input.length);
	    if (this.blockPos === -1) throw new Error('Cipher is not initialized.');
	    if (this.unpad || this.blockPos !== 0) throw new Error('Cannot crypt while buffering.');
	    if (input.length % this.blockSize !== 0) throw new Error('Input must be a multiple of the block size.');
	    const size = this.blockSize;
	    let len = input.length;
	    let pos = 0;
	    while (len > 0) {
	      this._update(output, pos, input, pos);
	      pos += size;
	      len -= size;
	    }
	    return output;
	  }
	  final() {
	    if (this.blockPos === -1) throw new Error('Cipher is not initialized.');
	    try {
	      return this._final();
	    } finally {
	      this.destroy();
	    }
	  }
	  destroy() {
	    this.ctx.destroy();
	    this.blockPos = -1;
	    this.lastSize = 0;
	    for (let i = 0; i < this.blockSize; i++) this.block[i] = 0;
	    if (this.unpad) {
	      for (let i = 0; i < this.blockSize; i++) this.last[i] = 0;
	    }
	    this._destroy();
	    return this;
	  }
	  _init(key, iv) {
	    throw new Error('Not implemented.');
	  }
	  _update(output, opos, input, ipos) {
	    throw new Error('Not implemented.');
	  }
	  _final() {
	    throw new Error('Not implemented.');
	  }
	  _destroy() {
	    throw new Error('Not implemented.');
	  }
	}

	/*
	 * Stream Mode
	 */

	class Stream extends Mode {
	  constructor(ctx) {
	    super(ctx);
	    this.pos = -1;
	  }
	  init(key, iv) {
	    if (iv == null) iv = EMPTY;
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));
	    this.ctx.init(key);
	    this.pos = 0;
	    this._init(key, iv);
	    return this;
	  }
	  update(input) {
	    assert(Buffer.isBuffer(input));
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    const output = Buffer.alloc(input.length);
	    this._crypt(output, input);
	    return output;
	  }
	  crypt(output, input) {
	    assert(Buffer.isBuffer(output));
	    assert(Buffer.isBuffer(input));
	    assert(output.length === input.length);
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    this._crypt(output, input);
	    return output;
	  }
	  final() {
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    try {
	      return this._final();
	    } finally {
	      this.destroy();
	    }
	  }
	  destroy() {
	    this.ctx.destroy();
	    this.pos = -1;
	    this._destroy();
	    return this;
	  }
	  _init(key, iv) {
	    throw new Error('Not implemented.');
	  }
	  _crypt(output, input) {
	    throw new Error('Not implemented.');
	  }
	  _final() {
	    throw new Error('Not implemented.');
	  }
	  _destroy() {
	    throw new Error('Not implemented.');
	  }
	}

	/**
	 * Raw Cipher
	 */

	class RawCipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	  _init(key, iv) {
	    assert(iv.length === 0);
	  }
	  _update(output, opos, input, ipos) {
	    this.ctx.encrypt(output, opos, input, ipos);
	  }
	  _final() {
	    if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    return;
	  }
	}

	/**
	 * Raw Decipher
	 */

	class RawDecipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	  _init(key, iv) {
	    assert(iv.length === 0);
	  }
	  _update(output, opos, input, ipos) {
	    this.ctx.decrypt(output, opos, input, ipos);
	  }
	  _final() {
	    if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    return;
	  }
	}

	/**
	 * PKCS#7 Cipher
	 */

	class PKCS7Cipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
	      return Buffer.alloc(0);
	    }
	    const left = this.blockSize - this.blockPos;
	    const block = Buffer.from(this.block);
	    for (let i = this.blockPos; i < this.blockSize; i++) block[i] = left;
	    this._update(block, 0, block, 0);
	    return block;
	  }
	  _setAutoPadding(padding) {
	    this.padding = padding;
	  }
	}

	/**
	 * PKCS#7 Decipher
	 */

	class PKCS7Decipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	  _final() {
	    if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
	    if (!this.padding) return Buffer.alloc(0);
	    if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
	    assert(this.lastSize === this.last.length);
	    assert(this.lastSize === this.blockSize);
	    const block = Buffer.from(this.last);
	    let left = block[block.length - 1];
	    let res = 1;

	    // left != 0
	    res &= left - 1 >>> 31 ^ 1;

	    // left <= block_size
	    res &= left - this.blockSize - 1 >>> 31;

	    // left = 0 if left == 0 or left > block_size
	    left &= -res;

	    // Verify padding in constant time.
	    const end = this.blockSize - left;
	    for (let i = 0; i < this.blockSize; i++) {
	      const ch = block[i];

	      // i < end or ch == left
	      res &= i - end >>> 31 | (ch ^ left) - 1 >>> 31;
	    }
	    if (!res) throw new Error('Bad decrypt (padding).');
	    return block.slice(0, end);
	  }
	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * ECB Cipher
	 */

	class ECBCipher extends PKCS7Cipher {
	  constructor(ctx) {
	    super(ctx);
	  }
	  _init(key, iv) {
	    assert(iv.length === 0);
	  }
	  _update(output, opos, input, ipos) {
	    this.ctx.encrypt(output, opos, input, ipos);
	  }
	  _destroy() {
	    return;
	  }
	}

	/**
	 * ECB Decipher
	 */

	class ECBDecipher extends PKCS7Decipher {
	  constructor(ctx) {
	    super(ctx);
	  }
	  _init(key, iv) {
	    assert(iv.length === 0);
	  }
	  _update(output, opos, input, ipos) {
	    this.ctx.decrypt(output, opos, input, ipos);
	  }
	  _destroy() {
	    return;
	  }
	}

	/**
	 * CBC Cipher
	 */

	class CBCCipher extends PKCS7Cipher {
	  constructor(ctx) {
	    super(ctx);
	    this.prev = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }
	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++) this.prev[i] ^= input[ipos + i];
	    this.ctx.encrypt(output, opos, this.prev, 0);
	    output.copy(this.prev, 0, opos, opos + this.blockSize);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) this.prev[i] = 0;
	  }
	}

	/**
	 * CBC Decipher
	 */

	class CBCDecipher extends PKCS7Decipher {
	  constructor(ctx) {
	    super(ctx);
	    this.prev = Buffer.alloc(this.blockSize);
	    this.tmp = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }
	  _update(output, opos, input, ipos) {
	    if (overlap(output, opos, input, ipos)) {
	      this.prev.copy(this.tmp, 0);
	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	      this.ctx.decrypt(output, opos, input, ipos);
	      for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.tmp[i];
	    } else {
	      this.ctx.decrypt(output, opos, input, ipos);
	      for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.prev[i];
	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	    }
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.prev[i] = 0;
	      this.tmp[i] = 0;
	    }
	  }
	}

	/**
	 * CTS Cipher
	 */

	class CTSCipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);
	    this.prev = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }
	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++) this.prev[i] ^= input[ipos + i];
	    this.ctx.encrypt(output, opos, this.prev, 0);
	    output.copy(this.prev, 0, opos, opos + this.blockSize);
	  }
	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
	      return Buffer.alloc(0);
	    }
	    if (this.lastSize === 0) throw new Error('Bad encrypt (no data).');
	    for (let i = 0; i < this.blockPos; i++) this.prev[i] ^= this.block[i];
	    this.ctx.encrypt(this.prev, 0, this.prev, 0);
	    const last = this.last.slice(0, this.blockPos);
	    return Buffer.concat([this.prev, last]);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) this.prev[i] = 0;
	  }
	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * CTS Decipher
	 */

	class CTSDecipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);
	    this.prev = Buffer.alloc(this.blockSize);
	    this.tmp = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }
	  _update(output, opos, input, ipos) {
	    if (overlap(output, opos, input, ipos)) {
	      this.prev.copy(this.tmp, 0);
	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	      this.ctx.decrypt(output, opos, input, ipos);
	      for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.tmp[i];
	    } else {
	      this.ctx.decrypt(output, opos, input, ipos);
	      for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.prev[i];
	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	    }
	  }
	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
	      return Buffer.alloc(0);
	    }
	    if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
	    const tmp = Buffer.alloc(this.blockSize);
	    this.ctx.decrypt(this.prev, 0, this.prev, 0);

	    // Recreate the previous (x2) ciphertext (`this.tmp`),
	    // which is normally only available on overlap.
	    for (let i = 0; i < this.blockSize; i++) tmp[i] = this.last[i] ^ this.prev[i];
	    for (let i = 0; i < this.blockPos; i++) {
	      this.last[i] = this.block[i];
	      this.block[i] ^= this.prev[i];
	    }
	    for (let i = this.blockPos; i < this.blockSize; i++) this.last[i] = this.prev[i];
	    this.ctx.decrypt(this.last, 0, this.last, 0);
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= tmp[i];
	    const block = this.block.slice(0, this.blockPos);
	    return Buffer.concat([this.last, block]);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.prev[i] = 0;
	      this.tmp[i] = 0;
	    }
	  }
	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * XTS
	 */

	class XTS extends Block {
	  constructor(ctx, encrypt) {
	    super(ctx, true);
	    this.encrypt = encrypt;
	    this.poly = polyTable[this.blockSize >>> 4];
	    this.tweak = Buffer.alloc(this.blockSize);
	    this.prev = Buffer.alloc(this.blockSize);
	  }
	  init(key, iv) {
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));
	    assert(key.length > 0 && (key.length & 1) === 0);
	    assert(iv.length === this.blockSize);
	    const size = key.length >>> 1;
	    const k1 = key.slice(0, size);
	    const k2 = key.slice(size);
	    if (safeEqual(k1, k2, size)) throw new Error('XTS keys are equal.');
	    this.ctx.init(k2);
	    this.ctx.encrypt(this.tweak, 0, iv, 0);
	    this.ctx.init(k1);
	    this.blockPos = 0;
	    this.lastSize = 0;
	    return this;
	  }
	  _shift() {
	    let cy = 0;
	    if (!this.encrypt) this.tweak.copy(this.prev, 0);
	    for (let i = 0; i < this.blockSize; i++) {
	      const c = this.tweak[i] >> 7;
	      this.tweak[i] <<= 1;
	      this.tweak[i] |= cy;
	      cy = c;
	    }
	    cy = -cy & 0xff;
	    this.tweak[2] ^= this.poly >> 16 & cy;
	    this.tweak[1] ^= this.poly >> 8 & cy;
	    this.tweak[0] ^= this.poly >> 0 & cy;
	  }
	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++) output[opos + i] = input[ipos + i] ^ this.tweak[i];
	    if (this.encrypt) this.ctx.encrypt(output, opos, output, opos);else this.ctx.decrypt(output, opos, output, opos);
	    for (let i = 0; i < this.blockSize; i++) output[opos + i] ^= this.tweak[i];
	    this._shift();
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.tweak[i] = 0;
	      this.prev[i] = 0;
	    }
	  }
	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/*
	 * XTS Cipher
	 */

	class XTSCipher extends XTS {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
	      return Buffer.alloc(0);
	    }
	    if (this.lastSize === 0) throw new Error('Bad encrypt (no data).');
	    if (this.blockPos === 0) return Buffer.from(this.last);

	    // Use ciphertext stealing for partial blocks.
	    const out = Buffer.alloc(this.blockPos);
	    for (let i = 0; i < this.blockPos; i++) {
	      out[i] = this.last[i];
	      this.last[i] = this.block[i];
	    }
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.tweak[i];
	    this.ctx.encrypt(this.last, 0, this.last, 0);
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.tweak[i];
	    return Buffer.concat([this.last, out]);
	  }
	}

	/*
	 * XTS Decipher
	 */

	class XTSDecipher extends XTS {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
	      return Buffer.alloc(0);
	    }
	    if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
	    if (this.blockPos === 0) return Buffer.from(this.last);

	    // Undo Block mode object's behavior of
	    // running _update on the last full block.
	    // Could avoid this somehow in the future.
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.prev[i];
	    this.ctx.encrypt(this.last, 0, this.last, 0);
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.prev[i];

	    // Recreate the last partial plaintext
	    // block (out) and the last ciphertext
	    // block (last).
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.tweak[i];
	    this.ctx.decrypt(this.last, 0, this.last, 0);
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.tweak[i];
	    const out = Buffer.alloc(this.blockPos);
	    for (let i = 0; i < this.blockPos; i++) {
	      out[i] = this.last[i];
	      this.last[i] = this.block[i];
	    }

	    // Now decrypt the last ciphertext block.
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.prev[i];
	    this.ctx.decrypt(this.last, 0, this.last, 0);
	    for (let i = 0; i < this.blockSize; i++) this.last[i] ^= this.prev[i];
	    return Buffer.concat([this.last, out]);
	  }
	}

	/**
	 * CTR
	 */

	class CTR extends Stream {
	  constructor(ctx) {
	    super(ctx);
	    this.state = Buffer.alloc(this.blockSize);
	    this.ctr = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.ctr, 0);
	  }
	  _increment() {
	    for (let i = this.ctr.length - 1; i >= 0; i--) {
	      this.ctr[i] += 1;
	      if (this.ctr[i] !== 0x00) break;
	    }
	  }
	  _crypt(output, input) {
	    const mask = this.blockSize - 1;
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }
	  _final() {
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	    }
	  }
	}

	/**
	 * CTR Cipher
	 */

	class CTRCipher extends CTR {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * CTR Decipher
	 */

	class CTRDecipher extends CTR {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * CFB
	 */

	class CFB extends Stream {
	  constructor(ctx) {
	    super(ctx);
	    this.state = Buffer.alloc(this.blockSize);
	    this.prev = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }
	  _final() {
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.prev[i] = 0;
	    }
	  }
	}

	/**
	 * CFB Cipher
	 */

	class CFBCipher extends CFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	  _crypt(output, input) {
	    const mask = this.blockSize - 1;
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.prev, 0);
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos];
	      this.prev[this.pos] = output[i];
	      this.pos += 1;
	    }
	  }
	}

	/**
	 * CFB Decipher
	 */

	class CFBDecipher extends CFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	  _crypt(output, input) {
	    const mask = this.blockSize - 1;
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.prev, 0);
	        this.pos = 0;
	      }
	      this.prev[this.pos] = input[i];
	      output[i] = input[i] ^ this.state[this.pos];
	      this.pos += 1;
	    }
	  }
	}

	/**
	 * OFB
	 */

	class OFB extends Stream {
	  constructor(ctx) {
	    super(ctx);
	    this.state = Buffer.alloc(this.blockSize);
	  }
	  _init(key, iv) {
	    assert(Buffer.isBuffer(iv));
	    assert(iv.length === this.blockSize);
	    iv.copy(this.state, 0);
	  }
	  _crypt(output, input) {
	    const mask = this.blockSize - 1;
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.state, 0);
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }
	  _final() {
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) this.state[i] = 0;
	  }
	}

	/**
	 * OFB Cipher
	 */

	class OFBCipher extends OFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * OFB Decipher
	 */

	class OFBDecipher extends OFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * GCM
	 */

	class GCM extends Stream {
	  constructor(ctx, encrypt) {
	    assert(ctx.blockSize === 16);
	    super(ctx);
	    this.encrypt = encrypt;
	    this.hash = new GHASH();
	    this.ctr = Buffer.alloc(16);
	    this.state = Buffer.alloc(16);
	    this.key = Buffer.alloc(16);
	    this.mask = Buffer.alloc(16);
	    this.tag = null;
	    this.mac = null;
	  }
	  _init(key, iv) {
	    for (let i = 0; i < 16; i++) {
	      this.ctr[i] = 0;
	      this.key[i] = 0;
	      this.mask[i] = 0;
	    }
	    this._encipher(this.key, this.key);
	    this.hash.init(this.key);

	    // Full round of ghash with same key.
	    if (iv.length !== 12) {
	      this.hash.update(iv);
	      iv = this.hash.final();
	      this.hash.init(this.key);
	    }
	    iv.copy(this.ctr, 0);
	    if (iv.length === 12) {
	      this.ctr[12] = 0x00;
	      this.ctr[13] = 0x00;
	      this.ctr[14] = 0x00;
	      this.ctr[15] = 0x01;
	    }
	    this._encipher(this.mask, this.mask);
	    this.tag = null;
	    this.mac = null;
	    return this;
	  }
	  _increment() {
	    let cy = 1;
	    let i = 4;
	    while (i--) {
	      cy += this.ctr[12 + i];
	      this.ctr[12 + i] = cy;
	      cy >>= 8;
	    }
	  }
	  _encipher(output, input) {
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & 15) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }
	  _crypt(output, input) {
	    if (this.encrypt) {
	      this._encipher(output, input);
	      this.hash.update(output);
	    } else {
	      this.hash.update(input);
	      this._encipher(output, input);
	    }
	  }
	  _final() {
	    const mac = this.hash.final();
	    for (let i = 0; i < 16; i++) mac[i] ^= this.mask[i];
	    if (this.encrypt) {
	      this.mac = mac;
	      return Buffer.alloc(0);
	    }
	    if (!this.tag) throw new Error('No tag provided.');
	    if (!safeEqual(mac, this.tag, this.tag.length)) throw new Error('Invalid tag.');
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    this.hash.destroy();
	    for (let i = 0; i < 16; i++) {
	      this.ctr[i] = 0;
	      this.state[i] = 0;
	      this.key[i] = 0;
	      this.mask[i] = 0;
	    }
	    if (this.tag) {
	      for (let i = 0; i < this.tag.length; i++) this.tag[i] = 0;
	      this.tag = null;
	    }
	  }
	  _setAAD(data) {
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    this.hash.aad(data);
	    return this;
	  }
	  _getAuthTag() {
	    if (!this.encrypt) throw new Error('Must be a cipher context.');
	    if (!this.mac) throw new Error('Cipher is not finalized.');
	    return Buffer.from(this.mac);
	  }
	  _setAuthTag(tag) {
	    if (this.encrypt) throw new Error('Must be a decipher context.');
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    if (tag.length !== 4 && tag.length !== 8 && (tag.length < 12 || tag.length > 16)) {
	      throw new RangeError('Invalid tag size.');
	    }
	    this.tag = Buffer.from(tag);
	    return this;
	  }
	}

	/**
	 * GCM Cipher
	 */

	class GCMCipher extends GCM {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * GCM Decipher
	 */

	class GCMDecipher extends GCM {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/**
	 * CBC-MAC
	 */

	class CBCMAC {
	  constructor(ctx) {
	    this.ctx = ctx;
	    this.size = ctx.blockSize;
	    this.mac = Buffer.alloc(this.size);
	    this.pos = -1;
	  }
	  init() {
	    this.mac.fill(0);
	    this.pos = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    if (this.pos === -1) throw new Error('Context is not initialized.');
	    for (let i = 0; i < data.length; i++) {
	      this.mac[this.pos++] ^= data[i];
	      if (this.pos === this.size) {
	        this.ctx.encrypt(this.mac, 0, this.mac, 0);
	        this.pos = 0;
	      }
	    }
	  }
	  pad() {
	    if (this.pos > 0) {
	      this.ctx.encrypt(this.mac, 0, this.mac, 0);
	      this.pos = 0;
	    }
	  }
	  final() {
	    if (this.pos === -1) throw new Error('Context is not initialized.');
	    this.pad();
	    this.pos = -1;
	    return Buffer.from(this.mac);
	  }
	}

	/**
	 * CCM
	 * https://tools.ietf.org/html/rfc3610
	 */

	class CCM extends Stream {
	  constructor(ctx, encrypt) {
	    assert(ctx.blockSize === 16);
	    super(ctx);
	    this.encrypt = encrypt;
	    this.hash = new CBCMAC(ctx);
	    this.state = Buffer.alloc(16);
	    this.ctr = Buffer.alloc(16);
	    this.tagLen = 0;
	    this.iv = null;
	    this.mac = null;
	    this.tag = null;
	  }
	  _increment() {
	    for (let i = 15; i >= 1; i--) {
	      this.ctr[i] += 1;
	      if (this.ctr[i] !== 0x00) break;
	    }
	  }
	  _encipher(output, input) {
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & 15) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }
	  _init(key, iv) {
	    // sjcl compat: no upper limit on l(N).
	    if (iv.length < 7) throw new RangeError('Invalid nonce length.');
	    if (iv.length > 13) iv = iv.slice(0, 13);
	    this.iv = Buffer.from(iv);
	    this.pos = -1;
	    this.tagLen = 0;
	    this.mac = null;
	    this.tag = null;
	  }
	  _setCCM(msgLen, tagLen, aad) {
	    if (!this.iv) throw new Error('Cipher is not initialized.');

	    // Compute L, M, and N.
	    let lm = msgLen;
	    let L = Math.ceil((32 - Math.clz32(lm)) / 8);
	    if (L < 2) L = 2;
	    const M = tagLen;
	    const N = 15 - L;
	    const Adata = (aad && aad.length > 0) | 0;
	    const block = Buffer.alloc(16);
	    if (M < 4 || M > 16 || (M & 1) !== 0) throw new RangeError('Invalid tag length.');

	    // Compute flags.
	    block[0] = 64 * Adata + 8 * ((M - 2) / 2) + (L - 1);

	    // sjcl compat: clamp nonces to 15-L.
	    this.iv.copy(block, 1, 0, Math.min(N, this.iv.length));

	    // Serialize message length.
	    for (let i = 15; i >= 1 + N; i--) {
	      block[i] = lm & 0xff;
	      lm >>>= 8;
	    }
	    assert(lm === 0);
	    this.hash.init();
	    this.hash.update(block);
	    if (Adata) {
	      if (aad.length < 0xff00) {
	        const buf = Buffer.alloc(2);
	        buf[0] = aad.length >>> 8;
	        buf[1] = aad.length >>> 0;
	        this.hash.update(buf);
	      } else if (aad.length < 0xffffffff) {
	        const buf = Buffer.alloc(6);
	        buf[0] = 0xff;
	        buf[1] = 0xfe;
	        buf[2] = aad.length >>> 24;
	        buf[3] = aad.length >>> 16;
	        buf[4] = aad.length >>> 8;
	        buf[5] = aad.length >>> 0;
	        this.hash.update(buf);
	      } else {
	        throw new RangeError('Invalid AAD length.');
	      }
	      this.hash.update(aad);
	      this.hash.pad();
	    }
	    block[0] &= 7;
	    block[15] = 1;
	    for (let i = 14; i >= 1 + N; i--) block[i] = 0;
	    block.copy(this.ctr, 0);
	    this.pos = 0;
	    this.tagLen = M;
	    this.iv = null;
	  }
	  _crypt(output, input) {
	    if (this.encrypt) {
	      this.hash.update(input);
	      this._encipher(output, input);
	    } else {
	      this._encipher(output, input);
	      this.hash.update(output);
	    }
	  }
	  _final() {
	    const mac = this.hash.final();

	    // Recreate S_0.
	    let i = 16 - ((this.ctr[0] & 7) + 1);
	    while (i < 16) this.ctr[i++] = 0;
	    this.pos = 0;
	    this._encipher(mac, mac);
	    if (this.encrypt) {
	      this.mac = mac.slice(0, this.tagLen);
	      return Buffer.alloc(0);
	    }
	    if (!this.tag) throw new Error('No tag provided.');
	    if (!safeEqual(mac, this.tag, this.tagLen)) throw new Error('Invalid tag.');
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    for (let i = 0; i < 16; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	    }
	    this.tagLen = 0;
	    this.iv = null;
	    this.tag = null;
	  }
	  _getAuthTag() {
	    if (!this.encrypt) throw new Error('Must be a cipher context.');
	    if (!this.mac) throw new Error('Cipher is not finalized.');
	    return Buffer.from(this.mac);
	  }
	  _setAuthTag(tag) {
	    if (this.encrypt) throw new Error('Must be a decipher context.');
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    if (this.tagLen === 0 || tag.length !== this.tagLen) throw new RangeError('Invalid tag size.');
	    this.tag = Buffer.from(tag);
	    return this;
	  }
	}

	/**
	 * CCM Cipher
	 */

	class CCMCipher extends CCM {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * CCM Decipher
	 */

	class CCMDecipher extends CCM {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/**
	 * CMAC
	 * https://tools.ietf.org/html/rfc4493
	 */

	class CMAC {
	  constructor(ctx) {
	    this.ctx = ctx;
	    this.poly = polyTable[ctx.blockSize >>> 4];
	    this.size = ctx.blockSize;
	    this.mac = Buffer.alloc(this.size);
	    this.pos = -1;
	  }
	  init(flag) {
	    this.mac.fill(0);
	    this.pos = 0;
	    if (flag != null) {
	      this.mac[this.size - 1] ^= flag;
	      this.pos = this.size;
	    }
	    return this;
	  }
	  shift(dst, src) {
	    let cy = 0;
	    for (let i = this.size - 1; i >= 0; i--) {
	      const c = src[i] >> 7;
	      dst[i] = src[i] << 1 | cy;
	      cy = c;
	    }
	    cy = -cy & 0xff;
	    dst[this.size - 3] ^= this.poly >> 16 & cy;
	    dst[this.size - 2] ^= this.poly >> 8 & cy;
	    dst[this.size - 1] ^= this.poly >> 0 & cy;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    if (this.pos === -1) throw new Error('Context is not initialized.');
	    for (let i = 0; i < data.length; i++) {
	      if (this.pos === this.size) {
	        this.ctx.encrypt(this.mac, 0, this.mac, 0);
	        this.pos = 0;
	      }
	      this.mac[this.pos++] ^= data[i];
	    }
	  }
	  final() {
	    if (this.pos === -1) throw new Error('Context is not initialized.');
	    const k = Buffer.alloc(this.size);
	    this.ctx.encrypt(k, 0, k, 0);
	    this.shift(k, k);
	    if (this.pos < this.size) {
	      this.mac[this.pos] ^= 0x80;
	      this.shift(k, k);
	    }
	    for (let i = 0; i < this.size; i++) this.mac[i] ^= k[i];
	    this.ctx.encrypt(this.mac, 0, this.mac, 0);
	    this.pos = -1;
	    return Buffer.from(this.mac);
	  }
	}

	/**
	 * EAX
	 */

	class EAX extends Stream {
	  constructor(ctx, encrypt) {
	    super(ctx);
	    this.encrypt = encrypt;
	    this.hash1 = new CMAC(ctx);
	    this.hash2 = new CMAC(ctx);
	    this.state = Buffer.alloc(this.blockSize);
	    this.ctr = Buffer.alloc(this.blockSize);
	    this.mask = Buffer.alloc(this.blockSize);
	    this.mac = null;
	    this.tag = null;
	  }
	  _increment() {
	    let i = this.blockSize;
	    let cy = 1;
	    while (i--) {
	      cy += this.ctr[i];
	      this.ctr[i] = cy;
	      cy >>= 8;
	    }
	  }
	  _encipher(output, input) {
	    const mask = this.blockSize - 1;
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }
	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }
	  _init(key, iv) {
	    assert(iv.length > 0);
	    this.hash1.init(0);
	    this.hash1.update(iv);
	    this.mask = this.hash1.final();
	    this.mask.copy(this.ctr, 0);
	    this.hash1.init(1);
	    this.hash2.init(2);
	    this.mac = null;
	    this.tag = null;
	  }
	  _crypt(output, input) {
	    if (this.encrypt) {
	      this._encipher(output, input);
	      this.hash2.update(output);
	    } else {
	      this.hash2.update(input);
	      this._encipher(output, input);
	    }
	  }
	  _final() {
	    const mac = Buffer.alloc(this.blockSize);
	    const mac1 = this.hash1.final();
	    const mac2 = this.hash2.final();
	    for (let i = 0; i < this.blockSize; i++) mac[i] = mac1[i] ^ mac2[i] ^ this.mask[i];
	    if (this.encrypt) {
	      this.mac = mac;
	      return Buffer.alloc(0);
	    }
	    if (!this.tag) throw new Error('No tag provided.');
	    if (!safeEqual(mac, this.tag, this.tag.length)) throw new Error('Invalid tag.');
	    return Buffer.alloc(0);
	  }
	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	      this.mask[i] = 0;
	    }
	    this.tag = null;
	  }
	  _setAAD(data) {
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    this.hash1.update(data);
	    return this;
	  }
	  _getAuthTag() {
	    if (!this.encrypt) throw new Error('Must be a cipher context.');
	    if (!this.mac) throw new Error('Cipher is not finalized.');
	    return Buffer.from(this.mac);
	  }
	  _setAuthTag(tag) {
	    if (this.encrypt) throw new Error('Must be a decipher context.');
	    if (this.pos === -1) throw new Error('Cipher is not initialized.');
	    if (tag.length === 0 || tag.length > this.blockSize) throw new RangeError('Invalid tag size.');
	    this.tag = Buffer.from(tag);
	    return this;
	  }
	}

	/**
	 * EAX Cipher
	 */

	class EAXCipher extends EAX {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * EAX Decipher
	 */

	class EAXDecipher extends EAX {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/*
	 * Helpers
	 */

	function get(name, encrypt = true) {
	  assert(typeof name === 'string');
	  assert(typeof encrypt === 'boolean');
	  switch (name) {
	    case 'RAW':
	      return encrypt ? RawCipher : RawDecipher;
	    case 'ECB':
	      return encrypt ? ECBCipher : ECBDecipher;
	    case 'CBC':
	      return encrypt ? CBCCipher : CBCDecipher;
	    case 'CTS':
	      return encrypt ? CTSCipher : CTSDecipher;
	    case 'XTS':
	      return encrypt ? XTSCipher : XTSDecipher;
	    case 'CTR':
	      return encrypt ? CTRCipher : CTRDecipher;
	    case 'CFB':
	      return encrypt ? CFBCipher : CFBDecipher;
	    case 'OFB':
	      return encrypt ? OFBCipher : OFBDecipher;
	    case 'GCM':
	      return encrypt ? GCMCipher : GCMDecipher;
	    case 'CCM':
	      return encrypt ? CCMCipher : CCMDecipher;
	    case 'EAX':
	      return encrypt ? EAXCipher : EAXDecipher;
	    default:
	      throw new Error(`Unknown mode: ${name}.`);
	  }
	}
	function overlap(output, opos, input, ipos) {
	  return output.buffer === input.buffer && output.byteOffset === input.byteOffset && opos === ipos;
	}
	function safeEqual(x, y, len) {
	  let z = 0;
	  for (let i = 0; i < len; i++) z |= x[i] ^ y[i];
	  return z - 1 >>> 31;
	}

	/*
	 * Expose
	 */

	modes.Mode = Mode;
	modes.Block = Block;
	modes.Stream = Stream;
	modes.RawCipher = RawCipher;
	modes.RawDecipher = RawDecipher;
	modes.PKCS7Cipher = PKCS7Cipher;
	modes.PKCS7Decipher = PKCS7Decipher;
	modes.ECBCipher = ECBCipher;
	modes.ECBDecipher = ECBDecipher;
	modes.CBCCipher = CBCCipher;
	modes.CBCDecipher = CBCDecipher;
	modes.CTSCipher = CTSCipher;
	modes.CTSDecipher = CTSDecipher;
	modes.XTS = XTS;
	modes.XTSCipher = XTSCipher;
	modes.XTSDecipher = XTSDecipher;
	modes.CTR = CTR;
	modes.CTRCipher = CTRCipher;
	modes.CTRDecipher = CTRDecipher;
	modes.CFB = CFB;
	modes.CFBCipher = CFBCipher;
	modes.CFBDecipher = CFBDecipher;
	modes.OFB = OFB;
	modes.OFBCipher = OFBCipher;
	modes.OFBDecipher = OFBDecipher;
	modes.GCM = GCM;
	modes.GCMCipher = GCMCipher;
	modes.GCMDecipher = GCMDecipher;
	modes.CBCMAC = CBCMAC;
	modes.CCM = CCM;
	modes.CCMCipher = CCMCipher;
	modes.CCMDecipher = CCMDecipher;
	modes.CMAC = CMAC;
	modes.EAX = EAX;
	modes.EAXCipher = EAXCipher;
	modes.EAXDecipher = EAXDecipher;
	modes.get = get;
	return modes;
}

/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredAes;

function requireAes () {
	if (hasRequiredAes) return aes$1;
	hasRequiredAes = 1;

	const AES = requireAes$1();
	const {
	  CBCCipher,
	  CBCDecipher
	} = requireModes();

	/**
	 * Encrypt data with aes 256 cbc.
	 * @param {Buffer} data
	 * @param {Buffer} key
	 * @param {Buffer} iv
	 * @returns {Buffer}
	 */

	function encipher(data, key, iv) {
	  const ctx = new CBCCipher(new AES(256));
	  ctx.init(key, iv);
	  return Buffer.concat([ctx.update(data), ctx.final()]);
	}

	/**
	 * Decrypt data with aes 256 cbc.
	 * @param {Buffer} data
	 * @param {Buffer} key
	 * @param {Buffer} iv
	 * @returns {Buffer}
	 */

	function decipher(data, key, iv) {
	  const ctx = new CBCDecipher(new AES(256));
	  ctx.init(key, iv);
	  return Buffer.concat([ctx.update(data), ctx.final()]);
	}

	/*
	 * Expose
	 */

	aes$1.native = 0;
	aes$1.encipher = encipher;
	aes$1.decipher = decipher;
	return aes$1;
}

/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */

var keccak;
var hasRequiredKeccak;

function requireKeccak () {
	if (hasRequiredKeccak) return keccak;
	hasRequiredKeccak = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = 0x80000000;
	const ROUND_CONST = new Uint32Array([0x00000001, 0x00000000, 0x00008082, 0x00000000, 0x0000808a, 0x80000000, 0x80008000, 0x80000000, 0x0000808b, 0x00000000, 0x80000001, 0x00000000, 0x80008081, 0x80000000, 0x00008009, 0x80000000, 0x0000008a, 0x00000000, 0x00000088, 0x00000000, 0x80008009, 0x00000000, 0x8000000a, 0x00000000, 0x8000808b, 0x00000000, 0x0000008b, 0x80000000, 0x00008089, 0x80000000, 0x00008003, 0x80000000, 0x00008002, 0x80000000, 0x00000080, 0x80000000, 0x0000800a, 0x00000000, 0x8000000a, 0x80000000, 0x80008081, 0x80000000, 0x00008080, 0x80000000, 0x80000001, 0x00000000, 0x80008008, 0x80000000]);

	/**
	 * Keccak
	 */

	class Keccak {
	  constructor() {
	    this.state = new Uint32Array(50);
	    this.block = Buffer.alloc(200);
	    this.bs = 136;
	    this.pos = FINALIZED;
	  }
	  init(bits) {
	    if (bits == null) bits = 256;
	    assert(bits >>> 0 === bits);
	    assert(bits >= 128);
	    assert(bits <= 512);
	    const rate = 1600 - bits * 2;
	    assert(rate >= 0 && (rate & 63) === 0);
	    this.bs = rate >>> 3;
	    this.pos = 0;
	    return this;
	  }
	  update(data) {
	    assert(Buffer.isBuffer(data));
	    assert(!(this.pos & FINALIZED), 'Context is not initialized.');
	    let len = data.length;
	    let pos = this.pos;
	    let off = 0;
	    this.pos = (this.pos + len) % this.bs;
	    if (pos > 0) {
	      let want = this.bs - pos;
	      if (want > len) want = len;
	      data.copy(this.block, pos, off, off + want);
	      pos += want;
	      len -= want;
	      off += want;
	      if (pos < this.bs) return this;
	      this._transform(this.block, 0);
	    }
	    while (len >= this.bs) {
	      this._transform(data, off);
	      off += this.bs;
	      len -= this.bs;
	    }
	    if (len > 0) data.copy(this.block, 0, off, off + len);
	    return this;
	  }
	  final(pad, len) {
	    if (pad == null) pad = 0x01;
	    if (len == null || len === 0) len = 100 - (this.bs >>> 1);
	    assert((pad & 0xff) === pad);
	    assert(len >>> 0 === len);
	    assert(!(this.pos & FINALIZED), 'Context is not initialized.');
	    this.block.fill(0, this.pos, this.bs);
	    this.block[this.pos] |= pad;
	    this.block[this.bs - 1] |= 0x80;
	    this._transform(this.block, 0);
	    this.pos = FINALIZED;
	    assert(len <= this.bs);
	    const out = Buffer.alloc(len);
	    for (let i = 0; i < len; i++) out[i] = this.state[i >>> 2] >>> 8 * (i & 3);
	    for (let i = 0; i < 50; i++) this.state[i] = 0;
	    for (let i = 0; i < this.bs; i++) this.block[i] = 0;
	    return out;
	  }
	  _transform(block, off) {
	    const count = this.bs >>> 2;
	    const s = this.state;
	    for (let i = 0; i < count; i++) s[i] ^= readU32(block, off + i * 4);
	    for (let n = 0; n < 48; n += 2) {
	      const c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      const c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      const c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      const c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      const c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      const c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      const c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      const c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      const c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      const c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
	      const h0 = c8 ^ (c2 << 1 | c3 >>> 31);
	      const l0 = c9 ^ (c3 << 1 | c2 >>> 31);
	      const h1 = c0 ^ (c4 << 1 | c5 >>> 31);
	      const l1 = c1 ^ (c5 << 1 | c4 >>> 31);
	      const h2 = c2 ^ (c6 << 1 | c7 >>> 31);
	      const l2 = c3 ^ (c7 << 1 | c6 >>> 31);
	      const h3 = c4 ^ (c8 << 1 | c9 >>> 31);
	      const l3 = c5 ^ (c9 << 1 | c8 >>> 31);
	      const h4 = c6 ^ (c0 << 1 | c1 >>> 31);
	      const l4 = c7 ^ (c1 << 1 | c0 >>> 31);
	      s[0] ^= h0;
	      s[1] ^= l0;
	      s[10] ^= h0;
	      s[11] ^= l0;
	      s[20] ^= h0;
	      s[21] ^= l0;
	      s[30] ^= h0;
	      s[31] ^= l0;
	      s[40] ^= h0;
	      s[41] ^= l0;
	      s[2] ^= h1;
	      s[3] ^= l1;
	      s[12] ^= h1;
	      s[13] ^= l1;
	      s[22] ^= h1;
	      s[23] ^= l1;
	      s[32] ^= h1;
	      s[33] ^= l1;
	      s[42] ^= h1;
	      s[43] ^= l1;
	      s[4] ^= h2;
	      s[5] ^= l2;
	      s[14] ^= h2;
	      s[15] ^= l2;
	      s[24] ^= h2;
	      s[25] ^= l2;
	      s[34] ^= h2;
	      s[35] ^= l2;
	      s[44] ^= h2;
	      s[45] ^= l2;
	      s[6] ^= h3;
	      s[7] ^= l3;
	      s[16] ^= h3;
	      s[17] ^= l3;
	      s[26] ^= h3;
	      s[27] ^= l3;
	      s[36] ^= h3;
	      s[37] ^= l3;
	      s[46] ^= h3;
	      s[47] ^= l3;
	      s[8] ^= h4;
	      s[9] ^= l4;
	      s[18] ^= h4;
	      s[19] ^= l4;
	      s[28] ^= h4;
	      s[29] ^= l4;
	      s[38] ^= h4;
	      s[39] ^= l4;
	      s[48] ^= h4;
	      s[49] ^= l4;
	      const b0 = s[0];
	      const b1 = s[1];
	      const b32 = s[11] << 4 | s[10] >>> 28;
	      const b33 = s[10] << 4 | s[11] >>> 28;
	      const b14 = s[20] << 3 | s[21] >>> 29;
	      const b15 = s[21] << 3 | s[20] >>> 29;
	      const b46 = s[31] << 9 | s[30] >>> 23;
	      const b47 = s[30] << 9 | s[31] >>> 23;
	      const b28 = s[40] << 18 | s[41] >>> 14;
	      const b29 = s[41] << 18 | s[40] >>> 14;
	      const b20 = s[2] << 1 | s[3] >>> 31;
	      const b21 = s[3] << 1 | s[2] >>> 31;
	      const b2 = s[13] << 12 | s[12] >>> 20;
	      const b3 = s[12] << 12 | s[13] >>> 20;
	      const b34 = s[22] << 10 | s[23] >>> 22;
	      const b35 = s[23] << 10 | s[22] >>> 22;
	      const b16 = s[33] << 13 | s[32] >>> 19;
	      const b17 = s[32] << 13 | s[33] >>> 19;
	      const b48 = s[42] << 2 | s[43] >>> 30;
	      const b49 = s[43] << 2 | s[42] >>> 30;
	      const b40 = s[5] << 30 | s[4] >>> 2;
	      const b41 = s[4] << 30 | s[5] >>> 2;
	      const b22 = s[14] << 6 | s[15] >>> 26;
	      const b23 = s[15] << 6 | s[14] >>> 26;
	      const b4 = s[25] << 11 | s[24] >>> 21;
	      const b5 = s[24] << 11 | s[25] >>> 21;
	      const b36 = s[34] << 15 | s[35] >>> 17;
	      const b37 = s[35] << 15 | s[34] >>> 17;
	      const b18 = s[45] << 29 | s[44] >>> 3;
	      const b19 = s[44] << 29 | s[45] >>> 3;
	      const b10 = s[6] << 28 | s[7] >>> 4;
	      const b11 = s[7] << 28 | s[6] >>> 4;
	      const b42 = s[17] << 23 | s[16] >>> 9;
	      const b43 = s[16] << 23 | s[17] >>> 9;
	      const b24 = s[26] << 25 | s[27] >>> 7;
	      const b25 = s[27] << 25 | s[26] >>> 7;
	      const b6 = s[36] << 21 | s[37] >>> 11;
	      const b7 = s[37] << 21 | s[36] >>> 11;
	      const b38 = s[47] << 24 | s[46] >>> 8;
	      const b39 = s[46] << 24 | s[47] >>> 8;
	      const b30 = s[8] << 27 | s[9] >>> 5;
	      const b31 = s[9] << 27 | s[8] >>> 5;
	      const b12 = s[18] << 20 | s[19] >>> 12;
	      const b13 = s[19] << 20 | s[18] >>> 12;
	      const b44 = s[29] << 7 | s[28] >>> 25;
	      const b45 = s[28] << 7 | s[29] >>> 25;
	      const b26 = s[38] << 8 | s[39] >>> 24;
	      const b27 = s[39] << 8 | s[38] >>> 24;
	      const b8 = s[48] << 14 | s[49] >>> 18;
	      const b9 = s[49] << 14 | s[48] >>> 18;
	      s[0] = b0 ^ ~b2 & b4;
	      s[1] = b1 ^ ~b3 & b5;
	      s[10] = b10 ^ ~b12 & b14;
	      s[11] = b11 ^ ~b13 & b15;
	      s[20] = b20 ^ ~b22 & b24;
	      s[21] = b21 ^ ~b23 & b25;
	      s[30] = b30 ^ ~b32 & b34;
	      s[31] = b31 ^ ~b33 & b35;
	      s[40] = b40 ^ ~b42 & b44;
	      s[41] = b41 ^ ~b43 & b45;
	      s[2] = b2 ^ ~b4 & b6;
	      s[3] = b3 ^ ~b5 & b7;
	      s[12] = b12 ^ ~b14 & b16;
	      s[13] = b13 ^ ~b15 & b17;
	      s[22] = b22 ^ ~b24 & b26;
	      s[23] = b23 ^ ~b25 & b27;
	      s[32] = b32 ^ ~b34 & b36;
	      s[33] = b33 ^ ~b35 & b37;
	      s[42] = b42 ^ ~b44 & b46;
	      s[43] = b43 ^ ~b45 & b47;
	      s[4] = b4 ^ ~b6 & b8;
	      s[5] = b5 ^ ~b7 & b9;
	      s[14] = b14 ^ ~b16 & b18;
	      s[15] = b15 ^ ~b17 & b19;
	      s[24] = b24 ^ ~b26 & b28;
	      s[25] = b25 ^ ~b27 & b29;
	      s[34] = b34 ^ ~b36 & b38;
	      s[35] = b35 ^ ~b37 & b39;
	      s[44] = b44 ^ ~b46 & b48;
	      s[45] = b45 ^ ~b47 & b49;
	      s[6] = b6 ^ ~b8 & b0;
	      s[7] = b7 ^ ~b9 & b1;
	      s[16] = b16 ^ ~b18 & b10;
	      s[17] = b17 ^ ~b19 & b11;
	      s[26] = b26 ^ ~b28 & b20;
	      s[27] = b27 ^ ~b29 & b21;
	      s[36] = b36 ^ ~b38 & b30;
	      s[37] = b37 ^ ~b39 & b31;
	      s[46] = b46 ^ ~b48 & b40;
	      s[47] = b47 ^ ~b49 & b41;
	      s[8] = b8 ^ ~b0 & b2;
	      s[9] = b9 ^ ~b1 & b3;
	      s[18] = b18 ^ ~b10 & b12;
	      s[19] = b19 ^ ~b11 & b13;
	      s[28] = b28 ^ ~b20 & b22;
	      s[29] = b29 ^ ~b21 & b23;
	      s[38] = b38 ^ ~b30 & b32;
	      s[39] = b39 ^ ~b31 & b33;
	      s[48] = b48 ^ ~b40 & b42;
	      s[49] = b49 ^ ~b41 & b43;
	      s[0] ^= ROUND_CONST[n + 0];
	      s[1] ^= ROUND_CONST[n + 1];
	    }
	  }
	  static hash() {
	    return new Keccak();
	  }
	  static hmac(bits, pad, len) {
	    if (bits == null) bits = 256;
	    assert(bits >>> 0 === bits);
	    const rate = 1600 - bits * 2;
	    assert(rate >= 0 && (rate & 63) === 0);
	    return new HMAC(Keccak, rate >>> 3, [bits], [pad, len]);
	  }
	  static digest(data, bits, pad, len) {
	    return Keccak.ctx.init(bits).update(data).final(pad, len);
	  }
	  static root(left, right, bits, pad, len) {
	    if (bits == null) bits = 256;
	    if (len == null) len = 0;
	    if (len === 0) len = bits >>> 3;
	    assert(bits >>> 0 === bits);
	    assert((bits & 7) === 0);
	    assert(len >>> 0 === len);
	    assert(Buffer.isBuffer(left) && left.length === len);
	    assert(Buffer.isBuffer(right) && right.length === len);
	    return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);
	  }
	  static multi(x, y, z, bits, pad, len) {
	    const {
	      ctx
	    } = Keccak;
	    ctx.init(bits);
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final(pad, len);
	  }
	  static mac(data, key, bits, pad, len) {
	    return Keccak.hmac(bits, pad, len).init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Keccak.native = 0;
	Keccak.id = 'KECCAK256';
	Keccak.size = 32;
	Keccak.bits = 256;
	Keccak.blockSize = 136;
	Keccak.zero = Buffer.alloc(32, 0x00);
	Keccak.ctx = new Keccak();

	/*
	 * Helpers
	 */

	function readU32(data, off) {
	  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
	}

	/*
	 * Expose
	 */

	keccak = Keccak;
	return keccak;
}

var murmur3 = {};

/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */

var hasRequiredMurmur3;

function requireMurmur3 () {
	if (hasRequiredMurmur3) return murmur3;
	hasRequiredMurmur3 = 1;

	const assert = requireAssert();

	/**
	 * Murmur3 hash.
	 * @param {Buffer} data
	 * @param {Number} seed
	 * @returns {Number}
	 */

	function sum(data, seed) {
	  assert(Buffer.isBuffer(data));
	  assert(typeof seed === 'number');
	  const tail = data.length - (data.length & 3);
	  const c1 = 0xcc9e2d51;
	  const c2 = 0x1b873593;
	  let h1 = seed | 0;
	  for (let i = 0; i < tail; i += 4) {
	    let k1 = readU32(data, i);
	    k1 = mul32(k1, c1);
	    k1 = rotl32(k1, 15);
	    k1 = mul32(k1, c2);
	    h1 ^= k1;
	    h1 = rotl32(h1, 13);
	    h1 = mul32(h1, 5) + 0xe6546b64 | 0;
	  }
	  let k1 = 0;
	  switch (data.length & 3) {
	    case 3:
	      k1 ^= data[tail + 2] << 16;
	    case 2:
	      k1 ^= data[tail + 1] << 8;
	    case 1:
	      k1 ^= data[tail + 0];
	      k1 = mul32(k1, c1);
	      k1 = rotl32(k1, 15);
	      k1 = mul32(k1, c2);
	      h1 ^= k1;
	  }
	  h1 ^= data.length;
	  h1 ^= h1 >>> 16;
	  h1 = mul32(h1, 0x85ebca6b);
	  h1 ^= h1 >>> 13;
	  h1 = mul32(h1, 0xc2b2ae35);
	  h1 ^= h1 >>> 16;
	  return h1 >>> 0;
	}

	/**
	 * Murmur3 hash.
	 * @param {Buffer} data
	 * @param {Number} n
	 * @param {Number} tweak
	 * @returns {Number}
	 */

	function tweak(data, n, tweak) {
	  assert(typeof n === 'number');
	  assert(typeof tweak === 'number');
	  const seed = mul32(n, 0xfba4c795) + (tweak | 0);
	  return sum(data, seed);
	}

	/*
	 * Helpers
	 */

	function mul32(a, b) {
	  const alo = a & 0xffff;
	  const blo = b & 0xffff;
	  const ahi = a >>> 16;
	  const bhi = b >>> 16;
	  const lo = alo * blo;
	  const hi = ahi * blo + bhi * alo + (lo >>> 16);
	  return hi << 16 | lo & 0xffff;
	}
	function rotl32(w, b) {
	  return w << b | w >>> 32 - b;
	}
	function readU32(data, off) {
	  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
	}

	/**
	 * Expose
	 */

	murmur3.native = 0;
	murmur3.sum = sum;
	murmur3.tweak = tweak;
	return murmur3;
}

/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p224;
var hasRequiredP224;

function requireP224 () {
	if (hasRequiredP224) return p224;
	hasRequiredP224 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();

	/*
	 * Expose
	 */

	p224 = new ECDSA('P224', SHA256, SHA256);
	return p224;
}

/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p256;
var hasRequiredP256;

function requireP256 () {
	if (hasRequiredP256) return p256;
	hasRequiredP256 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();

	/*
	 * Expose
	 */

	p256 = new ECDSA('P256', SHA256, SHA256);
	return p256;
}

/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */

var sha384;
var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384;
	hasRequiredSha384 = 1;

	const assert = requireAssert();
	const SHA512 = requireSha512();
	const HMAC = requireHmac();

	/**
	 * SHA384
	 */

	class SHA384 extends SHA512 {
	  constructor() {
	    super();
	  }
	  init() {
	    this.state[0] = 0xcbbb9d5d;
	    this.state[1] = 0xc1059ed8;
	    this.state[2] = 0x629a292a;
	    this.state[3] = 0x367cd507;
	    this.state[4] = 0x9159015a;
	    this.state[5] = 0x3070dd17;
	    this.state[6] = 0x152fecd8;
	    this.state[7] = 0xf70e5939;
	    this.state[8] = 0x67332667;
	    this.state[9] = 0xffc00b31;
	    this.state[10] = 0x8eb44a87;
	    this.state[11] = 0x68581511;
	    this.state[12] = 0xdb0c2e0d;
	    this.state[13] = 0x64f98fa7;
	    this.state[14] = 0x47b5481d;
	    this.state[15] = 0xbefa4fa4;
	    this.size = 0;
	    return this;
	  }
	  final() {
	    return super.final().slice(0, 48);
	  }
	  static hash() {
	    return new SHA384();
	  }
	  static hmac() {
	    return new HMAC(SHA384, 128);
	  }
	  static digest(data) {
	    return SHA384.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 48);
	    assert(Buffer.isBuffer(right) && right.length === 48);
	    return SHA384.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = SHA384;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return SHA384.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA384.native = 0;
	SHA384.id = 'SHA384';
	SHA384.size = 48;
	SHA384.bits = 384;
	SHA384.blockSize = 128;
	SHA384.zero = Buffer.alloc(48, 0x00);
	SHA384.ctx = new SHA384();

	/*
	 * Expose
	 */

	sha384 = SHA384;
	return sha384;
}

/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p384;
var hasRequiredP384;

function requireP384 () {
	if (hasRequiredP384) return p384;
	hasRequiredP384 = 1;

	const ECDSA = requireEcdsa();
	const SHA384 = requireSha384();

	/*
	 * Expose
	 */

	p384 = new ECDSA('P384', SHA384, SHA384);
	return p384;
}

/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */

var shake;
var hasRequiredShake;

function requireShake () {
	if (hasRequiredShake) return shake;
	hasRequiredShake = 1;

	const Keccak = requireKeccak();

	/**
	 * SHAKE
	 */

	class SHAKE extends Keccak {
	  /**
	   * Create a SHAKE Context.
	   * @constructor
	   */

	  constructor() {
	    super();
	  }
	  final(len) {
	    return super.final(0x1f, len);
	  }
	  static hash() {
	    return new SHAKE();
	  }
	  static hmac(bits, len) {
	    return super.hmac(bits, 0x1f, len);
	  }
	  static digest(data, bits, len) {
	    return super.digest(data, bits, 0x1f, len);
	  }
	  static root(left, right, bits, len) {
	    return super.root(left, right, bits, 0x1f, len);
	  }
	  static multi(x, y, z, bits, len) {
	    return super.multi(x, y, z, bits, 0x1f, len);
	  }
	  static mac(data, key, bits, len) {
	    return super.mac(data, key, bits, 0x1f, len);
	  }
	}

	/*
	 * Static
	 */

	SHAKE.native = Keccak.native;
	SHAKE.id = 'SHAKE256';
	SHAKE.size = 32;
	SHAKE.bits = 256;
	SHAKE.blockSize = 136;
	SHAKE.zero = Buffer.alloc(32, 0x00);
	SHAKE.ctx = new SHAKE();

	/*
	 * Expose
	 */

	shake = SHAKE;
	return shake;
}

/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var shake256;
var hasRequiredShake256;

function requireShake256 () {
	if (hasRequiredShake256) return shake256;
	hasRequiredShake256 = 1;

	const SHAKE = requireShake();

	/**
	 * SHAKE256
	 */

	class SHAKE256 extends SHAKE {
	  constructor() {
	    super();
	  }
	  init() {
	    return super.init(256);
	  }
	  static hash() {
	    return new SHAKE256();
	  }
	  static hmac(len) {
	    return super.hmac(256, len);
	  }
	  static digest(data, len) {
	    return super.digest(data, 256, len);
	  }
	  static root(left, right, len) {
	    return super.root(left, right, 256, len);
	  }
	  static multi(x, y, z, len) {
	    return super.multi(x, y, z, 256, len);
	  }
	  static mac(data, key, len) {
	    return super.mac(data, key, 256, len);
	  }
	}

	/*
	 * Static
	 */

	SHAKE256.native = SHAKE.native;
	SHAKE256.id = 'SHAKE256';
	SHAKE256.size = 32;
	SHAKE256.bits = 256;
	SHAKE256.blockSize = 136;
	SHAKE256.zero = Buffer.alloc(32, 0x00);
	SHAKE256.ctx = new SHAKE256();

	/*
	 * Expose
	 */

	shake256 = SHAKE256;
	return shake256;
}

/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p521;
var hasRequiredP521;

function requireP521 () {
	if (hasRequiredP521) return p521;
	hasRequiredP521 = 1;

	const ECDSA = requireEcdsa();
	const SHA512 = requireSha512();
	const SHAKE256 = requireShake256();

	/*
	 * Expose
	 */

	p521 = new ECDSA('P521', SHA512, SHAKE256);
	return p521;
}

var rsa = {};

var primes = {};

/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */

var hasRequiredPrimes;

function requirePrimes () {
	if (hasRequiredPrimes) return primes;
	hasRequiredPrimes = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const random = requireRandom();

	/*
	 * Constants
	 */

	const smallPrimes = new Uint8Array([3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]);
	const smallPrimesProduct = new BN('16294579238595022365', 10);
	const primeBitMaskLo = 0 | 1 << 2 | 1 << 3 | 1 << 5 | 1 << 7 | 1 << 11 | 1 << 13 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31;
	const primeBitMaskHi = 0 | 1 << 37 - 32 | 1 << 41 - 32 | 1 << 43 - 32 | 1 << 47 - 32 | 1 << 53 - 32 | 1 << 59 - 32 | 1 << 61 - 32;
	const primesA = new BN(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);
	const primesB = new BN(29 * 31 * 41 * 43 * 47 * 53);

	/*
	 * Primality
	 */

	function randomPrime(bits, reps = 20, rng = random) {
	  assert(bits >>> 0 === bits);
	  assert(reps >>> 0 === reps);
	  assert(rng != null);
	  if (bits < 2) throw new Error('Prime must be at least 2 bits.');
	  for (;;) {
	    const p = BN.randomBits(rng, bits);
	    p.setn(bits - 1, 1);
	    p.setn(bits - 2, 1);
	    p.setn(0, 1);
	    const mod = p.mod(smallPrimesProduct);
	    next: for (let delta = 0; delta < 1 << 20; delta += 2) {
	      const m = mod.addn(delta);
	      for (let i = 0; i < smallPrimes.length; i++) {
	        const prime = smallPrimes[i];
	        if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0)) continue next;
	      }
	      p.iaddn(delta);
	      break;
	    }
	    if (p.bitLength() !== bits) continue;
	    if (!isProbablePrime(p, reps, rng)) continue;
	    return p;
	  }
	}
	function isProbablePrime(x, reps, rng = random) {
	  assert(x instanceof BN);
	  if (x.sign() <= 0) return false;
	  if (x.cmpn(64) < 0) {
	    const w = x.word(0);
	    if (w > 31) return (primeBitMaskHi & 1 << w - 32) !== 0;
	    return (primeBitMaskLo & 1 << w) !== 0;
	  }
	  if (x.isEven()) return false;
	  const ra = x.mod(primesA).toNumber();
	  const rb = x.mod(primesB).toNumber();
	  if (ra % 3 === 0 || ra % 5 === 0 || ra % 7 === 0 || ra % 11 === 0 || ra % 13 === 0 || ra % 17 === 0 || ra % 19 === 0 || ra % 23 === 0 || ra % 37 === 0 || rb % 29 === 0 || rb % 31 === 0 || rb % 41 === 0 || rb % 43 === 0 || rb % 47 === 0 || rb % 53 === 0) {
	    return false;
	  }
	  return x.isPrime(rng, reps);
	}
	function isSafePrime(x, reps, rng) {
	  // Safe Prime (2p + 1).
	  if (!isProbablePrime(x, reps, rng)) return false;

	  // Sophie Germain Prime (p).
	  const p = x.subn(1).iushrn(1);
	  if (!isProbablePrime(p, reps, rng)) return false;
	  return true;
	}

	/*
	 * Expose
	 */

	primes.randomPrime = randomPrime;
	primes.isProbablePrime = isProbablePrime;
	primes.isSafePrime = isSafePrime;
	return primes;
}

var base64 = {};

/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	const CHARSET_URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
	const TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];
	const TABLE_URL = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];

	/*
	 * Encoding
	 */

	function _encode(data, charset, pad) {
	  assert(Buffer.isBuffer(data));
	  let left = data.length;
	  let str = '';
	  let i = 0;
	  while (left >= 3) {
	    const c1 = data[i++];
	    const c2 = data[i++];
	    const c3 = data[i++];
	    str += charset[c1 >> 2];
	    str += charset[(c1 & 3) << 4 | c2 >> 4];
	    str += charset[(c2 & 0x0f) << 2 | c3 >> 6];
	    str += charset[c3 & 0x3f];
	    left -= 3;
	  }
	  switch (left) {
	    case 1:
	      {
	        const c1 = data[i++];
	        str += charset[c1 >> 2];
	        str += charset[(c1 & 3) << 4];
	        if (pad) str += '==';
	        break;
	      }
	    case 2:
	      {
	        const c1 = data[i++];
	        const c2 = data[i++];
	        str += charset[c1 >> 2];
	        str += charset[(c1 & 3) << 4 | c2 >> 4];
	        str += charset[(c2 & 0x0f) << 2];
	        if (pad) str += '=';
	        break;
	      }
	  }
	  return str;
	}

	/*
	 * Decoding
	 */

	function _decode(str, table, size) {
	  assert(typeof str === 'string');
	  const data = Buffer.alloc(size);
	  let left = str.length;
	  let i = 0;
	  let j = 0;
	  if (left > 0 && str[left - 1] === '=') left -= 1;
	  if (left > 0 && str[left - 1] === '=') left -= 1;
	  if ((left & 3) === 1)
	    // Fail early.
	    throw new Error('Invalid base64 string.');
	  while (left >= 4) {
	    const c1 = str.charCodeAt(i++);
	    const c2 = str.charCodeAt(i++);
	    const c3 = str.charCodeAt(i++);
	    const c4 = str.charCodeAt(i++);
	    if ((c1 | c2 | c3 | c4) & 0xff80) throw new Error('Invalid base64 string.');
	    const t1 = table[c1];
	    const t2 = table[c2];
	    const t3 = table[c3];
	    const t4 = table[c4];
	    if ((t1 | t2 | t3 | t4) < 0) throw new Error('Invalid base64 string.');
	    data[j++] = t1 << 2 | t2 >> 4;
	    data[j++] = t2 << 4 | t3 >> 2;
	    data[j++] = t3 << 6 | t4 >> 0;
	    left -= 4;
	  }
	  switch (left) {
	    case 1:
	      {
	        throw new Error('Invalid base64 string.');
	      }
	    case 2:
	      {
	        const c1 = str.charCodeAt(i++);
	        const c2 = str.charCodeAt(i++);
	        if ((c1 | c2) & 0xff80) throw new Error('Invalid base64 string.');
	        const t1 = table[c1];
	        const t2 = table[c2];
	        if ((t1 | t2) < 0) throw new Error('Invalid base64 string.');
	        data[j++] = t1 << 2 | t2 >> 4;
	        if (t2 & 15) throw new Error('Invalid base64 string.');
	        break;
	      }
	    case 3:
	      {
	        const c1 = str.charCodeAt(i++);
	        const c2 = str.charCodeAt(i++);
	        const c3 = str.charCodeAt(i++);
	        if ((c1 | c2 | c3) & 0xff80) throw new Error('Invalid base64 string.');
	        const t1 = table[c1];
	        const t2 = table[c2];
	        const t3 = table[c3];
	        if ((t1 | t2 | t3) < 0) throw new Error('Invalid base64 string.');
	        data[j++] = t1 << 2 | t2 >> 4;
	        data[j++] = t2 << 4 | t3 >> 2;
	        if (t3 & 3) throw new Error('Invalid base64 string.');
	        break;
	      }
	  }
	  assert(j === size);
	  return data;
	}

	/*
	 * Testing
	 */

	function _test(str, table) {
	  assert(typeof str === 'string');
	  let len = str.length;
	  if (len > 0 && str[len - 1] === '=') len -= 1;
	  if (len > 0 && str[len - 1] === '=') len -= 1;
	  if ((len & 3) === 1) return false;
	  for (let i = 0; i < len; i++) {
	    const ch = str.charCodeAt(i);
	    if (ch & 0xff80) return false;
	    if (table[ch] === -1) return false;
	  }
	  switch (len & 3) {
	    case 1:
	      return false;
	    case 2:
	      return (table[str.charCodeAt(len - 1)] & 15) === 0;
	    case 3:
	      return (table[str.charCodeAt(len - 1)] & 3) === 0;
	  }
	  return true;
	}

	/*
	 * Base64
	 */

	function encode(data) {
	  return _encode(data, CHARSET, true);
	}
	function decode(str) {
	  const size = decodeSize(str);
	  if (!checkPadding(str, size)) throw new Error('Invalid base64 padding.');
	  return _decode(str, TABLE, size);
	}
	function test(str) {
	  const size = decodeSize(str);
	  if (!checkPadding(str, size)) return false;
	  return _test(str, TABLE);
	}

	/*
	 * Base64-URL
	 */

	function encodeURL(data) {
	  return _encode(data, CHARSET_URL, false);
	}
	function decodeURL(str) {
	  const size = decodeSize(str);
	  if (!checkPadding(str, 0)) throw new Error('Invalid base64 padding.');
	  return _decode(str, TABLE_URL, size);
	}
	function testURL(str) {
	  if (!checkPadding(str, 0)) return false;
	  return _test(str, TABLE_URL);
	}

	/*
	 * Helpers
	 */

	function decodeSize(str) {
	  assert(typeof str === 'string');
	  let len = str.length;
	  if (len > 0 && str[len - 1] === '=') len -= 1;
	  if (len > 0 && str[len - 1] === '=') len -= 1;
	  let size = (len >>> 2) * 3;
	  const rem = len & 3;
	  if (rem) size += rem - 1;
	  return size;
	}
	function checkPadding(str, size) {
	  assert(typeof str === 'string');
	  switch (size % 3) {
	    case 0:
	      {
	        if (str.length === 0) return true;
	        if (str.length === 1) return str[0] !== '=';
	        return str[str.length - 2] !== '=' && str[str.length - 1] !== '=';
	      }
	    case 1:
	      {
	        return str.length >= 4 && str[str.length - 2] === '=' && str[str.length - 1] === '=';
	      }
	    case 2:
	      {
	        return str.length >= 4 && str[str.length - 2] !== '=' && str[str.length - 1] === '=';
	      }
	    default:
	      {
	        throw new Error('unreachable');
	      }
	  }
	}

	/*
	 * Expose
	 */

	base64.native = 0;
	base64.encode = encode;
	base64.decode = decode;
	base64.test = test;
	base64.encodeURL = encodeURL;
	base64.decodeURL = decodeURL;
	base64.testURL = testURL;
	return base64;
}

var safe = {};

/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */

var hasRequiredSafe;

function requireSafe () {
	if (hasRequiredSafe) return safe;
	hasRequiredSafe = 1;

	const assert = requireAssert();

	/*
	 * Safe
	 */

	function safeCompare(x, y) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));
	  if (safeEqualInt(x.length, 0)) return safeEqualInt(y.length, 0);

	  // Assumes `y` is the "constant size"
	  // parameter. Note that constant size
	  // doesn't necessarily mean secret.
	  // Assuming we have a constant-size
	  // secret key or passphrase. This
	  // function should be called as:
	  //
	  // if (!safeCompare(input, key))
	  //   throw new Error('Bad passphrase.');
	  let v = x.length ^ y.length;
	  for (let i = 0; i < y.length; i++) v |= x[i % x.length] ^ y[i];
	  return v - 1 >>> 31;
	}
	function safeEqual(x, y) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));

	  // Assumes the lengths of both
	  // `x` and `y` are not secret.
	  if (!safeEqualInt(x.length, y.length)) return 0;
	  let v = 0;
	  for (let i = 0; i < x.length; i++) v |= x[i] ^ y[i];
	  return v - 1 >>> 31;
	}
	function safeEqualByte(x, y) {
	  return safeEqualInt(x & 0xff, y & 0xff);
	}
	function safeEqualInt(x, y) {
	  return (x ^ y) - 1 >>> 31;
	}
	function safeSelect(x, y, v) {
	  return x & v - 1 | y & ~(v - 1);
	}
	function safeLT(x, y) {
	  return x - y >>> 31;
	}
	function safeLTE(x, y) {
	  return x - y - 1 >>> 31;
	}
	function safeGT(x, y) {
	  return y - x >>> 31;
	}
	function safeGTE(x, y) {
	  return y - x - 1 >>> 31;
	}
	function safeMin(x, y) {
	  return safeSelect(x, y, safeLT(y, x));
	}
	function safeMax(x, y) {
	  return safeSelect(x, y, safeGT(y, x));
	}
	function safeAbs(x) {
	  return (x | 0) * (x >> 31 | 1);
	}
	function safeBool(x) {
	  return (x >> 31 | -x >> 31) & 1;
	}
	function safeCopy(x, y, v) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));
	  assert(safeEqualInt(x.length, y.length));
	  const xmask = v - 1 & 0xff;
	  const ymask = ~(v - 1) & 0xff;
	  for (let i = 0; i < x.length; i++) x[i] = x[i] & xmask | y[i] & ymask;
	}

	/*
	 * Expose
	 */

	safe.safeCompare = safeCompare;
	safe.safeEqual = safeEqual;
	safe.safeEqualByte = safeEqualByte;
	safe.safeEqualInt = safeEqualInt;
	safe.safeSelect = safeSelect;
	safe.safeLT = safeLT;
	safe.safeLTE = safeLTE;
	safe.safeGT = safeGT;
	safe.safeGTE = safeGTE;
	safe.safeMin = safeMin;
	safe.safeMax = safeMax;
	safe.safeAbs = safeAbs;
	safe.safeBool = safeBool;
	safe.safeCopy = safeCopy;
	return safe;
}

/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */

var hasRequiredRsa;

function requireRsa () {
	if (hasRequiredRsa) return rsa;
	hasRequiredRsa = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const rng = requireRandom();
	const {
	  randomPrime
	} = requirePrimes();
	const base64 = requireBase64();
	const asn1 = requireAsn1();
	const safe = requireSafe();
	const {
	  safeEqual,
	  safeEqualByte,
	  safeSelect,
	  safeLTE
	} = safe;

	/*
	 * Constants
	 */

	const DEFAULT_BITS = 2048;
	const DEFAULT_EXP = 65537;
	const MIN_BITS = 512;
	const MAX_BITS = 16384;
	const MIN_EXP = 3;
	const MAX_EXP = 2 ** 33 - 1;
	const MAX_EXP_BITS = 33;
	const SALT_LENGTH_AUTO = 0;
	const SALT_LENGTH_HASH = -1;
	const PREFIX = Buffer.alloc(8, 0x00);
	const EMPTY = Buffer.alloc(0);

	/**
	 * PKCS1v1.5+ASN.1 DigestInfo prefixes.
	 * @see [RFC8017] Page 45, Section 9.2.
	 * @see [RFC8017] Page 63, Section B.1.
	 * @const {Object}
	 */

	const digestInfo = {
	  __proto__: null,
	  BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),
	  BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),
	  BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),
	  BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),
	  BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),
	  BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),
	  BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),
	  BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),
	  GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),
	  HASH160: Buffer.from([20]),
	  HASH256: Buffer.from([32]),
	  KECCAK224: Buffer.from([28]),
	  KECCAK256: Buffer.from([32]),
	  KECCAK384: Buffer.from([48]),
	  KECCAK512: Buffer.from([64]),
	  MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
	  MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),
	  MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
	  MD5SHA1: Buffer.from([36]),
	  RIPEMD160: Buffer.from('3021300906052b2403020105000414', 'hex'),
	  SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
	  SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
	  SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
	  SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
	  SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
	  SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
	  SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
	  SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
	  SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
	  SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),
	  SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),
	  WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')
	};

	/**
	 * RSAPublicKey
	 */

	class RSAPublicKey {
	  constructor() {
	    this.n = new BN(0);
	    this.e = new BN(0);
	  }
	  bits() {
	    return this.n.bitLength();
	  }
	  size() {
	    return this.n.byteLength();
	  }
	  isSane() {
	    return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= MAX_BITS && this.e.bitLength() <= MAX_EXP_BITS;
	  }
	  verify() {
	    // Sanity checks.
	    if (!this.isSane()) return false;

	    // n >= 2^511 and n mod 2 != 0
	    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd()) return false;

	    // e >= 3 and e mod 2 != 0
	    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false;
	    return true;
	  }
	  encrypt(msg) {
	    // [RFC8017] Page 13, Section 5.1.1.
	    //           Page 16, Section 5.2.2.
	    assert(Buffer.isBuffer(msg));
	    const {
	      n,
	      e
	    } = this;
	    const m = BN.decode(msg);
	    if (m.cmp(n) >= 0) throw new Error('Invalid RSA message size.');

	    // c = m^e mod n
	    const c = m.powm(e, n);
	    return c.encode('be', n.byteLength());
	  }
	  encode() {
	    const size = asn1.sizeInt(this.n) + asn1.sizeInt(this.e);
	    const out = Buffer.alloc(asn1.sizeSeq(size));
	    let pos = 0;
	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeInt(out, pos, this.n);
	    pos = asn1.writeInt(out, pos, this.e);
	    assert(pos === out.length);
	    return out;
	  }
	  decode(data) {
	    let pos = 0;
	    pos = asn1.readSeq(data, pos);
	    [this.n, pos] = asn1.readInt(data, pos);
	    [this.e, pos] = asn1.readInt(data, pos);
	    if (pos !== data.length) throw new Error('Trailing bytes.');
	    return this;
	  }
	  static decode(data) {
	    return new RSAPublicKey().decode(data);
	  }
	}

	/**
	 * RSAPrivateKey
	 */

	class RSAPrivateKey extends RSAPublicKey {
	  constructor() {
	    super();
	    this.d = new BN(0);
	    this.p = new BN(0);
	    this.q = new BN(0);
	    this.dp = new BN(0);
	    this.dq = new BN(0);
	    this.qi = new BN(0);
	  }
	  isSane() {
	    return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= MAX_BITS && this.e.bitLength() <= MAX_EXP_BITS && this.d.bitLength() <= MAX_BITS && this.p.bitLength() <= MAX_BITS && this.q.bitLength() <= MAX_BITS && this.dp.bitLength() <= MAX_BITS && this.dq.bitLength() <= MAX_BITS && this.qi.bitLength() <= MAX_BITS;
	  }
	  verify() {
	    // Sanity checks.
	    if (!this.isSane()) return false;

	    // n >= 2^511 and n mod 2 != 0
	    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd()) return false;

	    // e >= 3 and e mod 2 != 0
	    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false;

	    // p >= 3 and p mod 2 != 0
	    if (this.p.cmpn(3) < 0 || !this.p.isOdd()) return false;

	    // q >= 3 and q mod 2 != 0
	    if (this.q.cmpn(3) < 0 || !this.q.isOdd()) return false;

	    // phi = (p - 1) * (q - 1)
	    const pm1 = this.p.subn(1);
	    const qm1 = this.q.subn(1);
	    const phi = pm1.mul(qm1);

	    // d >= 2 and d < phi
	    if (this.d.cmpn(2) < 0 || this.d.cmp(phi) >= 0) return false;

	    // dp != 0 and dp < p - 1
	    if (this.dp.sign() === 0 || this.dp.cmp(pm1) >= 0) return false;

	    // dq != 0 and dq < q - 1
	    if (this.dq.sign() === 0 || this.dq.cmp(qm1) >= 0) return false;

	    // qi <= 2 and qi < p
	    if (this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0) return false;

	    // p != q
	    if (this.p.cmp(this.q) === 0) return false;

	    // n == p * q
	    if (this.p.mul(this.q).cmp(this.n) !== 0) return false;

	    // lam = lcm(p - 1, q - 1)
	    const lam = phi.div(pm1.gcd(qm1));

	    // e * d mod lam
	    if (this.e.mul(this.d).imod(lam).cmpn(1) !== 0) return false;

	    // dp == d mod (p - 1)
	    if (this.d.mod(pm1).cmp(this.dp) !== 0) return false;

	    // dq == d mod (q - 1)
	    if (this.d.mod(qm1).cmp(this.dq) !== 0) return false;

	    // q * qi mod p == 1
	    if (this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0) return false;
	    return true;
	  }
	  decrypt(msg) {
	    // [RFC8017] Page 13, Section 5.1.2.
	    //           Page 15, Section 5.2.1.
	    assert(Buffer.isBuffer(msg));
	    const {
	      n,
	      e,
	      p,
	      q,
	      dp,
	      dq,
	      qi
	    } = this;

	    // Decode message.
	    const c = BN.decode(msg);

	    // Validate params.
	    if (c.cmp(n) >= 0) throw new Error('Invalid RSA message size.');

	    // Generate blinding factor.
	    let b, bi;
	    for (;;) {
	      // s = random integer in [1,n-1]
	      const s = BN.random(rng, 1, n);

	      // bi = s^-1 mod n
	      try {
	        bi = s.invert(n);
	      } catch (e) {
	        continue;
	      }

	      // b = s^e mod n
	      b = s.powm(e, n);
	      break;
	    }

	    // Blind.
	    c.imul(b).imod(n);

	    // Leverage Chinese Remainder Theorem.
	    //
	    // Computation:
	    //
	    //   mp = c^(d mod p-1) mod p
	    //   mq = c^(d mod q-1) mod q
	    //   md = (mp - mq) / q mod p
	    //   m = (md * q + mq) mod n
	    const mp = c.powm(dp, p, true);
	    const mq = c.powm(dq, q, true);
	    const md = mp.sub(mq).mul(qi).imod(p);
	    const m = md.mul(q).iadd(mq).imod(n);
	    if (m.powm(e, n).cmp(c) !== 0) throw new Error('Invalid RSA private key.');

	    // Unblind.
	    m.imul(bi).imod(n);
	    return m.encode('be', n.byteLength());
	  }
	  generate(bits, exponent) {
	    // [RFC8017] Page 9, Section 3.2.
	    // [FIPS186] Page 51, Appendix B.3.1
	    //           Page 55, Appendix B.3.3
	    //
	    // There are two methods for choosing `d`.
	    // Implementations differ on whether they
	    // use Euler's totient or the Carmichael
	    // function.
	    //
	    // The best explanation of Euler's phi vs.
	    // Carmichael's lambda I've seen comes from
	    // the crypto stackexchange[1].
	    //
	    // Note that both functions are _equivalent_
	    // when used with RSA, however, Carmichael's
	    // may lend itself to some perf benefits.
	    //
	    // [1] https://crypto.stackexchange.com/a/29595
	    assert(bits >>> 0 === bits);
	    assert(Number.isSafeInteger(exponent) && exponent >= 0);
	    assert(bits >= 64);
	    assert(exponent >= 3 && (exponent & 1) !== 0);
	    const e = new BN(exponent);
	    for (;;) {
	      const p = randomPrime((bits >>> 1) + (bits & 1));
	      const q = randomPrime(bits >>> 1);
	      if (p.cmp(q) === 0) continue;
	      if (p.cmp(q) < 0) p.swap(q);
	      if (p.sub(q).bitLength() <= (bits >>> 1) - 99) continue;
	      const n = p.mul(q);
	      if (n.bitLength() !== bits) continue;

	      // Euler's totient: (p - 1) * (q - 1).
	      const pm1 = p.subn(1);
	      const qm1 = q.subn(1);
	      const phi = pm1.mul(qm1);
	      if (e.gcd(phi).cmpn(1) !== 0) continue;

	      // Carmichael's function: lcm(p - 1, q - 1).
	      const lam = phi.div(pm1.gcd(qm1));
	      const d = e.invert(lam);
	      if (d.bitLength() <= bits + 1 >>> 1) continue;
	      const dp = d.mod(pm1);
	      const dq = d.mod(qm1);
	      const qi = q.invert(p);
	      this.n = n;
	      this.e = e;
	      this.d = d;
	      this.p = p;
	      this.q = q;
	      this.dp = dp;
	      this.dq = dq;
	      this.qi = qi;
	      return this;
	    }
	  }
	  async _generateSubtle(bits, exponent) {
	    assert(bits >>> 0 === bits);
	    assert(Number.isSafeInteger(exponent) && exponent >= 0);
	    assert(bits >= 64);
	    assert(exponent >= 3 && (exponent & 1) !== 0);
	    const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	    if (!crypto) throw new Error('Crypto API not available.');
	    const {
	      subtle
	    } = crypto;
	    if (!subtle || !subtle.generateKey || !subtle.exportKey) throw new Error('Subtle API not available.');
	    const e = new BN(exponent);
	    const algo = {
	      name: 'RSASSA-PKCS1-v1_5',
	      modulusLength: bits,
	      publicExponent: e.toArrayLike(Uint8Array, 'be', 8),
	      hash: {
	        name: 'SHA-256'
	      }
	    };
	    const ck = await subtle.generateKey(algo, true, ['sign']);
	    const jwk = await subtle.exportKey('jwk', ck.privateKey);
	    const p = BN.decode(base64.decodeURL(jwk.p));
	    const q = BN.decode(base64.decodeURL(jwk.q));
	    return this.fromPQE(p, q, e);
	  }
	  async generateAsync(bits, exponent) {
	    try {
	      return await this._generateSubtle(bits, exponent);
	    } catch (e) {
	      return this.generate(bits, exponent);
	    }
	  }
	  fromPQE(p, q, e) {
	    assert(p instanceof BN);
	    assert(q instanceof BN);
	    assert(e instanceof BN);
	    if (p.cmp(q) < 0) [p, q] = [q, p];
	    if (p.cmp(q) === 0) throw new Error('Invalid RSA private key.');
	    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');
	    if (!p.isOdd() || !q.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');
	    const n = p.mul(q);
	    assert(n.isOdd());
	    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    const pm1 = p.subn(1);
	    const qm1 = q.subn(1);
	    const lam = pm1.lcm(qm1);
	    const d = e.invert(lam);
	    const dp = d.mod(pm1);
	    const dq = d.mod(qm1);
	    const qi = q.invert(p);
	    this.n = n;
	    this.e = e;
	    this.d = d;
	    this.p = p;
	    this.q = q;
	    this.dp = dp;
	    this.dq = dq;
	    this.qi = qi;
	    return this;
	  }
	  fromPQD(p, q, d) {
	    assert(p instanceof BN);
	    assert(q instanceof BN);
	    assert(d instanceof BN);
	    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (!p.isOdd() || !q.isOdd()) throw new Error('Invalid RSA private key.');
	    const pm1 = p.subn(1);
	    const qm1 = q.subn(1);
	    const phi = pm1.mul(qm1);
	    if (d.cmpn(2) < 0 || d.cmp(phi) >= 0) throw new Error('Invalid RSA private key.');
	    const lam = phi.div(pm1.gcd(qm1));
	    const e = d.invert(lam);
	    return this.fromPQE(p, q, e);
	  }
	  fromNED(n, e, d) {
	    // Factor an RSA modulus given (n, e, d).
	    //
	    // This is basically the same logic as the
	    // Miller-Rabin primality test[1][2].
	    //
	    // [1] https://crypto.stackexchange.com/questions/11509
	    // [2] https://crypto.stackexchange.com/questions/22374
	    assert(n instanceof BN);
	    assert(e instanceof BN);
	    assert(d instanceof BN);
	    if (n.sign() < 0) throw new Error('Invalid RSA private key.');
	    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');
	    if (d.cmpn(2) < 0 || d.bitLength() > MAX_BITS) throw new Error('Invalid RSA private key.');
	    if (!n.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');
	    const f = e.mul(d).isubn(1);
	    const nm1 = n.subn(1);
	    const s = f.zeroBits();
	    const g = f.ushrn(s);
	    for (let i = 0; i < 64; i++) {
	      const a = BN.random(rng, 2, nm1);
	      let b = a.powm(g, n);
	      if (b.cmpn(1) === 0 || b.cmp(nm1) === 0) continue;
	      for (let j = 1; j < s; j++) {
	        const c = b.sqr().imod(n);
	        if (c.cmpn(1) === 0) {
	          const p = n.gcd(b.subn(1));
	          const q = n.gcd(b.addn(1));
	          return this.fromPQE(p, q, e);
	        }
	        if (c.cmp(nm1) === 0) break;
	        b = c;
	      }
	    }
	    throw new Error('Invalid RSA private key.');
	  }
	  toPublic() {
	    const pub = new RSAPublicKey();
	    pub.n = this.n;
	    pub.e = this.e;
	    return pub;
	  }
	  encode() {
	    let size = 0;
	    size += asn1.sizeVersion(0);
	    size += asn1.sizeInt(this.n);
	    size += asn1.sizeInt(this.e);
	    size += asn1.sizeInt(this.d);
	    size += asn1.sizeInt(this.p);
	    size += asn1.sizeInt(this.q);
	    size += asn1.sizeInt(this.dp);
	    size += asn1.sizeInt(this.dq);
	    size += asn1.sizeInt(this.qi);
	    const out = Buffer.alloc(asn1.sizeSeq(size));
	    let pos = 0;
	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeVersion(out, pos, 0);
	    pos = asn1.writeInt(out, pos, this.n);
	    pos = asn1.writeInt(out, pos, this.e);
	    pos = asn1.writeInt(out, pos, this.d);
	    pos = asn1.writeInt(out, pos, this.p);
	    pos = asn1.writeInt(out, pos, this.q);
	    pos = asn1.writeInt(out, pos, this.dp);
	    pos = asn1.writeInt(out, pos, this.dq);
	    pos = asn1.writeInt(out, pos, this.qi);
	    assert(pos === out.length);
	    return out;
	  }
	  decode(data) {
	    let pos = 0;
	    pos = asn1.readSeq(data, pos);
	    pos = asn1.readVersion(data, pos, 0);
	    [this.n, pos] = asn1.readInt(data, pos);
	    [this.e, pos] = asn1.readInt(data, pos);
	    [this.d, pos] = asn1.readInt(data, pos);
	    [this.p, pos] = asn1.readInt(data, pos);
	    [this.q, pos] = asn1.readInt(data, pos);
	    [this.dp, pos] = asn1.readInt(data, pos);
	    [this.dq, pos] = asn1.readInt(data, pos);
	    [this.qi, pos] = asn1.readInt(data, pos);
	    if (pos !== data.length) throw new Error('Trailing bytes.');
	    return this;
	  }
	  static generate(bits, exponent) {
	    return new RSAPrivateKey().generate(bits, exponent);
	  }
	  static async generateAsync(bits, exponent) {
	    return new RSAPrivateKey().generateAsync(bits, exponent);
	  }
	  static fromPQE(p, q, e) {
	    return new RSAPrivateKey().fromPQE(p, q, e);
	  }
	  static fromPQD(p, q, d) {
	    return new RSAPrivateKey().fromPQD(p, q, d);
	  }
	  static fromNED(n, e, d) {
	    return new RSAPrivateKey().fromNED(n, e, d);
	  }
	  static decode(data) {
	    return new RSAPrivateKey().decode(data);
	  }
	}

	/**
	 * Generate a private key.
	 * @param {Number} [bits=2048]
	 * @param {Number} [exponent=65537]
	 * @returns {Buffer} Private key.
	 */

	function privateKeyGenerate(bits, exponent) {
	  if (bits == null) bits = DEFAULT_BITS;
	  if (exponent == null) exponent = DEFAULT_EXP;
	  assert(bits >>> 0 === bits);
	  assert(Number.isSafeInteger(exponent) && exponent >= 0);
	  if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);
	  if (exponent < MIN_EXP || exponent > MAX_EXP) throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);
	  if (exponent === 1 || (exponent & 1) === 0) throw new RangeError('"exponent" must be odd.');
	  const key = RSAPrivateKey.generate(bits, exponent);
	  return key.encode();
	}

	/**
	 * Generate a private key.
	 * @param {Number} [bits=2048]
	 * @param {Number} [exponent=65537]
	 * @returns {Buffer} Private key.
	 */

	async function privateKeyGenerateAsync(bits, exponent) {
	  if (bits == null) bits = DEFAULT_BITS;
	  if (exponent == null) exponent = DEFAULT_EXP;
	  assert(bits >>> 0 === bits);
	  assert(Number.isSafeInteger(exponent) && exponent >= 0);
	  if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);
	  if (exponent < MIN_EXP || exponent > MAX_EXP) throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);
	  if (exponent === 1 || (exponent & 1) === 0) throw new RangeError('"exponent" must be odd.');
	  const key = await RSAPrivateKey.generateAsync(bits, exponent);
	  return key.encode();
	}

	/**
	 * Get a private key's modulus size in bits.
	 * @param {Buffer} key
	 * @returns {Number}
	 */

	function privateKeyBits(key) {
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  return k.bits();
	}

	/**
	 * Verify a private key.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function privateKeyVerify(key) {
	  // [RFC8017] Page 9, Section 3.2.
	  assert(Buffer.isBuffer(key));
	  let k;
	  try {
	    k = RSAPrivateKey.decode(key);
	  } catch (e) {
	    return false;
	  }
	  return k.verify();
	}

	/**
	 * Import a private key from an object.
	 * @param {Object} json
	 * @returns {Buffer}
	 */

	function privateKeyImport(json) {
	  // [RFC8017] Page 55, Section A.1.2.
	  assert(json && typeof json === 'object');
	  let k = new RSAPrivateKey();
	  if (json.n != null) k.n = BN.decode(json.n);
	  if (json.e != null) k.e = BN.decode(json.e);
	  if (json.d != null) k.d = BN.decode(json.d);
	  if (json.p != null) k.p = BN.decode(json.p);
	  if (json.q != null) k.q = BN.decode(json.q);
	  if (json.dp != null) k.dp = BN.decode(json.dp);
	  if (json.dq != null) k.dq = BN.decode(json.dq);
	  if (json.qi != null) k.qi = BN.decode(json.qi);
	  if (!k.verify()) {
	    if (!k.p.isZero() && !k.q.isZero()) {
	      if (!k.e.isZero()) k = RSAPrivateKey.fromPQE(k.p, k.q, k.e);else k = RSAPrivateKey.fromPQD(k.p, k.q, k.d);
	    } else {
	      k = RSAPrivateKey.fromNED(k.n, k.e, k.d);
	    }
	  }
	  return k.encode();
	}

	/**
	 * Export a private key to an object.
	 * @param {Buffer} key
	 * @returns {Object}
	 */

	function privateKeyExport(key) {
	  // [RFC8017] Page 55, Section A.1.2.
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  return {
	    n: k.n.encode(),
	    e: k.e.encode(),
	    d: k.d.encode(),
	    p: k.p.encode(),
	    q: k.q.encode(),
	    dp: k.dp.encode(),
	    dq: k.dq.encode(),
	    qi: k.qi.encode()
	  };
	}

	/**
	 * Create a public key from a private key.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function publicKeyCreate(key) {
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  const p = k.toPublic();
	  return p.encode();
	}

	/**
	 * Get a public key's modulus size in bits.
	 * @param {Buffer} key
	 * @returns {Number}
	 */

	function publicKeyBits(key) {
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  return k.bits();
	}

	/**
	 * Verify a public key.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function publicKeyVerify(key) {
	  // [RFC8017] Page 8, Section 3.1.
	  assert(Buffer.isBuffer(key));
	  let k;
	  try {
	    k = RSAPublicKey.decode(key);
	  } catch (e) {
	    return false;
	  }
	  return k.verify();
	}

	/**
	 * Import a public key from an object.
	 * @param {Object} json
	 * @returns {Buffer}
	 */

	function publicKeyImport(json) {
	  // [RFC8017] Page 54, Section A.1.1.
	  assert(json && typeof json === 'object');
	  const k = new RSAPublicKey();
	  if (json.n != null) k.n = BN.decode(json.n);
	  if (json.e != null) k.e = BN.decode(json.e);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  return k.encode();
	}

	/**
	 * Export a public key to an object.
	 * @param {Buffer} key
	 * @returns {Object}
	 */

	function publicKeyExport(key) {
	  // [RFC8017] Page 54, Section A.1.1.
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  return {
	    n: k.n.encode(),
	    e: k.e.encode()
	  };
	}

	/**
	 * Sign a message (PKCS1v1.5).
	 * @param {Object|String|null} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key - Private key.
	 * @returns {Buffer} PKCS#1v1.5-formatted signature.
	 */

	function sign(hash, msg, key) {
	  // [RFC8017] Page 36, Section 8.2.1.
	  //           Page 45, Section 9.2.
	  if (hash && typeof hash.id === 'string') hash = hash.id;
	  assert(hash == null || typeof hash === 'string');
	  assert(Buffer.isBuffer(msg));
	  const [prefix, hlen] = getDigestInfo(hash, msg);
	  if (!prefix) throw new Error('Unknown RSA hash function.');
	  if (msg.length !== hlen) throw new Error('Invalid RSA message size.');
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  const tlen = prefix.length + hlen;
	  const klen = k.size();
	  if (klen < tlen + 11) throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x01 || PS || 0x00 || T
	  const em = Buffer.alloc(klen);
	  em[0] = 0x00;
	  em[1] = 0x01;
	  for (let i = 2; i < klen - tlen - 1; i++) em[i] = 0xff;
	  em[klen - tlen - 1] = 0x00;
	  prefix.copy(em, klen - tlen);
	  msg.copy(em, klen - hlen);
	  return k.decrypt(em);
	}

	/**
	 * Verify a signature (PKCS1v1.5).
	 * @param {Object|String|null} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PKCS#1v1.5-formatted.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function verify(hash, msg, sig, key) {
	  if (hash && typeof hash.id === 'string') hash = hash.id;
	  assert(hash == null || typeof hash === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));
	  try {
	    return _verify(hash, msg, sig, key);
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * Verify a signature (PKCS1v1.5).
	 * @private
	 * @param {String} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PKCS#1v1.5-formatted.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function _verify(hash, msg, sig, key) {
	  // [RFC8017] Page 37, Section 8.2.2.
	  //           Page 45, Section 9.2.
	  const [prefix, hlen] = getDigestInfo(hash, msg);
	  if (!prefix) return false;
	  if (msg.length !== hlen) return false;
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) return false;
	  const klen = k.size();
	  if (sig.length !== klen) return false;
	  const tlen = prefix.length + hlen;
	  if (klen < tlen + 11) return false;
	  const em = k.encrypt(sig);

	  // EM = 0x00 || 0x01 || PS || 0x00 || T
	  let ok = 1;
	  ok &= safeEqualByte(em[0], 0x00);
	  ok &= safeEqualByte(em[1], 0x01);
	  for (let i = 2; i < klen - tlen - 1; i++) ok &= safeEqualByte(em[i], 0xff);
	  ok &= safeEqualByte(em[klen - tlen - 1], 0x00);
	  ok &= safeEqual(em.slice(klen - tlen, klen - hlen), prefix);
	  ok &= safeEqual(em.slice(klen - hlen, klen), msg);
	  return ok === 1;
	}

	/**
	 * Encrypt a message with public key (PKCS1v1.5).
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function encrypt(msg, key) {
	  // [RFC8017] Page 28, Section 7.2.1.
	  assert(Buffer.isBuffer(msg));
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  const klen = k.size();
	  if (msg.length > klen - 11) throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x02 || PS || 0x00 || M
	  const em = Buffer.alloc(klen);
	  const mlen = msg.length;
	  const plen = klen - mlen - 3;
	  em[0] = 0x00;
	  em[1] = 0x02;
	  rng.randomFill(em, 2, plen);
	  for (let i = 2; i < 2 + plen; i++) {
	    while (em[i] === 0x00) rng.randomFill(em, i, 1);
	  }
	  em[klen - mlen - 1] = 0x00;
	  msg.copy(em, klen - mlen);
	  return k.encrypt(em);
	}

	/**
	 * Decrypt a message with private key (PKCS1v1.5).
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function decrypt(msg, key) {
	  // [RFC8017] Page 29, Section 7.2.2.
	  assert(Buffer.isBuffer(msg));
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  const klen = k.size();
	  if (klen < 11) throw new Error('Invalid RSA private key.');
	  if (msg.length !== klen) throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x02 || PS || 0x00 || M
	  const em = k.decrypt(msg);
	  const zero = safeEqualByte(em[0], 0x00);
	  const two = safeEqualByte(em[1], 0x02);
	  let index = 0;
	  let looking = 1;
	  for (let i = 2; i < em.length; i++) {
	    const equals0 = safeEqualByte(em[i], 0x00);
	    index = safeSelect(index, i, looking & equals0);
	    looking = safeSelect(looking, 0, equals0);
	  }
	  const validPS = safeLTE(2 + 8, index);
	  const valid = zero & two & (looking ^ 1) & validPS;
	  const offset = safeSelect(0, index + 1, valid);
	  if (valid === 0) throw new Error('Invalid RSA ciphertext.');
	  return em.slice(offset);
	}

	/**
	 * Sign a message (PSS).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key - Private key.
	 * @param {Number} [saltLen=SALT_LENGTH_HASH]
	 * @returns {Buffer} PSS-formatted signature.
	 */

	function signPSS(hash, msg, key, saltLen) {
	  // [RFC8017] Page 33, Section 8.1.1.
	  if (saltLen == null) saltLen = SALT_LENGTH_HASH;
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert((saltLen | 0) === saltLen);
	  if (msg.length !== hash.size) throw new Error('Invalid RSA message size.');
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  const bits = k.bits();
	  const klen = bits + 7 >>> 3;
	  const emlen = bits + 6 >>> 3;
	  if (saltLen === SALT_LENGTH_AUTO) saltLen = emlen - 2 - hash.size;else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;
	  if (saltLen < 0 || saltLen > klen) throw new Error('Invalid PSS salt length.');
	  const salt = rng.randomBytes(saltLen);
	  const em = pssEncode(hash, msg, bits - 1, salt);

	  // Note that `em` may be one byte less
	  // than the modulus size in the case
	  // of (bits - 1) mod 8 == 0.
	  return k.decrypt(em);
	}

	/**
	 * Verify a signature (PSS).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PSS-formatted.
	 * @param {Buffer} key
	 * @param {Number} [saltLen=SALT_LENGTH_HASH]
	 * @returns {Boolean}
	 */

	function verifyPSS(hash, msg, sig, key, saltLen) {
	  if (saltLen == null) saltLen = SALT_LENGTH_HASH;
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));
	  assert((saltLen | 0) === saltLen);
	  try {
	    return _verifyPSS(hash, msg, sig, key, saltLen);
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * Verify a signature (PSS).
	 * @private
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PSS-formatted.
	 * @param {Buffer} key
	 * @param {Number} saltLen
	 * @returns {Boolean}
	 */

	function _verifyPSS(hash, msg, sig, key, saltLen) {
	  // [RFC8017] Page 34, Section 8.1.2.
	  if (msg.length !== hash.size) return false;
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) return false;
	  const bits = k.bits();
	  const klen = bits + 7 >>> 3;
	  if (sig.length !== klen) return false;
	  if (saltLen === SALT_LENGTH_AUTO) saltLen = 0; // Handled in pssVerify.
	  else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;
	  if (saltLen < 0 || saltLen > klen) return false;
	  let em = k.encrypt(sig);

	  // Edge case: the encoding crossed a
	  // a byte boundary. Our encryption
	  // function pads to the modulus size
	  // by default, meaning there's one
	  // extra zero byte prepended.
	  if ((bits - 1 & 7) === 0) {
	    if (em[0] !== 0x00) return false;
	    em = em.slice(1);
	  }
	  return pssVerify(hash, msg, em, bits - 1, saltLen);
	}

	/**
	 * Encrypt a message with public key (OAEP).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @param {Buffer?} label
	 * @returns {Buffer}
	 */

	function encryptOAEP(hash, msg, key, label) {
	  // [RFC8017] Page 22, Section 7.1.1.
	  if (label == null) label = EMPTY;
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(label));
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  const klen = k.size();
	  const mlen = msg.length;
	  const hlen = hash.size;
	  if (mlen > klen - 2 * hlen - 2) throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
	  const em = Buffer.alloc(klen);
	  const lhash = hash.digest(label);
	  const seed = em.slice(1, 1 + hlen);
	  const db = em.slice(1 + hlen);
	  const dlen = db.length;
	  em[0] = 0x00;
	  rng.randomFill(seed, 0, seed.length);
	  lhash.copy(db, 0);
	  db.fill(0x00, hlen, dlen - mlen - 1);
	  db[dlen - mlen - 1] = 0x01;
	  msg.copy(db, dlen - mlen);
	  mgf1xor(hash, db, seed);
	  mgf1xor(hash, seed, db);
	  return k.encrypt(em);
	}

	/**
	 * Decrypt a message with private key (OAEP).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @param {Buffer?} label
	 * @returns {Buffer}
	 */

	function decryptOAEP(hash, msg, key, label) {
	  // [RFC8017] Page 25, Section 7.1.2.
	  if (label == null) label = EMPTY;
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(label));
	  const k = RSAPrivateKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA private key.');
	  const klen = k.size();
	  const mlen = msg.length;
	  const hlen = hash.size;
	  if (klen < hlen * 2 + 2) throw new Error('Invalid RSA private key size.');
	  if (mlen !== klen) throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
	  const em = k.decrypt(msg);
	  const expect = hash.digest(label);
	  const zero = safeEqualByte(em[0], 0x00);
	  const seed = em.slice(1, hlen + 1);
	  const db = em.slice(hlen + 1);
	  mgf1xor(hash, seed, db);
	  mgf1xor(hash, db, seed);
	  const lhash = db.slice(0, hlen);
	  const lvalid = safeEqual(lhash, expect);
	  const rest = db.slice(hlen);
	  let looking = 1;
	  let index = 0;
	  let invalid = 0;
	  for (let i = 0; i < rest.length; i++) {
	    const equals0 = safeEqualByte(rest[i], 0x00);
	    const equals1 = safeEqualByte(rest[i], 0x01);
	    index = safeSelect(index, i, looking & equals1);
	    looking = safeSelect(looking, 0, equals1);
	    invalid = safeSelect(invalid, 1, looking & (equals0 ^ 1));
	  }
	  const valid = zero & lvalid & (invalid ^ 1) & (looking ^ 1);
	  if (valid === 0) throw new Error('Invalid RSA ciphertext.');
	  return rest.slice(index + 1);
	}

	/**
	 * "Veil" an RSA ciphertext to hide the key size.
	 * @param {Buffer} msg
	 * @param {Number} bits
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function veil(msg, bits, key) {
	  assert(Buffer.isBuffer(msg));
	  assert(bits >>> 0 === bits);
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  if (msg.length !== k.size()) throw new Error('Invalid RSA ciphertext.');
	  if (bits < k.bits()) throw new Error('Cannot make ciphertext smaller.');
	  const bytes = bits + 7 >>> 3;
	  const c = BN.decode(msg);
	  if (c.cmp(k.n) >= 0) throw new Error('Invalid RSA ciphertext.');
	  const vmax = BN.shift(1, bits);
	  const rmax = vmax.sub(c).iadd(k.n).isubn(1).div(k.n);
	  assert(rmax.sign() > 0);
	  let v = vmax;
	  while (v.cmp(vmax) >= 0) {
	    const r = BN.random(rng, 0, rmax);
	    v = c.add(r.mul(k.n));
	  }
	  assert(v.mod(k.n).cmp(c) === 0);
	  assert(v.bitLength() <= bits);
	  return v.encode('be', bytes);
	}

	/**
	 * "Unveil" a veiled RSA ciphertext.
	 * @param {Buffer} msg
	 * @param {Number} bits
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function unveil(msg, bits, key) {
	  assert(Buffer.isBuffer(msg));
	  assert(bits >>> 0 === bits);
	  const k = RSAPublicKey.decode(key);
	  if (!k.verify()) throw new Error('Invalid RSA public key.');
	  const klen = k.size();
	  if (msg.length < klen) throw new Error('Invalid RSA ciphertext.');
	  const v = BN.decode(msg);
	  if (bits !== 0 && v.bitLength() > bits) throw new Error('Invalid RSA ciphertext.');
	  const c = v.imod(k.n);
	  return c.encode('be', klen);
	}

	/*
	 * Digest Info
	 */

	function getDigestInfo(name, msg) {
	  // [RFC8017] Page 63, Section B.1.
	  assert(name == null || typeof name === 'string');
	  assert(Buffer.isBuffer(msg));
	  if (name == null) return [EMPTY, msg.length];
	  const prefix = digestInfo[name];
	  if (prefix == null) return [null, 0];
	  if (prefix.length === 1) return [EMPTY, prefix[0]];
	  return [prefix, prefix[prefix.length - 1]];
	}

	/*
	 * MGF1
	 */

	function mgf1xor(hash, out, seed) {
	  // [RFC8017] Page 67, Section B.2.1.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(out));
	  assert(Buffer.isBuffer(seed));
	  const ctr = Buffer.alloc(4, 0x00);
	  let i = 0;
	  while (i < out.length) {
	    const digest = hash.multi(seed, ctr);
	    let j = 0;
	    while (i < out.length && j < digest.length) out[i++] ^= digest[j++];
	    for (j = 3; j >= 0; j--) {
	      ctr[j] += 1;
	      if (ctr[j] !== 0x00) break;
	    }
	  }
	}

	/*
	 * PSS
	 */

	function pssEncode(hash, msg, embits, salt) {
	  // [RFC8017] Page 42, Section 9.1.1.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(embits >>> 0 === embits);
	  assert(Buffer.isBuffer(salt));
	  const hlen = hash.size;
	  const slen = salt.length;
	  const emlen = embits + 7 >>> 3;
	  if (msg.length !== hlen) throw new Error('Invalid RSA message size.');
	  if (emlen < hlen + slen + 2) throw new Error('Message too long.');

	  // EM = (PS || 0x01 || salt) || H || 0xbc
	  const em = Buffer.alloc(emlen);
	  const db = em.slice(0, emlen - hlen - 1);
	  const h = em.slice(emlen - hlen - 1, emlen - 1);
	  const h0 = hash.multi(PREFIX, msg, salt);
	  const mask = 0xff >>> 8 * emlen - embits;
	  db.fill(0x00, 0, emlen - slen - hlen - 2);
	  db[emlen - slen - hlen - 2] = 0x01;
	  salt.copy(db, emlen - slen - hlen - 1);
	  h0.copy(h, 0);
	  em[emlen - 1] = 0xbc;
	  mgf1xor(hash, db, h);
	  db[0] &= mask;
	  return em;
	}
	function pssVerify(hash, msg, em, embits, slen) {
	  // [RFC8017] Page 44, Section 9.1.2.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(em));
	  assert(embits >>> 0 === embits);
	  assert(slen >>> 0 === slen);
	  const hlen = hash.size;
	  const emlen = embits + 7 >>> 3;
	  if (msg.length !== hlen) return false;
	  if (emlen < hlen + slen + 2) return false;
	  if (em[emlen - 1] !== 0xbc) return false;

	  // EM = (PS || 0x01 || salt) || H || 0xbc
	  const db = em.slice(0, emlen - hlen - 1);
	  const h = em.slice(emlen - hlen - 1, emlen - 1);
	  const mask = 0xff >>> 8 * emlen - embits;
	  if (em[0] & ~mask) return false;
	  mgf1xor(hash, db, h);
	  db[0] &= mask;
	  if (slen === 0) {
	    // Auto
	    slen = -1;
	    for (let i = 0; i < db.length; i++) {
	      if (db[i] === 0x00) continue;
	      if (db[i] === 0x01) {
	        slen = db.length - (i + 1);
	        break;
	      }
	      return false;
	    }
	    if (slen === -1) return false;
	  } else {
	    const len = db.length - slen - 1;
	    for (let i = 0; i < len; i++) {
	      if (db[i] !== 0x00) return false;
	    }
	    if (db[len] !== 0x01) return false;
	  }
	  const salt = db.slice(db.length - slen);
	  const h0 = hash.multi(PREFIX, msg, salt);
	  return h0.equals(h);
	}

	/*
	 * Expose
	 */

	rsa.native = 0;
	rsa.SALT_LENGTH_AUTO = SALT_LENGTH_AUTO;
	rsa.SALT_LENGTH_HASH = SALT_LENGTH_HASH;
	rsa.privateKeyGenerate = privateKeyGenerate;
	rsa.privateKeyGenerateAsync = privateKeyGenerateAsync;
	rsa.privateKeyBits = privateKeyBits;
	rsa.privateKeyVerify = privateKeyVerify;
	rsa.privateKeyImport = privateKeyImport;
	rsa.privateKeyExport = privateKeyExport;
	rsa.publicKeyCreate = publicKeyCreate;
	rsa.publicKeyBits = publicKeyBits;
	rsa.publicKeyVerify = publicKeyVerify;
	rsa.publicKeyImport = publicKeyImport;
	rsa.publicKeyExport = publicKeyExport;
	rsa.sign = sign;
	rsa.verify = verify;
	rsa.encrypt = encrypt;
	rsa.decrypt = decrypt;
	rsa.signPSS = signPSS;
	rsa.verifyPSS = verifyPSS;
	rsa.encryptOAEP = encryptOAEP;
	rsa.decryptOAEP = decryptOAEP;
	rsa.veil = veil;
	rsa.unveil = unveil;
	return rsa;
}

var scrypt = {};

/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */

var hasRequiredScrypt;

function requireScrypt () {
	if (hasRequiredScrypt) return scrypt;
	hasRequiredScrypt = 1;

	const assert = requireAssert();
	const pbkdf2 = requirePbkdf2();
	const SHA256 = requireSha256();

	/*
	 * Constants
	 */

	const SLAB1 = Buffer.alloc(64);
	const SLAB2 = new Uint32Array(16);
	const SLAB3 = new Uint32Array(16);

	/**
	 * Perform scrypt key derivation.
	 * @param {Buffer} passwd
	 * @param {Buffer} salt
	 * @param {Number} N
	 * @param {Number} r
	 * @param {Number} p
	 * @param {Number} len
	 * @returns {Buffer}
	 */

	function derive(passwd, salt, N, r, p, len) {
	  if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');
	  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
	  if (salt == null) salt = Buffer.alloc(0);
	  assert(Buffer.isBuffer(passwd));
	  assert(Buffer.isBuffer(salt));
	  assert(N >>> 0 === N);
	  assert(r >>> 0 === r);
	  assert(p >>> 0 === p);
	  assert(len >>> 0 === len);
	  if (r * p >= 1 << 30) throw new Error('EFBIG');
	  if ((N & N - 1) !== 0 || N === 0) throw new Error('EINVAL');
	  if (N > 0xffffffff) throw new Error('EINVAL');
	  const XY = Buffer.alloc(256 * r);
	  const V = Buffer.alloc(128 * r * N);
	  const B = pbkdf2.derive(SHA256, passwd, salt, 1, p * 128 * r);
	  for (let i = 0; i < p; i++) smix(B, i * 128 * r, r, N, V, XY);
	  clear();
	  return pbkdf2.derive(SHA256, passwd, B, 1, len);
	}

	/**
	 * Perform scrypt key derivation (async).
	 * @param {Buffer} passwd
	 * @param {Buffer} salt
	 * @param {Number} N
	 * @param {Number} r
	 * @param {Number} p
	 * @param {Number} len
	 * @returns {Promise}
	 */

	async function deriveAsync(passwd, salt, N, r, p, len) {
	  if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');
	  if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
	  if (salt == null) salt = Buffer.alloc(0);
	  assert(Buffer.isBuffer(passwd));
	  assert(Buffer.isBuffer(salt));
	  assert(N >>> 0 === N);
	  assert(r >>> 0 === r);
	  assert(p >>> 0 === p);
	  assert(len >>> 0 === len);
	  if (r * p >= 1 << 30) throw new Error('EFBIG');
	  if ((N & N - 1) !== 0 || N === 0) throw new Error('EINVAL');
	  if (N > 0xffffffff) throw new Error('EINVAL');
	  const XY = Buffer.alloc(256 * r);
	  const V = Buffer.alloc(128 * r * N);
	  const B = await pbkdf2.deriveAsync(SHA256, passwd, salt, 1, p * 128 * r);
	  for (let i = 0; i < p; i++) await smixAsync(B, i * 128 * r, r, N, V, XY);
	  clear();
	  return pbkdf2.deriveAsync(SHA256, passwd, B, 1, len);
	}

	/*
	 * Helpers
	 */

	function salsa20_8(B) {
	  const B32 = SLAB2;
	  const X = SLAB3;
	  for (let i = 0; i < 16; i++) B32[i] = readU32(B, i * 4);
	  for (let i = 0; i < 16; i++) X[i] = B32[i];
	  for (let i = 0; i < 8; i += 2) {
	    X[4] ^= R(X[0] + X[12], 7);
	    X[8] ^= R(X[4] + X[0], 9);
	    X[12] ^= R(X[8] + X[4], 13);
	    X[0] ^= R(X[12] + X[8], 18);
	    X[9] ^= R(X[5] + X[1], 7);
	    X[13] ^= R(X[9] + X[5], 9);
	    X[1] ^= R(X[13] + X[9], 13);
	    X[5] ^= R(X[1] + X[13], 18);
	    X[14] ^= R(X[10] + X[6], 7);
	    X[2] ^= R(X[14] + X[10], 9);
	    X[6] ^= R(X[2] + X[14], 13);
	    X[10] ^= R(X[6] + X[2], 18);
	    X[3] ^= R(X[15] + X[11], 7);
	    X[7] ^= R(X[3] + X[15], 9);
	    X[11] ^= R(X[7] + X[3], 13);
	    X[15] ^= R(X[11] + X[7], 18);
	    X[1] ^= R(X[0] + X[3], 7);
	    X[2] ^= R(X[1] + X[0], 9);
	    X[3] ^= R(X[2] + X[1], 13);
	    X[0] ^= R(X[3] + X[2], 18);
	    X[6] ^= R(X[5] + X[4], 7);
	    X[7] ^= R(X[6] + X[5], 9);
	    X[4] ^= R(X[7] + X[6], 13);
	    X[5] ^= R(X[4] + X[7], 18);
	    X[11] ^= R(X[10] + X[9], 7);
	    X[8] ^= R(X[11] + X[10], 9);
	    X[9] ^= R(X[8] + X[11], 13);
	    X[10] ^= R(X[9] + X[8], 18);
	    X[12] ^= R(X[15] + X[14], 7);
	    X[13] ^= R(X[12] + X[15], 9);
	    X[14] ^= R(X[13] + X[12], 13);
	    X[15] ^= R(X[14] + X[13], 18);
	  }
	  for (let i = 0; i < 16; i++) B32[i] += X[i];
	  for (let i = 0; i < 16; i++) writeU32(B, B32[i], 4 * i);
	}
	function R(a, b) {
	  return a << b | a >>> 32 - b;
	}
	function blockmix_salsa8(B, Y, Yo, r) {
	  const X = SLAB1;
	  blkcpy(X, B, 0, (2 * r - 1) * 64, 64);
	  for (let i = 0; i < 2 * r; i++) {
	    blkxor(X, B, 0, i * 64, 64);
	    salsa20_8(X);
	    blkcpy(Y, X, Yo + i * 64, 0, 64);
	  }
	  for (let i = 0; i < r; i++) blkcpy(B, Y, i * 64, Yo + i * 2 * 64, 64);
	  for (let i = 0; i < r; i++) blkcpy(B, Y, (i + r) * 64, Yo + (i * 2 + 1) * 64, 64);
	}
	function integerify(B, r) {
	  return readU32(B, (2 * r - 1) * 64);
	}
	function smix(B, Bo, r, N, V, XY) {
	  const X = XY;
	  const Y = XY;
	  blkcpy(X, B, 0, Bo, 128 * r);
	  for (let i = 0; i < N; i++) {
	    blkcpy(V, X, i * (128 * r), 0, 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	  }
	  for (let i = 0; i < N; i++) {
	    const j = integerify(X, r) & N - 1;
	    blkxor(X, V, 0, j * (128 * r), 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	  }
	  blkcpy(B, X, Bo, 0, 128 * r);
	}
	async function smixAsync(B, Bo, r, N, V, XY) {
	  const X = XY;
	  const Y = XY;
	  blkcpy(X, B, 0, Bo, 128 * r);
	  for (let i = 0; i < N; i++) {
	    blkcpy(V, X, i * (128 * r), 0, 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	    await wait();
	  }
	  for (let i = 0; i < N; i++) {
	    const j = integerify(X, r) & N - 1;
	    blkxor(X, V, 0, j * (128 * r), 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	    await wait();
	  }
	  blkcpy(B, X, Bo, 0, 128 * r);
	}
	function blkcpy(dst, src, dstOff, srcOff, len) {
	  src.copy(dst, dstOff, srcOff, srcOff + len);
	}
	function blkxor(dst, src, dstOff, srcOff, len) {
	  for (let i = 0; i < len; i++) dst[dstOff + i] ^= src[srcOff + i];
	}
	function wait() {
	  return new Promise(r => setImmediate(r));
	}
	function clear() {
	  for (let i = 0; i < 64; i++) SLAB1[i] = 0;
	  for (let i = 0; i < 16; i++) {
	    SLAB2[i] = 0;
	    SLAB3[i] = 0;
	  }
	}
	function readU32(data, off) {
	  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
	}
	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	scrypt.native = 0;
	scrypt.derive = derive;
	scrypt.deriveAsync = deriveAsync;
	return scrypt;
}

/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */

var sha224;
var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224;
	hasRequiredSha224 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const HMAC = requireHmac();

	/**
	 * SHA224
	 */

	class SHA224 extends SHA256 {
	  constructor() {
	    super();
	  }
	  init() {
	    this.state[0] = 0xc1059ed8;
	    this.state[1] = 0x367cd507;
	    this.state[2] = 0x3070dd17;
	    this.state[3] = 0xf70e5939;
	    this.state[4] = 0xffc00b31;
	    this.state[5] = 0x68581511;
	    this.state[6] = 0x64f98fa7;
	    this.state[7] = 0xbefa4fa4;
	    this.size = 0;
	    return this;
	  }
	  final() {
	    return super.final().slice(0, 28);
	  }
	  static hash() {
	    return new SHA224();
	  }
	  static hmac() {
	    return new HMAC(SHA224, 64);
	  }
	  static digest(data) {
	    return SHA224.ctx.init().update(data).final();
	  }
	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 28);
	    assert(Buffer.isBuffer(right) && right.length === 28);
	    return SHA224.ctx.init().update(left).update(right).final();
	  }
	  static multi(x, y, z) {
	    const {
	      ctx
	    } = SHA224;
	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);
	    if (z) ctx.update(z);
	    return ctx.final();
	  }
	  static mac(data, key) {
	    return SHA224.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA224.native = 0;
	SHA224.id = 'SHA224';
	SHA224.size = 28;
	SHA224.bits = 224;
	SHA224.blockSize = 64;
	SHA224.zero = Buffer.alloc(28, 0x00);
	SHA224.ctx = new SHA224();

	/*
	 * Expose
	 */

	sha224 = SHA224;
	return sha224;
}

/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredBcrypto;

function requireBcrypto () {
	if (hasRequiredBcrypto) return bcrypto;
	hasRequiredBcrypto = 1;
	(function (exports) {

		// exports.AEAD = require('./aead');
		exports.aes = requireAes();
		// exports.ARC4 = require('./arc4');
		// exports.bcrypt = require('./bcrypt');
		// exports.BLAKE2b = require('./blake2b');
		// exports.BLAKE2b160 = require('./blake2b160');
		// exports.BLAKE2b256 = require('./blake2b256');
		// exports.BLAKE2b384 = require('./blake2b384');
		// exports.BLAKE2b512 = require('./blake2b512');
		// exports.BLAKE2s = require('./blake2s');
		// exports.BLAKE2s128 = require('./blake2s128');
		// exports.BLAKE2s160 = require('./blake2s160');
		// exports.BLAKE2s224 = require('./blake2s224');
		// exports.BLAKE2s256 = require('./blake2s256');
		exports.BN = requireBn();
		// exports.box = require('./box');
		exports.ChaCha20 = requireChacha20();
		// exports.cipher = require('./cipher');
		exports.cleanse = requireCleanse();
		// exports.CSHAKE = require('./cshake');
		// exports.CSHAKE128 = require('./cshake128');
		// exports.CSHAKE256 = require('./cshake256');
		// exports.CtrDRBG = require('./ctr-drbg');
		// exports.dsa = require('./dsa');
		// exports.dsaies = require('./dsaies');
		// exports.eb2k = require('./eb2k');
		// exports.ecies = require('./ecies');
		// exports.ed25519 = require('./ed25519');
		// exports.ed448 = require('./ed448');
		// exports.encoding = require('./encoding');
		// exports.GOST94 = require('./gost94');
		exports.Hash160 = requireHash160();
		exports.Hash256 = requireHash256();
		// exports.HashDRBG = require('./hash-drbg');
		// exports.hkdf = require('./hkdf');
		exports.HmacDRBG = requireHmacDrbg();
		exports.Keccak = requireKeccak();
		// exports.Keccak224 = require('./keccak224');
		// exports.Keccak256 = require('./keccak256');
		// exports.Keccak384 = require('./keccak384');
		// exports.Keccak512 = require('./keccak512');
		// exports.KMAC = require('./kmac');
		// exports.KMAC128 = require('./kmac128');
		// exports.KMAC256 = require('./kmac256');
		// exports.MD2 = require('./md2');
		// exports.MD4 = require('./md4');
		// exports.MD5 = require('./md5');
		// exports.MD5SHA1 = require('./md5sha1');
		exports.merkle = requireMerkle();
		// exports.mrkl = require('./mrkl');
		exports.murmur3 = requireMurmur3();
		// exports.p192 = require('./p192');
		exports.p224 = requireP224();
		exports.p256 = requireP256();
		exports.p384 = requireP384();
		exports.p521 = requireP521();
		exports.pbkdf2 = requirePbkdf2();
		// exports.pgp = require('./pgp');
		// exports.Poly1305 = require('./poly1305');
		exports.random = requireRandom();
		exports.RIPEMD160 = requireRipemd160();
		exports.rsa = requireRsa();
		// exports.rsaies = require('./rsaies');
		exports.safe = requireSafe();
		// exports.Salsa20 = require('./salsa20');
		// exports.schnorr = require('./schnorr');
		exports.scrypt = requireScrypt();
		exports.secp256k1 = requireSecp256k1();
		// exports.secretbox = require('./secretbox');
		// exports.ssh = require('./ssh');
		exports.SHA1 = requireSha1();
		exports.SHA224 = requireSha224();
		exports.SHA256 = requireSha256();
		exports.SHA384 = requireSha384();
		exports.SHA512 = requireSha512();
		// exports.SHA3 = require('./sha3');
		// exports.SHA3_224 = require('./sha3-224');
		// exports.SHA3_256 = require('./sha3-256');
		// exports.SHA3_384 = require('./sha3-384');
		// exports.SHA3_512 = require('./sha3-512');
		exports.SHAKE = requireShake();
		// exports.SHAKE128 = require('./shake128');
		exports.SHAKE256 = requireShake256();
		// exports.siphash = require('./siphash');
		// exports.Whirlpool = require('./whirlpool');
		// exports.x25519 = require('./x25519');
		// exports.x448 = require('./x448');

		exports.version = '5.5.1';
		exports.native = exports.SHA256.native; 
	} (bcrypto));
	return bcrypto;
}

var bfilter = {};

/*!
 * bloom.js - bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var bloom;
var hasRequiredBloom;

function requireBloom () {
	if (hasRequiredBloom) return bloom;
	hasRequiredBloom = 1;

	const {
	  enforce
	} = requireAssert$1();
	const bio = requireBufio();
	const murmur3 = requireMurmur3();

	/*
	 * Constants
	 */

	const DUMMY = Buffer.alloc(0);
	const LN2SQUARED = 0.4804530139182014246671025263266649717305529515945455;
	const LN2 = 0.6931471805599453094172321214581765680755001343602552;

	/**
	 * Bloom Filter
	 */

	class BloomFilter extends bio.Struct {
	  /**
	   * Create a bloom filter.
	   * @constructor
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @property {Buffer} filter
	   * @property {Number} size
	   * @property {Number} n
	   * @property {Number} tweak
	   * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
	   */

	  constructor(size, n, tweak, update) {
	    super();
	    this.filter = DUMMY;
	    this.size = 0;
	    this.n = 0;
	    this.tweak = 0;
	    this.update = BloomFilter.flags.NONE;
	    if (size != null) this.fromOptions(size, n, tweak, update);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @returns {BloomFilter}
	   */

	  fromOptions(size, n, tweak, update) {
	    if (tweak == null || tweak === -1) tweak = Math.random() * 0x100000000 >>> 0;
	    if (update == null || update === -1) update = BloomFilter.flags.NONE;
	    if (typeof update === 'string') {
	      update = BloomFilter.flags[update.toUpperCase()];
	      enforce(update != null, 'update', 'flag');
	    }
	    enforce(Number.isSafeInteger(size) && size >= 0, 'size', 'integer');
	    enforce(Number.isSafeInteger(n) && n >= 0, 'n', 'integer');
	    enforce(tweak >>> 0 === tweak, 'tweak', 'integer');
	    enforce(update >>> 0 === update, 'update', 'integer');
	    enforce(update <= 2, 'update', 'range between 0 and 2');
	    if (size < 8) size = 8;
	    if (n === 0) n = 1;
	    size -= size & 7;
	    this.filter = Buffer.alloc(size / 8, 0x00);
	    this.size = size;
	    this.n = n;
	    this.tweak = tweak;
	    this.update = update;
	    return this;
	  }

	  /**
	   * Instantiate bloom filter from options.
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @returns {BloomFilter}
	   */

	  static fromOptions(size, n, tweak, update) {
	    return new this().fromOptions(size, n, tweak, update);
	  }

	  /**
	   * Perform the mumur3 hash on data.
	   * @param {Buffer} value
	   * @param {Number} n
	   * @returns {Number}
	   */

	  hash(value, n) {
	    return murmur3.tweak(value, n, this.tweak) % this.size;
	  }

	  /**
	   * Reset the filter.
	   */

	  reset() {
	    this.filter.fill(0);
	  }

	  /**
	   * Add data to the filter.
	   * @param {Buffer|String}
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   */

	  add(value, enc) {
	    const val = toBuffer(value, enc);
	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      this.filter[index >>> 3] |= 1 << (7 & index);
	    }
	  }

	  /**
	   * Test whether data is present in the filter.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean}
	   */

	  test(value, enc) {
	    const val = toBuffer(value, enc);
	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      if ((this.filter[index >>> 3] & 1 << (7 & index)) === 0) return false;
	    }
	    return true;
	  }

	  /**
	   * Test whether data is present in the
	   * filter and potentially add data.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean} Whether data was added.
	   */

	  added(value, enc) {
	    const val = toBuffer(value, enc);
	    let ret = false;
	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      if (!ret && (this.filter[index >>> 3] & 1 << (7 & index)) === 0) ret = true;
	      this.filter[index >>> 3] |= 1 << (7 & index);
	    }
	    return ret;
	  }

	  /**
	   * Create a filter from a false positive rate.
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @param {Number|String} update
	   * @example
	   * BloomFilter.fromRate(800000, 0.0001, 'none');
	   * @returns {BloomFilter}
	   */

	  static fromRate(items, rate, update) {
	    enforce(Number.isSafeInteger(items) && items > 0, 'items', 'integer');
	    enforce(typeof rate === 'number' && isFinite(rate), 'rate', 'number');
	    enforce(rate >= 0 && rate <= 1, 'rate', 'range between 0.1 and 1.0.');
	    const bits = -1 / LN2SQUARED * items * Math.log(rate) | 0;
	    const size = Math.max(8, bits);
	    if (update !== -1) {
	      if (size > BloomFilter.MAX_BLOOM_FILTER_SIZE * 8) throw new Error('Bloom filter size violates policy limits!');
	    }
	    const n = Math.max(1, size / items * LN2 | 0);
	    if (update !== -1) {
	      if (n > BloomFilter.MAX_HASH_FUNCS) throw new Error('Bloom filter size violates policy limits!');
	    }
	    return new this(size, n, -1, update);
	  }

	  /**
	   * Ensure the filter is within the size limits.
	   * @returns {Boolean}
	   */

	  isWithinConstraints() {
	    if (this.size > BloomFilter.MAX_BLOOM_FILTER_SIZE * 8) return false;
	    if (this.n > BloomFilter.MAX_HASH_FUNCS) return false;
	    return true;
	  }

	  /**
	   * Get serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return bio.sizeVarBytes(this.filter) + 9;
	  }

	  /**
	   * Write filter to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  write(bw) {
	    bw.writeVarBytes(this.filter);
	    bw.writeU32(this.n);
	    bw.writeU32(this.tweak);
	    bw.writeU8(this.update);
	    return bw;
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  read(br) {
	    this.filter = br.readVarBytes();
	    this.size = this.filter.length * 8;
	    this.n = br.readU32();
	    this.tweak = br.readU32();
	    this.update = br.readU8();
	    if (this.update > 2) throw new Error('Invalid update flag.');
	    return this;
	  }
	}

	/**
	 * Max bloom filter size.
	 * @const {Number}
	 * @default
	 */

	BloomFilter.MAX_BLOOM_FILTER_SIZE = 36000;

	/**
	 * Max number of hash functions.
	 * @const {Number}
	 * @default
	 */

	BloomFilter.MAX_HASH_FUNCS = 50;

	/**
	 * Bloom filter update flags.
	 * @enum {Number}
	 * @default
	 */

	BloomFilter.flags = {
	  /**
	   * Never update the filter with outpoints.
	   */

	  NONE: 0,
	  /**
	   * Always update the filter with outpoints.
	   */

	  ALL: 1,
	  /**
	   * Only update the filter with outpoints if it is
	   * "asymmetric" in terms of addresses (pubkey/multisig).
	   */

	  PUBKEY_ONLY: 2
	};

	/**
	 * Bloom filter update flags by value.
	 * @const {RevMap}
	 */

	BloomFilter.flagsByVal = ['NONE', 'ALL', 'PUBKEY_ONLY'];

	/*
	 * Helpers
	 */

	function toBuffer(value, enc) {
	  if (typeof value !== 'string') {
	    enforce(Buffer.isBuffer(value), 'value', 'buffer');
	    return value;
	  }
	  enforce(typeof enc === 'string', 'enc', 'string');
	  return Buffer.from(value, enc);
	}

	/*
	 * Expose
	 */

	bloom = BloomFilter;
	return bloom;
}

/*!
 * rollingfilter.js - rolling bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var rolling;
var hasRequiredRolling;

function requireRolling () {
	if (hasRequiredRolling) return rolling;
	hasRequiredRolling = 1;

	const {
	  enforce
	} = requireAssert$1();
	const {
	  encoding
	} = requireBufio();
	const murmur3 = requireMurmur3();
	const DUMMY = Buffer.alloc(0);

	/**
	 * Rolling Bloom Filter
	 */

	class RollingFilter {
	  /**
	   * Create a rolling bloom filter.
	   * @constructor
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   */

	  constructor(items, rate) {
	    this.entries = 0;
	    this.generation = 1;
	    this.n = 0;
	    this.limit = 0;
	    this.size = 0;
	    this.items = 0;
	    this.tweak = 0;
	    this.filter = DUMMY;
	    if (items != null) this.fromRate(items, rate);
	  }

	  /**
	   * Inject properties from items and FPR.
	   * @private
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @returns {RollingFilter}
	   */

	  fromRate(items, rate) {
	    enforce(Number.isSafeInteger(items) && items > 0, 'items', 'integer');
	    enforce(typeof rate === 'number' && isFinite(rate), 'rate', 'number');
	    enforce(rate >= 0 && rate <= 1, 'rate', 'range between 0.1 and 1.0.');
	    const logRate = Math.log(rate);
	    const n = Math.max(1, Math.min(Math.round(logRate / Math.log(0.5)), 50));
	    const limit = (items + 1) / 2 | 0;
	    const max = limit * 3;
	    let size = -1 * n * max / Math.log(1.0 - Math.exp(logRate / n));
	    size = Math.ceil(size);
	    items = ((size + 63) / 64 | 0) << 1;
	    items >>>= 0;
	    items = Math.max(1, items);
	    const tweak = Math.random() * 0x100000000 >>> 0;
	    const filter = Buffer.alloc(items * 8, 0x00);
	    this.n = n;
	    this.limit = limit;
	    this.size = size;
	    this.items = items;
	    this.tweak = tweak;
	    this.filter = filter;
	    return this;
	  }

	  /**
	   * Instantiate rolling filter from items and FPR.
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @returns {RollingFilter}
	   */

	  static fromRate(items, rate) {
	    return new this().fromRate(items, rate);
	  }

	  /**
	   * Perform the mumur3 hash on data.
	   * @param {Buffer} value
	   * @param {Number} seed
	   * @returns {Number}
	   */

	  hash(value, n) {
	    return murmur3.tweak(value, n, this.tweak);
	  }

	  /**
	   * Reset the filter.
	   */

	  reset() {
	    if (this.entries === 0) return;
	    this.entries = 0;
	    this.generation = 1;
	    this.filter.fill(0);
	  }

	  /**
	   * Add data to the filter.
	   * @param {Buffer|String}
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   */

	  add(value, enc) {
	    const val = toBuffer(value, enc);
	    if (this.entries === this.limit) {
	      this.entries = 0;
	      this.generation += 1;
	      if (this.generation === 4) this.generation = 1;
	      const m1 = (this.generation & 1) * 0xffffffff;
	      const m2 = (this.generation >>> 1) * 0xffffffff;
	      for (let i = 0; i < this.items; i += 2) {
	        const pos1 = i * 8;
	        const pos2 = (i + 1) * 8;
	        const v1 = read(this.filter, pos1);
	        const v2 = read(this.filter, pos2);
	        const mhi = v1.hi ^ m1 | v2.hi ^ m2;
	        const mlo = v1.lo ^ m1 | v2.lo ^ m2;
	        v1.hi &= mhi;
	        v1.lo &= mlo;
	        v2.hi &= mhi;
	        v2.lo &= mlo;
	        write(this.filter, v1, pos1);
	        write(this.filter, v2, pos2);
	      }
	    }
	    this.entries += 1;
	    for (let i = 0; i < this.n; i++) {
	      const hash = this.hash(val, i);
	      const bits = hash & 0x3f;
	      const pos = (hash >>> 6) % this.items;
	      const pos1 = (pos & -2) * 8;
	      const pos2 = (pos | 1) * 8;
	      const bit = bits % 8;
	      const oct = (bits - bit) / 8;
	      this.filter[pos1 + oct] &= ~(1 << bit);
	      this.filter[pos1 + oct] |= (this.generation & 1) << bit;
	      this.filter[pos2 + oct] &= ~(1 << bit);
	      this.filter[pos2 + oct] |= this.generation >>> 1 << bit;
	    }
	  }

	  /**
	   * Test whether data is present in the filter.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean}
	   */

	  test(value, enc) {
	    if (this.entries === 0) return false;
	    const val = toBuffer(value, enc);
	    for (let i = 0; i < this.n; i++) {
	      const hash = this.hash(val, i);
	      const bits = hash & 0x3f;
	      const pos = (hash >>> 6) % this.items;
	      const pos1 = (pos & -2) * 8;
	      const pos2 = (pos | 1) * 8;
	      const bit = bits % 8;
	      const oct = (bits - bit) / 8;
	      const bit1 = this.filter[pos1 + oct] >>> bit & 1;
	      const bit2 = this.filter[pos2 + oct] >>> bit & 1;
	      if ((bit1 | bit2) === 0) return false;
	    }
	    return true;
	  }

	  /**
	   * Test whether data is present in the
	   * filter and potentially add data.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean} Whether data was added.
	   */

	  added(value, enc) {
	    const val = toBuffer(value, enc);
	    if (!this.test(val)) {
	      this.add(val);
	      return true;
	    }
	    return false;
	  }
	}

	/*
	 * Helpers
	 */

	class U64 {
	  constructor(hi, lo) {
	    this.hi = hi;
	    this.lo = lo;
	  }
	}
	function read(data, off) {
	  const hi = encoding.readU32(data, off + 4);
	  const lo = encoding.readU32(data, off);
	  return new U64(hi, lo);
	}
	function write(data, value, off) {
	  encoding.writeU32(data, value.hi, off + 4);
	  encoding.writeU32(data, value.lo, off);
	}
	function toBuffer(value, enc) {
	  if (typeof value !== 'string') {
	    enforce(Buffer.isBuffer(value), 'value', 'buffer');
	    return value;
	  }
	  enforce(typeof enc === 'string', 'enc', 'string');
	  return Buffer.from(value, enc);
	}

	/*
	 * Expose
	 */

	rolling = RollingFilter;
	return rolling;
}

/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBfilter;

function requireBfilter () {
	if (hasRequiredBfilter) return bfilter;
	hasRequiredBfilter = 1;

	const BloomFilter = requireBloom();
	const RollingFilter = requireRolling();
	bfilter.BloomFilter = BloomFilter;
	bfilter.RollingFilter = RollingFilter;
	return bfilter;
}

var pkg = {};

var name = "@hansekontor/checkout-components";
var version = "1.0.1";
var require$$0 = {
	name: name,
	version: version};

/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */

var hasRequiredPkg;

function requirePkg () {
	if (hasRequiredPkg) return pkg;
	hasRequiredPkg = 1;
	(function (exports) {

		const pkg = exports;

		/**
		 * Package Name
		 * @const {String}
		 * @default
		 */

		pkg.name = require$$0.name;

		/**
		 * Project Name
		 * @const {String}
		 * @default
		 */

		pkg.core = 'bcash';

		/**
		 * Organization Name
		 * @const {String}
		 * @default
		 */

		pkg.organization = 'badger-cash';

		/**
		 * Currency Name
		 * @const {String}
		 * @default
		 */

		pkg.currency = 'bitcoin cash';

		/**
		 * Currency Unit
		 * @const {String}
		 * @default
		 */

		pkg.unit = 'bch';

		/**
		 * Base Unit
		 * @const {String}
		 * @default
		 */

		pkg.base = 'satoshi';

		/**
		 * Config file name.
		 * @const {String}
		 * @default
		 */

		pkg.cfg = `${pkg.core}.conf`;

		/**
		 * Repository URL.
		 * @const {String}
		 * @default
		 */

		pkg.url = `https://github.com/${pkg.organization}/${pkg.name}`;

		/**
		 * Current version string.
		 * @const {String}
		 */

		pkg.version = require$$0.version; 
	} (pkg));
	return pkg;
}

/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBcoinBrowser;

function requireBcoinBrowser () {
	if (hasRequiredBcoinBrowser) return bcoinBrowser$1;
	hasRequiredBcoinBrowser = 1;
	(function (exports) {

		/**
		 * A bcoin "environment" which exposes all
		 * constructors for primitives, the blockchain,
		 * mempool, wallet, etc. It also exposes a
		 * global worker pool.
		 *
		 * @exports bcoin
		 * @type {Object}
		 */
		const bcoin = exports;

		/**
		 * Set the default network.
		 * @param {String} network
		 */

		bcoin.set = function set(network) {
		  bcoin.Network.set(network);
		  return bcoin;
		};

		/*
		 * Expose
		 */

		// BTC
		bcoin.btc = requireBtc();
		bcoin.Amount = requireAmount();
		bcoin.URI = requireUri();

		// Coins
		bcoin.coins = requireCoins();
		bcoin.Coins = requireCoins$1();
		bcoin.CoinEntry = requireCoinentry();
		bcoin.CoinView = requireCoinview();

		// HD
		bcoin.hd = requireHd();
		bcoin.HDPrivateKey = require_private();
		bcoin.HDPublicKey = require_public();
		bcoin.Mnemonic = requireMnemonic();

		// Primitives
		bcoin.primitives = requirePrimitives();
		bcoin.Address = requireAddress();
		bcoin.Block = requireBlock();
		bcoin.Coin = requireCoin();
		bcoin.Headers = requireHeaders();
		bcoin.Input = requireInput();
		bcoin.InvItem = requireInvitem();
		bcoin.KeyRing = requireKeyring();
		bcoin.MerkleBlock = requireMerkleblock();
		bcoin.MTX = requireMtx();
		bcoin.Outpoint = requireOutpoint();
		bcoin.Output = requireOutput();
		bcoin.TX = requireTx();

		// Protocol
		bcoin.protocol = requireProtocol();
		bcoin.consensus = requireConsensus();
		bcoin.Network = requireNetwork();
		bcoin.networks = requireNetworks();
		bcoin.policy = requirePolicy();

		// Script
		bcoin.script = requireScript();
		bcoin.Opcode = requireOpcode();
		bcoin.Script = requireScript$1();
		bcoin.ScriptNum = requireScriptnum();
		bcoin.SigCache = requireSigcache();
		bcoin.Stack = requireStack();

		// Utils
		bcoin.utils = requireUtils();
		bcoin.util = requireUtil();

		// bcrypto
		bcoin.bcrypto = requireBcrypto();

		// bfilter
		bcoin.bfilter = requireBfilter();

		// Package Info
		bcoin.pkg = requirePkg(); 
	} (bcoinBrowser$1));
	return bcoinBrowser$1;
}

var bcoinBrowserExports = requireBcoinBrowser();
var bcoinBrowser = /*@__PURE__*/getDefaultExportFromCjs(bcoinBrowserExports);

module.exports = bcoinBrowser;
//# sourceMappingURL=index.js.map
