import require$$0$3 from 'bsert';
import require$$1 from 'bufio';
import require$$2$1 from 'bstring';
import require$$3 from 'ecashaddrjs';
import require$$1$1 from 'n64';
import require$$2$2 from 'buffer-map';
import require$$1$2 from 'blru';
import require$$1$3 from 'bufio/lib/reader';
import require$$1$4 from 'bufio/lib/writer';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var bcoinBrowser$1 = {exports: {}};

var btc = {};

var fixed = {};

/*!
 * fixed.js - fixed number parsing
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredFixed;

function requireFixed () {
	if (hasRequiredFixed) return fixed;
	hasRequiredFixed = 1;
	(function (exports) {

		const assert = require$$0$3;

		/**
		 * Convert int to fixed number string and reduce by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {String} Fixed number string.
		 */

		exports.encode = function encode(num, exp) {
		  assert(Number.isSafeInteger(num), 'Invalid integer value.');

		  let sign = '';

		  if (num < 0) {
		    num = -num;
		    sign = '-';
		  }

		  const mult = pow10(exp);

		  let lo = num % mult;
		  let hi = (num - lo) / mult;

		  lo = lo.toString(10);
		  hi = hi.toString(10);

		  while (lo.length < exp)
		    lo = '0' + lo;

		  lo = lo.replace(/0+$/, '');

		  assert(lo.length <= exp, 'Invalid integer value.');

		  if (lo.length === 0)
		    lo = '0';

		  if (exp === 0)
		    return `${sign}${hi}`;

		  return `${sign}${hi}.${lo}`;
		};

		/**
		 * Parse a fixed number string and multiply by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {String} str
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Integer.
		 */

		exports.decode = function decode(str, exp) {
		  assert(typeof str === 'string');
		  assert(str.length <= 32, 'Fixed number string too large.');

		  let sign = 1;

		  if (str.length > 0 && str[0] === '-') {
		    str = str.substring(1);
		    sign = -1;
		  }

		  let hi = str;
		  let lo = '0';

		  const index = str.indexOf('.');

		  if (index !== -1) {
		    hi = str.substring(0, index);
		    lo = str.substring(index + 1);
		  }

		  hi = hi.replace(/^0+/, '');
		  lo = lo.replace(/0+$/, '');

		  assert(hi.length <= 16 - exp,
		    'Fixed number string exceeds 2^53-1.');

		  assert(lo.length <= exp,
		    'Too many decimal places in fixed number string.');

		  if (hi.length === 0)
		    hi = '0';

		  while (lo.length < exp)
		    lo += '0';

		  if (lo.length === 0)
		    lo = '0';

		  assert(/^\d+$/.test(hi) && /^\d+$/.test(lo),
		    'Non-numeric characters in fixed number string.');

		  hi = parseInt(hi, 10);
		  lo = parseInt(lo, 10);

		  const mult = pow10(exp);
		  const maxLo = modSafe(mult);
		  const maxHi = divSafe(mult);

		  assert(hi < maxHi || (hi === maxHi && lo <= maxLo),
		    'Fixed number string exceeds 2^53-1.');

		  return sign * (hi * mult + lo);
		};

		/**
		 * Convert int to float and reduce by a power
		 * of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Double float.
		 */

		exports.toFloat = function toFloat(num, exp) {
		  return parseFloat(exports.encode(num, exp));
		};

		/**
		 * Parse a double float number and multiply by a
		 * power of ten (uses no floating point arithmetic).
		 * @param {Number} num
		 * @param {Number} exp - Number of decimal places.
		 * @returns {Number} Integer.
		 */

		exports.fromFloat = function fromFloat(num, exp) {
		  assert(typeof num === 'number' && isFinite(num));
		  assert(Number.isSafeInteger(exp));
		  return exports.decode(num.toFixed(exp), exp);
		};

		/*
		 * Helpers
		 */

		function pow10(exp) {
		  switch (exp) {
		    case 0:
		      return 1;
		    case 1:
		      return 10;
		    case 2:
		      return 100;
		    case 3:
		      return 1000;
		    case 4:
		      return 10000;
		    case 5:
		      return 100000;
		    case 6:
		      return 1000000;
		    case 7:
		      return 10000000;
		    case 8:
		      return 100000000;
		  }
		  throw new Error('Exponent is too large.');
		}

		function modSafe(mod) {
		  switch (mod) {
		    case 1:
		      return 0;
		    case 10:
		      return 1;
		    case 100:
		      return 91;
		    case 1000:
		      return 991;
		    case 10000:
		      return 991;
		    case 100000:
		      return 40991;
		    case 1000000:
		      return 740991;
		    case 10000000:
		      return 4740991;
		    case 100000000:
		      return 54740991;
		  }
		  throw new Error('Exponent is too large.');
		}

		function divSafe(div) {
		  switch (div) {
		    case 1:
		      return 9007199254740991;
		    case 10:
		      return 900719925474099;
		    case 100:
		      return 90071992547409;
		    case 1000:
		      return 9007199254740;
		    case 10000:
		      return 900719925474;
		    case 100000:
		      return 90071992547;
		    case 1000000:
		      return 9007199254;
		    case 10000000:
		      return 900719925;
		    case 100000000:
		      return 90071992;
		  }
		  throw new Error('Exponent is too large.');
		} 
	} (fixed));
	return fixed;
}

/*!
 * amount.js - amount object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var amount;
var hasRequiredAmount;

function requireAmount () {
	if (hasRequiredAmount) return amount;
	hasRequiredAmount = 1;

	const assert = require$$0$3;
	const fixed = requireFixed();

	/**
	 * Amount
	 * Represents a bitcoin amount (satoshis internally).
	 * @alias module:btc.Amount
	 * @property {Amount} value
	 */

	class Amount {
	  /**
	   * Create an amount.
	   * @constructor
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   */

	  constructor(value, unit) {
	    this.value = 0;

	    if (value != null)
	      this.fromOptions(value, unit);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   * @returns {Amount}
	   */

	  fromOptions(value, unit) {
	    if (typeof unit === 'string')
	      return this.from(unit, value);

	    if (typeof value === 'number')
	      return this.fromValue(value);

	    return this.fromBTC(value);
	  }

	  /**
	   * Get satoshi value.
	   * @returns {Amount}
	   */

	  toValue() {
	    return this.value;
	  }

	  /**
	   * Get satoshi string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toSatoshis(num) {
	    if (num)
	      return this.value;

	    return this.value.toString(10);
	  }

	  /**
	   * Get bits string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toBits(num) {
	    return Amount.encode(this.value, 2, num);
	  }

	  /**
	   * Get mbtc string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toMBTC(num) {
	    return Amount.encode(this.value, 5, num);
	  }

	  /**
	   * Get btc string or value.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  toBTC(num) {
	    return Amount.encode(this.value, 8, num);
	  }

	  /**
	   * Get unit string or value.
	   * @param {String} unit - Can be `sat`,
	   * `ubtc`, `bits`, `mbtc`, or `btc`.
	   * @param {Boolean?} num
	   * @returns {String|Amount}
	   */

	  to(unit, num) {
	    switch (unit) {
	      case 'sat':
	        return this.toSatoshis(num);
	      case 'ubtc':
	      case 'bits':
	        return this.toBits(num);
	      case 'mbtc':
	        return this.toMBTC(num);
	      case 'btc':
	        return this.toBTC(num);
	    }
	    throw new Error(`Unknown unit "${unit}".`);
	  }

	  /**
	   * Convert amount to bitcoin string.
	   * @returns {String}
	   */

	  toString() {
	    return this.toBTC();
	  }

	  /**
	   * Inject properties from value.
	   * @private
	   * @param {Amount} value
	   * @returns {Amount}
	   */

	  fromValue(value) {
	    assert(Number.isSafeInteger(value) && value >= 0,
	      'Value must be an int64.');
	    this.value = value;
	    return this;
	  }

	  /**
	   * Inject properties from satoshis.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromSatoshis(value) {
	    this.value = Amount.decode(value, 0);
	    return this;
	  }

	  /**
	   * Inject properties from bits.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromBits(value) {
	    this.value = Amount.decode(value, 2);
	    return this;
	  }

	  /**
	   * Inject properties from mbtc.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromMBTC(value) {
	    this.value = Amount.decode(value, 5);
	    return this;
	  }

	  /**
	   * Inject properties from btc.
	   * @private
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  fromBTC(value) {
	    this.value = Amount.decode(value, 8);
	    return this;
	  }

	  /**
	   * Inject properties from unit.
	   * @private
	   * @param {String} unit
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  from(unit, value) {
	    switch (unit) {
	      case 'sat':
	        return this.fromSatoshis(value);
	      case 'ubtc':
	      case 'bits':
	        return this.fromBits(value);
	      case 'mbtc':
	        return this.fromMBTC(value);
	      case 'btc':
	        return this.fromBTC(value);
	    }
	    throw new Error(`Unknown unit "${unit}".`);
	  }

	  /**
	   * Instantiate amount from options.
	   * @param {(String|Number)?} value
	   * @param {String?} unit
	   * @returns {Amount}
	   */

	  static fromOptions(value, unit) {
	    return new this().fromOptions(value, unit);
	  }

	  /**
	   * Instantiate amount from value.
	   * @private
	   * @param {Amount} value
	   * @returns {Amount}
	   */

	  static fromValue(value) {
	    return new this().fromValue(value);
	  }

	  /**
	   * Instantiate amount from satoshis.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromSatoshis(value) {
	    return new this().fromSatoshis(value);
	  }

	  /**
	   * Instantiate amount from bits.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromBits(value) {
	    return new this().fromBits(value);
	  }

	  /**
	   * Instantiate amount from mbtc.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromMBTC(value) {
	    return new this().fromMBTC(value);
	  }

	  /**
	   * Instantiate amount from btc.
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static fromBTC(value) {
	    return new this().fromBTC(value);
	  }

	  /**
	   * Instantiate amount from unit.
	   * @param {String} unit
	   * @param {Number|String} value
	   * @returns {Amount}
	   */

	  static from(unit, value) {
	    return new this().from(unit, value);
	  }

	  /**
	   * Inspect amount.
	   * @returns {String}
	   */

	  inspect() {
	    return `<Amount: ${this.toString()}>`;
	  }

	  /**
	   * Safely convert satoshis to a BTC string.
	   * This function explicitly avoids any
	   * floating point arithmetic.
	   * @param {Amount} value - Satoshis.
	   * @returns {String} BTC string.
	   */

	  static btc(value, num) {
	    if (typeof value === 'string')
	      return value;

	    return Amount.encode(value, 8, num);
	  }

	  /**
	   * Safely convert a BTC string to satoshis.
	   * @param {String} str - BTC
	   * @returns {Amount} Satoshis.
	   * @throws on parse error
	   */

	  static value(str) {
	    if (typeof str === 'number')
	      return str;

	    return Amount.decode(str, 8);
	  }

	  /**
	   * Safely convert satoshis to a BTC string.
	   * @param {Amount} value
	   * @param {Number} exp - Exponent.
	   * @param {Boolean} num - Return a number.
	   * @returns {String|Number}
	   */

	  static encode(value, exp, num) {
	    if (num)
	      return fixed.toFloat(value, exp);
	    return fixed.encode(value, exp);
	  }

	  /**
	   * Safely convert a BTC string to satoshis.
	   * @param {String|Number} value - BTC
	   * @param {Number} exp - Exponent.
	   * @returns {Amount} Satoshis.
	   * @throws on parse error
	   */

	  static decode(value, exp) {
	    if (typeof value === 'number')
	      return fixed.fromFloat(value, exp);
	    return fixed.decode(value, exp);
	  }
	}

	/*
	 * Expose
	 */

	amount = Amount;
	return amount;
}

/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var assert_1;
var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert_1;
	hasRequiredAssert = 1;

	/*
	 * Assert
	 */

	function assert(val, msg) {
	  if (!val) {
	    const err = new Error(msg || 'Assertion failed');

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, assert);

	    throw err;
	  }
	}

	/*
	 * Expose
	 */

	assert_1 = assert;
	return assert_1;
}

/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */

var hmac;
var hasRequiredHmac;

function requireHmac () {
	if (hasRequiredHmac) return hmac;
	hasRequiredHmac = 1;

	const assert = requireAssert();

	/**
	 * HMAC
	 */

	class HMAC {
	  /**
	   * Create an HMAC.
	   * @param {Function} Hash
	   * @param {Number} size
	   * @param {Array} [x=[]]
	   * @param {Array} [y=[]]
	   */

	  constructor(Hash, size, x = [], y = []) {
	    assert(typeof Hash === 'function');
	    assert((size >>> 0) === size);
	    assert(Array.isArray(x));
	    assert(Array.isArray(y));

	    this.hash = Hash;
	    this.size = size;
	    this.x = x;
	    this.y = y;

	    this.inner = new Hash();
	    this.outer = new Hash();
	  }

	  /**
	   * Initialize HMAC context.
	   * @param {Buffer} data
	   */

	  init(key) {
	    assert(Buffer.isBuffer(key));

	    // Shorten key
	    if (key.length > this.size) {
	      const Hash = this.hash;
	      const h = new Hash();

	      h.init(...this.x);
	      h.update(key);

	      key = h.final(...this.y);

	      assert(key.length <= this.size);
	    }

	    // Pad key
	    const pad = Buffer.alloc(this.size);

	    for (let i = 0; i < key.length; i++)
	      pad[i] = key[i] ^ 0x36;

	    for (let i = key.length; i < pad.length; i++)
	      pad[i] = 0x36;

	    this.inner.init(...this.x);
	    this.inner.update(pad);

	    for (let i = 0; i < key.length; i++)
	      pad[i] = key[i] ^ 0x5c;

	    for (let i = key.length; i < pad.length; i++)
	      pad[i] = 0x5c;

	    this.outer.init(...this.x);
	    this.outer.update(pad);

	    return this;
	  }

	  /**
	   * Update HMAC context.
	   * @param {Buffer} data
	   */

	  update(data) {
	    this.inner.update(data);
	    return this;
	  }

	  /**
	   * Finalize HMAC context.
	   * @returns {Buffer}
	   */

	  final() {
	    this.outer.update(this.inner.final(...this.y));
	    return this.outer.final(...this.y);
	  }
	}

	/*
	 * Expose
	 */

	hmac = HMAC;
	return hmac;
}

/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */

var sha256;
var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256;
	hasRequiredSha256 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);

	PADDING[0] = 0x80;

	const K = new Uint32Array([
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	]);

	/**
	 * SHA256
	 */

	class SHA256 {
	  constructor() {
	    this.state = new Uint32Array(8);
	    this.msg = new Uint32Array(64);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }

	  init() {
	    this.state[0] = 0x6a09e667;
	    this.state[1] = 0xbb67ae85;
	    this.state[2] = 0x3c6ef372;
	    this.state[3] = 0xa54ff53a;
	    this.state[4] = 0x510e527f;
	    this.state[5] = 0x9b05688c;
	    this.state[6] = 0x1f83d9ab;
	    this.state[7] = 0x5be0cd19;
	    this.size = 0;
	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }

	  final() {
	    return this._final(Buffer.alloc(32));
	  }

	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    let pos = this.size & 63;
	    let off = 0;

	    this.size += len;

	    if (pos > 0) {
	      let want = 64 - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < 64)
	        return;

	      this._transform(this.block, 0);
	    }

	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);
	  }

	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    const pos = this.size & 63;
	    const len = this.size * 8;

	    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 0);
	    writeU32(DESC, len >>> 0, 4);

	    this._update(PADDING, 1 + ((119 - pos) & 63));
	    this._update(DESC, 8);

	    for (let i = 0; i < 8; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }

	    for (let i = 0; i < 64; i++)
	      this.msg[i] = 0;

	    for (let i = 0; i < 64; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;

	    return out;
	  }

	  _transform(chunk, pos) {
	    const W = this.msg;

	    let a = this.state[0];
	    let b = this.state[1];
	    let c = this.state[2];
	    let d = this.state[3];
	    let e = this.state[4];
	    let f = this.state[5];
	    let g = this.state[6];
	    let h = this.state[7];
	    let i = 0;

	    for (; i < 16; i++)
	      W[i] = readU32(chunk, pos + i * 4);

	    for (; i < 64; i++)
	      W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];

	    for (i = 0; i < 64; i++) {
	      const t1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];
	      const t2 = Sigma0(a) + Maj(a, b, c);

	      h = g;
	      g = f;
	      f = e;

	      e = (d + t1) >>> 0;

	      d = c;
	      c = b;
	      b = a;

	      a = (t1 + t2) >>> 0;
	    }

	    this.state[0] += a;
	    this.state[1] += b;
	    this.state[2] += c;
	    this.state[3] += d;
	    this.state[4] += e;
	    this.state[5] += f;
	    this.state[6] += g;
	    this.state[7] += h;
	  }

	  static hash() {
	    return new SHA256();
	  }

	  static hmac() {
	    return new HMAC(SHA256, 64);
	  }

	  static digest(data) {
	    return SHA256.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 32);
	    assert(Buffer.isBuffer(right) && right.length === 32);
	    return SHA256.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = SHA256;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return SHA256.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA256.native = 0;
	SHA256.id = 'SHA256';
	SHA256.size = 32;
	SHA256.bits = 256;
	SHA256.blockSize = 64;
	SHA256.zero = Buffer.alloc(32, 0x00);
	SHA256.ctx = new SHA256();

	/*
	 * Helpers
	 */

	function Sigma0(x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
	}

	function Sigma1(x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
	}

	function sigma0(x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
	}

	function sigma1(x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
	}

	function Ch(x, y, z) {
	  return z ^ (x & (y ^ z));
	}

	function Maj(x, y, z) {
	  return (x & y) | (z & (x | y));
	}

	function readU32(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha256 = SHA256;
	return sha256;
}

/*!
 * ripemd160.js - RIPEMD160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RIPEMD-160
 *   https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/ripemd.js
 */

var ripemd160;
var hasRequiredRipemd160;

function requireRipemd160 () {
	if (hasRequiredRipemd160) return ripemd160;
	hasRequiredRipemd160 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);

	PADDING[0] = 0x80;

	const r = new Uint8Array([
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	]);

	const rh = new Uint8Array([
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	]);

	const s = new Uint8Array([
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	]);

	const sh = new Uint8Array([
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	]);

	/**
	 * RIPEMD160
	 */

	class RIPEMD160 {
	  constructor() {
	    this.state = new Uint32Array(5);
	    this.msg = new Uint32Array(16);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }

	  init() {
	    this.state[0] = 0x67452301;
	    this.state[1] = 0xefcdab89;
	    this.state[2] = 0x98badcfe;
	    this.state[3] = 0x10325476;
	    this.state[4] = 0xc3d2e1f0;
	    this.size = 0;
	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }

	  final() {
	    return this._final(Buffer.alloc(20));
	  }

	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    let pos = this.size & 63;
	    let off = 0;

	    this.size += len;

	    if (pos > 0) {
	      let want = 64 - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < 64)
	        return;

	      this._transform(this.block, 0);
	    }

	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);
	  }

	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    const pos = this.size & 63;
	    const len = this.size * 8;

	    writeU32(DESC, len >>> 0, 0);
	    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 4);

	    this._update(PADDING, 1 + ((119 - pos) & 63));
	    this._update(DESC, 8);

	    for (let i = 0; i < 5; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }

	    for (let i = 0; i < 16; i++)
	      this.msg[i] = 0;

	    for (let i = 0; i < 64; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;

	    return out;
	  }

	  _transform(chunk, pos) {
	    const W = this.msg;

	    let A = this.state[0];
	    let B = this.state[1];
	    let C = this.state[2];
	    let D = this.state[3];
	    let E = this.state[4];
	    let Ah = A;
	    let Bh = B;
	    let Ch = C;
	    let Dh = D;
	    let Eh = E;

	    for (let i = 0; i < 16; i++)
	      W[i] = readU32(chunk, pos + i * 4);

	    for (let j = 0; j < 80; j++) {
	      let a = A + f(j, B, C, D) + W[r[j]] + K(j);
	      let b = rotl32(a, s[j]);
	      let T = b + E;

	      A = E;
	      E = D;
	      D = rotl32(C, 10);
	      C = B;
	      B = T;

	      a = Ah + f(79 - j, Bh, Ch, Dh) + W[rh[j]] + Kh(j);
	      b = rotl32(a, sh[j]);
	      T = b + Eh;
	      Ah = Eh;
	      Eh = Dh;
	      Dh = rotl32(Ch, 10);
	      Ch = Bh;
	      Bh = T;
	    }

	    const T = this.state[1] + C + Dh;

	    this.state[1] = this.state[2] + D + Eh;
	    this.state[2] = this.state[3] + E + Ah;
	    this.state[3] = this.state[4] + A + Bh;
	    this.state[4] = this.state[0] + B + Ch;
	    this.state[0] = T;
	  }

	  static hash() {
	    return new RIPEMD160();
	  }

	  static hmac() {
	    return new HMAC(RIPEMD160, 64);
	  }

	  static digest(data) {
	    return RIPEMD160.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return RIPEMD160.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = RIPEMD160;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return RIPEMD160.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	RIPEMD160.native = 0;
	RIPEMD160.id = 'RIPEMD160';
	RIPEMD160.size = 20;
	RIPEMD160.bits = 160;
	RIPEMD160.blockSize = 64;
	RIPEMD160.zero = Buffer.alloc(20, 0x00);
	RIPEMD160.ctx = new RIPEMD160();

	/*
	 * Helpers
	 */

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;

	  if (j <= 31)
	    return (x & y) | ((~x) & z);

	  if (j <= 47)
	    return (x | (~y)) ^ z;

	  if (j <= 63)
	    return (x & z) | (y & (~z));

	  return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;

	  if (j <= 31)
	    return 0x5a827999;

	  if (j <= 47)
	    return 0x6ed9eba1;

	  if (j <= 63)
	    return 0x8f1bbcdc;

	  return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;

	  if (j <= 31)
	    return 0x5c4dd124;

	  if (j <= 47)
	    return 0x6d703ef3;

	  if (j <= 63)
	    return 0x7a6d76e9;

	  return 0x00000000;
	}

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	ripemd160 = RIPEMD160;
	return ripemd160;
}

/*!
 * hash160.js - Hash160 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

var hash160;
var hasRequiredHash160;

function requireHash160 () {
	if (hasRequiredHash160) return hash160;
	hasRequiredHash160 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const RIPEMD160 = requireRipemd160();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const rmd = new RIPEMD160();

	/**
	 * Hash160
	 */

	class Hash160 {
	  constructor() {
	    this.ctx = new SHA256();
	  }

	  init() {
	    this.ctx.init();
	    return this;
	  }

	  update(data) {
	    this.ctx.update(data);
	    return this;
	  }

	  final() {
	    const out = Buffer.alloc(32);

	    this.ctx._final(out);

	    rmd.init();
	    rmd.update(out);
	    rmd._final(out);

	    return out.slice(0, 20);
	  }

	  static hash() {
	    return new Hash160();
	  }

	  static hmac() {
	    return new HMAC(Hash160, 64);
	  }

	  static digest(data) {
	    return Hash160.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return Hash160.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = Hash160;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return Hash160.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Hash160.native = 0;
	Hash160.id = 'HASH160';
	Hash160.size = 20;
	Hash160.bits = 160;
	Hash160.blockSize = 64;
	Hash160.zero = Buffer.alloc(20, 0x00);
	Hash160.ctx = new Hash160();

	/*
	 * Expose
	 */

	hash160 = Hash160;
	return hash160;
}

/*!
 * hash256.js - Hash256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/hash.h
 */

var hash256;
var hasRequiredHash256;

function requireHash256 () {
	if (hasRequiredHash256) return hash256;
	hasRequiredHash256 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const HMAC = requireHmac();

	/**
	 * Hash256
	 */

	class Hash256 {
	  constructor() {
	    this.ctx = new SHA256();
	  }

	  init() {
	    this.ctx.init();
	    return this;
	  }

	  update(data) {
	    this.ctx.update(data);
	    return this;
	  }

	  final() {
	    const out = Buffer.alloc(32);

	    this.ctx._final(out);
	    this.ctx.init();
	    this.ctx.update(out);
	    this.ctx._final(out);

	    return out;
	  }

	  static hash() {
	    return new Hash256();
	  }

	  static hmac() {
	    return new HMAC(Hash256, 64);
	  }

	  static digest(data) {
	    return Hash256.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 32);
	    assert(Buffer.isBuffer(right) && right.length === 32);
	    return Hash256.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = Hash256;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return Hash256.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Hash256.native = 0;
	Hash256.id = 'HASH256';
	Hash256.size = 32;
	Hash256.bits = 256;
	Hash256.blockSize = 64;
	Hash256.zero = Buffer.alloc(32, 0x00);
	Hash256.ctx = new Hash256();

	/*
	 * Expose
	 */

	hash256 = Hash256;
	return hash256;
}

var binary = {};

/*!
 * binary.js - binary search utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBinary;

function requireBinary () {
	if (hasRequiredBinary) return binary;
	hasRequiredBinary = 1;
	(function (exports) {

		/**
		 * Perform a binary search on a sorted array.
		 * @param {Array} items
		 * @param {Object} key
		 * @param {Function} compare
		 * @param {Boolean?} insert
		 * @returns {Number} Index.
		 */

		exports.search = function search(items, key, compare, insert) {
		  let start = 0;
		  let end = items.length - 1;

		  while (start <= end) {
		    const pos = (start + end) >>> 1;
		    const cmp = compare(items[pos], key);

		    if (cmp === 0)
		      return pos;

		    if (cmp < 0)
		      start = pos + 1;
		    else
		      end = pos - 1;
		  }

		  if (!insert)
		    return -1;

		  return start;
		};

		/**
		 * Perform a binary insert on a sorted array.
		 * @param {Array} items
		 * @param {Object} item
		 * @param {Function} compare
		 * @returns {Number} index
		 */

		exports.insert = function insert(items, item, compare, uniq) {
		  const i = exports.search(items, item, compare, true);

		  if (uniq && i < items.length) {
		    if (compare(items[i], item) === 0)
		      return -1;
		  }

		  if (i === 0)
		    items.unshift(item);
		  else if (i === items.length)
		    items.push(item);
		  else
		    items.splice(i, 0, item);

		  return i;
		};

		/**
		 * Perform a binary removal on a sorted array.
		 * @param {Array} items
		 * @param {Object} item
		 * @param {Function} compare
		 * @returns {Boolean}
		 */

		exports.remove = function remove(items, item, compare) {
		  const i = exports.search(items, item, compare, false);

		  if (i === -1)
		    return false;

		  splice(items, i);

		  return true;
		};

		/*
		 * Helpers
		 */

		function splice(list, i) {
		  if (i === 0) {
		    list.shift();
		    return;
		  }

		  let k = i + 1;

		  while (k < list.length)
		    list[i++] = list[k++];

		  list.pop();
		} 
	} (binary));
	return binary;
}

var networks = {};

var custom = {};

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$1 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$1(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect$1(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (browser$1.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect$1(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect$1.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect$1.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];

  if (style) {
    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
           '\u001b[' + inspect$1.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect$1 &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNullOrUndefined(arg) {
  return arg == null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return Buffer$1.isBuffer(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

var _polyfillNode_util = {
  inherits: inherits,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray,
  inspect: inspect$1,
  deprecate: deprecate,
  format: format,
  debuglog: debuglog,
  promisify: promisify,
  callbackify: callbackify,
};

var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	_extend: _extend,
	callbackify: callbackify,
	debuglog: debuglog,
	default: _polyfillNode_util,
	deprecate: deprecate,
	format: format,
	inherits: inherits,
	inspect: inspect$1,
	isArray: isArray,
	isBoolean: isBoolean,
	isBuffer: isBuffer,
	isDate: isDate,
	isError: isError,
	isFunction: isFunction,
	isNull: isNull,
	isNullOrUndefined: isNullOrUndefined,
	isNumber: isNumber,
	isObject: isObject,
	isPrimitive: isPrimitive,
	isRegExp: isRegExp,
	isString: isString,
	isSymbol: isSymbol,
	isUndefined: isUndefined,
	log: log,
	promisify: promisify
});

var require$$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredCustom;

function requireCustom () {
	if (hasRequiredCustom) return custom;
	hasRequiredCustom = 1;

	const {inspect} = require$$4;

	custom.custom = inspect.custom || 'inspect';
	return custom;
}

/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */

var bn;
var hasRequiredBn;

function requireBn () {
	if (hasRequiredBn) return bn;
	hasRequiredBn = 1;

	const {custom} = requireCustom();

	/*
	 * Constants
	 */

	const zeros = [
	  '',
	  '0',
	  '00',
	  '000',
	  '0000',
	  '00000',
	  '000000',
	  '0000000',
	  '00000000',
	  '000000000',
	  '0000000000',
	  '00000000000',
	  '000000000000',
	  '0000000000000',
	  '00000000000000',
	  '000000000000000',
	  '0000000000000000',
	  '00000000000000000',
	  '000000000000000000',
	  '0000000000000000000',
	  '00000000000000000000',
	  '000000000000000000000',
	  '0000000000000000000000',
	  '00000000000000000000000',
	  '000000000000000000000000',
	  '0000000000000000000000000'
	];

	const groupSizes = [
	  0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a,
	  0x09, 0x08, 0x08, 0x07, 0x07, 0x07,
	  0x07, 0x06, 0x06, 0x06, 0x06, 0x06,
	  0x06, 0x06, 0x05, 0x05, 0x05, 0x05,
	  0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	  0x05, 0x05, 0x05, 0x05, 0x05, 0x05
	];

	const groupBases = [
	  0x00000000, 0x02000000, 0x0290d741, 0x01000000,
	  0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000,
	  0x0290d741, 0x00989680, 0x012959c3, 0x0222c000,
	  0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000,
	  0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000,
	  0x003e5185, 0x004ea360, 0x006235f7, 0x00798000,
	  0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00,
	  0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000,
	  0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400
	];

	const primes = {
	  p192: null,
	  p224: null,
	  p521: null,
	  k256: null,
	  p251: null,
	  p25519: null,
	  p448: null
	};

	const modes = {
	  NONE: 0,
	  QUO: 1,
	  REM: 2,
	  BOTH: 3,
	  EUCLID: 4,
	  ALL: 7
	};

	const WND_WIDTH = 4;
	const WND_SIZE = 1 << (WND_WIDTH - 1);

	const HAS_BIGINT = typeof BigInt === 'function';

	/**
	 * BN
	 */

	class BN {
	  constructor(num, base, endian) {
	    this.words = [0];
	    this.length = 1;
	    this.negative = 0;
	    this.red = null;
	    this.from(num, base, endian);
	  }

	  /*
	   * Addition Engine
	   */

	  _iadd(a, b) {
	    let carry = 0;
	    let i = 0;

	    // a.length > b.length
	    if (a.length < b.length)
	      [a, b] = [b, a];

	    if (a !== this)
	      this._alloc(a.length);

	    for (; i < b.length; i++) {
	      const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;

	      this.words[i] = r & 0x3ffffff;

	      carry = r >>> 26;
	    }

	    for (; carry !== 0 && i < a.length; i++) {
	      const r = (a.words[i] | 0) + carry;

	      this.words[i] = r & 0x3ffffff;

	      carry = r >>> 26;
	    }

	    this.length = a.length;

	    if (carry !== 0) {
	      this._alloc(this.length + 1);
	      this.words[this.length++] = carry;
	    } else if (a !== this) {
	      // Copy the rest of the words.
	      for (; i < a.length; i++)
	        this.words[i] = a.words[i];
	    }

	    // Note: we shouldn't need to strip here.
	    return this;
	  }

	  _iaddn(num) {
	    this.words[0] += num;

	    if (this.words[0] < 0x4000000)
	      return this;

	    // Carry.
	    let i = 0;

	    this._alloc(this.length + 1);

	    this.words[this.length] = 0;

	    for (; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      this.words[i + 1] += 1;
	    }

	    this.length = Math.max(this.length, i + 1);

	    // Note: we shouldn't need to strip here.
	    return this;
	  }

	  /*
	   * Addition
	   */

	  iadd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.negative === num.negative) {
	      // x + y == x + y
	      // (-x) + (-y) == -(x + y)
	      this._iadd(this, num);
	    } else {
	      // x + (-y) == x - y == -(y - x)
	      // (-x) + y == y - x == -(x - y)
	      const cmp = this.ucmp(num);

	      // x + (-x) == (-x) + x == 0
	      if (cmp === 0) {
	        this.words[0] = 0;
	        this.length = 1;
	        this.negative = 0;
	        return this;
	      }

	      if (cmp < 0) {
	        this._isub(num, this);
	        this.negative ^= 1;
	      } else {
	        this._isub(this, num);
	      }
	    }

	    return this;
	  }

	  iaddn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    const negative = (num < 0) | 0;

	    if (negative)
	      num = -num;

	    if (this.negative === negative) {
	      // x + y == x + y
	      // (-x) + (-y) == -(x + y)
	      this._iaddn(num);
	    } else {
	      // x + (-y) == x - y == -(y - x)
	      // (-x) + y == y - x == -(x - y)
	      if (this.length === 1 && this.words[0] < num) {
	        this.words[0] = num - this.words[0];
	        this.negative ^= 1;
	      } else {
	        this._isubn(num);
	      }
	    }

	    return this;
	  }

	  add(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (num.length > this.length)
	      return num.clone().iadd(this);

	    return this.clone().iadd(num);
	  }

	  addn(num) {
	    return this.clone().iaddn(num);
	  }

	  /*
	   * Subtraction Engine
	   */

	  _isub(a, b) {
	    let carry = 0;
	    let i = 0;

	    // a > b
	    assert(a.length >= b.length);

	    if (a !== this)
	      this._alloc(a.length);

	    for (; i < b.length; i++) {
	      const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;

	      carry = r >> 26;

	      this.words[i] = r & 0x3ffffff;
	    }

	    for (; carry !== 0 && i < a.length; i++) {
	      const r = (a.words[i] | 0) + carry;

	      carry = r >> 26;

	      this.words[i] = r & 0x3ffffff;
	    }

	    assert(carry === 0);

	    // Copy rest of the words.
	    if (a !== this) {
	      for (; i < a.length; i++)
	        this.words[i] = a.words[i];
	    }

	    this.length = Math.max(this.length, i);

	    return this._strip();
	  }

	  _isubn(num) {
	    this.words[0] -= num;

	    if (this.words[0] >= 0)
	      return this._normalize();

	    assert(this.length !== 1);

	    // Carry.
	    this._alloc(this.length + 1);

	    for (let i = 0; i < this.length && this.words[i] < 0; i++) {
	      this.words[i] += 0x4000000;
	      this.words[i + 1] -= 1;
	    }

	    this.words[this.length] = 0;

	    return this._strip();
	  }

	  /*
	   * Subtraction
	   */

	  isub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.negative !== num.negative) {
	      // x - (-y) == x + y
	      // (-x) - y == -(x + y)
	      this._iadd(this, num);
	    } else {
	      // x - y == x - y == -(y - x)
	      // (-x) - (-y) == y - x == -(x - y)
	      const cmp = this.ucmp(num);

	      // x - x == 0
	      if (cmp === 0) {
	        this.words[0] = 0;
	        this.length = 1;
	        this.negative = 0;
	        return this;
	      }

	      if (cmp < 0) {
	        this._isub(num, this);
	        this.negative ^= 1;
	      } else {
	        this._isub(this, num);
	      }
	    }

	    return this;
	  }

	  isubn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    const negative = (num < 0) | 0;

	    if (negative)
	      num = -num;

	    if (this.negative !== negative) {
	      // x - (-y) == x + y
	      // (-x) - y == -(x + y)
	      this._iaddn(num);
	    } else {
	      // x - y == x - y == -(y - x)
	      // (-x) - (-y) == y - x == -(x - y)
	      if (this.length === 1 && this.words[0] < num) {
	        this.words[0] = num - this.words[0];
	        this.negative ^= 1;
	      } else {
	        this._isubn(num);
	      }
	    }

	    return this;
	  }

	  sub(num) {
	    return this.clone().isub(num);
	  }

	  subn(num) {
	    return this.clone().isubn(num);
	  }

	  /*
	   * Multiplication Engine
	   */

	  _mul(num, out) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    enforce(BN.isBN(out), 'out', 'bignum');

	    if (this.length === 10 && num.length === 10)
	      return comb10MulTo(this, num, out);

	    const len = this.length + num.length;

	    if (len < 63)
	      return smallMulTo(this, num, out);

	    if (len < 1024)
	      return bigMulTo(this, num, out);

	    return jumboMulTo(this, num, out);
	  }

	  /*
	   * Multiplication
	   */

	  imul(num) {
	    return this.mul(num)._move(this);
	  }

	  imuln(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    const neg = (num < 0) | 0;

	    if (neg)
	      num = -num;

	    // Carry.
	    let carry = 0;

	    for (let i = 0; i < this.length; i++) {
	      const w = this.words[i] * num;
	      const lo = (w & 0x3ffffff) + (carry & 0x3ffffff);

	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      carry += lo >>> 26;

	      this.words[i] = lo & 0x3ffffff;
	    }

	    this.negative ^= neg;

	    if (carry !== 0) {
	      this._alloc(this.length + 1);
	      this.words[this.length++] = carry;
	    } else {
	      this._strip();
	    }

	    return this;
	  }

	  mul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    const len = this.length + num.length;
	    const out = new BN();

	    out.words = new Array(len);

	    for (let i = 0; i < len; i ++)
	      out.words[i] = 0;

	    return this._mul(num, out);
	  }

	  muln(num) {
	    return this.clone().imuln(num);
	  }

	  /*
	   * Multiplication + Shift
	   */

	  mulShift(num, bits) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    const r = this.mul(num);
	    const b = r.utestn(bits - 1);

	    r.iushrn(bits);

	    if (this.negative ^ num.negative)
	      return r.isubn(b);

	    return r.iaddn(b);
	  }

	  /*
	   * Division Engine
	   */

	  _div(num, flags) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    assert((flags & modes.ALL) === flags);
	    assert(flags !== modes.NONE);

	    const a = this;
	    const b = num;

	    nonzero(!b.isZero());

	    if (a.isZero())
	      return [new BN(0), new BN(0)];

	    const as = a.negative;
	    const bs = b.negative;

	    a.negative = 0;
	    b.negative = 0;

	    let q = null;
	    let r = null;

	    if (a.ucmp(b) < 0) {
	      if (flags & modes.QUO)
	        q = new BN(0);

	      if (flags & modes.REM)
	        r = a.clone();
	    } else if (b.length === 1) {
	      if (flags & modes.QUO)
	        q = a.quon(b.words[0]);

	      if (flags & modes.REM)
	        r = a.remn(b.words[0]);
	    } else {
	      [q, r] = a._wordDiv(b, flags);
	    }

	    a.negative = as;
	    b.negative = bs;

	    if (flags & modes.QUO) {
	      q.negative = a.negative ^ b.negative;
	      q._normalize();
	    }

	    if (flags & modes.REM) {
	      r.negative = a.negative;
	      r._normalize();
	    }

	    if (flags & modes.EUCLID) {
	      if (flags & modes.QUO) {
	        assert((flags & modes.REM) !== 0);

	        if (r.negative !== 0) {
	          if (b.negative !== 0)
	            q.iaddn(1);
	          else
	            q.isubn(1);
	        }
	      }

	      if (flags & modes.REM) {
	        if (r.negative !== 0) {
	          if (b.negative !== 0)
	            r.isub(b);
	          else
	            r.iadd(b);
	        }
	      }
	    }

	    return [q, r];
	  }

	  _wordDiv(num, flags) {
	    let a = this.clone();
	    let b = num;
	    let q = null;
	    let hi;

	    // Normalize.
	    const word = b.words[b.length - 1] | 0;
	    const shift = 26 - countBits(word);

	    if (shift !== 0) {
	      b = b.clone();

	      a.iushln(shift);
	      b.iushln(shift);

	      hi = b.words[b.length - 1] | 0;
	    } else {
	      hi = word;
	    }

	    // Initialize quotient.
	    const m = a.length - b.length;

	    assert(m >= 0);

	    if (flags & modes.QUO) {
	      q = new BN(0);
	      q.length = m + 1;
	      q.words = new Array(q.length);

	      for (let i = 0; i < q.length; i++)
	        q.words[i] = 0;
	    }

	    // Diff.
	    const d = a.clone();

	    d._ishlnsubmul(b, 1, m);

	    if (d.negative === 0) {
	      if (q)
	        q.words[m] = 1;

	      a = d;
	    }

	    // Divide.
	    for (let j = m - 1; j >= 0; j--) {
	      const ahi = a.words[b.length + j];
	      const alo = a.words[b.length + j - 1];
	      const quo = ((ahi * 0x4000000 + alo) / hi) | 0;

	      let qj = Math.min(quo, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);

	      while (a.negative !== 0) {
	        qj -= 1;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        a.ineg();
	      }

	      if (q)
	        q.words[j] = qj;
	    }

	    // Strip.
	    if (q)
	      q._strip();

	    // Denormalize.
	    // Note: we shouldn't need to strip `a` here.
	    if ((flags & modes.REM) && shift !== 0)
	      a.iushrn(shift);

	    return [q, a];
	  }

	  _ishlnsubmul(num, mul, shift) {
	    let carry = 0;
	    let i = 0;

	    this._expand(num.length + shift);

	    for (; i < num.length; i++) {
	      const k = (this.words[i + shift] | 0) + carry;
	      const r = num.words[i] * mul;
	      const w = k - (r & 0x3ffffff);

	      carry = (w >> 26) - ((r / 0x4000000) | 0);

	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    for (; i < this.length - shift; i++) {
	      const w = (this.words[i + shift] | 0) + carry;

	      carry = w >> 26;

	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0)
	      return this._strip();

	    // Subtraction overflow.
	    assert(carry === -1);

	    carry = 0;

	    for (let i = 0; i < this.length; i++) {
	      const w = -(this.words[i] | 0) + carry;

	      carry = w >> 26;

	      this.words[i] = w & 0x3ffffff;
	    }

	    this.negative = 1;

	    return this._strip();
	  }

	  /*
	   * Truncation Division + Modulo
	   */

	  quorem(num) {
	    return this._div(num, modes.BOTH);
	  }

	  /*
	   * Truncation Division
	   */

	  iquo(num) {
	    return this.quo(num)._move(this);
	  }

	  iquon(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    nonzero(num !== 0);

	    const neg = (num < 0) | 0;

	    if (neg)
	      num = -num;

	    let carry = 0;

	    for (let i = this.length - 1; i >= 0; i--) {
	      const w = (this.words[i] | 0) + carry * 0x4000000;

	      this.words[i] = (w / num) | 0;

	      carry = w % num;
	    }

	    this.negative ^= neg;

	    return this._strip();
	  }

	  quo(num) {
	    return this._div(num, modes.QUO)[0];
	  }

	  quon(num) {
	    return this.clone().iquon(num);
	  }

	  /*
	   * Truncation Modulo
	   */

	  irem(num) {
	    return this.rem(num)._move(this);
	  }

	  iremn(num) {
	    let m = this.remrn(num);

	    if (m < 0)
	      m = -m;

	    this.words[0] = m;
	    this.length = 1;

	    return this._normalize();
	  }

	  rem(num) {
	    return this._div(num, modes.REM)[1];
	  }

	  remn(num) {
	    return this.clone().iremn(num);
	  }

	  remrn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    nonzero(num !== 0);

	    if (num < 0)
	      num = -num;

	    const p = (1 << 26) % num;

	    let acc = 0;

	    for (let i = this.length - 1; i >= 0; i--)
	      acc = (p * acc + (this.words[i] | 0)) % num;

	    return this.negative !== 0 ? (-acc | 0) : acc;
	  }

	  /*
	   * Euclidean Division + Modulo
	   */

	  divmod(num) {
	    return this._div(num, modes.BOTH | modes.EUCLID);
	  }

	  /*
	   * Euclidean Division
	   */

	  idiv(num) {
	    return this.div(num)._move(this);
	  }

	  idivn(num) {
	    if (this.negative === 0)
	      return this.iquon(num);

	    const r = this.remrn(num);

	    this.iquon(num);

	    if (r < 0) {
	      if (num < 0)
	        this.iaddn(1);
	      else
	        this.isubn(1);
	    }

	    return this;
	  }

	  div(num) {
	    return this._div(num, modes.BOTH | modes.EUCLID)[0];
	  }

	  divn(num) {
	    return this.clone().idivn(num);
	  }

	  /*
	   * Euclidean Modulo
	   */

	  imod(num) {
	    if (this.ucmp(num) < 0) {
	      if (this.negative !== 0) {
	        this._isub(num, this);
	        this.negative = 0;
	      }
	      return this;
	    }

	    return this.mod(num)._move(this);
	  }

	  imodn(num) {
	    this.words[0] = this.modrn(num);
	    this.length = 1;
	    this.negative = 0;
	    return this;
	  }

	  mod(num) {
	    return this._div(num, modes.REM | modes.EUCLID)[1];
	  }

	  modn(num) {
	    return this.clone().imodn(num);
	  }

	  modrn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    let r = this.remrn(num);

	    if (r < 0) {
	      if (num < 0)
	        r -= num;
	      else
	        r += num;
	    }

	    return r;
	  }

	  /*
	   * Round Division
	   */

	  divRound(num) {
	    const [q, r] = this.quorem(num);

	    // Fast case - exact division.
	    if (r.isZero())
	      return q;

	    const bit = num.words[0] & 1;

	    num.iushrn(1);

	    const cmp = r.ucmp(num);

	    num.iushln(1);

	    num.words[0] |= bit;

	    // Round down.
	    if (cmp < 0 || (num.isOdd() && cmp === 0))
	      return q;

	    // Round up.
	    if (this.negative ^ num.negative)
	      return q.isubn(1);

	    return q.iaddn(1);
	  }

	  /*
	   * Exponentiation
	   */

	  ipow(num) {
	    return this.pow(num)._move(this);
	  }

	  ipown(num) {
	    return this.pown(num)._move(this);
	  }

	  pow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    let b = countBits(num.words[num.length - 1]);
	    let r = new BN(1);

	    for (let i = num.length - 1; i >= 0; i--) {
	      const word = num.words[i];

	      for (let j = b - 1; j >= 0; j--) {
	        r = r.sqr();

	        if ((word >> j) & 1)
	          r = r.mul(this);
	      }

	      b = 26;
	    }

	    return r;
	  }

	  pown(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if (num < 0)
	      num = -num;

	    if (num === 0)
	      return new BN(1);

	    if (num === 1)
	      return this.clone();

	    const bits = countBits(num);

	    let r = this;

	    for (let i = bits - 2; i >= 0; i--) {
	      r = r.sqr();

	      if ((num >> i) & 1)
	        r = r.mul(this);
	    }

	    return r;
	  }

	  isqr() {
	    return this.imul(this);
	  }

	  sqr() {
	    return this.mul(this);
	  }

	  /*
	   * Roots Engine
	   */

	  _rootrem(pow, rem) {
	    enforce((pow >>> 0) === pow, 'num', 'uint32');

	    if (pow === 0)
	      throw new RangeError('Zeroth root.');

	    if (~pow & this.negative)
	      throw new RangeError('Negative with even root.');

	    if (this.ucmpn(1) <= 0)
	      return [this.clone(), new BN(0)];

	    let u = new BN(0);
	    let t = BN.shift(1, this.bitLength() / pow + 1 | 0);
	    let v, r;

	    if (this.negative !== 0)
	      t.ineg();

	    if (pow === 2) {
	      do {
	        u = t;
	        t = this.quo(u);
	        t.iadd(u);
	        t.iushrn(1);
	      } while (t.ucmp(u) < 0);
	    } else {
	      do {
	        u = t;
	        t = u.pown(pow - 1);
	        t = this.quo(t);
	        v = u.muln(pow - 1);
	        t.iadd(v);
	        t = t.quon(pow);
	      } while (t.ucmp(u) < 0);
	    }

	    if (rem) {
	      t = u.pown(pow);
	      r = this.sub(t);
	    }

	    return [u, r];
	  }

	  /*
	   * Roots
	   */

	  rootrem(pow) {
	    return this._rootrem(pow, 1);
	  }

	  iroot(pow) {
	    return this.root(pow)._move(this);
	  }

	  root(pow) {
	    return this._rootrem(pow, 0)[0];
	  }

	  isPower(pow) {
	    enforce((pow >>> 0) === pow, 'num', 'uint32');

	    if (pow === 0 || (~pow & this.negative))
	      return false;

	    const [, r] = this.rootrem(pow);

	    return r.sign() === 0;
	  }

	  sqrtrem() {
	    return this.rootrem(2);
	  }

	  isqrt() {
	    return this.sqrt()._move(this);
	  }

	  sqrt() {
	    return this.root(2);
	  }

	  isSquare() {
	    return this.isPower(2);
	  }

	  /*
	   * AND
	   */

	  iand(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    let x = this;
	    let y = num;

	    if (x === y)
	      return x;

	    if ((x.negative | y.negative) === 0)
	      return x.iuand(y);

	    if ((x.negative & y.negative) === 1) {
	      // (-x) & (-y) == ~(x-1) & ~(y-1)
	      //             == ~((x-1) | (y-1))
	      //             == -(((x-1) | (y-1)) + 1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuor(y);
	      x.isubn(1);
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    if (x.negative !== 0)
	      [x, y] = [y.clone(), x];

	    // x & (-y) == x & ~(y-1)
	    //          == x & ~(y-1)
	    const width = x.bitLength();

	    y.iaddn(1);
	    y.inotn(width);
	    x.iuand(y);
	    y.inotn(width);
	    y.isubn(1);

	    return x._move(this);
	  }

	  iandn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if ((this.negative | (num < 0)) !== 0)
	      return this.iand(new BN(num));

	    this.words[0] &= num;
	    this.length = 1;

	    return this;
	  }

	  and(num) {
	    return this.clone().iand(num);
	  }

	  andn(num) {
	    return this.clone().iandn(num);
	  }

	  andrn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if ((this.negative | (num < 0)) !== 0) {
	      const n = this.iand(new BN(num));

	      if (n.length > 1)
	        throw new RangeError('Number exceeds 26 bits.');

	      return n.negative !== 0 ? -n.words[0] : n.words[0];
	    }

	    return this.words[0] & num;
	  }

	  /*
	   * Unsigned AND
	   */

	  iuand(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    this.length = Math.min(this.length, num.length);

	    for (let i = 0; i < this.length; i++)
	      this.words[i] &= num.words[i];

	    return this._strip();
	  }

	  iuandn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    this.words[0] &= Math.abs(num);
	    this.length = 1;

	    return this._normalize();
	  }

	  uand(num) {
	    return this.clone().iuand(num);
	  }

	  uandn(num) {
	    return this.clone().iuandn(num);
	  }

	  uandrn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    const n = this.words[0] & Math.abs(num);

	    return this.negative !== 0 ? (-n | 0) : n;
	  }

	  /*
	   * OR
	   */

	  ior(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    let x = this;
	    let y = num;

	    if (x === y)
	      return x;

	    if ((x.negative | y.negative) === 0)
	      return x.iuor(y);

	    if ((x.negative & y.negative) === 1) {
	      // (-x) | (-y) == ~(x-1) | ~(y-1)
	      //             == ~((x-1) & (y-1))
	      //             == -(((x-1) & (y-1)) + 1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuand(y);
	      x.isubn(1);
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    y = y.clone();

	    if (x.negative !== 0)
	      [x, y] = [y, x];

	    // x | (-y) == x | ~(y-1)
	    //          == ~((y-1) & ~x)
	    //          == -(((y-1) & ~x) + 1)
	    y.iaddn(1);
	    x.inotn(y.bitLength());
	    y.iuand(x);
	    y.isubn(1);

	    return y._move(this);
	  }

	  iorn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if ((this.negative | (num < 0)) !== 0)
	      return this.ior(new BN(num));

	    this.words[0] |= num;

	    return this;
	  }

	  or(num) {
	    return this.clone().ior(num);
	  }

	  orn(num) {
	    return this.clone().iorn(num);
	  }

	  /*
	   * Unsigned OR
	   */

	  iuor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    this._expand(num.length);

	    for (let i = 0; i < num.length; i++)
	      this.words[i] |= num.words[i];

	    // Note: we shouldn't need to strip here.
	    return this;
	  }

	  iuorn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    this.words[0] |= Math.abs(num);

	    return this;
	  }

	  uor(num) {
	    return this.clone().iuor(num);
	  }

	  uorn(num) {
	    return this.clone().iuorn(num);
	  }

	  /*
	   * XOR
	   */

	  ixor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    let x = this;
	    let y = num;

	    if (x === y) {
	      x.words[0] = 0;
	      x.length = 1;
	      x.negative = 0;
	      return x;
	    }

	    if ((x.negative | y.negative) === 0)
	      return x.iuxor(y);

	    if ((x.negative & y.negative) === 1) {
	      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)
	      //             == (x-1) ^ (y-1)
	      x.iaddn(1);
	      y.iaddn(1);
	      x.iuxor(y);
	      x.ineg();
	      y.isubn(1);
	      return x;
	    }

	    // Assume x is the positive number.
	    if (x.negative !== 0)
	      [x, y] = [y.clone(), x];

	    // x ^ (-y) == x ^ ~(y-1)
	    //          == ~(x ^ (y-1))
	    //          == -((x ^ (y-1)) + 1)
	    y.iaddn(1);
	    x.iuxor(y);
	    x.iaddn(1);
	    x.ineg();
	    y.isubn(1);

	    return x._move(this);
	  }

	  ixorn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if ((this.negative | (num < 0)) !== 0)
	      return this.ixor(new BN(num));

	    this.words[0] ^= num;

	    return this;
	  }

	  xor(num) {
	    return this.clone().ixor(num);
	  }

	  xorn(num) {
	    return this.clone().ixorn(num);
	  }

	  /*
	   * Unsigned XOR
	   */

	  iuxor(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    let a = this;
	    let b = num;

	    if (a.length < b.length)
	      [a, b] = [b, a];

	    let i = 0;

	    for (; i < b.length; i++)
	      this.words[i] = a.words[i] ^ b.words[i];

	    if (a !== this) {
	      this._alloc(a.length);

	      for (; i < a.length; i++)
	        this.words[i] = a.words[i];
	    }

	    this.length = a.length;

	    return this._strip();
	  }

	  iuxorn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    this.words[0] ^= Math.abs(num);

	    return this._normalize();
	  }

	  uxor(num) {
	    return this.clone().iuxor(num);
	  }

	  uxorn(num) {
	    return this.clone().iuxorn(num);
	  }

	  /*
	   * NOT
	   */

	  inot() {
	    if (this.negative !== 0) {
	      // ~(-x) == ~(~(x-1)) == x-1
	      this.ineg().isubn(1);
	    } else {
	      // ~x == -x-1 == -(x+1)
	      this.iaddn(1).ineg();
	    }
	    return this;
	  }

	  not() {
	    return this.clone().inot();
	  }

	  inotn(width) {
	    enforce((width >>> 0) === width, 'width', 'uint32');

	    const r = width % 26;

	    let s = Math.ceil(width / 26);
	    let i = 0;

	    // Extend the buffer with leading zeroes.
	    this._expand(s);

	    if (r > 0)
	      s -= 1;

	    // Handle complete words.
	    for (; i < s; i++)
	      this.words[i] ^= 0x3ffffff;

	    // Handle the residue.
	    if (r > 0)
	      this.words[i] ^= (1 << r) - 1;

	    // And remove leading zeroes.
	    return this._strip();
	  }

	  notn(width) {
	    return this.clone().inotn(width);
	  }

	  /*
	   * Left Shift
	   */

	  ishl(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.ishln(num.toNumber());
	  }

	  ishln(bits) {
	    return this.iushln(bits);
	  }

	  shl(num) {
	    return this.clone().ishl(num);
	  }

	  shln(bits) {
	    return this.clone().ishln(bits);
	  }

	  /*
	   * Unsigned Left Shift
	   */

	  iushl(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.iushln(num.toNumber());
	  }

	  iushln(bits) {
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    const r = bits % 26;
	    const s = (bits - r) / 26;
	    const mask = ((1 << r) - 1) << (26 - r);

	    if (r !== 0) {
	      let carry = 0;

	      for (let i = 0; i < this.length; i++) {
	        const ncarry = this.words[i] & mask;
	        const c = ((this.words[i] | 0) - ncarry) << r;

	        this.words[i] = c | carry;

	        carry = ncarry >>> (26 - r);
	      }

	      if (carry !== 0) {
	        this._alloc(this.length + 1);
	        this.words[this.length++] = carry;
	      }
	    }

	    if (s !== 0) {
	      this._alloc(this.length + s);

	      for (let i = this.length - 1; i >= 0; i--)
	        this.words[i + s] = this.words[i];

	      for (let i = 0; i < s; i++)
	        this.words[i] = 0;

	      this.length += s;
	    }

	    return this._strip();
	  }

	  ushl(num) {
	    return this.clone().iushl(num);
	  }

	  ushln(bits) {
	    return this.clone().iushln(bits);
	  }

	  /*
	   * Right Shift Engine
	   */

	  _split(bits, output) {
	    const r = bits % 26;
	    const s = Math.min((bits - r) / 26, this.length);
	    const mask = (1 << r) - 1;

	    // Extended mode, copy masked part.
	    if (output) {
	      output._alloc(s);

	      for (let i = 0; i < s; i++)
	        output.words[i] = this.words[i];

	      output.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (let i = 0; i < this.length; i++)
	        this.words[i] = this.words[i + s];
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    let carry = 0;

	    if (r !== 0) {
	      for (let i = this.length - 1; i >= 0; i--) {
	        const word = this.words[i] | 0;

	        this.words[i] = (carry << (26 - r)) | (word >>> r);

	        carry = word & mask;
	      }
	    }

	    // Push carried bits as a mask.
	    if (output) {
	      if (carry !== 0) {
	        output._alloc(output.length + 1);
	        output.words[output.length++] = carry;
	      } else {
	        if (output.length === 0)
	          output.words[output.length++] = 0;

	        output._strip();
	      }
	    }

	    return this._strip();
	  }

	  /*
	   * Right Shift
	   */

	  ishr(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.ishrn(num.toNumber());
	  }

	  ishrn(bits) {
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    if (this.negative !== 0) {
	      // (-x) >> y == ~(x-1) >> y
	      //           == ~((x-1) >> y)
	      //           == -(((x-1) >> y) + 1)
	      this.iaddn(1);
	      this.iushrn(bits);
	      this.isubn(1);
	      return this;
	    }

	    return this.iushrn(bits);
	  }

	  shr(num) {
	    return this.clone().ishr(num);
	  }

	  shrn(bits) {
	    return this.clone().ishrn(bits);
	  }

	  /*
	   * Unsigned Right Shift
	   */

	  iushr(num) {
	    enforce(BN.isBN(num), 'bits', 'bignum');
	    enforce(num.bitLength() <= 32, 'bits', 'uint32');
	    return this.iushrn(num.toNumber());
	  }

	  iushrn(bits) {
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');
	    return this._split(bits, null);
	  }

	  ushr(num) {
	    return this.clone().iushr(num);
	  }

	  ushrn(bits) {
	    return this.clone().iushrn(bits);
	  }

	  /*
	   * Bit Manipulation
	   */

	  setn(bit, val) {
	    enforce((bit >>> 0) === bit, 'bit', 'uint32');

	    if (this.negative !== 0) {
	      this.iaddn(1);
	      this.usetn(bit, !val);
	      this.isubn(1);
	      return this;
	    }

	    return this.usetn(bit, val);
	  }

	  usetn(bit, val) {
	    enforce((bit >>> 0) === bit, 'bit', 'uint32');

	    const r = bit % 26;
	    const s = (bit - r) / 26;

	    this._expand(s + 1);

	    if (val)
	      this.words[s] |= (1 << r);
	    else
	      this.words[s] &= ~(1 << r);

	    return this._strip();
	  }

	  testn(bit) {
	    enforce((bit >>> 0) === bit, 'bit', 'uint32');

	    const r = bit % 26;
	    const s = (bit - r) / 26;

	    // Fast case: bit is much higher than all existing words.
	    if (this.length <= s)
	      return this.negative;

	    // Check bit and return.
	    const w = this.words[s];
	    const val = (w >> r) & 1;

	    if (this.negative !== 0) {
	      if (r > 0 && (w & ((1 << r) - 1)))
	        return val ^ 1;

	      let j = s;

	      while (j--) {
	        if (this.words[j] > 0)
	          return val ^ 1;
	      }
	    }

	    return val;
	  }

	  utestn(bit) {
	    enforce((bit >>> 0) === bit, 'bit', 'uint32');

	    const r = bit % 26;
	    const s = (bit - r) / 26;

	    // Fast case: bit is much higher than all existing words.
	    if (this.length <= s)
	      return 0;

	    // Check bit and return.
	    return (this.words[s] >> r) & 1;
	  }

	  imaskn(bits) {
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    if (this.negative !== 0) {
	      this.iaddn(1);
	      this.inotn(bits + 1);
	      this.ineg();
	    }

	    return this.iumaskn(bits);
	  }

	  maskn(bits) {
	    return this.clone().imaskn(bits);
	  }

	  iumaskn(bits) {
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    const r = bits % 26;

	    let s = (bits - r) / 26;

	    if (this.length <= s)
	      return this;

	    if (r !== 0)
	      s += 1;

	    this.length = Math.min(s, this.length);

	    if (r !== 0)
	      this.words[this.length - 1] &= (1 << r) - 1;

	    if (this.length === 0)
	      this.words[this.length++] = 0;

	    return this._strip();
	  }

	  umaskn(bits) {
	    return this.clone().iumaskn(bits);
	  }

	  andln(num) {
	    return this.words[0] & num;
	  }

	  bit(pos) {
	    return this.utestn(pos);
	  }

	  bits(pos, width) {
	    enforce((pos >>> 0) === pos, 'pos', 'uint32');
	    enforce((width >>> 0) === width, 'width', 'uint32');
	    enforce(width <= 26, 'width', 'width');

	    const shift = pos % 26;
	    const index = (pos - shift) / 26;

	    if (index >= this.length)
	      return 0;

	    let bits = (this.words[index] >> shift) & ((1 << width) - 1);

	    if (shift + width > 26 && index + 1 < this.length) {
	      const more = shift + width - 26;
	      const next = this.words[index + 1] & ((1 << more) - 1);

	      bits |= next << (26 - shift);
	    }

	    return bits;
	  }

	  /*
	   * Negation
	   */

	  ineg() {
	    if (!this.isZero())
	      this.negative ^= 1;

	    return this;
	  }

	  neg() {
	    return this.clone().ineg();
	  }

	  iabs() {
	    this.negative = 0;
	    return this;
	  }

	  abs() {
	    return this.clone().iabs();
	  }

	  /*
	   * Comparison
	   */

	  cmp(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.negative !== num.negative)
	      return num.negative - this.negative;

	    const res = this.ucmp(num);

	    if (this.negative !== 0)
	      return -res | 0;

	    return res;
	  }

	  cmpn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    const negative = (num < 0) | 0;

	    if (this.negative !== negative)
	      return negative - this.negative;

	    const res = this.ucmpn(num);

	    if (this.negative !== 0)
	      return -res | 0;

	    return res;
	  }

	  eq(num) {
	    return this.cmp(num) === 0;
	  }

	  eqn(num) {
	    return this.cmpn(num) === 0;
	  }

	  gt(num) {
	    return this.cmp(num) > 0;
	  }

	  gtn(num) {
	    return this.cmpn(num) > 0;
	  }

	  gte(num) {
	    return this.cmp(num) >= 0;
	  }

	  gten(num) {
	    return this.cmpn(num) >= 0;
	  }

	  lt(num) {
	    return this.cmp(num) < 0;
	  }

	  ltn(num) {
	    return this.cmpn(num) < 0;
	  }

	  lte(num) {
	    return this.cmp(num) <= 0;
	  }

	  lten(num) {
	    return this.cmpn(num) <= 0;
	  }

	  sign() {
	    if (this.negative !== 0)
	      return -1;

	    if (this.length === 1 && this.words[0] === 0)
	      return 0;

	    return 1;
	  }

	  isZero() {
	    return this.length === 1 && this.words[0] === 0;
	  }

	  isNeg() {
	    return this.negative !== 0;
	  }

	  isPos() {
	    return this.negative === 0;
	  }

	  isOdd() {
	    return (this.words[0] & 1) === 1;
	  }

	  isEven() {
	    return (this.words[0] & 1) === 0;
	  }

	  /*
	   * Unsigned Comparison
	   */

	  ucmp(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.length < num.length)
	      return -1;

	    if (this.length > num.length)
	      return 1;

	    for (let i = this.length - 1; i >= 0; i--) {
	      const a = this.words[i] | 0;
	      const b = num.words[i] | 0;

	      if (a === b)
	        continue;

	      return (a > b) - (a < b);
	    }

	    return 0;
	  }

	  ucmpn(num) {
	    enforce(isSMI(num), 'num', 'smi');

	    if (this.length > 1)
	      return 1;

	    const w = this.words[0] | 0;

	    if (num < 0)
	      num = -num;

	    return (w > num) - (w < num);
	  }

	  /*
	   * Number Theoretic Functions
	   */

	  legendre(num) {
	    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
	    return this.toRed(red).redLegendre();
	  }

	  jacobi(num) {
	    // See: A Binary Algorithm for the Jacobi Symbol
	    //   J. Shallit, J. Sorenson
	    //   Page 3, Section 3
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (num.isZero() || num.isEven())
	      throw new Error('jacobi: `num` must be odd.');

	    let a = this._cloneNormal();
	    let b = num.clone();
	    let j = 1;

	    if (b.isNeg()) {
	      if (a.isNeg())
	        j = -1;
	      b.ineg();
	    }

	    if (a.isNeg() || a.ucmp(b) >= 0)
	      a.imod(b);

	    while (!a.isZero()) {
	      const bits = a._makeOdd();

	      if (bits & 1) {
	        const bmod8 = b.andln(7);

	        if (bmod8 === 3 || bmod8 === 5)
	          j = -j;
	      }

	      if (a.ucmp(b) < 0) {
	        [a, b] = [b, a];

	        if (a.andln(3) === 3 && b.andln(3) === 3)
	          j = -j;
	      }

	      a._isub(a, b).iushrn(1);

	      const bmod8 = b.andln(7);

	      if (bmod8 === 3 || bmod8 === 5)
	        j = -j;
	    }

	    if (b.cmpn(1) !== 0)
	      return 0;

	    return j;
	  }

	  kronecker(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.isZero())
	      return num.ucmpn(1) === 0 ? 1 : 0;

	    if (num.isZero())
	      return this.ucmpn(1) === 0 ? 1 : 0;

	    if (((this.words[0] | num.words[0]) & 1) === 0)
	      return 0;

	    const x = this;
	    const y = num.clone();
	    const bits = y._makeOdd();
	    const table = [0, 1, 0, -1, 0, -1, 0, 1];

	    let k = x.jacobi(y);

	    if (bits & 1)
	      k *= table[x.andln(7)];

	    return k | 0;
	  }

	  igcd(num) {
	    return this.gcd(num)._move(this);
	  }

	  gcd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.isZero())
	      return num.abs();

	    if (num.isZero())
	      return this.abs();

	    let a = this.clone();
	    let b = num.clone();

	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two.
	    const shift = a._factor2(b);

	    if (shift !== 0) {
	      a.iushrn(shift);
	      b.iushrn(shift);
	    }

	    for (;;) {
	      a._makeOdd();
	      b._makeOdd();

	      const cmp = a.ucmp(b);

	      if (cmp < 0) {
	        // a > b
	        [a, b] = [b, a];
	      } else if (cmp === 0 || b.ucmpn(1) === 0) {
	        // Break if a == b.
	        // Break if b == 1 to avoid repeated subtraction.
	        break;
	      }

	      a._isub(a, b);
	    }

	    return b.iushln(shift);
	  }

	  ilcm(num) {
	    return this.lcm(num)._move(this);
	  }

	  lcm(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.isZero() || num.isZero())
	      return new BN(0);

	    return this.quo(this.gcd(num)).mul(num).iabs();
	  }

	  egcd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    if (this.isZero()) {
	      return [
	        new BN(0),
	        new BN(num.sign()),
	        num.abs()
	      ];
	    }

	    if (num.isZero()) {
	      return [
	        new BN(this.sign()),
	        new BN(0),
	        this.abs()
	      ];
	    }

	    const x = this.clone();
	    const y = num.clone();

	    x.negative = 0;
	    y.negative = 0;

	    // A * x + B * y = x
	    const A = new BN(1);
	    const B = new BN(0);

	    // C * x + D * y = y
	    const C = new BN(0);
	    const D = new BN(1);

	    // Remove common factor of two.
	    const g = x._factor2(y);

	    if (g > 0) {
	      x.iushrn(g);
	      y.iushrn(g);
	    }

	    const xp = x.clone();
	    const yp = y.clone();

	    while (!x.isZero()) {
	      let i = x._makeOdd();
	      let j = y._makeOdd();

	      while (i--) {
	        if (A.isOdd() || B.isOdd()) {
	          A.iadd(yp);
	          B.isub(xp);
	        }

	        A.iushrn(1);
	        B.iushrn(1);
	      }

	      while (j--) {
	        if (C.isOdd() || D.isOdd()) {
	          C.iadd(yp);
	          D.isub(xp);
	        }

	        C.iushrn(1);
	        D.iushrn(1);
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    if (this.negative !== 0)
	      C.ineg();

	    if (num.negative !== 0)
	      D.ineg();

	    return [C, D, y.iushln(g)];
	  }

	  iinvert(num) {
	    return this.invert(num)._move(this);
	  }

	  invert(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    range(num.sign() > 0, 'invert');

	    if (num.isOdd())
	      return this._invertp(num);

	    if (num.cmpn(1) === 0)
	      throw new RangeError('Not invertible.');

	    const [s,, g] = this.egcd(num);

	    if (g.cmpn(1) !== 0)
	      throw new RangeError('Not invertible.');

	    return s.imod(num);
	  }

	  ifermat(num) {
	    return this.fermat(num)._move(this);
	  }

	  fermat(num) {
	    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
	    return this.toRed(red).redFermat().fromRed();
	  }

	  ipowm(y, m, mont) {
	    return this.powm(y, m, mont)._move(this);
	  }

	  powm(y, m, mont) {
	    const red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);
	    return this.toRed(red).redPow(y).fromRed();
	  }

	  ipowmn(y, m, mont) {
	    return this.powmn(y, m, mont)._move(this);
	  }

	  powmn(y, m, mont) {
	    const red = mont ? BN.mont(m) : BN.red(m);
	    return this.toRed(red).redPown(y).fromRed();
	  }

	  isqrtm(p) {
	    return this.sqrtm(p)._move(this);
	  }

	  sqrtm(p) {
	    enforce(BN.isBN(p), 'p', 'bignum');

	    let red;

	    if (p.andln(3) === 3 || p.andln(7) === 5) {
	      // Probably not worth the setup.
	      red = BN.red(p);
	    } else {
	      red = BN.mont(p);
	    }

	    return this.toRed(red).redSqrt().fromRed();
	  }

	  isqrtpq(p, q) {
	    return this.sqrtpq(p, q)._move(this);
	  }

	  sqrtpq(p, q) {
	    const sp = this.sqrtm(p);
	    const sq = this.sqrtm(q);
	    const [mp, mq] = p.egcd(q);
	    const lhs = sq.mul(mp).mul(p);
	    const rhs = sp.mul(mq).mul(q);
	    const n = p.mul(q);

	    return lhs.iadd(rhs).imod(n);
	  }

	  /*
	   * Primality Testing
	   */

	  isPrime(rng, reps, limit) {
	    enforce((reps >>> 0) === reps, 'reps', 'uint32');

	    if (!this.isPrimeMR(rng, reps + 1, true))
	      return false;

	    if (!this.isPrimeLucas(limit))
	      return false;

	    return true;
	  }

	  isPrimeMR(rng, reps, force2 = false) {
	    enforce((reps >>> 0) === reps, 'reps', 'uint32');
	    enforce(reps > 0, 'reps', 'integer');
	    enforce(typeof force2 === 'boolean', 'force2', 'boolean');

	    const n = this;

	    if (n.cmpn(7) < 0) {
	      return n.cmpn(2) === 0
	          || n.cmpn(3) === 0
	          || n.cmpn(5) === 0;
	    }

	    if (n.isEven())
	      return false;

	    const nm1 = n.subn(1);
	    const nm3 = nm1.subn(2);
	    const k = nm1.zeroBits();
	    const q = nm1.ushrn(k);

	    const red = BN.red(n);
	    const rnm1 = nm1.toRed(red);
	    const rone = new BN(1).toRed(red);

	next:
	    for (let i = 0; i < reps; i++) {
	      let x;

	      if (i === reps - 1 && force2) {
	        x = new BN(2);
	      } else {
	        x = BN.random(rng, 0, nm3);
	        x.iaddn(2);
	      }

	      let y = x.toRed(red).redPow(q);

	      if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0)
	        continue;

	      for (let j = 1; j < k; j++) {
	        y = y.redSqr();

	        if (y.cmp(rnm1) === 0)
	          continue next;

	        if (y.cmp(rone) === 0)
	          return false;
	      }

	      return false;
	    }

	    return true;
	  }

	  isPrimeLucas(limit = 0) {
	    enforce((limit >>> 0) === limit, 'limit', 'uint32');

	    const n = this;

	    // Ignore 0 and 1.
	    if (n.cmpn(1) <= 0)
	      return false;

	    // Two is the only even prime.
	    if (n.isEven())
	      return n.cmpn(2) === 0;

	    let p = 3;

	    for (;;) {
	      if (p > 10000) {
	        // Thought to be impossible.
	        throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);
	      }

	      if (limit !== 0 && p > limit) {
	        // Optional DoS limit.
	        return false;
	      }

	      const d = new BN(p * p - 4);
	      const j = d.jacobi(n);

	      if (j === -1)
	        break;

	      if (j === 0)
	        return n.cmpn(p + 2) === 0;

	      if (p === 40) {
	        if (n.isSquare())
	          return false;
	      }

	      p += 1;
	    }

	    const s = n.addn(1);
	    const r = s._makeOdd();

	    let vk = new BN(2);
	    let vk1 = new BN(p);

	    for (let i = s.bitLength(); i >= 0; i--) {
	      if (s.utestn(i)) {
	        vk = vk.mul(vk1).isubn(p).imod(n);
	        vk1 = vk1.sqr().isubn(2).imod(n);
	      } else {
	        vk1 = vk1.mul(vk).isubn(p).imod(n);
	        vk = vk.sqr().isubn(2).imod(n);
	      }
	    }

	    if (vk.cmpn(2) === 0 || vk.cmp(n.subn(2)) === 0) {
	      const a = vk.muln(p).imod(n);
	      const b = vk1.ushln(1).imod(n);

	      if (a.cmp(b) === 0)
	        return true;
	    }

	    for (let t = 0; t < r - 1; t++) {
	      if (vk.isZero())
	        return true;

	      if (vk.cmpn(2) === 0)
	        return false;

	      vk = vk.sqr().isubn(2).imod(n);
	    }

	    return false;
	  }

	  /*
	   * Twos Complement
	   */

	  toTwos(width) {
	    if (this.negative !== 0)
	      return this.abs().inotn(width).iaddn(1);

	    return this.clone();
	  }

	  fromTwos(width) {
	    enforce((width >>> 0) === width, 'width', 'uint32');
	    range(width > 0, 'width');

	    if (this.testn(width - 1))
	      return this.notn(width).iaddn(1).ineg();

	    return this.clone();
	  }

	  /*
	   * Reduction Context
	   */

	  toRed(ctx) {
	    enforce(ctx instanceof Red, 'ctx', 'reduction context');

	    if (this.red)
	      throw new Error('Already in reduction context.');

	    return ctx.convertTo(this);
	  }

	  fromRed() {
	    red(this.red, 'fromRed');
	    return this.red.convertFrom(this);
	  }

	  forceRed(ctx) {
	    enforce(ctx instanceof Red, 'ctx', 'reduction context');

	    if (this.red) {
	      if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont)
	        throw new Error('Already in reduction context.');
	    } else {
	      range(this.negative === 0, 'red');
	      range(this.ucmp(ctx.m) < 0, 'red');
	    }

	    return this.clone()._forceRed(ctx);
	  }

	  redIAdd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIAdd');
	    return this.red.iadd(this, num);
	  }

	  redAdd(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redAdd');
	    return this.red.add(this, num);
	  }

	  redIAddn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIAddn');
	    return this.red.iaddn(this, num);
	  }

	  redAddn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redAddn');
	    return this.red.addn(this, num);
	  }

	  redISub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redISub');
	    return this.red.isub(this, num);
	  }

	  redSub(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redSub');
	    return this.red.sub(this, num);
	  }

	  redISubn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redISubn');
	    return this.red.isubn(this, num);
	  }

	  redSubn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redSubn');
	    return this.red.subn(this, num);
	  }

	  redIMul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIMul');
	    return this.red.imul(this, num);
	  }

	  redMul(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redMul');
	    return this.red.mul(this, num);
	  }

	  redIMuln(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIMuln');
	    return this.red.imuln(this, num);
	  }

	  redMuln(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redMuln');
	    return this.red.muln(this, num);
	  }

	  redIDiv(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIDiv');
	    return this.red.idiv(this, num);
	  }

	  redDiv(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redDiv');
	    return this.red.div(this, num);
	  }

	  redIDivn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIDivn');
	    return this.red.idivn(this, num);
	  }

	  redDivn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redDivn');
	    return this.red.divn(this, num);
	  }

	  redIPow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIPow');
	    nonred(!num.red, 'redIPow');
	    return this.red.ipow(this, num);
	  }

	  redPow(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redPow');
	    nonred(!num.red, 'redPow');
	    return this.red.pow(this, num);
	  }

	  redIPown(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redIPown');
	    return this.red.ipown(this, num);
	  }

	  redPown(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redPown');
	    return this.red.pown(this, num);
	  }

	  redISqr() {
	    red(this.red, 'redISqr');
	    return this.red.isqr(this);
	  }

	  redSqr() {
	    red(this.red, 'redSqr');
	    return this.red.sqr(this);
	  }

	  redISqrt() {
	    red(this.red, 'redISqrt');
	    return this.red.isqrt(this);
	  }

	  redSqrt() {
	    red(this.red, 'redSqrt');
	    return this.red.sqrt(this);
	  }

	  redIDivSqrt(v) {
	    red(this.red, 'redIDivSqrt');
	    return this.red.idivsqrt(this, v);
	  }

	  redDivSqrt(v) {
	    red(this.red, 'redDivSqrt');
	    return this.red.divsqrt(this, v);
	  }

	  redIsSquare() {
	    red(this.red, 'redIsSquare');
	    return this.red.isSquare(this);
	  }

	  redIShl(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redIShl');
	    nonred(!num.red, 'redIShl');
	    return this.red.ishl(this, num);
	  }

	  redShl(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redShl');
	    nonred(!num.red, 'redShl');
	    return this.red.shl(this, num);
	  }

	  redIShln(num) {
	    enforce((num >>> 0) === num, 'num', 'uint32');
	    red(this.red, 'redIShln');
	    return this.red.ishln(this, num);
	  }

	  redShln(num) {
	    enforce((num >>> 0) === num, 'num', 'uint32');
	    red(this.red, 'redShln');
	    return this.red.shln(this, num);
	  }

	  redINeg() {
	    red(this.red, 'redINeg');
	    return this.red.ineg(this);
	  }

	  redNeg() {
	    red(this.red, 'redNeg');
	    return this.red.neg(this);
	  }

	  redEq(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');
	    red(this.red, 'redEq');
	    return this.red.eq(this, num);
	  }

	  redEqn(num) {
	    enforce(isSMI(num), 'num', 'smi');
	    red(this.red, 'redEqn');
	    return this.red.eqn(this, num);
	  }

	  redIsHigh() {
	    red(this.red, 'redIsHigh');
	    return this.red.isHigh(this);
	  }

	  redIsLow() {
	    red(this.red, 'redIsLow');
	    return this.red.isLow(this);
	  }

	  redIsOdd() {
	    red(this.red, 'redIsOdd');
	    return this.red.isOdd(this);
	  }

	  redIsEven() {
	    red(this.red, 'redIsEven');
	    return this.red.isEven(this);
	  }

	  redLegendre() {
	    red(this.red, 'redLegendre');
	    return this.red.legendre(this);
	  }

	  redJacobi() {
	    red(this.red, 'redJacobi');
	    return this.red.jacobi(this);
	  }

	  redKronecker() {
	    red(this.red, 'redKronecker');
	    return this.red.kronecker(this);
	  }

	  redIInvert() {
	    red(this.red, 'redIInvert');
	    return this.red.iinvert(this);
	  }

	  redInvert() {
	    red(this.red, 'redInvert');
	    return this.red.invert(this);
	  }

	  redIFermat() {
	    red(this.red, 'redIFermat');
	    return this.red.ifermat(this);
	  }

	  redFermat() {
	    red(this.red, 'redFermat');
	    return this.red.fermat(this);
	  }

	  /*
	   * Internal
	   */

	  _move(dest) {
	    dest.words = this.words;
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	    return dest;
	  }

	  _alloc(size) {
	    while (this.words.length < size)
	      this.words.push(0);

	    return this;
	  }

	  _expand(size) {
	    this._alloc(size);

	    while (this.length < size)
	      this.words[this.length++] = 0;

	    return this;
	  }

	  _strip() {
	    while (this.length > 1 && this.words[this.length - 1] === 0)
	      this.length -= 1;

	    return this._normalize();
	  }

	  _normalize() {
	    assert(this.length > 0);

	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0)
	      this.negative = 0;

	    return this;
	  }

	  _check() {
	    // We never have a zero length number.
	    assert(this.length > 0);

	    // Cannot exceed array bounds.
	    assert(this.length <= this.words.length);

	    if (this.length === 1) {
	      // Must be normalized.
	      if (this.words[0] === 0)
	        assert(this.negative === 0);
	      return this;
	    }

	    // Must be stripped.
	    assert(this.words[this.length - 1] !== 0);

	    return this;
	  }

	  _invertp(p) {
	    // Penk's right shift binary EGCD.
	    //
	    // See: The Art of Computer Programming,
	    //      Volume 2, Seminumerical Algorithms
	    //   Donald E. Knuth
	    //   Exercise 4.5.2.39
	    enforce(BN.isBN(p), 'p', 'bignum');
	    range(p.sign() > 0, 'invert');
	    assert(p.isOdd());

	    if (p.cmpn(1) === 0)
	      throw new RangeError('Not invertible.');

	    const a = this.clone();
	    const b = p.clone();
	    const u = new BN(1);
	    const v = new BN(0);

	    if (a.isNeg() || a.ucmp(b) >= 0)
	      a.imod(b);

	    while (!a.isZero()) {
	      let i = a._makeOdd();
	      let j = b._makeOdd();

	      while (i--) {
	        if (u.isOdd())
	          u._iadd(u, p);

	        u.iushrn(1);
	      }

	      while (j--) {
	        if (v.isOdd())
	          v._iadd(v, p);

	        v.iushrn(1);
	      }

	      if (a.ucmp(b) >= 0) {
	        a._isub(a, b);
	        if (u.ucmp(v) < 0) {
	          u._isub(v, u);
	          u._isub(p, u);
	        } else {
	          u._isub(u, v);
	        }
	      } else {
	        b._isub(b, a);
	        if (v.ucmp(u) < 0) {
	          v._isub(u, v);
	          v._isub(p, v);
	        } else {
	          v._isub(v, u);
	        }
	      }
	    }

	    if (b.cmpn(1) !== 0)
	      throw new RangeError('Not invertible.');

	    assert(v.negative === 0);
	    assert(v.ucmp(p) < 0);

	    return v;
	  }

	  _makeOdd() {
	    const shift = this.zeroBits();

	    if (shift > 0)
	      this.iushrn(shift);

	    return shift;
	  }

	  _factor2(num) {
	    // Find common factor of two.
	    // Expects inputs to be non-zero.
	    if ((this.words[0] | num.words[0]) & 1)
	      return 0;

	    const len = Math.min(this.length, num.length);

	    let r = 0;

	    for (let i = 0; i < len; i++) {
	      const b = zeroBits(this.words[i] | num.words[i]);

	      r += b;

	      if (b !== 26)
	        break;
	    }

	    return r;
	  }

	  _cloneNormal() {
	    return this.red ? this.fromRed() : this.clone();
	  }

	  _forceRed(ctx) {
	    this.red = ctx;
	    return this;
	  }

	  /*
	   * Helpers
	   */

	  clone() {
	    const copy = new BN();

	    copy.words = new Array(this.length);

	    for (let i = 0; i < this.length; i++)
	      copy.words[i] = this.words[i];

	    copy.length = this.length;
	    copy.negative = this.negative;
	    copy.red = this.red;

	    return copy;
	  }

	  inject(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    this._alloc(num.length);

	    for (let i = 0; i < num.length; i++)
	      this.words[i] = num.words[i];

	    this.length = num.length;
	    this.negative = num.negative;
	    this.red = num.red;

	    return this;
	  }

	  set(num, endian) {
	    return this.fromNumber(num, endian);
	  }

	  swap(num) {
	    enforce(BN.isBN(num), 'num', 'bignum');

	    const x = this;
	    const y = num;

	    [x.words, y.words] = [y.words, x.words];
	    [x.length, y.length] = [y.length, x.length];
	    [x.negative, y.negative] = [y.negative, x.negative];
	    [x.red, y.red] = [y.red, x.red];

	    return x;
	  }

	  reverse() {
	    const neg = this.negative;

	    this.fromBuffer(this.toBuffer('be'), 'le');
	    this.negative = neg;

	    return this;
	  }

	  byteLength() {
	    return Math.ceil(this.bitLength() / 8);
	  }

	  bitLength() {
	    const w = this.words[this.length - 1];
	    const hi = countBits(w);
	    return (this.length - 1) * 26 + hi;
	  }

	  zeroBits() {
	    if (this.isZero())
	      return 0;

	    if (this.isOdd())
	      return 0;

	    let r = 0;

	    for (let i = 0; i < this.length; i++) {
	      const b = zeroBits(this.words[i]);

	      r += b;

	      if (b !== 26)
	        break;
	    }

	    return r;
	  }

	  isSafe() {
	    if (this.length <= 2)
	      return true;

	    if (this.length === 3 && this.words[2] === 0x01)
	      return true;

	    return false;
	  }

	  word(pos) {
	    enforce((pos >>> 0) === pos, 'pos', 'uint32');

	    if (pos >= this.length)
	      return 0;

	    return this.words[pos];
	  }

	  [custom]() {
	    let prefix = 'BN';

	    if (this.red)
	      prefix = 'BN-R';

	    return `<${prefix}: ${this.toString(10)}>`;
	  }

	  /*
	   * Conversion
	   */

	  toNumber() {
	    let num = this.words[0];

	    if (this.length === 2) {
	      num += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // Note: at this stage it is known that the top bit is set.
	      num += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      throw new RangeError('Number can only safely store up to 53 bits.');
	    }

	    return this.negative !== 0 ? -num : num;
	  }

	  toDouble() {
	    let num = 0;

	    for (let i = this.length - 1; i >= 0; i--)
	      num = (num * 0x4000000) + this.words[i];

	    return this.negative !== 0 ? -num : num;
	  }

	  valueOf() {
	    return this.toDouble();
	  }

	  toBigInt() {
	    if (!HAS_BIGINT)
	      throw new Error('BigInt is not supported!');

	    const s52 = BigInt(52);
	    const s26 = BigInt(26);

	    let i = this.length - 1;
	    let num = BigInt(0);

	    for (; i >= 1; i -= 2) {
	      const hi = this.words[i] * 0x4000000;
	      const lo = this.words[i - 1];

	      num = (num << s52) | BigInt(hi + lo);
	    }

	    if (i >= 0)
	      num = (num << s26) | BigInt(this.words[0]);

	    return this.negative !== 0 ? -num : num;
	  }

	  toBool() {
	    return !this.isZero();
	  }

	  toString(base, padding) {
	    base = getBase(base);

	    if (padding == null)
	      padding = 0;

	    if (padding === 0)
	      padding = 1;

	    enforce((base >>> 0) === base, 'base', 'uint32');
	    enforce((padding >>> 0) === padding, 'padding', 'uint32');

	    if (base < 2 || base > 36)
	      throw new RangeError('Base ranges between 2 and 36.');

	    this._check();

	    if (base === 16) {
	      let out = '';
	      let off = 0;
	      let carry = 0;

	      for (let i = 0; i < this.length; i++) {
	        const w = this.words[i];
	        const word = (((w << off) | carry) & 0xffffff).toString(16);

	        carry = (w >>> (24 - off)) & 0xffffff;

	        if (carry !== 0 || i !== this.length - 1)
	          out = zeros[6 - word.length] + word + out;
	        else
	          out = word + out;

	        off += 2;

	        if (off >= 26) {
	          off -= 26;
	          i -= 1;
	        }
	      }

	      if (carry !== 0)
	        out = carry.toString(16) + out;

	      while (out.length % padding !== 0)
	        out = '0' + out;

	      if (this.negative !== 0)
	        out = '-' + out;

	      return out;
	    }

	    const groupSize = groupSizes[base - 1];
	    const groupBase = groupBases[base - 1];
	    const c = this.clone();

	    let out = '';

	    c.negative = 0;

	    while (!c.isZero()) {
	      const r = c.remrn(groupBase).toString(base);

	      c.iquon(groupBase);

	      if (!c.isZero())
	        out = zeros[groupSize - r.length] + r + out;
	      else
	        out = r + out;
	    }

	    if (this.isZero())
	      out = '0';

	    while (out.length % padding !== 0)
	      out = '0' + out;

	    if (this.negative !== 0)
	      out = '-' + out;

	    return out;
	  }

	  toJSON() {
	    return this.toString(16, 2);
	  }

	  toArray(endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  }

	  toBuffer(endian, length) {
	    return this.toArrayLike(Buffer, endian, length);
	  }

	  toArrayLike(ArrayType, endian, length) {
	    if (endian == null)
	      endian = 'be';

	    if (length == null)
	      length = 0;

	    enforce(typeof ArrayType === 'function', 'ArrayType', 'function');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
	    enforce((length >>> 0) === length, 'length', 'uint32');

	    this._check();

	    const bytes = this.byteLength();
	    const size = length || Math.max(1, bytes);

	    if (bytes > size)
	      throw new RangeError('Byte array longer than desired length.');

	    const res = allocate(ArrayType, size);

	    // See: https://github.com/indutny/bn.js/pull/222
	    if (endian === 'be') {
	      let pos = res.length - 1;
	      let carry = 0;

	      for (let i = 0; i < this.length; i++) {
	        const shift = (i & 3) << 1;
	        const word = (this.words[i] << shift) | carry;

	        res[pos--] = word & 0xff;

	        if (pos >= 0)
	          res[pos--] = (word >>> 8) & 0xff;

	        if (pos >= 0)
	          res[pos--] = (word >>> 16) & 0xff;

	        if (shift === 6) {
	          if (pos >= 0)
	            res[pos--] = (word >>> 24) & 0xff;

	          carry = 0;
	        } else {
	          carry = word >>> 24;
	        }
	      }

	      if (pos >= 0) {
	        res[pos--] = carry;

	        while (pos >= 0)
	          res[pos--] = 0;

	        carry = 0;
	      }

	      assert(carry === 0);
	    } else {
	      let pos = 0;
	      let carry = 0;

	      for (let i = 0; i < this.length; i++) {
	        const shift = (i & 3) << 1;
	        const word = (this.words[i] << shift) | carry;

	        res[pos++] = word & 0xff;

	        if (pos < res.length)
	          res[pos++] = (word >>> 8) & 0xff;

	        if (pos < res.length)
	          res[pos++] = (word >>> 16) & 0xff;

	        if (shift === 6) {
	          if (pos < res.length)
	            res[pos++] = (word >>> 24) & 0xff;

	          carry = 0;
	        } else {
	          carry = word >>> 24;
	        }
	      }

	      if (pos < res.length) {
	        res[pos++] = carry;

	        while (pos < res.length)
	          res[pos++] = 0;

	        carry = 0;
	      }

	      assert(carry === 0);
	    }

	    return res;
	  }

	  encode(endian, length) {
	    return this.toBuffer(endian, length);
	  }

	  /*
	   * Instantiation
	   */

	  of(num, endian) {
	    return this.fromNumber(num, endian);
	  }

	  fromNumber(num, endian) {
	    if (endian == null)
	      endian = 'be';

	    enforce(isInteger(num), 'num', 'integer');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

	    const neg = (num < 0) | 0;

	    if (neg)
	      num = -num;

	    if (num < 0x4000000) {
	      this.words[0] = num & 0x3ffffff;
	      this.length = 1;
	    } else if (num < 0x10000000000000) {
	      this.words = [
	        num & 0x3ffffff,
	        (num / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      this.words = [
	        num & 0x3ffffff,
	        (num / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    this.negative = neg;

	    if (endian === 'le')
	      this.reverse();

	    return this;
	  }

	  fromDouble(num, endian) {
	    if (endian == null)
	      endian = 'be';

	    enforce(typeof num === 'number', 'num', 'double');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

	    if (!isFinite(num))
	      num = 0;

	    const neg = (num <= -1) | 0;

	    if (num < 0)
	      num = -num;

	    num = Math.floor(num);

	    this.words = [];

	    while (num > 0) {
	      const lo = num % 0x4000000;
	      const hi = (num - lo) / 0x4000000;

	      this.words.push(lo);

	      num = hi;
	    }

	    if (this.words.length === 0)
	      this.words.push(0);

	    this.length = this.words.length;
	    this.negative = neg;

	    if (endian === 'le')
	      this.reverse();

	    return this;
	  }

	  fromBigInt(num, endian) {
	    if (endian == null)
	      endian = 'be';

	    enforce(typeof num === 'bigint', 'num', 'bigint');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

	    if (!HAS_BIGINT)
	      throw new Error('BigInt is not supported!');

	    // You know the implementation has a
	    // problem when strings are twice
	    // as fast as bigints.
	    const start = (num < BigInt(0)) | 0;

	    this._fromHex(num.toString(16), start);
	    this.negative = start;

	    if (endian === 'le')
	      this.reverse();

	    return this;
	  }

	  fromBool(value) {
	    enforce(typeof value === 'boolean', 'value', 'boolean');

	    this.words[0] = value | 0;
	    this.length = 1;
	    this.negative = 0;

	    return this;
	  }

	  fromString(str, base, endian) {
	    if (base === 'le' || base === 'be')
	      [base, endian] = [endian, base];

	    base = getBase(base);

	    if (endian == null)
	      endian = 'be';

	    enforce(typeof str === 'string', 'string', 'string');
	    enforce((base >>> 0) === base, 'base', 'uint32');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

	    if (base < 2 || base > 36)
	      throw new Error('Base ranges between 2 and 36.');

	    str = str.replace(/\s+/g, '');

	    let start = 0;

	    if (str.length > 0 && str.charCodeAt(0) === 0x2d)
	      start = 1;

	    if (base === 16)
	      this._fromHex(str, start);
	    else
	      this._fromBase(str, base, start);

	    this.negative = start;

	    this._normalize();

	    if (endian === 'le')
	      this.reverse();

	    return this;
	  }

	  _fromHex(str, start) {
	    this.length = Math.max(2, Math.ceil((str.length - start) / 6));
	    this.words = new Array(this.length);

	    for (let i = 0; i < this.length; i++)
	      this.words[i] = 0;

	    // Scan 24-bit chunks and add them to the number.
	    let off = 0;
	    let i = str.length - 6;
	    let j = 0;

	    for (; i >= start; i -= 6) {
	      const w = parseHex(str, i, i + 6);

	      this.words[j] |= (w << off) & 0x3ffffff;

	      // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.
	      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;

	      off += 24;

	      if (off >= 26) {
	        off -= 26;
	        j += 1;
	      }
	    }

	    if (i + 6 !== start) {
	      const w = parseHex(str, start, i + 6);

	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;
	    }

	    return this._strip();
	  }

	  _fromBase(str, base, start) {
	    // Initialize as zero.
	    this.words[0] = 0;
	    this.length = 1;
	    this.negative = 0;

	    // Find length of limb in base.
	    let limbLen = 0;
	    let limbPow = 1;

	    for (; limbPow <= 0x3ffffff; limbPow *= base)
	      limbLen += 1;

	    limbLen -= 1;
	    limbPow = (limbPow / base) | 0;

	    const total = str.length - start;
	    const mod = total % limbLen;
	    const end = Math.min(total, total - mod) + start;

	    let i = start;

	    for (; i < end; i += limbLen) {
	      const word = parseBase(str, i, i + limbLen, base);

	      this.imuln(limbPow);
	      this._iaddn(word);
	    }

	    if (mod !== 0) {
	      const pow = Math.pow(base, mod);
	      const word = parseBase(str, i, str.length, base);

	      this.imuln(pow);
	      this._iaddn(word);
	    }

	    return this;
	  }

	  fromJSON(json) {
	    if (BN.isBN(json)) {
	      if (json.red)
	        return json.fromRed();

	      return json.clone();
	    }

	    if (Array.isArray(json)) {
	      for (const chunk of json)
	        enforce(typeof chunk === 'string', 'chunk', 'string');

	      json = json.join('');
	    }

	    return this.fromString(json, 16);
	  }

	  fromBN(num) {
	    return this.inject(num);
	  }

	  fromArray(data, endian) {
	    enforce(Array.isArray(data), 'data', 'array');
	    return this.fromArrayLike(data, endian);
	  }

	  fromBuffer(data, endian) {
	    enforce(Buffer.isBuffer(data), 'data', 'buffer');
	    return this.fromArrayLike(data, endian);
	  }

	  fromArrayLike(data, endian) {
	    if (endian == null)
	      endian = 'be';

	    enforce(data && (data.length >>> 0) === data.length, 'data', 'array-like');
	    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

	    if (data.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	      this.negative = 0;
	      return this;
	    }

	    this.length = Math.max(2, Math.ceil(data.length / 3));
	    this.words = new Array(this.length);
	    this.negative = 0;

	    for (let i = 0; i < this.length; i++)
	      this.words[i] = 0;

	    const left = data.length % 3;

	    let off = 0;
	    let j = 0;
	    let w = 0;

	    if (endian === 'be') {
	      for (let i = data.length - 1; i >= 2; i -= 3) {
	        const w = data[i] | (data[i - 1] << 8) | (data[i - 2] << 16);

	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

	        off += 24;

	        if (off >= 26) {
	          off -= 26;
	          j += 1;
	        }
	      }

	      switch (left) {
	        case 2:
	          w = data[1] | (data[0] << 8);
	          break;
	        case 1:
	          w = data[0];
	          break;
	      }
	    } else {
	      const len = data.length - left;

	      for (let i = 0; i < len; i += 3) {
	        const w = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16);

	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

	        off += 24;

	        if (off >= 26) {
	          off -= 26;
	          j += 1;
	        }
	      }

	      switch (left) {
	        case 2:
	          w = data[len] | (data[len + 1] << 8);
	          break;
	        case 1:
	          w = data[len];
	          break;
	      }
	    }

	    if (left > 0) {
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	    }

	    return this._strip();
	  }

	  decode(data, endian) {
	    return this.fromBuffer(data, endian);
	  }

	  from(num, base, endian) {
	    if (num == null)
	      return this;

	    if (base === 'le' || base === 'be')
	      [base, endian] = [endian, base];

	    if (typeof num === 'number')
	      return this.fromNumber(num, endian);

	    if (typeof num === 'bigint')
	      return this.fromBigInt(num, endian);

	    if (typeof num === 'string')
	      return this.fromString(num, base, endian);

	    if (typeof num === 'object') {
	      if (BN.isBN(num))
	        return this.fromBN(num, endian);

	      if ((num.length >>> 0) === num.length)
	        return this.fromArrayLike(num, endian);
	    }

	    if (typeof num === 'boolean')
	      return this.fromBool(num);

	    throw new TypeError('Non-numeric object passed to BN.');
	  }

	  /*
	   * Static Methods
	   */

	  static min(...args) {
	    let min = null;

	    for (const num of args) {
	      enforce(BN.isBN(num), 'num', 'bignum');

	      if (!min || num.cmp(min) < 0)
	        min = num;
	    }

	    return min || new BN(0);
	  }

	  static max(...args) {
	    let max = null;

	    for (const num of args) {
	      enforce(BN.isBN(num), 'num', 'bignum');

	      if (!max || num.cmp(max) > 0)
	        max = num;
	    }

	    return max || new BN(0);
	  }

	  static cmp(a, b) {
	    enforce(BN.isBN(a), 'a', 'bignum');
	    return a.cmp(b);
	  }

	  static ucmp(a, b) {
	    enforce(BN.isBN(a), 'a', 'bignum');
	    return a.ucmp(b);
	  }

	  static red(num) {
	    return new Red(num);
	  }

	  static barrett(num) {
	    return new Barrett(num);
	  }

	  static mont(num) {
	    return new Mont(num);
	  }

	  static _prime(name) {
	    if (primes[name])
	      return primes[name];

	    let prime;

	    if (name === 'p192')
	      prime = new P192();
	    else if (name === 'p224')
	      prime = new P224();
	    else if (name === 'p521')
	      prime = new P521();
	    else if (name === 'k256')
	      prime = new K256();
	    else if (name === 'p251')
	      prime = new P251();
	    else if (name === 'p25519')
	      prime = new P25519();
	    else if (name === 'p448')
	      prime = new P448();
	    else
	      throw new Error(`Unknown prime: "${name}".`);

	    primes[name] = prime;

	    return prime;
	  }

	  static prime(name) {
	    return BN._prime(name).p.clone();
	  }

	  static pow(num, exp) {
	    if (num === 2)
	      return BN.shift(1, exp);

	    return new BN().fromNumber(num).pown(exp);
	  }

	  static shift(num, bits) {
	    if (num === 1)
	      return new BN(0).usetn(bits, 1);

	    return new BN().fromNumber(num).ishln(bits);
	  }

	  static mask(bits) {
	    return BN.shift(1, bits).isubn(1);
	  }

	  static randomBits(rng, bits) {
	    enforce(rng != null, 'rng', 'rng');
	    enforce((bits >>> 0) === bits, 'bits', 'uint32');

	    if (typeof rng === 'object') {
	      enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');

	      const size = (bits + 7) >>> 3;
	      const total = size * 8;
	      const bytes = rng.randomBytes(size);

	      enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');

	      if (bytes.length !== size)
	        throw new RangeError('Invalid number of bytes returned from RNG.');

	      const num = BN.fromBuffer(bytes);

	      if (total > bits)
	        num.iushrn(total - bits);

	      return num;
	    }

	    enforce(typeof rng === 'function', 'rng', 'rng');

	    const num = rng(bits);

	    enforce(BN.isBN(num), 'num', 'bignum');
	    range(num.negative === 0, 'RNG');
	    nonred(!num.red, 'RNG');

	    if (num.bitLength() > bits)
	      throw new RangeError('Invalid number of bits returned from RNG.');

	    return num;
	  }

	  static random(rng, min, max) {
	    min = BN.cast(min, 16);
	    max = BN.cast(max, 16);

	    if (min.cmp(max) > 0)
	      throw new RangeError('Minimum cannot be greater than maximum.');

	    const space = max.sub(min).iabs();
	    const bits = space.bitLength();

	    if (bits === 0)
	      return min.clone();

	    for (;;) {
	      const num = BN.randomBits(rng, bits);

	      // Maximum is _exclusive_!
	      if (num.cmp(space) >= 0)
	        continue;

	      // Minimum is _inclusive_!
	      num.iadd(min);

	      return num;
	    }
	  }

	  static of(num, endian) {
	    return new BN().of(num, endian);
	  }

	  static fromNumber(num, endian) {
	    return new BN().fromNumber(num, endian);
	  }

	  static fromDouble(num, endian) {
	    return new BN().fromDouble(num, endian);
	  }

	  static fromBigInt(num, endian) {
	    return new BN().fromBigInt(num, endian);
	  }

	  static fromBool(value) {
	    return new BN().fromBool(value);
	  }

	  static fromString(str, base, endian) {
	    return new BN().fromString(str, base, endian);
	  }

	  static fromJSON(json) {
	    return new BN().fromJSON(json);
	  }

	  static fromBN(num) {
	    return new BN().fromBN(num);
	  }

	  static fromArray(data, endian) {
	    return new BN().fromArray(data, endian);
	  }

	  static fromBuffer(data, endian) {
	    return new BN().fromBuffer(data, endian);
	  }

	  static fromArrayLike(data, endian) {
	    return new BN().fromArrayLike(data, endian);
	  }

	  static decode(data, endian) {
	    return new BN().decode(data, endian);
	  }

	  static from(num, base, endian) {
	    return new BN().from(num, base, endian);
	  }

	  static cast(num, base, endian) {
	    if (BN.isBN(num))
	      return num;

	    return new BN(num, base, endian);
	  }

	  static isBN(obj) {
	    return obj instanceof BN;
	  }
	}

	/*
	 * Static
	 */

	BN.BN = BN;
	BN.wordSize = 26;
	BN.native = 0;

	/**
	 * Prime
	 */

	class Prime {
	  constructor(name, p) {
	    // P = 2^N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = BN.shift(1, this.n).isub(this.p);
	    this.lo = this.p.clone();
	    this.one = this.p.clone();
	  }

	  ireduce(num) {
	    // Assumes that `num` is less than `P^2`:
	    // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)
	    const neg = num.negative !== 0;

	    // Track bits.
	    let bits = num.bitLength();

	    // Must be less than P^2.
	    assert(bits <= this.n * 2);

	    // Ensure positive.
	    num.negative = 0;

	    // Reduce.
	    while (bits > this.n) {
	      // lo = num & ((1 << n) - 1)
	      // num = num >> n
	      this.split(num, this.lo);

	      // num = num * K
	      this.imulK(num);

	      // num = num + lo
	      num._iadd(num, this.lo);

	      // bits = bitlen(num)
	      bits = num.bitLength();
	    }

	    // Final reduction.
	    const cmp = bits < this.n ? -1 : num.ucmp(this.p);

	    if (cmp === 0) {
	      num.words[0] = 0;
	      num.length = 1;
	    } else if (cmp > 0) {
	      num._isub(num, this.p);
	    } else ;

	    // Adjust sign.
	    if (neg && !num.isZero())
	      num._isub(this.p, num);

	    return num;
	  }

	  split(input, out) {
	    input._split(this.n, out);
	  }

	  imulK(num) {
	    return num.imul(this.k);
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    throw new Error('Not implemented.');
	  }

	  fermat(x) {
	    return this.pm2(x);
	  }
	}

	/**
	 * Prime (3 mod 4)
	 */

	class Prime34 extends Prime {
	  constructor(name, p) {
	    super(name, p);
	  }

	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    throw new Error('Not implemented.');
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    throw new Error('Not implemented.');
	  }

	  sqrt(x) {
	    // r = x^((p + 1) / 4) mod p
	    const {red} = x;
	    const r = this.pp1d4(x);

	    if (!red.sqr(r).eq(x))
	      throw new SquareRootError(r);

	    return r;
	  }

	  divsqrt(u, v) {
	    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
	    const {red} = u;
	    const u2 = red.sqr(u);
	    const u3 = red.mul(u2, u);
	    const u5 = red.mul(u3, u2);
	    const v3 = red.mul(red.sqr(v), v);
	    const p = this.pm3d4(red.mul(u5, v3));
	    const x = red.mul(red.mul(u3, v), p);
	    const c = red.mul(v, red.sqr(x));

	    if (c.eq(u))
	      return x;

	    throw new SquareRootError(x);
	  }
	}

	/**
	 * Prime (5 mod 8)
	 */

	class Prime58 extends Prime {
	  constructor(name, p, sm1) {
	    super(name, p);

	    this.sm1 = new BN(sm1, 16);
	  }

	  pm5d8(x1) {
	    // Exponent: (p - 5) / 8
	    throw new Error('Not implemented.');
	  }

	  pp3d8(x1) {
	    // Exponent: (p + 3) / 8
	    throw new Error('Not implemented.');
	  }

	  sqrt(x) {
	    // r = x^((p + 3) / 8) mod p
	    const {red} = x;
	    const sm1 = this.sm1._forceRed(red);
	    const r = this.pp3d8(x);

	    if (red.sqr(r).eq(x))
	      return r;

	    const c = red.mul(r, sm1);

	    if (red.sqr(c).eq(x))
	      return c;

	    throw new SquareRootError(r);
	  }

	  divsqrt(u, v) {
	    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
	    const {red} = u;
	    const sm1 = this.sm1._forceRed(red);
	    const v3 = red.mul(red.sqr(v), v);
	    const v7 = red.mul(red.sqr(v3), v);
	    const p = this.pm5d8(red.mul(u, v7));
	    const x = red.mul(red.mul(u, v3), p);
	    const c = red.mul(v, red.sqr(x));

	    if (c.eq(u))
	      return x;

	    const mc = red.ineg(c);

	    if (mc.eq(u))
	      return red.mul(x, sm1);

	    if (mc.eq(red.mul(u, sm1)))
	      throw new SquareRootError(red.mul(x, sm1));

	    throw new SquareRootError(x);
	  }
	}

	/**
	 * Prime (1 mod 16)
	 */

	class Prime116 extends Prime {
	  constructor(name, p, g) {
	    super(name, p);

	    this.g = new BN(g, 16);
	    this.z = this.p.subn(1).zeroBits();
	  }

	  powS(x1) {
	    // Exponent: (p - 1) / 2^k
	    throw new Error('Not implemented.');
	  }

	  powE(x1) {
	    // Exponent: (s + 1) / 2
	    throw new Error('Not implemented.');
	  }

	  sqrt(x) {
	    // Tonelli-Shanks (variable time).
	    //
	    // Constants:
	    //
	    //   k = factors of 2 for (p - 1)
	    //   s = (p - 1) / 2^k
	    //   e = (s + 1) / 2
	    //   n = first non-square in F(p)
	    //
	    // Algorithm:
	    //
	    //   g = n^s mod p
	    //   y = x^e mod p
	    //   b = x^s mod p
	    //
	    //   loop:
	    //     t = b
	    //     m = 0
	    //
	    //     while t != 1:
	    //       t = t^2 mod p
	    //       m += 1
	    //
	    //     if m == 0:
	    //       break
	    //
	    //     if m >= k:
	    //       fail
	    //
	    //     t = g^(2^(k - m - 1)) mod p
	    //     g = t^2 mod p
	    //     y = y * t mod p
	    //     b = b * g mod p
	    //     k = m
	    //
	    //   return y
	    //
	    const {red} = x;

	    switch (red.jacobi(x)) {
	      case -1:
	        throw new SquareRootError(x);
	      case 0:
	        return x.clone();
	    }

	    let g = this.g._forceRed(red);
	    let y = this.powE(x);
	    let b = this.powS(x);
	    let k = this.z;

	    for (;;) {
	      let t = b;
	      let m = 0;

	      while (t.cmpn(1) !== 0 && m < k) {
	        t = red.sqr(t);
	        m += 1;
	      }

	      if (m === 0)
	        break;

	      assert(m < k);

	      t = red.sqrn(g, k - m - 1);
	      g = red.sqr(t);
	      y = red.mul(y, t);
	      b = red.mul(b, g);
	      k = m;
	    }

	    return y;
	  }

	  divsqrt(u, v) {
	    const {red} = u;

	    if (v.isZero())
	      throw new SquareRootError(v);

	    return this.sqrt(red.div(u, v));
	  }
	}

	/**
	 * P192
	 */

	class P192 extends Prime34 {
	  constructor() {
	    // 2^192 - 2^64 - 1 (= 3 mod 4)
	    super('p192', 'ffffffff ffffffff ffffffff fffffffe'
	                + 'ffffffff ffffffff');
	  }

	  imulK(num) {
	    // K = 0x10000000000000001
	    // K = 2^64 + 1
	    const one = this.one.inject(num);
	    return num.iushln(64)._iadd(num, one);
	  }

	  core(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 127x1 1x0 62x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x30 = red.sqrnmul(x24, 6, x6);
	    const x31 = red.sqrnmul(x30, 1, x1);
	    const x62 = red.sqrnmul(x31, 31, x31);
	    const x124 = red.sqrnmul(x62, 62, x62);
	    const x127 = red.sqrnmul(x124, 3, x3);
	    const r0 = red.sqrn(x127, 1);
	    const r1 = red.sqrnmul(r0, 62, x62);

	    return r1;
	  }

	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 127x1 1x0 62x1
	    return this.core(x1);
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 127x1 1x0 62x1 1x0 1x1
	    const {red} = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);

	    return r2;
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 128x1 62x0
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x8 = red.sqrnmul(x4, 4, x4);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);
	    const r0 = red.sqrn(x128, 62);

	    return r0;
	  }
	}

	/**
	 * P224
	 */

	class P224 extends Prime116 {
	  constructor() {
	    // 2^224 - 2^96 + 1 (1 mod 16)
	    super('p224', 'ffffffff ffffffff ffffffff ffffffff'
	                + '00000000 00000000 00000001',
	                  '6a0fec67 8598a792 0c55b2d4 0b2d6ffb'
	                + 'bea3d8ce f3fb3632 dc691b74');
	  }

	  imulK(num) {
	    // K = 0xffffffffffffffffffffffff
	    // K = 2^96 - 1
	    const one = this.one.inject(num);
	    return num.iushln(96)._isub(num, one);
	  }

	  powS(x1) {
	    // Exponent: 2^128 - 1
	    // Bits: 128x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x8 = red.sqrnmul(x4, 4, x4);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);

	    return x128;
	  }

	  powE(x1) {
	    // Exponent: 2^127
	    // Bits: 1x1 127x0
	    const {red} = x1;
	    const r0 = red.sqrn(x1, 127);

	    return r0;
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 127x1 1x0 96x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x48 = red.sqrnmul(x24, 24, x24);
	    const x96 = red.sqrnmul(x48, 48, x48);
	    const x120 = red.sqrnmul(x96, 24, x24);
	    const x126 = red.sqrnmul(x120, 6, x6);
	    const x127 = red.sqrnmul(x126, 1, x1);
	    const r0 = red.sqrn(x127, 1);
	    const r1 = red.sqrnmul(r0, 96, x96);

	    return r1;
	  }
	}

	/**
	 * P521
	 */

	class P521 extends Prime34 {
	  constructor() {
	    // 2^521 - 1 (= 3 mod 4)
	    super('p521', '000001ff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff');
	  }

	  imulK(num) {
	    // K = 0x01
	    return num;
	  }

	  core(x1) {
	    // Exponent: 2^519 - 1
	    // Bits: 519x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x7 = red.sqrnmul(x6, 1, x1);
	    const x8 = red.sqrnmul(x7, 1, x1);
	    const x16 = red.sqrnmul(x8, 8, x8);
	    const x32 = red.sqrnmul(x16, 16, x16);
	    const x64 = red.sqrnmul(x32, 32, x32);
	    const x128 = red.sqrnmul(x64, 64, x64);
	    const x256 = red.sqrnmul(x128, 128, x128);
	    const x512 = red.sqrnmul(x256, 256, x256);
	    const x519 = red.sqrnmul(x512, 7, x7);

	    return x519;
	  }

	  pm3d4(x1) {
	    // Exponent: 2^519 - 1
	    // Bits: 519x1
	    return this.core(x1);
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 519x1 1x0 1x1
	    const {red} = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);

	    return r2;
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 1x1 519x0
	    const {red} = x1;
	    const r0 = red.sqrn(x1, 519);

	    return r0;
	  }
	}

	/**
	 * K256
	 */

	class K256 extends Prime34 {
	  constructor() {
	    // 2^256 - 2^32 - 977 (= 3 mod 4)
	    super('k256', 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff fffffffe fffffc2f');
	  }

	  split(input, output) {
	    // 256 = 9 * 26 + 22
	    const mask = 0x3fffff;
	    const len = Math.min(input.length, 9);

	    output._alloc(len + 1);

	    for (let i = 0; i < len; i++)
	      output.words[i] = input.words[i];

	    output.length = len;

	    if (input.length <= 9) {
	      output._strip();
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs.
	    let prev = input.words[9];
	    let i = 10;

	    output.words[output.length++] = prev & mask;
	    output._strip();

	    for (; i < input.length; i++) {
	      const next = input.words[i] | 0;

	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);

	      prev = next;
	    }

	    prev >>>= 22;

	    input.words[i - 10] = prev;

	    if (prev === 0 && input.length > 10)
	      input.length -= 10;
	    else
	      input.length -= 9;

	    input._strip(); // Unsure if we need this.
	  }

	  imulK(num) {
	    // K = 0x1000003d1 = [0x40, 0x3d1]
	    // K = 2^32 + 977
	    num._expand(num.length + 2);

	    // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    let lo = 0;

	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i];

	      lo += w * 0x3d1;

	      num.words[i] = lo & 0x3ffffff;

	      lo = w * 0x40 + Math.floor(lo / 0x4000000);
	    }

	    // Fast length reduction.
	    if (num.words[num.length - 1] === 0) {
	      num.length -= 1;
	      if (num.words[num.length - 1] === 0)
	        num.length -= 1;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }

	  core(x1, x2) {
	    // Exponent: (p - 47) / 64
	    // Bits: 223x1 1x0 22x1 4x0
	    const {red} = x1;
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x9 = red.sqrnmul(x6, 3, x3);
	    const x11 = red.sqrnmul(x9, 2, x2);
	    const x22 = red.sqrnmul(x11, 11, x11);
	    const x44 = red.sqrnmul(x22, 22, x22);
	    const x88 = red.sqrnmul(x44, 44, x44);
	    const x176 = red.sqrnmul(x88, 88, x88);
	    const x220 = red.sqrnmul(x176, 44, x44);
	    const x223 = red.sqrnmul(x220, 3, x3);
	    const r0 = red.sqrn(x223, 1);
	    const r1 = red.sqrnmul(r0, 22, x22);
	    const r2 = red.sqrn(r1, 4);

	    return r2;
	  }

	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 1, x1);
	    const r4 = red.sqrn(r3, 1);
	    const r5 = red.sqrnmul(r4, 2, x2);

	    return r5;
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1 1x0 1x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 1, x1);
	    const r4 = red.sqrn(r3, 1);
	    const r5 = red.sqrnmul(r4, 2, x2);
	    const r6 = red.sqrn(r5, 1);
	    const r7 = red.sqrnmul(r6, 1, x1);

	    return r7;
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 223x1 1x0 22x1 4x0 2x1 2x0
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r2 = this.core(x1, x2);
	    const r3 = red.sqrnmul(r2, 2, x2);
	    const r4 = red.sqrn(r3, 2);

	    return r4;
	  }
	}

	/**
	 * P251
	 */

	class P251 extends Prime34 {
	  constructor() {
	    // 2^251 - 9
	    super('p251', '07ffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff ffffffff fffffff7');
	  }

	  imulK(num) {
	    // K = 0x09
	    if (num.isZero())
	      return num;

	    let carry = 0;

	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i] * 0x09 + carry;

	      carry = w >>> 26;

	      num.words[i] = w & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      num._alloc(num.length + 1);
	      num.words[num.length++] = carry;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }

	  core(x1) {
	    // Exponent: 2^247 - 1
	    // Bits: 247x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x12 = red.sqrnmul(x6, 6, x6);
	    const x24 = red.sqrnmul(x12, 12, x12);
	    const x48 = red.sqrnmul(x24, 24, x24);
	    const x96 = red.sqrnmul(x48, 48, x48);
	    const x192 = red.sqrnmul(x96, 96, x96);
	    const x240 = red.sqrnmul(x192, 48, x48);
	    const x246 = red.sqrnmul(x240, 6, x6);
	    const x247 = red.sqrnmul(x246, 1, x1);

	    return x247;
	  }

	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 247x1 1x0 1x1
	    const {red} = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);

	    return r2;
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 247x1 1x0 1x1 1x0 1x1
	    const {red} = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    const r3 = red.sqrn(r2, 1);
	    const r4 = red.sqrnmul(r3, 1, x1);

	    return r4;
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 248x1 1x0
	    const {red} = x1;
	    const r0 = this.core(x1);
	    const r1 = red.sqrnmul(r0, 1, x1);
	    const r2 = red.sqrn(r1, 1);

	    return r2;
	  }
	}

	/**
	 * P25519
	 */

	class P25519 extends Prime58 {
	  constructor() {
	    // 2^255 - 19 (= 5 mod 8)
	    super('p25519', '7fffffff ffffffff ffffffff ffffffff'
	                  + 'ffffffff ffffffff ffffffff ffffffed',
	                    '2b832480 4fc1df0b 2b4d0099 3dfbd7a7'
	                  + '2f431806 ad2fe478 c4ee1b27 4a0ea0b0');
	  }

	  imulK(num) {
	    // K = 0x13
	    let carry = 0;

	    for (let i = 0; i < num.length; i++) {
	      const w = num.words[i] * 0x13 + carry;

	      carry = w >>> 26;

	      num.words[i] = w & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      num._alloc(num.length + 1);
	      num.words[num.length++] = carry;
	    }

	    // Note: we shouldn't need to strip here.
	    return num;
	  }

	  core(x1, x2) {
	    // Exponent: 2^250 - 1
	    // Bits: 250x1
	    const {red} = x1;
	    const x4 = red.sqrnmul(x2, 2, x2);
	    const x5 = red.sqrnmul(x4, 1, x1);
	    const x10 = red.sqrnmul(x5, 5, x5);
	    const x20 = red.sqrnmul(x10, 10, x10);
	    const x40 = red.sqrnmul(x20, 20, x20);
	    const x50 = red.sqrnmul(x40, 10, x10);
	    const x100 = red.sqrnmul(x50, 50, x50);
	    const x200 = red.sqrnmul(x100, 100, x100);
	    const x250 = red.sqrnmul(x200, 50, x50);

	    return x250;
	  }

	  pm5d8(x1) {
	    // Exponent: (p - 5) / 8
	    // Bits: 250x1 1x0 1x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);

	    return r2;
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 250x1 1x0 1x1 1x0 2x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);
	    const r3 = red.sqrn(r2, 1);
	    const r4 = red.sqrnmul(r3, 2, x2);

	    return r4;
	  }

	  pp3d8(x1) {
	    // Exponent: (p + 3) / 8
	    // Bits: 251x1 1x0
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrnmul(r0, 1, x1);
	    const r2 = red.sqrn(r1, 1);

	    return r2;
	  }
	}

	/**
	 * P448
	 */

	class P448 extends Prime34 {
	  constructor() {
	    // 2^448 - 2^224 - 1 (= 3 mod 4)
	    super('p448', 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff fffffffe ffffffff'
	                + 'ffffffff ffffffff ffffffff ffffffff'
	                + 'ffffffff ffffffff');
	  }

	  imulK(num) {
	    // K = 0x100000000000000000000000000000000000000000000000000000001
	    // K = 2^224 + 1
	    const one = this.one.inject(num);
	    return num.iushln(224)._iadd(num, one);
	  }

	  core(x1, x2) {
	    // Exponent: 2^222 - 1
	    // Bits: 222x1
	    const {red} = x1;
	    const x3 = red.sqrnmul(x2, 1, x1);
	    const x6 = red.sqrnmul(x3, 3, x3);
	    const x9 = red.sqrnmul(x6, 3, x3);
	    const x11 = red.sqrnmul(x9, 2, x2);
	    const x22 = red.sqrnmul(x11, 11, x11);
	    const x44 = red.sqrnmul(x22, 22, x22);
	    const x88 = red.sqrnmul(x44, 44, x44);
	    const x176 = red.sqrnmul(x88, 88, x88);
	    const x220 = red.sqrnmul(x176, 44, x44);
	    const x222 = red.sqrnmul(x220, 2, x2);

	    return x222;
	  }

	  pm3d4(x1) {
	    // Exponent: (p - 3) / 4
	    // Bits: 223x1 1x0 222x1
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const x222 = this.core(x1, x2);
	    const r0 = red.sqrnmul(x222, 1, x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 222, x222);

	    return r2;
	  }

	  pm2(x1) {
	    // Exponent: p - 2
	    // Bits: 223x1 1x0 222x1 1x0 1x1
	    const {red} = x1;
	    const r0 = this.pm3d4(x1);
	    const r1 = red.sqrn(r0, 1);
	    const r2 = red.sqrnmul(r1, 1, x1);

	    return r2;
	  }

	  pp1d4(x1) {
	    // Exponent: (p + 1) / 4
	    // Bits: 224x1 222x0
	    const {red} = x1;
	    const x2 = red.sqrnmul(x1, 1, x1);
	    const r0 = this.core(x1, x2);
	    const r1 = red.sqrnmul(r0, 2, x2);
	    const r2 = red.sqrn(r1, 222);

	    return r2;
	  }
	}

	/**
	 * Reduction Engine
	 */

	class Red {
	  constructor(m) {
	    let prime = null;

	    if (typeof m === 'string') {
	      prime = BN._prime(m);
	      m = prime.p;
	    }

	    enforce(BN.isBN(m), 'm', 'bignum');
	    nonred(!m.red, 'reduction');
	    range(m.sign() > 0, 'reduction');

	    this.m = m;
	    this.prime = prime;
	    this.mb = null;
	    this.sm1 = null;
	  }

	  _verify1(a) {
	    range(a.negative === 0, 'red');
	    red(a.red != null, 'red');
	  }

	  _verify2(a, b) {
	    range((a.negative | b.negative) === 0, 'red');
	    red(a.red != null && a.red === b.red, 'red');
	  }

	  get mont() {
	    return false;
	  }

	  precompute() {
	    // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.
	    if (this.sm1 === null && this.m.andln(7) === 5) {
	      if (this.prime) {
	        this.sm1 = this.prime.sm1.clone()._forceRed(this);
	      } else {
	        const x = new BN(2).toRed(this);
	        const e = this.m.subn(1).iushrn(2);

	        // sqrt(-1) = 2^((p - 1) / 4) mod p
	        this.sm1 = this.pow(x, e);
	      }
	    }

	    return this;
	  }

	  convertTo(num) {
	    const res = num.mod(this.m);
	    res.red = this;
	    return res;
	  }

	  convertFrom(num) {
	    const res = num.clone();
	    res.red = null;
	    return res;
	  }

	  intTo(a) {
	    return a;
	  }

	  intFrom(a) {
	    return a;
	  }

	  imod(a) {
	    if (this.prime)
	      return this.prime.ireduce(a)._forceRed(this);

	    return a.imod(this.m)._forceRed(this);
	  }

	  iadd(a, b) {
	    this._verify2(a, b);

	    a._iadd(a, b);

	    if (a.ucmp(this.m) >= 0)
	      a._isub(a, this.m);

	    return a;
	  }

	  add(a, b) {
	    if (a.length < b.length)
	      return this.iadd(b.clone(), a);

	    return this.iadd(a.clone(), b);
	  }

	  iaddn(a, num) {
	    this._verify1(a);

	    if (num < 0)
	      return this.isubn(a, -num);

	    if (this.m.length === 1)
	      num %= this.m.words[0];

	    a._iaddn(num);

	    if (a.ucmp(this.m) >= 0)
	      a._isub(a, this.m);

	    return a;
	  }

	  addn(a, num) {
	    return this.iaddn(a.clone(), num);
	  }

	  isub(a, b) {
	    this._verify2(a, b);

	    //  0: a - a mod m == 0
	    // -1: a - b mod m == m - (b - a)
	    // +1: a - b mod m == a - b
	    const cmp = a.ucmp(b);

	    if (cmp === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    if (cmp < 0) {
	      a._isub(b, a);
	      a._isub(this.m, a);
	    } else {
	      a._isub(a, b);
	    }

	    return a;
	  }

	  sub(a, b) {
	    return this.isub(a.clone(), b);
	  }

	  isubn(a, num) {
	    this._verify1(a);

	    if (num < 0)
	      return this.iaddn(a, -num);

	    if (this.m.length === 1)
	      num %= this.m.words[0];

	    //  <: a - b mod m == m - (b - a)
	    // >=: a - b mod m == a - b
	    if (a.length === 1 && a.words[0] < num) {
	      a.words[0] = num - a.words[0];
	      a._isub(this.m, a);
	    } else {
	      a._isubn(num);
	    }

	    return a;
	  }

	  subn(a, num) {
	    return this.isubn(a.clone(), num);
	  }

	  imul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  }

	  mul(a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  }

	  imuln(a, num) {
	    this._verify1(a);

	    if (a.isZero())
	      return a;

	    if (num === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    const neg = num < 0;

	    if (neg)
	      num = -num;

	    if (this.m.length === 1)
	      num %= this.m.words[0];

	    a.imuln(num);

	    if (num <= 16) {
	      // Quick reduction.
	      while (a.ucmp(this.m) >= 0)
	        a._isub(a, this.m);
	    } else {
	      this.imod(a);
	    }

	    if (neg)
	      this.ineg(a);

	    return a;
	  }

	  muln(a, num) {
	    return this.imuln(a.clone(), num);
	  }

	  idiv(a, b) {
	    return this.div(a, b)._move(a);
	  }

	  div(a, b) {
	    return this.mul(a, this.invert(b));
	  }

	  idivn(a, num) {
	    return this.divn(a, num)._move(a);
	  }

	  divn(a, num) {
	    return this.div(a, this.convertTo(new BN(num)));
	  }

	  ipow(a, num) {
	    return this.pow(a, num)._move(a);
	  }

	  pow(a, num) {
	    this._verify1(a);

	    if (num.isNeg())
	      a = this.invert(a);

	    // Small exponent.
	    if (num.length === 1)
	      return this.pown(a, num.words[0]);

	    // Call out to BigInt.
	    if (HAS_BIGINT && !this.prime)
	      return this.powInt(a, num);

	    // Otherwise, a BN implementation.
	    return this.powNum(a, num);
	  }

	  powNum(a, num) {
	    // Sliding window (odd multiples only).
	    const one = new BN(1).toRed(this);
	    const wnd = new Array(WND_SIZE);
	    const a2 = this.sqr(a);

	    wnd[0] = a;

	    for (let i = 1; i < WND_SIZE; i++)
	      wnd[i] = this.mul(wnd[i - 1], a2);

	    let i = num.bitLength();
	    let r = one;

	    while (i >= WND_WIDTH) {
	      let width = WND_WIDTH;
	      let bits = num.bits(i - width, width);

	      if (bits < WND_SIZE) {
	        r = this.sqr(r);
	        i -= 1;
	        continue;
	      }

	      while ((bits & 1) === 0) {
	        width -= 1;
	        bits >>= 1;
	      }

	      if (r === one) {
	        r = wnd[bits >> 1].clone();
	      } else {
	        r = this.sqrn(r, width);
	        r = this.mul(r, wnd[bits >> 1]);
	      }

	      i -= width;
	    }

	    if (i > 0) {
	      const bits = num.bits(0, i);

	      while (i--) {
	        r = this.sqr(r);

	        if ((bits >> i) & 1)
	          r = this.mul(r, a);
	      }
	    }

	    return r;
	  }

	  powInt(a, num) {
	    if (this.mb === null)
	      this.mb = this.m.toBigInt();

	    const x = this.intFrom(a.toBigInt());
	    const y = powInt(x, num, this.mb);
	    const z = this.intTo(y);

	    return BN.fromBigInt(z)._forceRed(this);
	  }

	  sqrn(a, n) {
	    while (n--)
	      a = this.sqr(a);

	    return a;
	  }

	  sqrnmul(a, n, b) {
	    return this.mul(this.sqrn(a, n), b);
	  }

	  ipown(a, num) {
	    return this.pown(a, num)._move(a);
	  }

	  pown(a, num) {
	    this._verify1(a);

	    if (num < 0) {
	      a = this.invert(a);
	      num = -num;
	    }

	    if (num === 0)
	      return new BN(1).toRed(this);

	    if (num === 1)
	      return a.clone();

	    const bits = countBits(num);

	    let r = a;

	    for (let i = bits - 2; i >= 0; i--) {
	      r = this.sqr(r);

	      if ((num >> i) & 1)
	        r = this.mul(r, a);
	    }

	    return r;
	  }

	  isqr(a) {
	    return this.imul(a, a);
	  }

	  sqr(a) {
	    return this.mul(a, a);
	  }

	  isqrt(x) {
	    return this.sqrt(x)._move(x);
	  }

	  sqrt(x) {
	    this._verify1(x);

	    // Optimized square root chain.
	    if (this.prime)
	      return this.prime.sqrt(x);

	    // Fast case (p = 3 mod 4).
	    if (this.m.andln(3) === 3)
	      return this.sqrt3mod4(x);

	    // Fast case (p = 5 mod 8).
	    if (this.m.andln(7) === 5) {
	      if (this.sm1 != null)
	        return this.sqrt5mod8sm1(x);
	      return this.sqrt5mod8(x);
	    }

	    // Slow case (Tonelli-Shanks).
	    return this.sqrt0(x);
	  }

	  sqrt3mod4(x) {
	    const e = this.m.addn(1).iushrn(2); // (p + 1) / 4
	    const b = this.pow(x, e);

	    if (!this.sqr(b).eq(x))
	      throw new SquareRootError(b);

	    return b;
	  }

	  sqrt5mod8(x) {
	    // Atkin's Algorithm.
	    const one = new BN(1).toRed(this);
	    const e = this.m.ushrn(3); // (p - 5) / 8
	    const x2 = this.add(x, x);
	    const alpha = this.pow(x2, e);
	    const beta = this.mul(x2, this.sqr(alpha));
	    const b = this.mul(this.mul(alpha, x), this.isub(beta, one));

	    if (!this.sqr(b).eq(x))
	      throw new SquareRootError(b);

	    return b;
	  }

	  sqrt5mod8sm1(x) {
	    const e = this.m.addn(3).iushrn(3); // (p + 3) / 8
	    const b = this.pow(x, e);

	    if (this.sqr(b).eq(x))
	      return b;

	    const c = this.mul(b, this.sm1);

	    if (this.sqr(c).eq(x))
	      return c;

	    throw new SquareRootError(b);
	  }

	  sqrt0(x) {
	    if (this.m.cmpn(1) === 0 || !this.m.isOdd())
	      throw new Error('Invalid prime.');

	    switch (this.jacobi(x)) {
	      case -1:
	        throw new SquareRootError(x);
	      case 0:
	        return x.clone();
	    }

	    const one = new BN(1).toRed(this);
	    const s = this.m.subn(1);
	    const e = s._makeOdd();
	    const n = new BN(2).toRed(this);

	    while (this.jacobi(n) !== -1)
	      this.iadd(n, one);

	    let g = this.pow(n, s);
	    let b = this.pow(x, s);
	    let y = this.pow(x, s.iaddn(1).iushrn(1));
	    let k = e;

	    for (;;) {
	      let t = b;
	      let m = 0;

	      while (!t.eq(one) && m < k) {
	        t = this.sqr(t);
	        m += 1;
	      }

	      if (m === 0)
	        break;

	      assert(m < k);

	      t = this.sqrn(g, k - m - 1);
	      g = this.sqr(t);
	      y = this.mul(y, t);
	      b = this.mul(b, g);
	      k = m;
	    }

	    return y;
	  }

	  idivsqrt(u, v) {
	    return this.divsqrt(u, v)._move(u);
	  }

	  divsqrt(u, v) {
	    this._verify2(u, v);

	    // u = 0, v = 0
	    if (u.isZero() && v.isZero())
	      throw new SquareRootError(v);

	    // Optimized inverse square root chain.
	    if (this.prime)
	      return this.prime.divsqrt(u, v);

	    // p = 3 mod 4
	    if (this.m.andln(3) === 3)
	      return this.divsqrt3mod4(u, v);

	    // p = 5 mod 8
	    if (this.sm1 != null && this.m.andln(7) === 5)
	      return this.divsqrt5mod8(u, v);

	    // v = 0
	    if (v.isZero())
	      throw new SquareRootError(v);

	    return this.sqrt(this.div(u, v));
	  }

	  divsqrt3mod4(u, v) {
	    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
	    const e = this.m.subn(3).iushrn(2);
	    const u2 = this.sqr(u);
	    const u3 = this.mul(u2, u);
	    const u5 = this.mul(u3, u2);
	    const v3 = this.mul(this.sqr(v), v);
	    const p = this.pow(this.mul(u5, v3), e);
	    const x = this.mul(this.mul(u3, v), p);
	    const c = this.mul(v, this.sqr(x));

	    if (c.eq(u))
	      return x;

	    throw new SquareRootError(x);
	  }

	  divsqrt5mod8(u, v) {
	    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
	    const e = this.m.subn(5).iushrn(3);
	    const v3 = this.mul(this.sqr(v), v);
	    const v7 = this.mul(this.sqr(v3), v);
	    const p = this.pow(this.mul(u, v7), e);
	    const x = this.mul(this.mul(u, v3), p);
	    const c = this.mul(v, this.sqr(x));

	    if (c.eq(u))
	      return x;

	    const mc = this.ineg(c);

	    if (mc.eq(u))
	      return this.mul(x, this.sm1);

	    if (mc.eq(this.mul(u, this.sm1)))
	      throw new SquareRootError(this.mul(x, this.sm1));

	    throw new SquareRootError(x);
	  }

	  isSquare(a) {
	    if (this.m.isOdd())
	      return this.jacobi(a) >= 0;

	    return this.kronecker(a) >= 0;
	  }

	  ishl(a, num) {
	    this._verify1(a);
	    return this.imod(a.iushl(num));
	  }

	  shl(a, num) {
	    return this.ishl(a.clone(), num);
	  }

	  ishln(a, num) {
	    this._verify1(a);

	    a.iushln(num);

	    if (num <= 4) {
	      // Quick reduction.
	      while (a.ucmp(this.m) >= 0)
	        a._isub(a, this.m);
	    } else {
	      this.imod(a);
	    }

	    return a;
	  }

	  shln(a, num) {
	    return this.ishln(a.clone(), num);
	  }

	  ineg(a) {
	    this._verify1(a);

	    if (!a.isZero())
	      a._isub(this.m, a);

	    return a;
	  }

	  neg(a) {
	    return this.ineg(a.clone());
	  }

	  eq(a, b) {
	    this._verify2(a, b);
	    return a.ucmp(b) === 0;
	  }

	  eqn(a, num) {
	    this._verify1(a);

	    if (this.m.length === 1) {
	      num %= this.m.words[0];

	      if (num < 0)
	        num += this.m.words[0];

	      return a.ucmpn(num) === 0;
	    }

	    if (num < 0) {
	      this.m._isubn(-num);

	      const cmp = a.ucmp(this.m);

	      this.m._iaddn(-num);

	      return cmp === 0;
	    }

	    return a.ucmpn(num) === 0;
	  }

	  isHigh(a) {
	    return !this.isLow(a);
	  }

	  isLow(a) {
	    this._verify1(a);
	    return a.ucmp(this.m.ushrn(1)) <= 0;
	  }

	  isOdd(a) {
	    this._verify1(a);
	    return a.isOdd();
	  }

	  isEven(a) {
	    this._verify1(a);
	    return a.isEven();
	  }

	  legendre(num) {
	    this._verify1(num);

	    if (this.m.isEven())
	      throw new Error('legendre: `num` must be odd.');

	    // Euler's criterion.
	    const e = this.m.subn(1).iushrn(1); // (p - 1) / 2
	    const symbol = this.pow(num, e);

	    if (symbol.isZero())
	      return 0;

	    const one = new BN(1).toRed(this);

	    if (symbol.eq(one))
	      return 1;

	    if (symbol.eq(this.ineg(one)))
	      return -1;

	    throw new Error('Invalid prime.');
	  }

	  jacobi(a) {
	    this._verify1(a);
	    return a.jacobi(this.m);
	  }

	  kronecker(a) {
	    this._verify1(a);
	    return a.kronecker(this.m);
	  }

	  iinvert(a) {
	    return this.invert(a)._move(a);
	  }

	  invert(a) {
	    this._verify1(a);
	    return a.invert(this.m)._forceRed(this);
	  }

	  ifermat(a) {
	    return this.fermat(a)._move(a);
	  }

	  fermat(a) {
	    this._verify1(a);

	    if (a.isZero() || this.m.cmpn(1) === 0)
	      throw new RangeError('Not invertible.');

	    // Optimized inversion chain.
	    if (this.prime)
	      return this.prime.fermat(a);

	    // Invert using fermat's little theorem.
	    return this.pow(a, this.m.subn(2));
	  }

	  invertAll(elems) {
	    // Montgomery's trick.
	    enforce(Array.isArray(elems), 'elems', 'array');

	    for (const elem of elems) {
	      enforce(BN.isBN(elem), 'elem', 'bignum');

	      this._verify1(elem);
	    }

	    if (this.m.cmpn(1) === 0 || this.m.isEven())
	      throw new RangeError('Not invertible.');

	    const len = elems.length;
	    const invs = new Array(len);

	    if (len === 0)
	      return invs;

	    let acc = new BN(1).toRed(this);

	    for (let i = 0; i < len; i++) {
	      if (elems[i].isZero()) {
	        invs[i] = elems[i].clone();
	        continue;
	      }

	      invs[i] = acc;
	      acc = this.mul(acc, elems[i]);
	    }

	    acc = this.invert(acc);

	    for (let i = len - 1; i >= 0; i--) {
	      if (elems[i].isZero())
	        continue;

	      invs[i] = this.mul(acc, invs[i]);
	      acc = this.mul(acc, elems[i]);
	    }

	    return invs;
	  }

	  [custom]() {
	    if (this.prime)
	      return `<Red: ${this.prime.name}>`;

	    return `<Red: ${this.m.toString(10)}>`;
	  }
	}

	/**
	 * Barrett Engine
	 */

	class Barrett extends Red {
	  constructor(m) {
	    super(m);

	    this.prime = null;
	    this.n = this.m.bitLength();

	    if ((this.n % 26) !== 0)
	      this.n += 26 - (this.n % 26);

	    this.k = this.n * 2;
	    this.w = this.k / 26;
	    this.b = BN.shift(1, this.k).div(this.m);
	  }

	  convertTo(num) {
	    if (num.length > this.w)
	      return super.convertTo(num);

	    return this.imod(num.clone());
	  }

	  _shift(q) {
	    let i = 0;
	    let j = this.w;

	    while (j < q.length)
	      q.words[i++] = q.words[j++];

	    if (i === 0)
	      q.words[i++] = 0;

	    q.length = i;
	  }

	  imod(a) {
	    const neg = a.negative;

	    assert(a.length <= this.w);

	    a.negative = 0;

	    const q = a.mul(this.b);

	    // Shift right by `k` bits.
	    this._shift(q);

	    a._isub(a, q.mul(this.m));

	    if (a.ucmp(this.m) >= 0)
	      a._isub(a, this.m);

	    if (neg && !a.isZero())
	      a._isub(this.m, a);

	    a.red = this;

	    return a;
	  }
	}

	/**
	 * Montgomery Engine
	 */

	class Mont extends Red {
	  constructor(m) {
	    super(m);

	    // Note that:
	    //
	    //   mi = (-m^-1 mod (2^(n * 2))) mod r
	    //
	    // and:
	    //
	    //   mi = (((2^n)^-1 mod m) * r^-1 - 1) / m
	    //
	    // are equivalent.
	    this.prime = null;
	    this.n = this.m.length * 26;
	    this.r = BN.shift(1, this.n);
	    this.r2 = BN.shift(1, this.n * 2).imod(this.m);
	    this.ri = this.r.invert(this.m);
	    this.mi = this.r.mul(this.ri).isubn(1).div(this.m);
	    this.rib = null;
	  }

	  get mont() {
	    return true;
	  }

	  convertTo(num) {
	    if (num.isNeg() || num.ucmp(this.m) >= 0)
	      return this.imod(num.ushln(this.n));

	    // Equivalent to: (num * 2^n) mod m
	    return this.mul(num, this.r2);
	  }

	  convertFrom(num) {
	    // Equivalent to: num * r^-1 mod m
	    const r = this.mul(num, new BN(1));
	    r.red = null;
	    return r;
	  }

	  intTo(a) {
	    return (a << BigInt(this.n)) % this.mb;
	  }

	  intFrom(a) {
	    if (this.rib === null)
	      this.rib = this.ri.toBigInt();

	    return (a * this.rib) % this.mb;
	  }

	  iaddn(a, num) {
	    return this.iadd(a, this.convertTo(new BN(num)));
	  }

	  isubn(a, num) {
	    return this.isub(a, this.convertTo(new BN(num)));
	  }

	  imul(a, b) {
	    return this.mul(a, b)._move(a);
	  }

	  mul(a, b) {
	    if (a.isZero() || b.isZero())
	      return new BN(0)._forceRed(this);

	    const t = a.mul(b);
	    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);
	    const u = t.iadd(c.mul(this.m)).iushrn(this.n);

	    if (u.ucmp(this.m) >= 0)
	      u._isub(u, this.m);

	    return u._forceRed(this);
	  }

	  imuln(a, num) {
	    this._verify1(a);

	    if (a.isZero())
	      return a;

	    if (num === 0) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    const neg = num < 0;

	    if (neg)
	      num = -num;

	    if (this.m.length === 1)
	      num %= this.m.words[0];

	    const bits = countBits(num);

	    // Potentially compute with additions.
	    // This avoids an expensive division.
	    if (bits > 5) {
	      // Slow case (num > 31).
	      this.imul(a, this.convertTo(new BN(num)));
	    } else if ((num & (num - 1)) === 0) {
	      // Optimize for powers of two.
	      for (let i = 0; i < bits - 1; i++)
	        this.iadd(a, a);
	    } else {
	      // Multiply left to right.
	      const c = a.clone();

	      for (let i = bits - 2; i >= 0; i--) {
	        this.iadd(a, a);

	        if ((num >> i) & 1)
	          this.iadd(a, c);
	      }
	    }

	    if (neg)
	      this.ineg(a);

	    return a;
	  }

	  eqn(a, num) {
	    this._verify1(a);

	    if (num === 0)
	      return a.isZero();

	    return a.ucmp(this.convertTo(new BN(num))) === 0;
	  }

	  isLow(a) {
	    this._verify1(a);
	    return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;
	  }

	  isOdd(a) {
	    this._verify1(a);
	    return this.convertFrom(a).isOdd();
	  }

	  isEven(a) {
	    this._verify1(a);
	    return this.convertFrom(a).isEven();
	  }

	  invert(a) {
	    this._verify1(a);

	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    return this.imod(a.invert(this.m).mul(this.r2));
	  }
	}

	/*
	 * Helpers
	 */

	function makeError(Error, msg, start) {
	  const err = new Error(msg);

	  if (Error.captureStackTrace)
	    Error.captureStackTrace(err, start);

	  return err;
	}

	function assert(value, message) {
	  if (!value) {
	    const msg = message || 'Assertion failed.';
	    throw makeError(Error, msg, assert);
	  }
	}

	function enforce(value, name, type) {
	  if (!value) {
	    const msg = `"${name}" must be a(n) ${type}.`;
	    throw makeError(TypeError, msg, enforce);
	  }
	}

	function range(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with positive numbers.`;
	    throw makeError(RangeError, msg, range);
	  }
	}

	function red(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with red numbers.`;
	    throw makeError(TypeError, msg, red);
	  }
	}

	function nonred(value, name) {
	  if (!value) {
	    const msg = `"${name}" only works with normal numbers.`;
	    throw makeError(TypeError, msg, nonred);
	  }
	}

	function nonzero(value) {
	  if (!value) {
	    const msg = 'Cannot divide by zero.';
	    throw makeError(RangeError, msg, nonzero);
	  }
	}

	class SquareRootError extends Error {
	  constructor(result) {
	    super();

	    this.name = 'SquareRootError';
	    this.message = 'X is not a square mod P.';
	    this.result = result.fromRed();

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(this, SquareRootError);
	  }
	}

	function isInteger(num) {
	  return Number.isSafeInteger(num);
	}

	function isSMI(num) {
	  return isInteger(num)
	      && num >= -67108863
	      && num <= 0x3ffffff;
	}

	function allocate(ArrayType, size) {
	  if (ArrayType.allocUnsafeSlow)
	    return ArrayType.allocUnsafeSlow(size);

	  return new ArrayType(size);
	}

	function getBase(base) {
	  if (base == null)
	    return 10;

	  if (typeof base === 'number')
	    return base;

	  switch (base) {
	    case 'bin':
	      return 2;
	    case 'oct':
	      return 8;
	    case 'dec':
	      return 10;
	    case 'hex':
	      return 16;
	  }

	  return 0;
	}

	/*
	 * Internal
	 */

	function countBits(w) {
	  if (Math.clz32)
	    return 32 - Math.clz32(w);

	  let t = w;
	  let r = 0;

	  if (t >= 0x1000) {
	    r += 13;
	    t >>>= 13;
	  }

	  if (t >= 0x40) {
	    r += 7;
	    t >>>= 7;
	  }

	  if (t >= 0x8) {
	    r += 4;
	    t >>>= 4;
	  }

	  if (t >= 0x02) {
	    r += 2;
	    t >>>= 2;
	  }

	  return r + t;
	}

	function zeroBits(w) {
	  // Shortcut.
	  if (w === 0)
	    return 26;

	  let t = w;
	  let r = 0;

	  if ((t & 0x1fff) === 0) {
	    r += 13;
	    t >>>= 13;
	  }

	  if ((t & 0x7f) === 0) {
	    r += 7;
	    t >>>= 7;
	  }

	  if ((t & 0xf) === 0) {
	    r += 4;
	    t >>>= 4;
	  }

	  if ((t & 0x3) === 0) {
	    r += 2;
	    t >>>= 2;
	  }

	  if ((t & 0x1) === 0)
	    r += 1;

	  return r;
	}

	function parseHex(str, start, end) {
	  const len = Math.min(str.length, end);

	  let r = 0;
	  let z = 0;

	  for (let i = start; i < len; i++) {
	    const c = str.charCodeAt(i) - 48;

	    r <<= 4;

	    let b;

	    if (c >= 49 && c <= 54) {
	      // 'a' - 'f'
	      b = c - 49 + 0xa;
	    } else if (c >= 17 && c <= 22) {
	      // 'A' - 'F'
	      b = c - 17 + 0xa;
	    } else {
	      // '0' - '9'
	      b = c;
	    }

	    r |= b;
	    z |= b;
	  }

	  if (z & -16)
	    throw new Error('Invalid string.');

	  return r;
	}

	function parseBase(str, start, end, mul) {
	  const len = Math.min(str.length, end);

	  let r = 0;

	  for (let i = start; i < len; i++) {
	    const c = str.charCodeAt(i) - 48;

	    r *= mul;

	    let b;

	    if (c >= 49) {
	      // 'a'
	      b = c - 49 + 0xa;
	    } else if (c >= 17) {
	      // 'A'
	      b = c - 17 + 0xa;
	    } else {
	      // '0' - '9'
	      b = c;
	    }

	    if (c < 0 || c > 207 || b >= mul)
	      throw new Error('Invalid string.');

	    r += b;
	  }

	  return r;
	}

	/*
	 * Exponentiation (bigint)
	 */

	function powInt(x, e, m) {
	  // Sliding window (odd multiples only).
	  const one = BigInt(1);
	  const wnd = new Array(WND_SIZE);
	  const x2 = (x * x) % m;

	  wnd[0] = x;

	  for (let i = 1; i < WND_SIZE; i++)
	    wnd[i] = (wnd[i - 1] * x2) % m;

	  let i = e.bitLength();
	  let r = one;

	  while (i >= WND_WIDTH) {
	    let width = WND_WIDTH;
	    let bits = e.bits(i - width, width);

	    if (bits < WND_SIZE) {
	      r = (r * r) % m;
	      i -= 1;
	      continue;
	    }

	    while ((bits & 1) === 0) {
	      width -= 1;
	      bits >>= 1;
	    }

	    if (r === one) {
	      r = wnd[bits >> 1];
	    } else {
	      r = sqrn(r, width, m);
	      r = (r * wnd[bits >> 1]) % m;
	    }

	    i -= width;
	  }

	  if (i > 0) {
	    const bits = e.bits(0, i);

	    while (i--) {
	      r = (r * r) % m;

	      if ((bits >> i) & 1)
	        r = (r * x) % m;
	    }
	  }

	  return r;
	}

	function sqrn(x, n, m) {
	  for (let i = 0; i < n; i++)
	    x = (x * x) % m;
	  return x;
	}

	/*
	 * Multiplication
	 */

	function smallMulTo(self, num, out) {
	  const len = self.length + num.length;

	  out.negative = self.negative ^ num.negative;
	  out._alloc(len);
	  out.length = len;

	  // Peel one iteration (compiler can't
	  // do it, because of code complexity).
	  const a = self.words[0];
	  const b = num.words[0];
	  const r = a * b;
	  const lo = r & 0x3ffffff;

	  let carry = (r / 0x4000000) | 0;
	  let k = 1;

	  out.words[0] = lo;

	  for (; k < out.length - 1; k++) {
	    // Sum all words with the same
	    // `i + j = k` and accumulate
	    // `ncarry`, note that ncarry
	    // could be >= 0x3ffffff.
	    let ncarry = carry >>> 26;
	    let rword = carry & 0x3ffffff;

	    const min = Math.max(0, k - self.length + 1);
	    const max = Math.min(k, num.length - 1);

	    for (let j = min; j <= max; j++) {
	      const i = k - j;
	      const a = self.words[i];
	      const b = num.words[j];
	      const r = a * b + rword;

	      ncarry += (r / 0x4000000) | 0;
	      rword = r & 0x3ffffff;
	    }

	    out.words[k] = rword | 0;
	    carry = ncarry | 0;
	  }

	  if (carry !== 0)
	    out.words[k] = carry | 0;
	  else
	    out.length -= 1;

	  return out._strip();
	}

	function bigMulTo(self, num, out) {
	  const len = self.length + num.length;

	  out.negative = self.negative ^ num.negative;
	  out._alloc(len);
	  out.length = len;

	  let carry = 0;
	  let hncarry = 0;
	  let k = 0;

	  for (; k < out.length - 1; k++) {
	    // Sum all words with the same
	    // `i + j = k` and accumulate
	    // `ncarry`, note that ncarry
	    // could be >= 0x3ffffff.
	    let ncarry = hncarry;

	    hncarry = 0;

	    let rword = carry & 0x3ffffff;

	    const min = Math.max(0, k - self.length + 1);
	    const max = Math.min(k, num.length - 1);

	    for (let j = min; j <= max; j++) {
	      const i = k - j;
	      const a = self.words[i];
	      const b = num.words[j];
	      const r = a * b;

	      let lo = r & 0x3ffffff;

	      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	      lo = (lo + rword) | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = (ncarry + (lo >>> 26)) | 0;

	      hncarry += ncarry >>> 26;
	      ncarry &= 0x3ffffff;
	    }

	    out.words[k] = rword;
	    carry = ncarry;
	    ncarry = hncarry;
	  }

	  if (carry !== 0)
	    out.words[k] = carry;
	  else
	    out.length -= 1;

	  return out._strip();
	}

	function jumboMulTo(x, y, out) {
	  // v8 has a 2147483519 bit max (~256mb).
	  if (!HAS_BIGINT || x.length + y.length > 82595519)
	    return bigMulTo(x, y, out);

	  const zero = BigInt(0);
	  const mask = BigInt(0x3ffffff);
	  const shift = BigInt(26);

	  let z = x.toBigInt() * y.toBigInt();

	  const neg = (z < zero) | 0;

	  if (neg)
	    z = -z;

	  let i = 0;

	  while (z > zero) {
	    out.words[i++] = Number(z & mask);
	    z >>= shift;
	  }

	  if (i === 0)
	    out.words[i++] = 0;

	  out.length = i;
	  out.negative = neg;

	  return out;
	}

	function comb10MulTo(self, num, out) {
	  const a = self.words;
	  const b = num.words;
	  const o = out.words;
	  const a0 = a[0] | 0;
	  const al0 = a0 & 0x1fff;
	  const ah0 = a0 >>> 13;
	  const a1 = a[1] | 0;
	  const al1 = a1 & 0x1fff;
	  const ah1 = a1 >>> 13;
	  const a2 = a[2] | 0;
	  const al2 = a2 & 0x1fff;
	  const ah2 = a2 >>> 13;
	  const a3 = a[3] | 0;
	  const al3 = a3 & 0x1fff;
	  const ah3 = a3 >>> 13;
	  const a4 = a[4] | 0;
	  const al4 = a4 & 0x1fff;
	  const ah4 = a4 >>> 13;
	  const a5 = a[5] | 0;
	  const al5 = a5 & 0x1fff;
	  const ah5 = a5 >>> 13;
	  const a6 = a[6] | 0;
	  const al6 = a6 & 0x1fff;
	  const ah6 = a6 >>> 13;
	  const a7 = a[7] | 0;
	  const al7 = a7 & 0x1fff;
	  const ah7 = a7 >>> 13;
	  const a8 = a[8] | 0;
	  const al8 = a8 & 0x1fff;
	  const ah8 = a8 >>> 13;
	  const a9 = a[9] | 0;
	  const al9 = a9 & 0x1fff;
	  const ah9 = a9 >>> 13;
	  const b0 = b[0] | 0;
	  const bl0 = b0 & 0x1fff;
	  const bh0 = b0 >>> 13;
	  const b1 = b[1] | 0;
	  const bl1 = b1 & 0x1fff;
	  const bh1 = b1 >>> 13;
	  const b2 = b[2] | 0;
	  const bl2 = b2 & 0x1fff;
	  const bh2 = b2 >>> 13;
	  const b3 = b[3] | 0;
	  const bl3 = b3 & 0x1fff;
	  const bh3 = b3 >>> 13;
	  const b4 = b[4] | 0;
	  const bl4 = b4 & 0x1fff;
	  const bh4 = b4 >>> 13;
	  const b5 = b[5] | 0;
	  const bl5 = b5 & 0x1fff;
	  const bh5 = b5 >>> 13;
	  const b6 = b[6] | 0;
	  const bl6 = b6 & 0x1fff;
	  const bh6 = b6 >>> 13;
	  const b7 = b[7] | 0;
	  const bl7 = b7 & 0x1fff;
	  const bh7 = b7 >>> 13;
	  const b8 = b[8] | 0;
	  const bl8 = b8 & 0x1fff;
	  const bh8 = b8 >>> 13;
	  const b9 = b[9] | 0;
	  const bl9 = b9 & 0x1fff;
	  const bh9 = b9 >>> 13;

	  let c = 0;
	  let lo, mid, hi;

	  out.negative = self.negative ^ num.negative;
	  out._alloc(20);
	  out.length = 19;

	  /* k = 0 */
	  lo = Math.imul(al0, bl0);
	  mid = Math.imul(al0, bh0);
	  mid = (mid + Math.imul(ah0, bl0)) | 0;
	  hi = Math.imul(ah0, bh0);

	  let w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	  w0 &= 0x3ffffff;

	  /* k = 1 */
	  lo = Math.imul(al1, bl0);
	  mid = Math.imul(al1, bh0);
	  mid = (mid + Math.imul(ah1, bl0)) | 0;
	  hi = Math.imul(ah1, bh0);
	  lo = (lo + Math.imul(al0, bl1)) | 0;
	  mid = (mid + Math.imul(al0, bh1)) | 0;
	  mid = (mid + Math.imul(ah0, bl1)) | 0;
	  hi = (hi + Math.imul(ah0, bh1)) | 0;

	  let w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	  w1 &= 0x3ffffff;

	  /* k = 2 */
	  lo = Math.imul(al2, bl0);
	  mid = Math.imul(al2, bh0);
	  mid = (mid + Math.imul(ah2, bl0)) | 0;
	  hi = Math.imul(ah2, bh0);
	  lo = (lo + Math.imul(al1, bl1)) | 0;
	  mid = (mid + Math.imul(al1, bh1)) | 0;
	  mid = (mid + Math.imul(ah1, bl1)) | 0;
	  hi = (hi + Math.imul(ah1, bh1)) | 0;
	  lo = (lo + Math.imul(al0, bl2)) | 0;
	  mid = (mid + Math.imul(al0, bh2)) | 0;
	  mid = (mid + Math.imul(ah0, bl2)) | 0;
	  hi = (hi + Math.imul(ah0, bh2)) | 0;

	  let w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	  w2 &= 0x3ffffff;

	  /* k = 3 */
	  lo = Math.imul(al3, bl0);
	  mid = Math.imul(al3, bh0);
	  mid = (mid + Math.imul(ah3, bl0)) | 0;
	  hi = Math.imul(ah3, bh0);
	  lo = (lo + Math.imul(al2, bl1)) | 0;
	  mid = (mid + Math.imul(al2, bh1)) | 0;
	  mid = (mid + Math.imul(ah2, bl1)) | 0;
	  hi = (hi + Math.imul(ah2, bh1)) | 0;
	  lo = (lo + Math.imul(al1, bl2)) | 0;
	  mid = (mid + Math.imul(al1, bh2)) | 0;
	  mid = (mid + Math.imul(ah1, bl2)) | 0;
	  hi = (hi + Math.imul(ah1, bh2)) | 0;
	  lo = (lo + Math.imul(al0, bl3)) | 0;
	  mid = (mid + Math.imul(al0, bh3)) | 0;
	  mid = (mid + Math.imul(ah0, bl3)) | 0;
	  hi = (hi + Math.imul(ah0, bh3)) | 0;

	  let w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	  w3 &= 0x3ffffff;

	  /* k = 4 */
	  lo = Math.imul(al4, bl0);
	  mid = Math.imul(al4, bh0);
	  mid = (mid + Math.imul(ah4, bl0)) | 0;
	  hi = Math.imul(ah4, bh0);
	  lo = (lo + Math.imul(al3, bl1)) | 0;
	  mid = (mid + Math.imul(al3, bh1)) | 0;
	  mid = (mid + Math.imul(ah3, bl1)) | 0;
	  hi = (hi + Math.imul(ah3, bh1)) | 0;
	  lo = (lo + Math.imul(al2, bl2)) | 0;
	  mid = (mid + Math.imul(al2, bh2)) | 0;
	  mid = (mid + Math.imul(ah2, bl2)) | 0;
	  hi = (hi + Math.imul(ah2, bh2)) | 0;
	  lo = (lo + Math.imul(al1, bl3)) | 0;
	  mid = (mid + Math.imul(al1, bh3)) | 0;
	  mid = (mid + Math.imul(ah1, bl3)) | 0;
	  hi = (hi + Math.imul(ah1, bh3)) | 0;
	  lo = (lo + Math.imul(al0, bl4)) | 0;
	  mid = (mid + Math.imul(al0, bh4)) | 0;
	  mid = (mid + Math.imul(ah0, bl4)) | 0;
	  hi = (hi + Math.imul(ah0, bh4)) | 0;

	  let w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	  w4 &= 0x3ffffff;

	  /* k = 5 */
	  lo = Math.imul(al5, bl0);
	  mid = Math.imul(al5, bh0);
	  mid = (mid + Math.imul(ah5, bl0)) | 0;
	  hi = Math.imul(ah5, bh0);
	  lo = (lo + Math.imul(al4, bl1)) | 0;
	  mid = (mid + Math.imul(al4, bh1)) | 0;
	  mid = (mid + Math.imul(ah4, bl1)) | 0;
	  hi = (hi + Math.imul(ah4, bh1)) | 0;
	  lo = (lo + Math.imul(al3, bl2)) | 0;
	  mid = (mid + Math.imul(al3, bh2)) | 0;
	  mid = (mid + Math.imul(ah3, bl2)) | 0;
	  hi = (hi + Math.imul(ah3, bh2)) | 0;
	  lo = (lo + Math.imul(al2, bl3)) | 0;
	  mid = (mid + Math.imul(al2, bh3)) | 0;
	  mid = (mid + Math.imul(ah2, bl3)) | 0;
	  hi = (hi + Math.imul(ah2, bh3)) | 0;
	  lo = (lo + Math.imul(al1, bl4)) | 0;
	  mid = (mid + Math.imul(al1, bh4)) | 0;
	  mid = (mid + Math.imul(ah1, bl4)) | 0;
	  hi = (hi + Math.imul(ah1, bh4)) | 0;
	  lo = (lo + Math.imul(al0, bl5)) | 0;
	  mid = (mid + Math.imul(al0, bh5)) | 0;
	  mid = (mid + Math.imul(ah0, bl5)) | 0;
	  hi = (hi + Math.imul(ah0, bh5)) | 0;

	  let w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	  w5 &= 0x3ffffff;

	  /* k = 6 */
	  lo = Math.imul(al6, bl0);
	  mid = Math.imul(al6, bh0);
	  mid = (mid + Math.imul(ah6, bl0)) | 0;
	  hi = Math.imul(ah6, bh0);
	  lo = (lo + Math.imul(al5, bl1)) | 0;
	  mid = (mid + Math.imul(al5, bh1)) | 0;
	  mid = (mid + Math.imul(ah5, bl1)) | 0;
	  hi = (hi + Math.imul(ah5, bh1)) | 0;
	  lo = (lo + Math.imul(al4, bl2)) | 0;
	  mid = (mid + Math.imul(al4, bh2)) | 0;
	  mid = (mid + Math.imul(ah4, bl2)) | 0;
	  hi = (hi + Math.imul(ah4, bh2)) | 0;
	  lo = (lo + Math.imul(al3, bl3)) | 0;
	  mid = (mid + Math.imul(al3, bh3)) | 0;
	  mid = (mid + Math.imul(ah3, bl3)) | 0;
	  hi = (hi + Math.imul(ah3, bh3)) | 0;
	  lo = (lo + Math.imul(al2, bl4)) | 0;
	  mid = (mid + Math.imul(al2, bh4)) | 0;
	  mid = (mid + Math.imul(ah2, bl4)) | 0;
	  hi = (hi + Math.imul(ah2, bh4)) | 0;
	  lo = (lo + Math.imul(al1, bl5)) | 0;
	  mid = (mid + Math.imul(al1, bh5)) | 0;
	  mid = (mid + Math.imul(ah1, bl5)) | 0;
	  hi = (hi + Math.imul(ah1, bh5)) | 0;
	  lo = (lo + Math.imul(al0, bl6)) | 0;
	  mid = (mid + Math.imul(al0, bh6)) | 0;
	  mid = (mid + Math.imul(ah0, bl6)) | 0;
	  hi = (hi + Math.imul(ah0, bh6)) | 0;

	  let w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	  w6 &= 0x3ffffff;

	  /* k = 7 */
	  lo = Math.imul(al7, bl0);
	  mid = Math.imul(al7, bh0);
	  mid = (mid + Math.imul(ah7, bl0)) | 0;
	  hi = Math.imul(ah7, bh0);
	  lo = (lo + Math.imul(al6, bl1)) | 0;
	  mid = (mid + Math.imul(al6, bh1)) | 0;
	  mid = (mid + Math.imul(ah6, bl1)) | 0;
	  hi = (hi + Math.imul(ah6, bh1)) | 0;
	  lo = (lo + Math.imul(al5, bl2)) | 0;
	  mid = (mid + Math.imul(al5, bh2)) | 0;
	  mid = (mid + Math.imul(ah5, bl2)) | 0;
	  hi = (hi + Math.imul(ah5, bh2)) | 0;
	  lo = (lo + Math.imul(al4, bl3)) | 0;
	  mid = (mid + Math.imul(al4, bh3)) | 0;
	  mid = (mid + Math.imul(ah4, bl3)) | 0;
	  hi = (hi + Math.imul(ah4, bh3)) | 0;
	  lo = (lo + Math.imul(al3, bl4)) | 0;
	  mid = (mid + Math.imul(al3, bh4)) | 0;
	  mid = (mid + Math.imul(ah3, bl4)) | 0;
	  hi = (hi + Math.imul(ah3, bh4)) | 0;
	  lo = (lo + Math.imul(al2, bl5)) | 0;
	  mid = (mid + Math.imul(al2, bh5)) | 0;
	  mid = (mid + Math.imul(ah2, bl5)) | 0;
	  hi = (hi + Math.imul(ah2, bh5)) | 0;
	  lo = (lo + Math.imul(al1, bl6)) | 0;
	  mid = (mid + Math.imul(al1, bh6)) | 0;
	  mid = (mid + Math.imul(ah1, bl6)) | 0;
	  hi = (hi + Math.imul(ah1, bh6)) | 0;
	  lo = (lo + Math.imul(al0, bl7)) | 0;
	  mid = (mid + Math.imul(al0, bh7)) | 0;
	  mid = (mid + Math.imul(ah0, bl7)) | 0;
	  hi = (hi + Math.imul(ah0, bh7)) | 0;

	  let w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	  w7 &= 0x3ffffff;

	  /* k = 8 */
	  lo = Math.imul(al8, bl0);
	  mid = Math.imul(al8, bh0);
	  mid = (mid + Math.imul(ah8, bl0)) | 0;
	  hi = Math.imul(ah8, bh0);
	  lo = (lo + Math.imul(al7, bl1)) | 0;
	  mid = (mid + Math.imul(al7, bh1)) | 0;
	  mid = (mid + Math.imul(ah7, bl1)) | 0;
	  hi = (hi + Math.imul(ah7, bh1)) | 0;
	  lo = (lo + Math.imul(al6, bl2)) | 0;
	  mid = (mid + Math.imul(al6, bh2)) | 0;
	  mid = (mid + Math.imul(ah6, bl2)) | 0;
	  hi = (hi + Math.imul(ah6, bh2)) | 0;
	  lo = (lo + Math.imul(al5, bl3)) | 0;
	  mid = (mid + Math.imul(al5, bh3)) | 0;
	  mid = (mid + Math.imul(ah5, bl3)) | 0;
	  hi = (hi + Math.imul(ah5, bh3)) | 0;
	  lo = (lo + Math.imul(al4, bl4)) | 0;
	  mid = (mid + Math.imul(al4, bh4)) | 0;
	  mid = (mid + Math.imul(ah4, bl4)) | 0;
	  hi = (hi + Math.imul(ah4, bh4)) | 0;
	  lo = (lo + Math.imul(al3, bl5)) | 0;
	  mid = (mid + Math.imul(al3, bh5)) | 0;
	  mid = (mid + Math.imul(ah3, bl5)) | 0;
	  hi = (hi + Math.imul(ah3, bh5)) | 0;
	  lo = (lo + Math.imul(al2, bl6)) | 0;
	  mid = (mid + Math.imul(al2, bh6)) | 0;
	  mid = (mid + Math.imul(ah2, bl6)) | 0;
	  hi = (hi + Math.imul(ah2, bh6)) | 0;
	  lo = (lo + Math.imul(al1, bl7)) | 0;
	  mid = (mid + Math.imul(al1, bh7)) | 0;
	  mid = (mid + Math.imul(ah1, bl7)) | 0;
	  hi = (hi + Math.imul(ah1, bh7)) | 0;
	  lo = (lo + Math.imul(al0, bl8)) | 0;
	  mid = (mid + Math.imul(al0, bh8)) | 0;
	  mid = (mid + Math.imul(ah0, bl8)) | 0;
	  hi = (hi + Math.imul(ah0, bh8)) | 0;

	  let w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	  w8 &= 0x3ffffff;

	  /* k = 9 */
	  lo = Math.imul(al9, bl0);
	  mid = Math.imul(al9, bh0);
	  mid = (mid + Math.imul(ah9, bl0)) | 0;
	  hi = Math.imul(ah9, bh0);
	  lo = (lo + Math.imul(al8, bl1)) | 0;
	  mid = (mid + Math.imul(al8, bh1)) | 0;
	  mid = (mid + Math.imul(ah8, bl1)) | 0;
	  hi = (hi + Math.imul(ah8, bh1)) | 0;
	  lo = (lo + Math.imul(al7, bl2)) | 0;
	  mid = (mid + Math.imul(al7, bh2)) | 0;
	  mid = (mid + Math.imul(ah7, bl2)) | 0;
	  hi = (hi + Math.imul(ah7, bh2)) | 0;
	  lo = (lo + Math.imul(al6, bl3)) | 0;
	  mid = (mid + Math.imul(al6, bh3)) | 0;
	  mid = (mid + Math.imul(ah6, bl3)) | 0;
	  hi = (hi + Math.imul(ah6, bh3)) | 0;
	  lo = (lo + Math.imul(al5, bl4)) | 0;
	  mid = (mid + Math.imul(al5, bh4)) | 0;
	  mid = (mid + Math.imul(ah5, bl4)) | 0;
	  hi = (hi + Math.imul(ah5, bh4)) | 0;
	  lo = (lo + Math.imul(al4, bl5)) | 0;
	  mid = (mid + Math.imul(al4, bh5)) | 0;
	  mid = (mid + Math.imul(ah4, bl5)) | 0;
	  hi = (hi + Math.imul(ah4, bh5)) | 0;
	  lo = (lo + Math.imul(al3, bl6)) | 0;
	  mid = (mid + Math.imul(al3, bh6)) | 0;
	  mid = (mid + Math.imul(ah3, bl6)) | 0;
	  hi = (hi + Math.imul(ah3, bh6)) | 0;
	  lo = (lo + Math.imul(al2, bl7)) | 0;
	  mid = (mid + Math.imul(al2, bh7)) | 0;
	  mid = (mid + Math.imul(ah2, bl7)) | 0;
	  hi = (hi + Math.imul(ah2, bh7)) | 0;
	  lo = (lo + Math.imul(al1, bl8)) | 0;
	  mid = (mid + Math.imul(al1, bh8)) | 0;
	  mid = (mid + Math.imul(ah1, bl8)) | 0;
	  hi = (hi + Math.imul(ah1, bh8)) | 0;
	  lo = (lo + Math.imul(al0, bl9)) | 0;
	  mid = (mid + Math.imul(al0, bh9)) | 0;
	  mid = (mid + Math.imul(ah0, bl9)) | 0;
	  hi = (hi + Math.imul(ah0, bh9)) | 0;

	  let w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	  w9 &= 0x3ffffff;

	  /* k = 10 */
	  lo = Math.imul(al9, bl1);
	  mid = Math.imul(al9, bh1);
	  mid = (mid + Math.imul(ah9, bl1)) | 0;
	  hi = Math.imul(ah9, bh1);
	  lo = (lo + Math.imul(al8, bl2)) | 0;
	  mid = (mid + Math.imul(al8, bh2)) | 0;
	  mid = (mid + Math.imul(ah8, bl2)) | 0;
	  hi = (hi + Math.imul(ah8, bh2)) | 0;
	  lo = (lo + Math.imul(al7, bl3)) | 0;
	  mid = (mid + Math.imul(al7, bh3)) | 0;
	  mid = (mid + Math.imul(ah7, bl3)) | 0;
	  hi = (hi + Math.imul(ah7, bh3)) | 0;
	  lo = (lo + Math.imul(al6, bl4)) | 0;
	  mid = (mid + Math.imul(al6, bh4)) | 0;
	  mid = (mid + Math.imul(ah6, bl4)) | 0;
	  hi = (hi + Math.imul(ah6, bh4)) | 0;
	  lo = (lo + Math.imul(al5, bl5)) | 0;
	  mid = (mid + Math.imul(al5, bh5)) | 0;
	  mid = (mid + Math.imul(ah5, bl5)) | 0;
	  hi = (hi + Math.imul(ah5, bh5)) | 0;
	  lo = (lo + Math.imul(al4, bl6)) | 0;
	  mid = (mid + Math.imul(al4, bh6)) | 0;
	  mid = (mid + Math.imul(ah4, bl6)) | 0;
	  hi = (hi + Math.imul(ah4, bh6)) | 0;
	  lo = (lo + Math.imul(al3, bl7)) | 0;
	  mid = (mid + Math.imul(al3, bh7)) | 0;
	  mid = (mid + Math.imul(ah3, bl7)) | 0;
	  hi = (hi + Math.imul(ah3, bh7)) | 0;
	  lo = (lo + Math.imul(al2, bl8)) | 0;
	  mid = (mid + Math.imul(al2, bh8)) | 0;
	  mid = (mid + Math.imul(ah2, bl8)) | 0;
	  hi = (hi + Math.imul(ah2, bh8)) | 0;
	  lo = (lo + Math.imul(al1, bl9)) | 0;
	  mid = (mid + Math.imul(al1, bh9)) | 0;
	  mid = (mid + Math.imul(ah1, bl9)) | 0;
	  hi = (hi + Math.imul(ah1, bh9)) | 0;

	  let w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	  w10 &= 0x3ffffff;

	  /* k = 11 */
	  lo = Math.imul(al9, bl2);
	  mid = Math.imul(al9, bh2);
	  mid = (mid + Math.imul(ah9, bl2)) | 0;
	  hi = Math.imul(ah9, bh2);
	  lo = (lo + Math.imul(al8, bl3)) | 0;
	  mid = (mid + Math.imul(al8, bh3)) | 0;
	  mid = (mid + Math.imul(ah8, bl3)) | 0;
	  hi = (hi + Math.imul(ah8, bh3)) | 0;
	  lo = (lo + Math.imul(al7, bl4)) | 0;
	  mid = (mid + Math.imul(al7, bh4)) | 0;
	  mid = (mid + Math.imul(ah7, bl4)) | 0;
	  hi = (hi + Math.imul(ah7, bh4)) | 0;
	  lo = (lo + Math.imul(al6, bl5)) | 0;
	  mid = (mid + Math.imul(al6, bh5)) | 0;
	  mid = (mid + Math.imul(ah6, bl5)) | 0;
	  hi = (hi + Math.imul(ah6, bh5)) | 0;
	  lo = (lo + Math.imul(al5, bl6)) | 0;
	  mid = (mid + Math.imul(al5, bh6)) | 0;
	  mid = (mid + Math.imul(ah5, bl6)) | 0;
	  hi = (hi + Math.imul(ah5, bh6)) | 0;
	  lo = (lo + Math.imul(al4, bl7)) | 0;
	  mid = (mid + Math.imul(al4, bh7)) | 0;
	  mid = (mid + Math.imul(ah4, bl7)) | 0;
	  hi = (hi + Math.imul(ah4, bh7)) | 0;
	  lo = (lo + Math.imul(al3, bl8)) | 0;
	  mid = (mid + Math.imul(al3, bh8)) | 0;
	  mid = (mid + Math.imul(ah3, bl8)) | 0;
	  hi = (hi + Math.imul(ah3, bh8)) | 0;
	  lo = (lo + Math.imul(al2, bl9)) | 0;
	  mid = (mid + Math.imul(al2, bh9)) | 0;
	  mid = (mid + Math.imul(ah2, bl9)) | 0;
	  hi = (hi + Math.imul(ah2, bh9)) | 0;

	  let w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	  w11 &= 0x3ffffff;

	  /* k = 12 */
	  lo = Math.imul(al9, bl3);
	  mid = Math.imul(al9, bh3);
	  mid = (mid + Math.imul(ah9, bl3)) | 0;
	  hi = Math.imul(ah9, bh3);
	  lo = (lo + Math.imul(al8, bl4)) | 0;
	  mid = (mid + Math.imul(al8, bh4)) | 0;
	  mid = (mid + Math.imul(ah8, bl4)) | 0;
	  hi = (hi + Math.imul(ah8, bh4)) | 0;
	  lo = (lo + Math.imul(al7, bl5)) | 0;
	  mid = (mid + Math.imul(al7, bh5)) | 0;
	  mid = (mid + Math.imul(ah7, bl5)) | 0;
	  hi = (hi + Math.imul(ah7, bh5)) | 0;
	  lo = (lo + Math.imul(al6, bl6)) | 0;
	  mid = (mid + Math.imul(al6, bh6)) | 0;
	  mid = (mid + Math.imul(ah6, bl6)) | 0;
	  hi = (hi + Math.imul(ah6, bh6)) | 0;
	  lo = (lo + Math.imul(al5, bl7)) | 0;
	  mid = (mid + Math.imul(al5, bh7)) | 0;
	  mid = (mid + Math.imul(ah5, bl7)) | 0;
	  hi = (hi + Math.imul(ah5, bh7)) | 0;
	  lo = (lo + Math.imul(al4, bl8)) | 0;
	  mid = (mid + Math.imul(al4, bh8)) | 0;
	  mid = (mid + Math.imul(ah4, bl8)) | 0;
	  hi = (hi + Math.imul(ah4, bh8)) | 0;
	  lo = (lo + Math.imul(al3, bl9)) | 0;
	  mid = (mid + Math.imul(al3, bh9)) | 0;
	  mid = (mid + Math.imul(ah3, bl9)) | 0;
	  hi = (hi + Math.imul(ah3, bh9)) | 0;

	  let w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	  w12 &= 0x3ffffff;

	  /* k = 13 */
	  lo = Math.imul(al9, bl4);
	  mid = Math.imul(al9, bh4);
	  mid = (mid + Math.imul(ah9, bl4)) | 0;
	  hi = Math.imul(ah9, bh4);
	  lo = (lo + Math.imul(al8, bl5)) | 0;
	  mid = (mid + Math.imul(al8, bh5)) | 0;
	  mid = (mid + Math.imul(ah8, bl5)) | 0;
	  hi = (hi + Math.imul(ah8, bh5)) | 0;
	  lo = (lo + Math.imul(al7, bl6)) | 0;
	  mid = (mid + Math.imul(al7, bh6)) | 0;
	  mid = (mid + Math.imul(ah7, bl6)) | 0;
	  hi = (hi + Math.imul(ah7, bh6)) | 0;
	  lo = (lo + Math.imul(al6, bl7)) | 0;
	  mid = (mid + Math.imul(al6, bh7)) | 0;
	  mid = (mid + Math.imul(ah6, bl7)) | 0;
	  hi = (hi + Math.imul(ah6, bh7)) | 0;
	  lo = (lo + Math.imul(al5, bl8)) | 0;
	  mid = (mid + Math.imul(al5, bh8)) | 0;
	  mid = (mid + Math.imul(ah5, bl8)) | 0;
	  hi = (hi + Math.imul(ah5, bh8)) | 0;
	  lo = (lo + Math.imul(al4, bl9)) | 0;
	  mid = (mid + Math.imul(al4, bh9)) | 0;
	  mid = (mid + Math.imul(ah4, bl9)) | 0;
	  hi = (hi + Math.imul(ah4, bh9)) | 0;

	  let w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	  w13 &= 0x3ffffff;

	  /* k = 14 */
	  lo = Math.imul(al9, bl5);
	  mid = Math.imul(al9, bh5);
	  mid = (mid + Math.imul(ah9, bl5)) | 0;
	  hi = Math.imul(ah9, bh5);
	  lo = (lo + Math.imul(al8, bl6)) | 0;
	  mid = (mid + Math.imul(al8, bh6)) | 0;
	  mid = (mid + Math.imul(ah8, bl6)) | 0;
	  hi = (hi + Math.imul(ah8, bh6)) | 0;
	  lo = (lo + Math.imul(al7, bl7)) | 0;
	  mid = (mid + Math.imul(al7, bh7)) | 0;
	  mid = (mid + Math.imul(ah7, bl7)) | 0;
	  hi = (hi + Math.imul(ah7, bh7)) | 0;
	  lo = (lo + Math.imul(al6, bl8)) | 0;
	  mid = (mid + Math.imul(al6, bh8)) | 0;
	  mid = (mid + Math.imul(ah6, bl8)) | 0;
	  hi = (hi + Math.imul(ah6, bh8)) | 0;
	  lo = (lo + Math.imul(al5, bl9)) | 0;
	  mid = (mid + Math.imul(al5, bh9)) | 0;
	  mid = (mid + Math.imul(ah5, bl9)) | 0;
	  hi = (hi + Math.imul(ah5, bh9)) | 0;

	  let w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	  w14 &= 0x3ffffff;

	  /* k = 15 */
	  lo = Math.imul(al9, bl6);
	  mid = Math.imul(al9, bh6);
	  mid = (mid + Math.imul(ah9, bl6)) | 0;
	  hi = Math.imul(ah9, bh6);
	  lo = (lo + Math.imul(al8, bl7)) | 0;
	  mid = (mid + Math.imul(al8, bh7)) | 0;
	  mid = (mid + Math.imul(ah8, bl7)) | 0;
	  hi = (hi + Math.imul(ah8, bh7)) | 0;
	  lo = (lo + Math.imul(al7, bl8)) | 0;
	  mid = (mid + Math.imul(al7, bh8)) | 0;
	  mid = (mid + Math.imul(ah7, bl8)) | 0;
	  hi = (hi + Math.imul(ah7, bh8)) | 0;
	  lo = (lo + Math.imul(al6, bl9)) | 0;
	  mid = (mid + Math.imul(al6, bh9)) | 0;
	  mid = (mid + Math.imul(ah6, bl9)) | 0;
	  hi = (hi + Math.imul(ah6, bh9)) | 0;

	  let w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	  w15 &= 0x3ffffff;

	  /* k = 16 */
	  lo = Math.imul(al9, bl7);
	  mid = Math.imul(al9, bh7);
	  mid = (mid + Math.imul(ah9, bl7)) | 0;
	  hi = Math.imul(ah9, bh7);
	  lo = (lo + Math.imul(al8, bl8)) | 0;
	  mid = (mid + Math.imul(al8, bh8)) | 0;
	  mid = (mid + Math.imul(ah8, bl8)) | 0;
	  hi = (hi + Math.imul(ah8, bh8)) | 0;
	  lo = (lo + Math.imul(al7, bl9)) | 0;
	  mid = (mid + Math.imul(al7, bh9)) | 0;
	  mid = (mid + Math.imul(ah7, bl9)) | 0;
	  hi = (hi + Math.imul(ah7, bh9)) | 0;

	  let w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	  w16 &= 0x3ffffff;

	  /* k = 17 */
	  lo = Math.imul(al9, bl8);
	  mid = Math.imul(al9, bh8);
	  mid = (mid + Math.imul(ah9, bl8)) | 0;
	  hi = Math.imul(ah9, bh8);
	  lo = (lo + Math.imul(al8, bl9)) | 0;
	  mid = (mid + Math.imul(al8, bh9)) | 0;
	  mid = (mid + Math.imul(ah8, bl9)) | 0;
	  hi = (hi + Math.imul(ah8, bh9)) | 0;

	  let w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	  w17 &= 0x3ffffff;

	  /* k = 18 */
	  lo = Math.imul(al9, bl9);
	  mid = Math.imul(al9, bh9);
	  mid = (mid + Math.imul(ah9, bl9)) | 0;
	  hi = Math.imul(ah9, bh9);

	  let w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	  c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	  w18 &= 0x3ffffff;

	  o[0] = w0;
	  o[1] = w1;
	  o[2] = w2;
	  o[3] = w3;
	  o[4] = w4;
	  o[5] = w5;
	  o[6] = w6;
	  o[7] = w7;
	  o[8] = w8;
	  o[9] = w9;
	  o[10] = w10;
	  o[11] = w11;
	  o[12] = w12;
	  o[13] = w13;
	  o[14] = w14;
	  o[15] = w15;
	  o[16] = w16;
	  o[17] = w17;
	  o[18] = w18;

	  if (c !== 0) {
	    o[19] = c;
	    out.length += 1;
	  }

	  // Note: we shouldn't need to strip here.
	  return out;
	}

	// Polyfill comb.
	if (!Math.imul)
	  comb10MulTo = smallMulTo;

	/*
	 * Expose
	 */

	BN.Red = Red;

	bn = BN;
	return bn;
}

/*!
 * network.js - bitcoin networks for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2019-2020, Jonathan Gonzalez (MIT License).
 * https://github.com/cash-org/cashnode
 */

var hasRequiredNetworks;

function requireNetworks () {
	if (hasRequiredNetworks) return networks;
	hasRequiredNetworks = 1;
	(function (exports) {

		/**
		 * @module protocol/networks
		 */

		const BN = requireBn();

		const network = exports;

		/*
		 * Helpers
		 */

		function b(hash) {
		  return Buffer.from(hash, 'hex');
		}

		/**
		 * Network type list.
		 * @memberof module:protocol/networks
		 * @const {String[]}
		 * @default
		 */

		network.types = ['main', 'testnet', 'regtest', 'simnet'];

		/**
		 * Mainnet
		 * @static
		 * @lends module:protocol/networks
		 * @type {Object}
		 */

		const main = {};

		/**
		 * Symbolic network type.
		 * @const {String}
		 * @default
		 */

		main.type = 'main';

		/**
		 * Default DNS seeds.
		 * @const {String[]}
		 * @default
		 */

		main.seeds = [
		  'seed.flowee.cash',
		  'seed-bch.bitcoinforks.org',
		  'btccash-seeder.bitcoinunlimited.info',
		  'seed.bchd.cash',
		  'seed.bch.loping.net',
		  'dnsseed.electroncash.de'
		];

		/**
		 * Packet magic number.
		 * @const {Number}
		 * @default
		 */

		main.magic = 0xe8f3e1e3;

		/**
		 * Default network port.
		 * @const {Number}
		 * @default
		 */

		main.port = 8333;

		/**
		 * Checkpoint block list.
		 * @const {Object}
		 */

		main.checkpointMap = {
		  11111: b('1d7c6eb2fd42f55925e92efad68b61edd22fba29fde8783df744e26900000000'),
		  33333: b('a6d0b5df7d0df069ceb1e736a216ad187a50b07aaa4e78748a58d52d00000000'),
		  74000: b('201a66b853f9e7814a820e2af5f5dc79c07144e31ce4c9a39339570000000000'),
		  105000: b('97dc6b1d15fbeef373a744fee0b254b0d2c820a3ae7f0228ce91020000000000'),
		  134444: b('feb0d2420d4a18914c81ac30f494a5d4ff34cd15d34cfd2fb105000000000000'),
		  168000: b('63b703835cb735cb9a89d733cbe66f212f63795e0172ea619e09000000000000'),
		  193000: b('17138bca83bdc3e6f60f01177c3877a98266de40735f2a459f05000000000000'),
		  210000: b('2e3471a19b8e22b7f939c63663076603cf692f19837e34958b04000000000000'),
		  216116: b('4edf231bf170234e6a811460f95c94af9464e41ee833b4f4b401000000000000'),
		  225430: b('32595730b165f097e7b806a679cf7f3e439040f750433808c101000000000000'),
		  250000: b('14d2f24d29bed75354f3f88a5fb50022fc064b02291fdf873800000000000000'),
		  279000: b('407ebde958e44190fa9e810ea1fc3a7ef601c3b0a0728cae0100000000000000'),
		  295000: b('83a93246c67003105af33ae0b29dd66f689d0f0ff54e9b4d0000000000000000'),
		  300255: b('b2f3a0f0de4120c1089d5f5280a263059f9b6e7c520428160000000000000000'),
		  319400: b('3bf115fd057391587ca39a531c5d4989e1adec9b2e05c6210000000000000000'),
		  343185: b('548536d48e7678fcfa034202dd45d4a76b1ad061f38b2b070000000000000000'),
		  352940: b('ffc9520143e41c94b6e03c2fa3e62bb76b55ba2df45d75100000000000000000'),
		  382320: b('b28afdde92b0899715e40362f56afdb20e3d135bedc68d0a0000000000000000'),
		  401465: b('eed16cb3e893ed9366f27c39a9ecd95465d02e3ef40e45010000000000000000'),
		  420000: b('a1ff746b2d42b834cb7d6b8981b09c265c2cabc016e8cc020000000000000000'),
		  440000: b('9bf296b8de5f834f7635d5e258a434ad51b4dbbcf7c08c030000000000000000'),
		  450000: b('0ba2070c62cd9da1f8cef88a0648c661a411d33e728340010000000000000000'),
		  460000: b('8c25fc7e414d3e868d6ce0ec473c30ad44e7e8bc1b75ef000000000000000000'),
		  470000: b('89756d1ed75901437300af10d5ab69070a282e729c536c000000000000000000'),
		  // UAHF fork block:
		  478559: b('ec5e1a193601f25ff1d94b421ddead0dbefcb99cf91e65000000000000000000'),
		  480000: b('f93408ffca92d88a6e46d3b90046f97bde6be0c08e7ed40c0000000000000000'),
		  490000: b('d1c65d766c6dc270b8ff4f1edb052fb71dc2b4750ede8a010000000000000000'),
		  500000: b('01b2328355f4a4dc9efa5c610687304507b7df9f3f4de1050000000000000000'),
		  // DAA fork block
		  504031: b('9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000'),
		  510000: b('040e6b1f2f4cb198a5780d366bf81e591de257642b9267030000000000000000'),
		  525000: b('c994fba2bf168333fd969bcfa64f03ca1b62074f9a8f1b010000000000000000'),
		  // Monolith Activation
		  530359: b('0391c40195cf8ae3436f3955f1a8444f07468fd08bda1a010000000000000000'),
		  // Magnetic Anomaly Activation:
		  556767: b('6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000'),
		  // Great Wall Activation:
		  582680: b('18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000'),
		  // Graviton Activation:
		  609136: b('b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000'),
		  // Phonon Activation:
		  635259: b('f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000'),
		  // Axion Activation:
		  661648: b('7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000'),
		  664198: b('60824622a1d2b689fbb234ce2c5939ff92e8ed8c57902f0c0000000000000000'),
		  680140: b('0b7c2ff6c3658cb3f846aa092145c44a1d45638b56482c230000000000000000'),
		  // Tachyon Activation
		  686621: b('45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000'),
		  // Selectron Activation
		  713661: b('8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000'),
		  // Gluon activation
		  739536: b('617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000'),
		  // Jefferson activation
		  766195: b('94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000')
		};

		/**
		 * Last checkpoint height.
		 * @const {Number}
		 * @default
		 */

		main.lastCheckpoint = 525000;

		/**
		 * @const {Number}
		 * @default
		 */

		main.halvingInterval = 210000;

		/**
		 * Genesis block header.
		 * @const {Object}
		 */

		main.genesis = {
		  version: 1,
		  hash: b('6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000'),
		  prevBlock:
		    b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot:
		    b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1231006505,
		  bits: 486604799,
		  nonce: 2083236893,
		  height: 0
		};

		/**
		 * The network's genesis block in a hex string.
		 * @const {String}
		 */

		main.genesisBlock =
		  '0100000000000000000000000000000000000000000000000000000000000000000000'
		  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab'
		  + '5f49ffff001d1dac2b7c01010000000100000000000000000000000000000000000000'
		  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
		  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
		  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
		  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
		  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
		  + 'ac00000000';

		/**
		 * POW-related constants.
		 * @enum {Number}
		 * @default
		 */

		main.pow = {
		  /**
		   * Default target.
		   * @const {BN}
		   */

		  limit: new BN(
		    '00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
		    'hex'
		  ),

		  /**
		   * Compact pow limit.
		   * @const {Number}
		   * @default
		   */

		  bits: 486604799,

		  /**
		   * Half Life value used in DAA.
		   * Represents the value of two days in seconds
		   * @const {Number}
		   * @default
		   */

		  halfLife: 172800,

		  /**
		   * Minimum chainwork for best chain.
		   * @const {BN}
		   */

		  chainwork: new BN(
		    '0000000000000000000000000000000000000000013c95e14d4d9db91d671020',
		    'hex'
		  ),

		  /**
		   * Desired retarget period in seconds.
		   * @const {Number}
		   * @default
		   */

		  targetTimespan: 14 * 24 * 60 * 60,

		  /**
		   * Average block time.
		   * @const {Number}
		   * @default
		   */

		  targetSpacing: 10 * 60,

		  /**
		   * Retarget interval in blocks.
		   * @const {Number}
		   * @default
		   */

		  retargetInterval: 2016,

		  /**
		   * Whether to reset target if a block
		   * has not been mined recently.
		   * @const {Boolean}
		   * @default
		   */

		  targetReset: false,

		  /**
		   * Do not allow retargetting.
		   * @const {Boolean}
		   * @default
		   */

		  noRetargeting: false
		};

		/**
		 * Block constants.
		 * @enum {Number}
		 * @default
		 */

		main.block = {
		  /**
		   * Height at which bip34 was activated.
		   * Used for avoiding bip30 checks.
		   */

		  bip34height: 227931,

		  /**
		   * Hash of the block that activated bip34.
		   */

		  bip34hash:
		    b('b808089c756add1591b1d17bab44bba3fed9e02f942ab4894b02000000000000'),

		  /**
		   * Height at which bip65 was activated.
		   */

		  bip65height: 388381,

		  /**
		   * Hash of the block that activated bip65.
		   */

		  bip65hash:
		    b('f035476cfaeb9f677c2cdad00fd908c556775ded24b6c2040000000000000000'),

		  /**
		   * Height at which bip66 was activated.
		   */

		  bip66height: 363725,

		  /**
		   * Hash of the block that activated bip66.
		   */

		  bip66hash:
		    b('3109b588941188a9f1c2576aae462d729b8cce9da1ea79030000000000000000'),

		  /**
		   * Height at which UAHF was activated.
		   */

		  uahfHeight: 478558,

		  /**
		   * Hash of the block that activated UAHF.
		   */

		  uahfHash:
		    b('432d350741fbf28f2e1486eabe2c4e143bfe2241af6518010000000000000000'),

		  /**
		   * Height at which DAA was activated.
		   * November 13, 2017 hard fork
		   */

		  daaHeight: 504031,

		  /**
		   * Hash of the block that activated DAA
		   */

		  daaHash:
		    b('9cabb6ee1b1a4c3b659d70be75810be83d0a0db665bf1e010000000000000000'),

		  /**
		   * Height at which Magnetic Anomaly was activated.
		   * Nov 15, 2018 hard fork
		   */

		  magneticAnomalyHeight: 556767,

		  /**
		   * Hash of the block that activatd Magnetic Anomaly.
		   * November 15, 2018
		   */

		  maaHash:
		    b('6cd5e644acccee5743ce2e93c541d34169933b6eff2646000000000000000000'),

		  /**
		   * Height at which Great Wall was activated.
		   * Wed, 15 May 2019 hard fork
		   */

		  greatWallActivationHeight: 582680,

		  /**
		   * Hash of the block that activated Great Wall.
		   * May 15, 2019
		   */

		  gwaHash:
		    b('18cc7d8c39ca16dc749acb7278a471964f7dec6ae3b8b4010000000000000000'),

		  /**
		   * Graviton Hard Fork activation time.
		   * Nov 15, 2019 12:00:00 UTC
		   */

		  gravitonActivationTime: 1573819200,

		  /**
		   * Height at which Graviton was activated.
		   * Friday, 15 November 2019 hard fork
		   */

		  gravitonHeight: 609136,

		  /**
		   * Hash of the block that activated Graviton.
		   * November 15th, 2019
		   */

		  gravitonHash:
		    b('b1c55b4f69aa2e3209c91ae413c355c65aacfa07b28bb4000000000000000000'),

		  /**
		   * Time at which Phonon was activated.
		   * May 15, 2020 12:00:00 UTC
		   */

		  phononActivationTime: 1589544000,

		  /**
		  * Height at which Phonon Activation occured.
		  * May 15, 2020
		  */

		  phononHeight: 635259,

		  /**
		  * Hash of the block that activated Phonon.
		  * May 15th 2020
		  */

		  phononHash:
		    b('f73075b2c598f49b3a19558c070b52d5a5d6c21fefdf33000000000000000000'),

		  /**
		   * Time at which Asert3d-2i was activated.
		   * November 15, 2020 12:00:00 UTC
		   */

		  asertActivationTime: 1605441600,

		  /**
		   * Time at which Axion was activated.
		   * November 15, 2020 12:00:00 UTC
		   */

		  axionActivationTime: 1605441600,

		  /**
		  * Height at which Axion Activation occured.
		  * November 15, 2020
		  */

		  axionHeight: 661648,

		  /**
		  * Hash of the block that activated Axion.
		  * November 15th 2020
		  */

		   axionHash:
		   b('7d7510f907bdc9bd2907e56beceaef31f78f2c8b9d4c28040000000000000000'),

		  /**
		   * Time at which Tachyon was activated.
		   * May 15, 2021 12:00:00 UTC
		   */

		  tachyonActivationTime: 1621080000,

		  /**
		  * Height at which Tachyon Activation occured.
		  * May 15, 2021 12:00:00 UTC
		  */

		  tachyonHeight: 686621,

		  /**
		  * Hash of the block that activated Tachyon.
		  * May 15, 2021 12:00:00 UTC
		  */

		  tachyonHash:
		  b('45b7e5be980bd6e98a22f895fcdc80546d9f0a57f7e68f3c0000000000000000'),

		  /**
		   * Time at which Selectron was activated.
		   * November 15, 2021 12:00:00 UTC
		   */

		  selectronActivationTime: 1636977600,

		  /**
		  * Height at which Selectron Activation occured.
		  *  November 15, 2021 12:00:00 UTC
		  */

		  selectronHeight: 713661,

		  /**
		  * Hash of the block that activated Selectron.
		  * November 15, 2021 12:00:00 UTC
		  */

		  selectronHash:
		  b('8defaaea383ab73c75ceea3f08190f3ab5ccc70743f876060000000000000000'),

		  /**
		   * Time at which Gluon was activated.
		   * May 15, 2022 12:00:00 UTC
		   */

		  gluonActivationTime: 1652572800,

		  /**
		  * Height at which Gluon activation occured.
		  *  May 15, 2022 12:00:00 UTC
		  */

		  gluonHeight: 739536,

		  /**
		  * Hash of the block that activated Gluon.
		  * May 15, 2022 12:00:00 UTC
		  */

		  gluonHash:
		  b('617bfc596bce59b129242fe67b5afe0509560946cd04db060000000000000000'), 

		  /**
		   * Time at which Jefferson was activated.
		   * November 15, 2022 12:00:00 UTC
		   */

		  jeffersonActivationTime: 1668470400,

		  /**
		  * Height at which Gluon activation occured.
		  *  November 15, 2022 12:00:00 UTC
		  */

		  jeffersonHeight: 766195,

		  /**
		  * Hash of the block that activated Gluon.
		  * November 15, 2022 12:00:00 UTC
		  */

		  jeffersonHash:
		  b('94e0246db72955957dedb431eb1096de9a5b715348c92b100000000000000000'), 

		  /**
		   * Time at which Wellington was activated.
		   * May 15, 2023 12:00:00 UTC
		   */

		  wellingtonActivationTime: 1684108800,

		  /**
		   * Safe height to start pruning.
		   */

		  pruneAfterHeight: 1000,

		  /**
		   * Safe number of blocks to keep.
		   */

		  keepBlocks: 288,

		  /**
		   * Age used for the time delta to
		   * determine whether the chain is synced.
		   */

		  maxTipAge: 24 * 60 * 60,

		  /**
		   * Height at which block processing is
		   * slow enough that we can output
		   * logs without spamming.
		   */

		  slowHeight: 325000
		};

		/**
		 * Map of historical blocks which create duplicate transactions hashes.
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
		 * @const {Object}
		 * @default
		 */

		main.bip30 = {
		  91842: b('eccae000e3c8e4e093936360431f3b7603c563c1ff6181390a4d0a0000000000'),
		  91880: b('21d77ccb4c08386a04ac0196ae10f6a1d2c2a377558ca190f143070000000000')
		};

		/**
		 * For versionbits.
		 * @const {Number}
		 * @default
		 */

		main.activationThreshold = 1916; // 95% of 2016

		/**
		 * Confirmation window for versionbits.
		 * @const {Number}
		 * @default
		 */

		main.minerWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing

		/**
		 * Deployments for versionbits.
		 * @const {Object}
		 * @default
		 */

		main.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 1462060800, // May 1st, 2016
		    timeout: 1493596800, // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601, // January 1, 2008
		    timeout: 1230767999, // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};

		/**
		 * Deployments for versionbits (array form, sorted).
		 * @const {Array}
		 * @default
		 */

		main.deploys = [
		  main.deployments.csv,
		  main.deployments.testdummy
		];

		/**
		 * Key prefixes.
		 * @enum {Number}
		 * @default
		 */

		main.keyPrefix = {
		  privkey: 0x80,
		  xpubkey: 0x0488b21e,
		  xprivkey: 0x0488ade4,
		  xpubkey58: 'xpub',
		  xprivkey58: 'xprv',
		  coinType: 0
		};

		/**
		 * {@link Address} prefixes.
		 * @enum {Number}
		 */

		main.addressPrefix = {
		  pubkeyhash: 0x00,
		  scripthash: 0x05,
		  cashaddr: 'ecash'
		};

		/**
		 * Default value for whether the mempool
		 * accepts non-standard transactions.
		 * @const {Boolean}
		 * @default
		 */

		main.requireStandard = true;

		/**
		 * Default http port.
		 * @const {Number}
		 * @default
		 */

		main.rpcPort = 8332;

		/**
		 * Default wallet port.
		 * @const {Number}
		 * @default
		 */

		main.walletPort = 8334;

		/**
		 * Default min relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.minRelay = 1000;

		/**
		 * Default normal relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.feeRate = 100000;

		/**
		 * Maximum normal relay rate.
		 * @const {Rate}
		 * @default
		 */

		main.maxFeeRate = 400000;

		/**
		 * Whether to allow self-connection.
		 * @const {Boolean}
		 */

		main.selfConnect = false;

		/**
		 * Whether to request mempool on sync.
		 * @const {Boolean}
		 */

		main.requestMempool = false;

		/*
		 * Testnet (v3)
		 * https://en.bitcoin.it/wiki/Testnet
		 */

		const testnet = {};

		testnet.type = 'testnet';

		testnet.seeds = [
		  'testnet-seed.bitcoinabc.org', // Bitcoin ABC seeder
		  'testnet-seed-abc.bitcoinforks.org', // bitcoinforks seeders
		  'testnet-seed.deadalnix.me', // Amaury SCHET
		  'testnet-seed.bchd.cash'
		];

		testnet.magic = 0xf4f3e5f4;

		testnet.port = 18333;

		testnet.checkpointMap = {
		  546: b('70cb6af7ebbcb1315d3414029c556c55f3e2fc353c4c9063a76c932a00000000'),
		  10000: b('02a1b43f52591e53b660069173ac83b675798e12599dbb0442b7580000000000'),
		  50000: b('0c6ceabe803cec55ba2831e445956d0a43ba9521743a802cddac7e0700000000'),
		  90000: b('cafc21e17faf90461a5905aa03302c394912651ed9475ae711723e0d00000000'),
		  100000: b('1e0a16bbadccde1d80c66597b1939e45f91b570d29f95fc158299e0000000000'),
		  140000: b('92c0877b54c556889b72175ccbe0c91a1208f6ef7efb2c006101062300000000'),
		  170000: b('508125560d202b89757889bb0e49c712477be20440058f05db4f0e0000000000'),
		  210000: b('32365454b5f29a826bff8ad9b0448cad0072fc73d50e482d91a3dece00000000'),
		  230000: b('b11a447e62643e0b27406eb0fc270cb8126d7b5b70822fb642d9513400000000'),
		  270000: b('1c42b811cf9c163932f6e95ec55bf9b5e2cb5324e7e93001572e000000000000'),
		  300000: b('a141bf3972424853f04367b47995e220e0b5a2706e5618766f22000000000000'),
		  340000: b('67edd4d92e405608109164b15f92b193377d49325b0ed036739c010000000000'),
		  350000: b('592b44bc0f7a4286cf07ead8497114c6952c1c7dea7305193deacf8e00000000'),
		  390000: b('f217e183484fb6d695609cc71fa2ae24c3020943407e0150b298030000000000'),
		  420000: b('de9e73a3b91fbb014e036e8583a17d6b638a699aeb2de8573d12580800000000'),
		  460000: b('2e8baaffc107f15c87aebe01664b63d07476afa53bcbada1281a030000000000'),
		  500000: b('06f60922a2aab2757317820fc6ffaf6a470e2cbb0f63a2aac0a7010000000000'),
		  540000: b('8dd0bebfbc4878f5af09d3e848dcc57827d2c1cebea8ec5d8cbe420500000000'),
		  570000: b('87acbd4cd3c40ec9bd648f8698ed226b31187274c06cc7a9af79030000000000'),
		  600000: b('169a05b3bb04b7d13ad628915630900a5ed2e89f3a9dc6064f62000000000000'),
		  630000: b('bbbe117035432a6a4effcb297207a02b031735b43e0d19a9217c000000000000'),
		  670000: b('080bfe75caed8624fcfdfbc65973c8f962d7bdc495a891f5d16b7d0000000000'),
		  700000: b('c14d3f6a1e7c7d66fd940951e44f3c3be1273bea4d2ab1786140000000000000'),
		  740000: b('b3b423f0462fd78a01e4f1a59a2737a0525b5dbb9bba0b4634f9000000000000'),
		  780000: b('0381582e34c3755964dc2813e2b33e521e5596367144e1670851050000000000'),
		  800000: b('03b5f8ab257e02903f509f5ff2935220eec2e77b1819651d099b200000000000'),
		  840000: b('dac1648107bd4394e57e4083c86d42b548b1cfb119665f179ea80a0000000000'),
		  880000: b('ff90b4bb07eded8e96715bf595c09c7d21dd8c61b8306ff48705d60000000000'),
		  900000: b('9bd8ac418beeb1a2cf5d68c8b5c6ebaa947a5b766e5524898d6f350000000000'),
		  940000: b('c98f1651a475b00d12f8c25eb166ee843affaa90610e36a19d68030000000000'),
		  980000: b('cc8e9774542d044a9698ca2336ae02d5987157e676f1c76aa3877c0000000000'),
		  1010000:
		    b('9d9fb11abc2712d80368229e97b8d827b2a07d27eb5335e5c924000000000000'),
		  1050000:
		    b('d8190cf0af7f08e179cab51d67db0b44b87951a78f7fdc31b4a01a0000000000'),
		  1090000:
		    b('41f83c47e02a8852d033ac884df7cca877726b384a461fb9e802000000000000'),
		  1130000:
		    b('b8d63c3830e3c5685d3f7d2c2271fdb2ce3315619a473c324ea1a4ce00000000'),
		  // UAHF fork block.
		  1155875:
		    b('38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000'),
		  // DAA fork block.
		  1188697:
		    b('fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000'),
		  // GWA fork block.
		  1303885:
		    b('d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000'),
		  // Graviton fork block
		  1341712:
		    b('5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000'),
		  // Phonon fork block.
		  1378461:
		    b('d715e9fab7bbdf301081eeadbe6e931db282cf6b92b1365f9b50f59900000000')

		};

		testnet.lastCheckpoint = 1341712;

		testnet.halvingInterval = 210000;

		testnet.genesis = {
		  version: 1,
		  hash: b('43497fd7f826957108f4a30fd9cec3aeba79972084e90ead01ea330900000000'),
		  prevBlock:
		    b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot:
		    b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1296688602,
		  bits: 486604799,
		  nonce: 414098458,
		  height: 0
		};

		testnet.genesisBlock =
		  '0100000000000000000000000000000000000000000000000000000000000000000000'
		  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5'
		  + '494dffff001d1aa4ae1801010000000100000000000000000000000000000000000000'
		  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
		  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
		  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
		  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
		  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
		  + 'ac00000000';

		testnet.pow = {
		  limit: new BN(
		    '00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
		    'hex'
		  ),
		  bits: 486604799,
		  chainwork: new BN(
		    '00000000000000000000000000000000000000000000006956e7298fb096a1cc',
		    'hex'
		  ),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: false
		};

		testnet.block = {
		  bip34height: 21111,
		  bip34hash:
		    b('f88ecd9912d00d3f5c2a8e0f50417d3e415c75b3abe584346da9b32300000000'),
		  bip65height: 581885,
		  bip65hash:
		    b('b61e864fbec41dfaf09da05d1d76dc068b0dd82ee7982ff255667f0000000000'),
		  bip66height: 330776,
		  bip66hash:
		    b('82a14b9e5ea81d4832b8e2cd3c2a6092b5a3853285a8995ec4c8042100000000'),

		  uahfHeight: 1155875,
		  uahfHash:
		    b('38f1ae7f0ea8c1b589884c5fbd0b83721e3ab6759a4b897206857cf100000000'),

		  daaHeight: 1188697,
		  daaHash:
		    b('fb47e0ab0d2448f71192a09fe61bc9c46cd3b4e7bd778091d00e170000000000'),

		  magneticAnomalyHeight: 1267996,
		  maaHash:
		    b('244b485f4871816d3ca060f6f363abe81c6fa1bed45c09e0fa01000000000000'),

		  greatWallActivationHeight: 1303885,
		  gwaHash:
		    b('d323ee8d7ede5bef62f84db98f93cc8c47fae4f02e8938914700000000000000'),

		  gravitonActivationTime: 1573819200,

		  gravitonHeight: 1341712,
		  gravitonHash:
		    b('5ba3af2992073940ed9e5a9d9eef9194bbfba905d92b202eea44fcff00000000'),

		  phononActivationTime: 1589544000,
		  asertActivationTime: 1605441600,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 24 * 60 * 60,
		  slowHeight: 950000
		};

		testnet.bip30 = {};

		testnet.activationThreshold = 1512; // 75% for testchains

		testnet.minerWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing

		testnet.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 1456790400, // March 1st, 2016
		    timeout: 1493596800, // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601, // January 1, 2008
		    timeout: 1230767999, // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};

		testnet.deploys = [
		  testnet.deployments.csv,
		  testnet.deployments.testdummy
		];

		testnet.keyPrefix = {
		  privkey: 0xef,
		  xpubkey: 0x043587cf,
		  xprivkey: 0x04358394,
		  xpubkey58: 'tpub',
		  xprivkey58: 'tprv',
		  coinType: 1
		};

		testnet.addressPrefix = {
		  pubkeyhash: 0x6f,
		  scripthash: 0xc4,
		  cashaddr: 'xectest'
		};

		testnet.requireStandard = false;

		testnet.rpcPort = 18332;

		testnet.walletPort = 18334;

		testnet.minRelay = 1000;

		testnet.feeRate = 20000;

		testnet.maxFeeRate = 60000;

		testnet.selfConnect = false;

		testnet.requestMempool = false;

		/*
		 * Regtest
		 */

		const regtest = {};

		regtest.type = 'regtest';

		regtest.seeds = [
		  '127.0.0.1'
		];

		regtest.magic = 0xfabfb5da;

		regtest.port = 48444;

		regtest.checkpointMap = {};
		regtest.lastCheckpoint = 0;

		regtest.halvingInterval = 150;

		regtest.genesis = {
		  version: 1,
		  hash: b('06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f'),
		  prevBlock:
		    b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot:
		    b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1296688602,
		  bits: 545259519,
		  nonce: 2,
		  height: 0
		};

		regtest.genesisBlock =
		  '0100000000000000000000000000000000000000000000000000000000000000000000'
		  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5'
		  + '494dffff7f200200000001010000000100000000000000000000000000000000000000'
		  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
		  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
		  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
		  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
		  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
		  + 'ac00000000';

		regtest.pow = {
		  limit: new BN(
		    '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
		    'hex'
		  ),
		  bits: 545259519,
		  chainwork: new BN(
		    '0000000000000000000000000000000000000000000000000000000000000002',
		    'hex'
		  ),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: true
		};

		regtest.block = {
		  bip34height: 100000000,
		  bip34hash: null,
		  bip65height: 1351,
		  bip65hash: null,
		  bip66height: 1251,
		  bip66hash: null,
		  uahfHeight: 0,
		  uahfHash: null,
		  daaHeight: 0,
		  daaHash: null,
		  magneticAnomalyHeight: 0,
		  maaHash: null,
		  greatWallActivationHeight: 0,
		  gwaHash: null,
		  gravitonHeight: 0,
		  gravitonHash: null,
		  phononActivationTime: 0,
		  asertActivationTime: 0,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 0xffffffff,
		  slowHeight: 0
		};

		regtest.bip30 = {};

		regtest.activationThreshold = 108; // 75% for testchains

		regtest.minerWindow = 144; // Faster than normal for regtest

		regtest.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 0,
		    timeout: 0xffffffff,
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 0,
		    timeout: 0xffffffff,
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};

		regtest.deploys = [
		  regtest.deployments.csv,
		  regtest.deployments.testdummy
		];

		regtest.keyPrefix = {
		  privkey: 0x5a,
		  xpubkey: 0xeab4fa05,
		  xprivkey: 0xeab404c7,
		  xpubkey58: 'rpub',
		  xprivkey58: 'rprv',
		  coinType: 1
		};

		regtest.addressPrefix = {
		  pubkeyhash: 0x3c,
		  scripthash: 0x26,
		  cashaddr: 'xecreg'
		};

		regtest.requireStandard = false;

		regtest.rpcPort = 48332;

		regtest.walletPort = 48334;

		regtest.minRelay = 1000;

		regtest.feeRate = 20000;

		regtest.maxFeeRate = 60000;

		regtest.selfConnect = true;

		regtest.requestMempool = true;

		/*
		 * Simnet (btcd)
		 */

		const simnet = {};

		simnet.type = 'simnet';

		simnet.seeds = [
		  '127.0.0.1'
		];

		simnet.magic = 0xf2faede4;

		simnet.port = 18555;

		simnet.checkpointMap = {};

		simnet.lastCheckpoint = 0;

		simnet.halvingInterval = 210000;

		simnet.genesis = {
		  version: 1,
		  hash:
		    b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  prevBlock:
		    b('0000000000000000000000000000000000000000000000000000000000000000'),
		  merkleRoot:
		    b('3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a'),
		  time: 1401292357,
		  bits: 545259519,
		  nonce: 2,
		  height: 0
		};

		simnet.genesisBlock =
		  '0100000000000000000000000000000000000000000000000000000000000000000000'
		  + '003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a4506'
		  + '8653ffff7f200200000001010000000100000000000000000000000000000000000000'
		  + '00000000000000000000000000ffffffff4d04ffff001d0104455468652054696d6573'
		  + '2030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66'
		  + '207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01'
		  + '000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f'
		  + '61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'
		  + 'ac00000000';

		simnet.pow = {
		  limit: new BN(
		    // High target of 0x207fffff (545259519)
		    '7fffff0000000000000000000000000000000000000000000000000000000000',
		    'hex'
		  ),
		  bits: 545259519,
		  chainwork: new BN(
		    '0000000000000000000000000000000000000000000000000000000000000002',
		    'hex'
		  ),
		  halfLife: 172800,
		  targetTimespan: 14 * 24 * 60 * 60,
		  targetSpacing: 10 * 60,
		  retargetInterval: 2016,
		  targetReset: true,
		  noRetargeting: false
		};

		simnet.block = {
		  bip34height: 0,
		  bip34hash:
		    b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  bip65height: 0,
		  bip65hash:
		    b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  bip66height: 0,
		  bip66hash:
		    b('f67ad7695d9b662a72ff3d8edbbb2de0bfa67b13974bb9910d116d5cbd863e68'),
		  uahfHeight: 0,
		  uahfHash: null,
		  daaHeight: 0,
		  daaHash: null,
		  magneticAnomalyActivationTime: 1542300000,
		  greatWallActivationTime: 1557921600,
		  pruneAfterHeight: 1000,
		  keepBlocks: 10000,
		  maxTipAge: 0xffffffff,
		  slowHeight: 0
		};

		simnet.bip30 = {};

		simnet.activationThreshold = 75; // 75% for testchains

		simnet.minerWindow = 100; // nPowTargetTimespan / nPowTargetSpacing

		simnet.deployments = {
		  csv: {
		    name: 'csv',
		    bit: 0,
		    startTime: 0, // March 1st, 2016
		    timeout: 0xffffffff, // May 1st, 2017
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  },
		  testdummy: {
		    name: 'testdummy',
		    bit: 28,
		    startTime: 1199145601, // January 1, 2008
		    timeout: 1230767999, // December 31, 2008
		    threshold: -1,
		    window: -1,
		    required: false,
		    force: true
		  }
		};

		simnet.deploys = [
		  simnet.deployments.csv,
		  simnet.deployments.testdummy
		];

		simnet.keyPrefix = {
		  privkey: 0x64,
		  xpubkey: 0x0420bd3a,
		  xprivkey: 0x0420b900,
		  xpubkey58: 'spub',
		  xprivkey58: 'sprv',
		  coinType: 115
		};

		simnet.addressPrefix = {
		  pubkeyhash: 0x3f,
		  scripthash: 0x7b,
		  cashaddr: 'xecsim'
		};

		simnet.requireStandard = false;

		simnet.rpcPort = 18556;

		simnet.walletPort = 18558;

		simnet.minRelay = 1000;

		simnet.feeRate = 20000;

		simnet.maxFeeRate = 60000;

		simnet.selfConnect = false;

		simnet.requestMempool = false;

		/*
		 * Expose
		 */

		network.main = main;
		  network.testnet = testnet;
		  network.regtest = regtest;
		  network.simnet = simnet; 
	} (networks));
	return networks;
}

var consensus = {};

/*!
 * consensus.js - consensus constants and helpers for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredConsensus;

function requireConsensus () {
	if (hasRequiredConsensus) return consensus;
	hasRequiredConsensus = 1;
	(function (exports) {

		/**
		 * @module protocol/consensus
		 */

		const assert = require$$0$3;
		const BN = requireBn();

		/**
		 * One bitcoin in satoshis.
		 * @const {Amount}
		 * @default
		 */

		exports.COIN = 100000000;

		/**
		 * Maximum amount of money in satoshis:
		 * `21million * 1btc` (consensus).
		 * @const {Amount}
		 * @default
		 */

		exports.MAX_MONEY = 21000000 * exports.COIN;

		/**
		 * Base block subsidy (consensus).
		 * Note to shitcoin implementors: if you
		 * increase this to anything greater than
		 * 33 bits, getReward will have to be
		 * modified to handle the shifts.
		 * @const {Amount}
		 * @default
		 */

		exports.BASE_REWARD = 50 * exports.COIN;

		/**
		 * Half base block subsidy. Required to
		 * calculate the reward properly (with
		 * only 32 bit shifts available).
		 * @const {Amount}
		 * @default
		 */

		exports.HALF_REWARD = Math.floor(exports.BASE_REWARD / 2);

		/**
		 * Maximum block base size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIZE = 1000000;

		/**
		 * Maximum block base size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_FORK_BLOCK_SIZE = 32000000;

		/**
		 * Maximum transaction version (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_VERSION = 2;

		/**
		 * Maximum transaction size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIZE = 1000000;

		/**
		 * Maximum sigcheck operations per transaction.
		 * @const {Number
		 * @default
		 */

		exports.MAX_TX_SIGCHECKS = 3000;

		/**
		 * Ratio between the allowable block-size / sigchecks during sigcheck
		 * operations in a block. (Network rule)
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGCHECKS_RATIO = 141;

		/**
		 * Minimum transaction size (consensus)
		 * @const {Number}
		 * @see https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/
		 * @default
		 */

		exports.MIN_TX_SIZE = 100;

		/**
		 * Maximum block serialization size (protocol).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_RAW_BLOCK_SIZE = 32000000;

		/**
		 * Maximum block sigops per mb (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGOPS_PER_MB = 20000;

		/**
		 * Maximum transaction sigops
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIGOPS = 20000;

		/**
		 * Maximum block sigops cost (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIGOPS_COST = 80000;

		/**
		 * Maximum size for coinbase script sig
		 * @const {Number}
		 * @default
		 */
		exports.MAX_COINBASE_SCRIPTSIG_SIZE = 100;

		/**
		 * Address for Coinbase Rule (8% of block reward+fees goes to this address)
		 * @const {String}
		 * @default
		 */
		 exports.COINBASE_RULE_ADDR = [
		   'ecash:pqnqv9lt7e5vjyp0w88zf2af0l92l8rxdg2jj94l5j',
		   'ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07'
		  ];

		/**
		 * Size of set to pick median time from.
		 * @const {Number}
		 * @default
		 */

		exports.MEDIAN_TIMESPAN = 11;

		/**
		 * What bits to set in version
		 * for versionbits blocks.
		 * @const {Number}
		 * @default
		 */

		exports.VERSION_TOP_BITS = 0x20000000;

		/**
		 * What bitmask determines whether
		 * versionbits is in use.
		 * @const {Number}
		 * @default
		 */

		exports.VERSION_TOP_MASK = 0xe0000000;

		/**
		 * Number of blocks before a coinbase
		 * spend can occur (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.COINBASE_MATURITY = 100;

		/**
		 * nLockTime threshold for differentiating
		 * between height and time (consensus).
		 * Tue Nov 5 00:53:20 1985 UTC
		 * @const {Number}
		 * @default
		 */

		exports.LOCKTIME_THRESHOLD = 500000000;

		/**
		 * Highest nSequence bit -- disables
		 * sequence locktimes (consensus).
		 * @const {Number}
		 */

		exports.SEQUENCE_DISABLE_FLAG = (1 << 31) >>> 0;

		/**
		 * Sequence time: height or time (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_TYPE_FLAG = 1 << 22;

		/**
		 * Sequence granularity for time (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_GRANULARITY = 9;

		/**
		 * Sequence mask (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.SEQUENCE_MASK = 0x0000ffff;

		/**
		 * Max serialized script size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_SIZE = 10000;

		/**
		 * Max stack size during execution (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_STACK = 1000;

		/**
		 * Max script element size (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_PUSH = 520;

		/**
		 * Max opcodes executed (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_SCRIPT_OPS = 201;

		/**
		 * Max `n` value for multisig (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_MULTISIG_PUBKEYS = 20;

		/**
		 * The date bip16 (p2sh) was activated (consensus).
		 * @const {Number}
		 * @default
		 */

		exports.BIP16_TIME = 1333238400;

		/**
		 * A hash of all zeroes.
		 * @const {Buffer}
		 * @default
		 */

		exports.ZERO_HASH = Buffer.alloc(32, 0x00);

		/**
		 * A hash of all zeroes.
		 * @const {String}
		 * @default
		 */

		exports.NULL_HASH =
		  '0000000000000000000000000000000000000000000000000000000000000000';

		/**
		 * Anti replay commitment.
		 * @const {String}
		 * @default
		 */

		exports.ANTI_REPLAY_COMMITMENT =
		  'Bitcoin: A Peer-to-Peer Electronic Cash System';

		/**
		 * Convert a compact number to a big number.
		 * Used for `block.bits` -> `target` conversion.
		 * @param {Number} compact
		 * @returns {BN}
		 */

		exports.fromCompact = function fromCompact(compact) {
		  if (compact === 0)
		    return new BN(0);

		  const exponent = compact >>> 24;
		  const negative = (compact >>> 23) & 1;

		  let mantissa = compact & 0x7fffff;
		  let num;

		  if (exponent <= 3) {
		    mantissa >>>= 8 * (3 - exponent);
		    num = new BN(mantissa);
		  } else {
		    num = new BN(mantissa);
		    num.iushln(8 * (exponent - 3));
		  }

		  if (negative)
		    num.ineg();

		  return num;
		};

		/**
		 * Convert a big number to a compact number.
		 * Used for `target` -> `block.bits` conversion.
		 * @param {BN} num
		 * @returns {Number}
		 */

		exports.toCompact = function toCompact(num) {
		  if (num.isZero())
		    return 0;

		  let exponent = num.byteLength();
		  let mantissa;

		  if (exponent <= 3) {
		    mantissa = num.toNumber();
		    mantissa <<= 8 * (3 - exponent);
		  } else {
		    mantissa = num.ushrn(8 * (exponent - 3)).toNumber();
		  }

		  if (mantissa & 0x800000) {
		    mantissa >>= 8;
		    exponent++;
		  }

		  let compact = (exponent << 24) | mantissa;

		  if (num.isNeg())
		    compact |= 0x800000;

		  compact >>>= 0;

		  return compact;
		};

		/**
		 * Verify proof-of-work.
		 * @param {Hash} hash
		 * @param {Number} bits
		 * @returns {Boolean}
		 */

		exports.verifyPOW = function verifyPOW(hash, bits) {
		  const target = exports.fromCompact(bits);

		  if (target.isNeg() || target.isZero())
		    return false;

		  if (target.bitLength() > 256)
		    return false;

		  const num = new BN(hash, 'le');

		  if (num.gt(target))
		    return false;

		  return true;
		};

		/**
		 * Calculate block subsidy.
		 * @param {Number} height - Reward era by height.
		 * @returns {Amount}
		 */

		exports.getReward = function getReward(height, interval) {
		  assert(height >= 0, 'Bad height for reward.');

		  const halvings = Math.floor(height / interval);

		  // BIP 42 (well, our own version of it,
		  // since we can only handle 32 bit shifts).
		  // https://github.com/bitcoin/bips/blob/master/bip-0042.mediawiki
		  if (halvings >= 33)
		    return 0;

		  // We need to shift right by `halvings`,
		  // but 50 btc is a 33 bit number, so we
		  // cheat. We only start halving once the
		  // halvings are at least 1.
		  if (halvings === 0)
		    return exports.BASE_REWARD;

		  return exports.HALF_REWARD >>> (halvings - 1);
		};

		/**
		 * Test version bit.
		 * @param {Number} version
		 * @param {Number} bit
		 * @returns {Boolean}
		 */

		exports.hasBit = function hasBit(version, bit) {
		  const TOP_MASK = exports.VERSION_TOP_MASK;
		  const TOP_BITS = exports.VERSION_TOP_BITS;
		  const bits = (version & TOP_MASK) >>> 0;
		  const mask = 1 << bit;
		  return bits === TOP_BITS && (version & mask) !== 0;
		};

		/**
		 * Calculate max block sigops.
		 * @param {Number} size
		 * @returns {Number}
		 */

		exports.maxBlockSigops = function maxBlockSigops(size) {
		  const mb = 1 + ((size - 1) / 1e6 | 0);
		  return mb * exports.MAX_BLOCK_SIGOPS_PER_MB;
		};

		/**
		 * Calculate maximum block sigchecks.
		 * @param {Number} size 
		 * @returns {Number}
		 */

		exports.maxBlockSigchecks = function maxBlockSigchecks(size) {
		  return size / exports.MAX_BLOCK_SIGCHECKS_RATIO;
		}; 
	} (consensus));
	return consensus;
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var _polyfillNode_events = /*#__PURE__*/Object.freeze({
	__proto__: null,
	EventEmitter: EventEmitter,
	default: EventEmitter
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

var util = {};

/*!
 * util.js - utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {

		const assert = require$$0$3;

		/**
		 * @exports utils/util
		 */

		const util = exports;

		/**
		 * Return hrtime (shim for browser).
		 * @param {Array} time
		 * @returns {Array} [seconds, nanoseconds]
		 */

		util.bench = function bench(time) {
		  if (!process.hrtime) {
		    const now = Date.now();

		    if (time) {
		      const [hi, lo] = time;
		      const start = hi * 1000 + lo / 1e6;
		      return now - start;
		    }

		    const ms = now % 1000;

		    // Seconds
		    const hi = (now - ms) / 1000;

		    // Nanoseconds
		    const lo = ms * 1e6;

		    return [hi, lo];
		  }

		  if (time) {
		    const [hi, lo] = process.hrtime(time);
		    return hi * 1000 + lo / 1e6;
		  }

		  return process.hrtime();
		};

		/**
		 * Get current time in unix time (seconds).
		 * @returns {Number}
		 */

		util.now = function now() {
		  return Math.floor(Date.now() / 1000);
		};

		/**
		 * Get current time in unix time (milliseconds).
		 * @returns {Number}
		 */

		util.ms = function ms() {
		  return Date.now();
		};

		/**
		 * Create a Date ISO string from time in unix time (seconds).
		 * @param {Number?} time - Seconds in unix time.
		 * @returns {String}
		 */

		util.date = function date(time) {
		  if (time == null)
		    time = util.now();

		  return new Date(time * 1000).toISOString().slice(0, -5) + 'Z';
		};

		/**
		 * Get unix seconds from a Date string.
		 * @param {String?} date - Date ISO String.
		 * @returns {Number}
		 */

		util.time = function time(date) {
		  if (date == null)
		    return util.now();

		  return new Date(date) / 1000 | 0;
		};

		/**
		 * Reverse a hex-string.
		 * @param {Buffer}
		 * @returns {String} Reversed hex string.
		 */

		util.revHex = function revHex(buf) {
		  assert(Buffer.isBuffer(buf));

		  return Buffer.from(buf).reverse().toString('hex');
		};

		util.fromRev = function fromRev(str) {
		  assert(typeof str === 'string');
		  assert((str.length & 1) === 0);

		  return Buffer.from(str, 'hex').reverse();
		}; 
	} (util));
	return util;
}

/*!
 * timedata.js - time management for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var timedata;
var hasRequiredTimedata;

function requireTimedata () {
	if (hasRequiredTimedata) return timedata;
	hasRequiredTimedata = 1;

	const EventEmitter = require$$0$2;
	const util = requireUtil();
	const binary = requireBinary();

	/**
	 * Time Data
	 * An object which handles "adjusted time". This may not
	 * look it, but this is actually a semi-consensus-critical
	 * piece of code. It handles version packets from peers
	 * and calculates what to offset our system clock's time by.
	 * @alias module:protocol.TimeData
	 * @extends EventEmitter
	 * @property {Array} samples
	 * @property {Object} known
	 * @property {Number} limit
	 * @property {Number} offset
	 */

	class TimeData extends EventEmitter {
	  /**
	   * Create time data.
	   * @constructor
	   * @param {Number} [limit=200]
	   */

	  constructor(limit) {
	    super();

	    if (limit == null)
	      limit = 200;

	    this.samples = [];
	    this.known = new Map();
	    this.limit = limit;
	    this.offset = 0;
	    this.checked = false;
	  }

	  /**
	   * Add time data.
	   * @param {String} id
	   * @param {Number} time
	   */

	  add(id, time) {
	    if (this.samples.length >= this.limit)
	      return;

	    if (this.known.has(id))
	      return;

	    const sample = time - util.now();

	    this.known.set(id, sample);

	    binary.insert(this.samples, sample, compare);

	    this.emit('sample', sample, this.samples.length);

	    if (this.samples.length >= 5 && this.samples.length % 2 === 1) {
	      let median = this.samples[this.samples.length >>> 1];

	      if (Math.abs(median) >= 70 * 60) {
	        if (!this.checked) {
	          let match = false;

	          for (const offset of this.samples) {
	            if (offset !== 0 && Math.abs(offset) < 5 * 60) {
	              match = true;
	              break;
	            }
	          }

	          if (!match) {
	            this.checked = true;
	            this.emit('mismatch');
	          }
	        }

	        median = 0;
	      }

	      this.offset = median;
	      this.emit('offset', this.offset);
	    }
	  }

	  /**
	   * Get the current adjusted time.
	   * @returns {Number} Adjusted Time.
	   */

	  now() {
	    return util.now() + this.offset;
	  }

	  /**
	   * Adjust a timestamp.
	   * @param {Number} time
	   * @returns {Number} Adjusted Time.
	   */

	  adjust(time) {
	    return time + this.offset;
	  }

	  /**
	   * Unadjust a timestamp.
	   * @param {Number} time
	   * @returns {Number} Local Time.
	   */

	  local(time) {
	    return time - this.offset;
	  }

	  /**
	   * Get the current adjusted time in milliseconds.
	   * @returns {Number} Adjusted Time.
	   */

	  ms() {
	    return Date.now() + this.offset * 1000;
	  }
	}

	/*
	 * Helpers
	 */

	function compare(a, b) {
	  return a - b;
	}

	/*
	 * Expose
	 */

	timedata = TimeData;
	return timedata;
}

/*!
 * network.js - network object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var network;
var hasRequiredNetwork;

function requireNetwork () {
	if (hasRequiredNetwork) return network;
	hasRequiredNetwork = 1;

	const assert = require$$0$3;
	const binary = requireBinary();
	const networks = requireNetworks();
	const consensus = requireConsensus();
	const TimeData = requireTimedata();

	/**
	 * Network
	 * Represents a network.
	 * @alias module:protocol.Network
	 */

	class Network {
	  /**
	   * Create a network.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    assert(!Network[options.type], 'Cannot create two networks.');

	    this.type = options.type;
	    this.seeds = options.seeds;
	    this.magic = options.magic;
	    this.port = options.port;
	    this.checkpointMap = options.checkpointMap;
	    this.lastCheckpoint = options.lastCheckpoint;
	    this.checkpoints = [];
	    this.halvingInterval = options.halvingInterval;
	    this.genesis = options.genesis;
	    this.genesisBlock = options.genesisBlock;
	    this.pow = options.pow;
	    this.block = options.block;
	    this.bip30 = options.bip30;
	    this.activationThreshold = options.activationThreshold;
	    this.minerWindow = options.minerWindow;
	    this.deployments = options.deployments;
	    this.deploys = options.deploys;
	    this.unknownBits = ~consensus.VERSION_TOP_MASK;
	    this.keyPrefix = options.keyPrefix;
	    this.addressPrefix = options.addressPrefix;
	    this.requireStandard = options.requireStandard;
	    this.rpcPort = options.rpcPort;
	    this.walletPort = options.walletPort;
	    this.minRelay = options.minRelay;
	    this.feeRate = options.feeRate;
	    this.maxFeeRate = options.maxFeeRate;
	    this.selfConnect = options.selfConnect;
	    this.requestMempool = options.requestMempool;
	    this.time = new TimeData();

	    this.init();
	  }

	  /**
	   * Get a deployment by bit index.
	   * @param {Number} bit
	   * @returns {Object}
	   */

	  init() {
	    let bits = 0;

	    for (const deployment of this.deploys)
	      bits |= 1 << deployment.bit;

	    bits |= consensus.VERSION_TOP_MASK;

	    this.unknownBits = ~bits >>> 0;

	    for (const key of Object.keys(this.checkpointMap)) {
	      const hash = this.checkpointMap[key];
	      const height = Number(key);

	      this.checkpoints.push({ hash, height });
	    }

	    this.checkpoints.sort(cmpNode);
	  }

	  /**
	   * Get a deployment by bit index.
	   * @param {Number} bit
	   * @returns {Object}
	   */

	  byBit(bit) {
	    const index = binary.search(this.deploys, bit, cmpBit);

	    if (index === -1)
	      return null;

	    return this.deploys[index];
	  }

	  /**
	   * Get network adjusted time.
	   * @returns {Number}
	   */

	  now() {
	    return this.time.now();
	  }

	  /**
	   * Get network adjusted time in milliseconds.
	   * @returns {Number}
	   */

	  ms() {
	    return this.time.ms();
	  }

	  /**
	   * Create a network. Get existing network if possible.
	   * @param {NetworkType|Object} options
	   * @returns {Network}
	   */

	  static create(options) {
	    if (typeof options === 'string')
	      options = networks[options];

	    assert(options, 'Unknown network.');

	    if (Network[options.type])
	      return Network[options.type];

	    const network = new Network(options);

	    Network[network.type] = network;

	    if (!Network.primary)
	      Network.primary = network;

	    return network;
	  }

	  /**
	   * Set the default network. This network will be used
	   * if nothing is passed as the `network` option for
	   * certain objects.
	   * @param {NetworkType} type - Network type.
	   * @returns {Network}
	   */

	  static set(type) {
	    assert(typeof type === 'string', 'Bad network.');
	    Network.primary = Network.get(type);
	    Network.type = type;
	    return Network.primary;
	  }

	  /**
	   * Get a network with a string or a Network object.
	   * @param {NetworkType|Network} type - Network type.
	   * @returns {Network}
	   */

	  static get(type) {
	    if (!type) {
	      assert(Network.primary, 'No default network.');
	      return Network.primary;
	    }

	    if (type instanceof Network)
	      return type;

	    if (typeof type === 'string')
	      return Network.create(type);

	    throw new Error('Unknown network.');
	  }

	  /**
	   * Get a network with a string or a Network object.
	   * @param {NetworkType|Network} type - Network type.
	   * @returns {Network}
	   */

	  static ensure(type) {
	    if (!type) {
	      assert(Network.primary, 'No default network.');
	      return Network.primary;
	    }

	    if (type instanceof Network)
	      return type;

	    if (typeof type === 'string') {
	      if (networks[type])
	        return Network.create(type);
	    }

	    assert(Network.primary, 'No default network.');

	    return Network.primary;
	  }

	  /**
	   * Get a network by an associated comparator.
	   * @private
	   * @param {Object} value
	   * @param {Function} compare
	   * @param {Network|null} network
	   * @param {String} name
	   * @returns {Network}
	   */

	  static by(value, compare, network, name) {
	    if (network) {
	      network = Network.get(network);
	      if (compare(network, value))
	        return network;
	      throw new Error(`Network mismatch for ${name}.`);
	    }

	    for (const type of networks.types) {
	      network = networks[type];
	      if (compare(network, value))
	        return Network.get(type);
	    }

	    throw new Error(`Network not found for ${name}.`);
	  }

	  /**
	   * Get a network by its magic number.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromMagic(value, network) {
	    return Network.by(value, cmpMagic, network, 'magic number');
	  }

	  /**
	   * Get a network by its WIF prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromWIF(prefix, network) {
	    return Network.by(prefix, cmpWIF, network, 'WIF');
	  }

	  /**
	   * Get a network by its xpubkey prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPublic(prefix, network) {
	    return Network.by(prefix, cmpPub, network, 'xpubkey');
	  }

	  /**
	   * Get a network by its xprivkey prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPrivate(prefix, network) {
	    return Network.by(prefix, cmpPriv, network, 'xprivkey');
	  }

	  /**
	   * Get a network by its xpubkey base58 prefix.
	   * @param {String} prefix
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPublic58(prefix, network) {
	    return Network.by(prefix, cmpPub58, network, 'xpubkey');
	  }

	  /**
	   * Get a network by its xprivkey base58 prefix.
	   * @param {String} prefix
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromPrivate58(prefix, network) {
	    return Network.by(prefix, cmpPriv58, network, 'xprivkey');
	  }

	  /**
	   * Get a network by its base58 address prefix.
	   * @param {Number} value
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromAddress(prefix, network) {
	    return Network.by(prefix, cmpAddress, network, 'base58 address');
	  }

	  /**
	   * Get a network by its cashaddr address prefix.
	   * @param {String} hrp
	   * @param {Network?} network
	   * @returns {Network}
	   */

	  static fromCashAddr(prefix, network) {
	    return Network.by(prefix, cmpCashAddr, network, 'cashaddr address');
	  }

	  /**
	   * Convert the network to a string.
	   * @returns {String}
	   */

	  toString() {
	    return this.type;
	  }

	  /**
	   * Inspect the network.
	   * @returns {String}
	   */

	  inspect() {
	    return `<Network: ${this.type}>`;
	  }

	  /**
	   * Test an object to see if it is a Network.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isNetwork(obj) {
	    return obj instanceof Network;
	  }
	}

	/**
	 * Default network.
	 * @type {Network}
	 */

	Network.primary = null;

	/**
	 * Default network type.
	 * @type {String}
	 */

	Network.type = null;

	/*
	 * Networks (to avoid hash table mode).
	 */

	Network.main = null;
	Network.testnet = null;
	Network.regtest = null;
	Network.segnet4 = null;
	Network.simnet = null;

	/*
	 * Set initial network.
	 */

	Network.set(process.env.BCASH_NETWORK || 'main');

	/*
	 * Helpers
	 */

	function cmpBit(a, b) {
	  return a.bit - b;
	}

	function cmpNode(a, b) {
	  return a.height - b.height;
	}

	function cmpMagic(network, magic) {
	  return network.magic === magic;
	}

	function cmpWIF(network, prefix) {
	  return network.keyPrefix.privkey === prefix;
	}

	function cmpPub(network, prefix) {
	  return network.keyPrefix.xpubkey === prefix;
	}

	function cmpPriv(network, prefix) {
	  return network.keyPrefix.xprivkey === prefix;
	}

	function cmpPub58(network, prefix) {
	  return network.keyPrefix.xpubkey58 === prefix;
	}

	function cmpPriv58(network, prefix) {
	  return network.keyPrefix.xprivkey58 === prefix;
	}

	function cmpAddress(network, prefix) {
	  const prefixes = network.addressPrefix;

	  switch (prefix) {
	    case prefixes.pubkeyhash:
	    case prefixes.scripthash:
	      return true;
	  }

	  return false;
	}

	function cmpCashAddr(network, prefix) {
	  return network.addressPrefix.cashaddr === prefix;
	}

	/*
	 * Expose
	 */

	network = Network;
	return network;
}

var utils = {};

var message = {};

var random = {};

/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */

var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return random;
	hasRequiredRandom = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	const HAS_CRYPTO = crypto && typeof crypto.getRandomValues === 'function';
	const randomValues = HAS_CRYPTO ? crypto.getRandomValues.bind(crypto) : null;
	const pool = new Uint32Array(16);
	const MAX_BYTES = 65536;

	let poolPos = 0;

	/**
	 * Generate pseudo-random bytes.
	 * @param {Number} size
	 * @returns {Buffer}
	 */

	function randomBytes(size) {
	  assert((size >>> 0) === size);

	  const data = Buffer.alloc(size);

	  randomFillSync(data, 0, size);

	  return data;
	}

	/**
	 * Generate pseudo-random bytes.
	 * @param {Buffer} data
	 * @param {Number} [off=0]
	 * @param {Number} [size=data.length-off]
	 * @returns {Buffer}
	 */

	function randomFill(data, off, size) {
	  assert(Buffer.isBuffer(data));

	  if (off == null)
	    off = 0;

	  assert((off >>> 0) === off);

	  if (size == null)
	    size = data.length - off;

	  assert((size >>> 0) === size);
	  assert(off + size <= data.length);

	  randomFillSync(data, off, size);

	  return data;
	}

	/**
	 * Generate a random uint32.
	 * @returns {Number}
	 */

	function randomInt() {
	  if ((poolPos & 15) === 0) {
	    getRandomValues(pool);
	    poolPos = 0;
	  }

	  return pool[poolPos++];
	}

	/**
	 * Generate a random uint32 within a range.
	 * @param {Number} min - Inclusive.
	 * @param {Number} max - Exclusive.
	 * @returns {Number}
	 */

	function randomRange(min, max) {
	  assert((min >>> 0) === min);
	  assert((max >>> 0) === max);
	  assert(max >= min);

	  const space = max - min;

	  if (space === 0)
	    return min;

	  const top = -space >>> 0;

	  let x, r;

	  do {
	    x = randomInt();
	    r = x % space;
	  } while (x - r > top);

	  return r + min;
	}

	/*
	 * Helpers
	 */

	function getRandomValues(array) {
	  if (!HAS_CRYPTO)
	    throw new Error('Entropy source not available.');

	  return randomValues(array);
	}

	function randomFillSync(data, off, size) {
	  assert(Buffer.isBuffer(data));
	  assert(data.buffer instanceof ArrayBuffer);
	  assert((data.byteOffset >>> 0) === data.byteOffset);
	  assert((data.byteLength >>> 0) === data.byteLength);
	  assert((off >>> 0) === off);
	  assert((size >>> 0) === size);
	  assert(off + size <= data.byteLength);

	  if (size > 2 ** 31 - 1)
	    throw new RangeError('The value "size" is out of range.');

	  const offset = data.byteOffset + off;
	  const array = new Uint8Array(data.buffer, offset, size);

	  if (array.length > MAX_BYTES) {
	    for (let i = 0; i < array.length; i += MAX_BYTES) {
	      let j = i + MAX_BYTES;

	      if (j > array.length)
	        j = array.length;

	      getRandomValues(array.subarray(i, j));
	    }
	  } else {
	    if (array.length > 0)
	      getRandomValues(array);
	  }
	}

	/*
	 * Expose
	 */

	random.native = 0;
	random.randomBytes = randomBytes;
	random.randomFill = randomFill;
	random.randomInt = randomInt;
	random.randomRange = randomRange;
	return random;
}

var asn1$1 = {};

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = (function () {
    return function foo() {}.name === 'foo';
  }());
}
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

function assert(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}

// assert.AssertionError instanceof Error
inherits(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
}

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
}

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
}

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert.throws = throws;
function throws(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
}

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
}

assert.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AssertionError: AssertionError,
	assert: ok,
	deepEqual: deepEqual,
	deepStrictEqual: deepStrictEqual,
	default: assert,
	doesNotThrow: doesNotThrow,
	equal: equal,
	fail: fail,
	ifError: ifError,
	notDeepEqual: notDeepEqual,
	notDeepStrictEqual: notDeepStrictEqual,
	notEqual: notEqual,
	notStrictEqual: notStrictEqual,
	ok: ok,
	strictEqual: strictEqual,
	throws: throws
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredAsn1$1;

function requireAsn1$1 () {
	if (hasRequiredAsn1$1) return asn1$1;
	hasRequiredAsn1$1 = 1;

	const assert = require$$0$1;
	const BN = requireBn();

	/*
	 * ASN1
	 */

	function readSize(data, pos, strict) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert(typeof strict === 'boolean');

	  if (pos >= data.length)
	    throw new Error('Invalid size.');

	  const field = data[pos];
	  const bytes = field & 0x7f;

	  pos += 1;

	  // Definite form.
	  if ((field & 0x80) === 0) {
	    // Short form.
	    return [bytes, pos];
	  }

	  // Indefinite form.
	  if (strict && bytes === 0)
	    throw new Error('Indefinite length.');

	  // Long form.
	  let size = 0;

	  for (let i = 0; i < bytes; i++) {
	    assert(pos < data.length);

	    const ch = data[pos];

	    pos += 1;

	    if (size >= (1 << 24))
	      throw new Error('Length too large.');

	    size *= 0x100;
	    size += ch;

	    if (strict && size === 0)
	      throw new Error('Unexpected leading zeroes.');
	  }

	  if (strict && size < 0x80)
	    throw new Error('Non-minimal length.');

	  return [size, pos];
	}

	function readSeq(data, pos, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert(typeof strict === 'boolean');

	  if (pos >= data.length || data[pos] !== 0x30)
	    throw new Error('Invalid sequence tag.');

	  pos += 1;

	  let size;
	  [size, pos] = readSize(data, pos, strict);

	  if (strict && pos + size !== data.length)
	    throw new Error('Trailing bytes.');

	  return pos;
	}

	function readInt(data, pos, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert(typeof strict === 'boolean');

	  if (pos >= data.length || data[pos] !== 0x02)
	    throw new Error('Invalid integer tag.');

	  pos += 1;

	  let size;
	  [size, pos] = readSize(data, pos, strict);

	  if (pos + size > data.length)
	    throw new Error('Integer body out of bounds.');

	  if (strict) {
	    // Zero length integer.
	    if (size === 0)
	      throw new Error('Zero length integer.');

	    // No negatives.
	    if (data[pos] & 0x80)
	      throw new Error('Integers must be positive.');

	    // Allow zero only if it prefixes a high bit.
	    if (size > 1) {
	      if (data[pos] === 0x00 && (data[pos + 1] & 0x80) === 0x00)
	        throw new Error('Unexpected leading zeroes.');
	    }
	  }

	  // Eat leading zeroes.
	  while (size > 0 && data[pos] === 0x00) {
	    pos += 1;
	    size -= 1;
	  }

	  // No reason to have an integer larger than this.
	  if (size > 2048)
	    throw new Error('Invalid integer size.');

	  const num = BN.decode(data.slice(pos, pos + size));

	  pos += size;

	  return [num, pos];
	}

	function readVersion(data, pos, version, strict = true) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert((version & 0xff) === version);
	  assert(typeof strict === 'boolean');

	  let num;
	  [num, pos] = readInt(data, pos, strict);

	  if (num.cmpn(version) !== 0)
	    throw new Error('Invalid version.');

	  return pos;
	}

	function sizeSize(size) {
	  assert((size >>> 0) === size);

	  if (size <= 0x7f) // [size]
	    return 1;

	  if (size <= 0xff) // 0x81 [size]
	    return 2;

	  assert(size <= 0xffff);

	  return 3; // 0x82 [size-hi] [size-lo]
	}

	function sizeSeq(size) {
	  return 1 + sizeSize(size) + size;
	}

	function sizeInt(num) {
	  assert(num instanceof BN);

	  // 0x02 [size] [0x00?] [int]
	  const bits = num.bitLength();

	  let size = (bits + 7) >>> 3;

	  if (bits > 0 && (bits & 7) === 0)
	    size += num.testn(bits - 1);

	  if (bits === 0)
	    size = 1;

	  return 1 + sizeSize(size) + size;
	}

	function sizeVersion(version) {
	  assert((version & 0xff) === version);
	  return 3;
	}

	function writeSize(data, pos, size) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert((size >>> 0) === size);

	  if (size <= 0x7f)  {
	    // [size]
	    data[pos++] = size;
	  } else if (size <= 0xff) {
	    // 0x81 [size]
	    data[pos++] = 0x81;
	    data[pos++] = size;
	  } else {
	    // 0x82 [size-hi] [size-lo]
	    assert(size <= 0xffff);
	    data[pos++] = 0x82;
	    data[pos++] = size >> 8;
	    data[pos++] = size & 0xff;
	  }

	  assert(pos <= data.length);

	  return pos;
	}

	function writeSeq(data, pos, size) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);

	  data[pos++] = 0x30;

	  return writeSize(data, pos, size);
	}

	function writeInt(data, pos, num) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert(num instanceof BN);

	  // 0x02 [size] [0x00?] [int]
	  const bits = num.bitLength();

	  let size = (bits + 7) >>> 3;
	  let pad = 0;

	  if (bits > 0 && (bits & 7) === 0)
	    pad = num.testn(bits - 1);

	  if (bits === 0)
	    size = 1;

	  data[pos++] = 0x02;

	  pos = writeSize(data, pos, pad + size);

	  if (pad)
	    data[pos++] = 0x00;

	  if (bits !== 0)
	    num.encode().copy(data, pos);
	  else
	    data[pos] = 0x00;

	  pos += size;

	  assert(pos <= data.length);

	  return pos;
	}

	function writeVersion(data, pos, version) {
	  assert(Buffer.isBuffer(data));
	  assert((pos >>> 0) === pos);
	  assert((version & 0xff) === version);
	  assert(pos + 3 <= data.length);

	  data[pos++] = 0x02;
	  data[pos++] = 0x01;
	  data[pos++] = version;

	  return pos;
	}

	/*
	 * Expose
	 */

	asn1$1.readSize = readSize;
	asn1$1.readSeq = readSeq;
	asn1$1.readInt = readInt;
	asn1$1.readVersion = readVersion;
	asn1$1.sizeSize = sizeSize;
	asn1$1.sizeSeq = sizeSeq;
	asn1$1.sizeInt = sizeInt;
	asn1$1.sizeVersion = sizeVersion;
	asn1$1.writeSize = writeSize;
	asn1$1.writeSeq = writeSeq;
	asn1$1.writeInt = writeInt;
	asn1$1.writeVersion = writeVersion;
	return asn1$1;
}

/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */

var chacha20;
var hasRequiredChacha20;

function requireChacha20 () {
	if (hasRequiredChacha20) return chacha20;
	hasRequiredChacha20 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

	/**
	 * ChaCha20
	 */

	class ChaCha20 {
	  /**
	   * Create a ChaCha20 context.
	   * @constructor
	   */

	  constructor() {
	    this.state = new Uint32Array(16);
	    this.stream = new Uint32Array(16);
	    this.bytes = new Uint8Array(this.stream.buffer);
	    this.pos = -1;

	    if (BIG_ENDIAN)
	      this.bytes = Buffer.alloc(64);
	  }

	  /**
	   * Initialize chacha20 with a key, nonce, and counter.
	   * @param {Buffer} key
	   * @param {Buffer} nonce
	   * @param {Number} counter
	   */

	  init(key, nonce, counter) {
	    if (counter == null)
	      counter = 0;

	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(nonce));
	    assert(Number.isSafeInteger(counter));

	    if (key.length !== 16 && key.length !== 32)
	      throw new RangeError('Invalid key size.');

	    if (nonce.length >= 24) {
	      key = ChaCha20.derive(key, nonce.slice(0, 16));
	      nonce = nonce.slice(16);
	    }

	    this.state[0] = 0x61707865;
	    this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
	    this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
	    this.state[3] = 0x6b206574;
	    this.state[4] = readU32(key, 0);
	    this.state[5] = readU32(key, 4);
	    this.state[6] = readU32(key, 8);
	    this.state[7] = readU32(key, 12);
	    this.state[8] = readU32(key, 16 % key.length);
	    this.state[9] = readU32(key, 20 % key.length);
	    this.state[10] = readU32(key, 24 % key.length);
	    this.state[11] = readU32(key, 28 % key.length);
	    this.state[12] = counter >>> 0;

	    if (nonce.length === 8) {
	      this.state[13] = (counter / 0x100000000) >>> 0;
	      this.state[14] = readU32(nonce, 0);
	      this.state[15] = readU32(nonce, 4);
	    } else if (nonce.length === 12) {
	      this.state[13] = readU32(nonce, 0);
	      this.state[14] = readU32(nonce, 4);
	      this.state[15] = readU32(nonce, 8);
	    } else if (nonce.length === 16) {
	      this.state[12] = readU32(nonce, 0);
	      this.state[13] = readU32(nonce, 4);
	      this.state[14] = readU32(nonce, 8);
	      this.state[15] = readU32(nonce, 12);
	    } else {
	      throw new RangeError('Invalid nonce size.');
	    }

	    this.pos = 0;

	    return this;
	  }

	  /**
	   * Encrypt/decrypt data.
	   * @param {Buffer} data - Will be mutated.
	   * @returns {Buffer}
	   */

	  encrypt(data) {
	    assert(Buffer.isBuffer(data));

	    if (this.pos === -1)
	      throw new Error('Context is not initialized.');

	    for (let i = 0; i < data.length; i++) {
	      if ((this.pos & 63) === 0) {
	        this._block();
	        this.pos = 0;
	      }

	      data[i] ^= this.bytes[this.pos++];
	    }

	    return data;
	  }

	  /**
	   * Stir the stream.
	   */

	  _block() {
	    for (let i = 0; i < 16; i++)
	      this.stream[i] = this.state[i];

	    for (let i = 0; i < 10; i++) {
	      qround(this.stream, 0, 4, 8, 12);
	      qround(this.stream, 1, 5, 9, 13);
	      qround(this.stream, 2, 6, 10, 14);
	      qround(this.stream, 3, 7, 11, 15);
	      qround(this.stream, 0, 5, 10, 15);
	      qround(this.stream, 1, 6, 11, 12);
	      qround(this.stream, 2, 7, 8, 13);
	      qround(this.stream, 3, 4, 9, 14);
	    }

	    for (let i = 0; i < 16; i++)
	      this.stream[i] += this.state[i];

	    if (BIG_ENDIAN) {
	      for (let i = 0; i < 16; i++)
	        writeU32(this.bytes, this.stream[i], i * 4);
	    }

	    this.state[12] += 1;

	    if (this.state[12] === 0)
	      this.state[13] += 1;
	  }

	  /**
	   * Destroy context.
	   */

	  destroy() {
	    for (let i = 0; i < 16; i++) {
	      this.state[i] = 0;
	      this.stream[i] = 0;
	    }

	    if (BIG_ENDIAN) {
	      for (let i = 0; i < 64; i++)
	        this.bytes[i] = 0;
	    }

	    this.pos = -1;

	    return this;
	  }

	  /**
	   * Derive key with XChaCha20.
	   * @param {Buffer} key
	   * @param {Buffer} nonce
	   * @returns {Buffer}
	   */

	  static derive(key, nonce) {
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(nonce));

	    if (key.length !== 16 && key.length !== 32)
	      throw new RangeError('Invalid key size.');

	    if (nonce.length !== 16)
	      throw new RangeError('Invalid nonce size.');

	    const state = new Uint32Array(16);

	    state[0] = 0x61707865;
	    state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
	    state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
	    state[3] = 0x6b206574;
	    state[4] = readU32(key, 0);
	    state[5] = readU32(key, 4);
	    state[6] = readU32(key, 8);
	    state[7] = readU32(key, 12);
	    state[8] = readU32(key, 16 % key.length);
	    state[9] = readU32(key, 20 % key.length);
	    state[10] = readU32(key, 24 % key.length);
	    state[11] = readU32(key, 28 % key.length);
	    state[12] = readU32(nonce, 0);
	    state[13] = readU32(nonce, 4);
	    state[14] = readU32(nonce, 8);
	    state[15] = readU32(nonce, 12);

	    for (let i = 0; i < 10; i++) {
	      qround(state, 0, 4, 8, 12);
	      qround(state, 1, 5, 9, 13);
	      qround(state, 2, 6, 10, 14);
	      qround(state, 3, 7, 11, 15);
	      qround(state, 0, 5, 10, 15);
	      qround(state, 1, 6, 11, 12);
	      qround(state, 2, 7, 8, 13);
	      qround(state, 3, 4, 9, 14);
	    }

	    const out = Buffer.alloc(32);

	    writeU32(out, state[0], 0);
	    writeU32(out, state[1], 4);
	    writeU32(out, state[2], 8);
	    writeU32(out, state[3], 12);
	    writeU32(out, state[12], 16);
	    writeU32(out, state[13], 20);
	    writeU32(out, state[14], 24);
	    writeU32(out, state[15], 28);

	    return out;
	  }
	}

	/*
	 * Static
	 */

	ChaCha20.native = 0;

	/*
	 * Helpers
	 */

	function qround(x, a, b, c, d) {
	  x[a] += x[b];
	  x[d] = rotl32(x[d] ^ x[a], 16);

	  x[c] += x[d];
	  x[b] = rotl32(x[b] ^ x[c], 12);

	  x[a] += x[b];
	  x[d] = rotl32(x[d] ^ x[a], 8);

	  x[c] += x[d];
	  x[b] = rotl32(x[b] ^ x[c], 7);
	}

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	chacha20 = ChaCha20;
	return chacha20;
}

/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */

var batchRng;
var hasRequiredBatchRng;

function requireBatchRng () {
	if (hasRequiredBatchRng) return batchRng;
	hasRequiredBatchRng = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const ChaCha20 = requireChacha20();
	const SHA256 = requireSha256();

	/**
	 * BatchRNG
	 */

	class BatchRNG {
	  constructor(curve, encode = key => key) {
	    this.curve = curve;
	    this.encode = encode;
	    this.hash = new SHA256();
	    this.chacha = new ChaCha20();
	    this.key = Buffer.alloc(32, 0x00);
	    this.iv = Buffer.alloc(8, 0x00);
	    this.cache = [new BN(1), new BN(1)];
	  }

	  init(batch) {
	    assert(Array.isArray(batch));

	    this.hash.init();

	    for (const [msg, sig, key] of batch) {
	      this.hash.update(SHA256.digest(msg));
	      this.hash.update(sig);
	      this.hash.update(this.encode(key));
	    }

	    this.key = this.hash.final();
	    this.cache[0] = new BN(1);
	    this.cache[1] = new BN(1);

	    return this;
	  }

	  encrypt(counter) {
	    const size = this.curve.scalarSize * 2;
	    const data = Buffer.alloc(size, 0x00);
	    const left = data.slice(0, this.curve.scalarSize);
	    const right = data.slice(this.curve.scalarSize);

	    this.chacha.init(this.key, this.iv, counter);
	    this.chacha.encrypt(data);

	    return [
	      this.curve.decodeScalar(left),
	      this.curve.decodeScalar(right)
	    ];
	  }

	  refresh(counter) {
	    let overflow = 0;

	    for (;;) {
	      // First word is always zero.
	      this.iv[4] = overflow;
	      this.iv[5] = overflow >>> 8;
	      this.iv[6] = overflow >>> 16;
	      this.iv[7] = overflow >>> 24;

	      overflow += 1;

	      const [s1, s2] = this.encrypt(counter);

	      if (s1.isZero() || s1.cmp(this.curve.n) >= 0)
	        continue;

	      if (s2.isZero() || s2.cmp(this.curve.n) >= 0)
	        continue;

	      this.cache[0] = s1;
	      this.cache[1] = s2;

	      break;
	    }
	  }

	  generate(index) {
	    assert((index >>> 0) === index);

	    if (index & 1)
	      this.refresh(index >>> 1);

	    return this.cache[index & 1];
	  }
	}

	/*
	 * Expose
	 */

	batchRng = BatchRNG;
	return batchRng;
}

/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */

var schnorrLegacy;
var hasRequiredSchnorrLegacy;

function requireSchnorrLegacy () {
	if (hasRequiredSchnorrLegacy) return schnorrLegacy;
	hasRequiredSchnorrLegacy = 1;

	const assert = requireAssert();
	const BatchRNG = requireBatchRng();
	const BN = requireBn();

	/**
	 * Schnorr
	 */

	class Schnorr {
	  constructor(curve, hash) {
	    this.curve = curve;
	    this.hash = hash;
	    this.rng = new BatchRNG(this.curve, this.encode.bind(this));
	  }

	  check() {
	    // [SCHNORR] "Footnotes".
	    // Must be congruent to 3 mod 4.
	    if (this.curve.p.andln(3) !== 3)
	      throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
	  }

	  encode(key) {
	    // Extra speedy key reserialization.
	    assert(Buffer.isBuffer(key));

	    const {fieldSize} = this.curve;

	    if (key.length === 1 + fieldSize)
	      return key;

	    if (key.length !== 1 + fieldSize * 2)
	      throw new Error('Invalid point.');

	    const out = Buffer.alloc(1 + fieldSize);

	    out[0] = 0x02 | (key[key.length - 1] & 1);
	    key.copy(out, 1, 1, 1 + fieldSize);

	    return out;
	  }

	  hashInt(...items) {
	    // [SCHNORR] "Specification".
	    // eslint-disable-next-line
	    const h = new this.hash();

	    h.init();

	    for (const item of items)
	      h.update(item);

	    let hash = h.final(this.curve.scalarSize);

	    if (hash.length > this.curve.scalarSize)
	      hash = hash.slice(0, this.curve.scalarSize);

	    const num = BN.decode(hash, this.curve.endian);

	    num.iumaskn(this.curve.scalarBits);

	    return num.imod(this.curve.n);
	  }

	  hashNonce(a, m) {
	    return this.hashInt(a, m);
	  }

	  hashChallenge(R, A, m) {
	    return this.hashInt(R, this.encode(A), m);
	  }

	  sign(msg, key) {
	    assert(Buffer.isBuffer(msg));

	    this.check();

	    return this._sign(msg, key);
	  }

	  _sign(msg, key) {
	    // Schnorr Signing.
	    //
	    // [SCHNORR] "Signing".
	    // [CASH] "Recommended practices for secure signature generation".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `a` be a secret non-zero scalar.
	    //   - k != 0.
	    //
	    // Computation:
	    //
	    //   A = G * a
	    //   k = H(a, m) mod n
	    //   R = G * k
	    //   k = -k mod n, if y(R) is not square
	    //   r = x(R)
	    //   e = H(r, A, m) mod n
	    //   s = (k + e * a) mod n
	    //   S = (r, s)
	    //
	    // Note that `k` must remain secret,
	    // otherwise an attacker can compute:
	    //
	    //   a = (s - k) / e mod n
	    const {n} = this.curve;
	    const G = this.curve.g;
	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(n) >= 0)
	      throw new Error('Invalid private key.');

	    const A = G.mulBlind(a);
	    const k = this.hashNonce(key, msg);

	    if (k.isZero())
	      throw new Error('Signing failed (k\' = 0).');

	    const R = G.mulBlind(k);

	    if (!R.isSquare())
	      k.ineg().imod(n);

	    const Rraw = R.encodeX();
	    const Araw = A.encode();
	    const e = this.hashChallenge(Rraw, Araw, msg);
	    const s = k.add(e.mul(a)).imod(n);

	    return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);
	  }

	  verify(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));

	    this.check();

	    if (sig.length !== this.curve.fieldSize + this.curve.scalarSize)
	      return false;

	    try {
	      return this._verify(msg, sig, key);
	    } catch (e) {
	      return false;
	    }
	  }

	  _verify(msg, sig, key) {
	    // Schnorr Verification.
	    //
	    // [SCHNORR] "Verification".
	    // [CASH] "Signature verification algorithm".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - r^3 + a * r + b is square in F(p).
	    //   - sqrt(r^3 + a * r + b) is square in F(p).
	    //   - r < p, s < n.
	    //   - R != O.
	    //
	    // Computation:
	    //
	    //   R = (r, sqrt(r^3 + a * r + b))
	    //   e = H(r, A, m) mod n
	    //   R == G * s - A * e
	    //
	    // We can skip a square root with:
	    //
	    //   e = H(r, A, m) mod n
	    //   R = G * s - A * e
	    //   y(R) is square
	    //   x(R) == r
	    //
	    // We can also avoid affinization by
	    // replacing the two assertions with:
	    //
	    //   (y(R) * z(R) mod p) is square
	    //   x(R) == r * z(R)^2 mod p
	    //
	    // Furthermore, squareness can be calculated
	    // with a variable time Jacobi symbol algorithm.
	    const {p, n} = this.curve;
	    const G = this.curve.g;
	    const Rraw = sig.slice(0, this.curve.fieldSize);
	    const sraw = sig.slice(this.curve.fieldSize);
	    const r = this.curve.decodeField(Rraw);
	    const s = this.curve.decodeScalar(sraw);
	    const A = this.curve.decodePoint(key);

	    if (r.cmp(p) >= 0 || s.cmp(n) >= 0)
	      return false;

	    const e = this.hashChallenge(Rraw, key, msg);
	    const R = G.jmulAdd(s, A, e.ineg().imod(n));

	    if (!R.isSquare())
	      return false;

	    if (!R.eqX(r))
	      return false;

	    return true;
	  }

	  verifyBatch(batch) {
	    assert(Array.isArray(batch));

	    this.check();

	    for (const item of batch) {
	      assert(Array.isArray(item) && item.length === 3);

	      const [msg, sig, key] = item;

	      assert(Buffer.isBuffer(msg));
	      assert(Buffer.isBuffer(sig));
	      assert(Buffer.isBuffer(key));

	      if (sig.length !== this.curve.fieldSize + this.curve.scalarSize)
	        return false;
	    }

	    try {
	      return this._verifyBatch(batch);
	    } catch (e) {
	      return false;
	    }
	  }

	  _verifyBatch(batch) {
	    // Schnorr Batch Verification.
	    //
	    // [SCHNORR] "Batch Verification".
	    //
	    // Assumptions:
	    //
	    //   - Let `H` be a cryptographic hash function.
	    //   - Let `m` be a 32-byte array.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - Let `i` be the batch item index.
	    //   - r^3 + a * r + b is square in F(p).
	    //   - sqrt(r^3 + a * r + b) is square in F(p).
	    //   - r < p, s < n.
	    //   - a1 = 1 mod n.
	    //
	    // Computation:
	    //
	    //   Ri = (ri, sqrt(ri^3 + a * ri + b))
	    //   ei = H(ri, Ai, mi) mod n
	    //   ai = random integer in [1,n-1]
	    //   lhs = si * ai + ... mod n
	    //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...
	    //   G * -lhs + rhs == O
	    const {n} = this.curve;
	    const G = this.curve.g;
	    const points = new Array(1 + batch.length * 2);
	    const coeffs = new Array(1 + batch.length * 2);
	    const sum = new BN(0);

	    this.rng.init(batch);

	    points[0] = G;
	    coeffs[0] = sum;

	    for (let i = 0; i < batch.length; i++) {
	      const [msg, sig, key] = batch[i];
	      const Rraw = sig.slice(0, this.curve.fieldSize);
	      const sraw = sig.slice(this.curve.fieldSize);
	      const R = this.curve.decodeSquare(Rraw);
	      const s = this.curve.decodeScalar(sraw);
	      const A = this.curve.decodePoint(key);

	      if (s.cmp(n) >= 0)
	        return false;

	      const e = this.hashChallenge(Rraw, key, msg);
	      const a = this.rng.generate(i);
	      const ea = e.mul(a).imod(n);

	      sum.iadd(s.mul(a)).imod(n);

	      points[1 + i * 2 + 0] = R;
	      coeffs[1 + i * 2 + 0] = a;
	      points[1 + i * 2 + 1] = A;
	      coeffs[1 + i * 2 + 1] = ea;
	    }

	    sum.ineg().imod(n);

	    return this.curve.jmulAll(points, coeffs).isInfinity();
	  }
	}

	/*
	 * Expose
	 */

	schnorrLegacy = Schnorr;
	return schnorrLegacy;
}

/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */

var hmacDrbg;
var hasRequiredHmacDrbg;

function requireHmacDrbg () {
	if (hasRequiredHmacDrbg) return hmacDrbg;
	hasRequiredHmacDrbg = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const RESEED_INTERVAL = 0x1000000000000;
	const ZERO = Buffer.from([0x00]);
	const ONE = Buffer.from([0x01]);

	/**
	 * HmacDRBG
	 */

	class HmacDRBG {
	  constructor(hash, entropy, nonce, pers) {
	    assert(hash && typeof hash.id === 'string');

	    this.hash = hash;
	    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;

	    this.K = Buffer.alloc(hash.size);
	    this.V = Buffer.alloc(hash.size);
	    this.rounds = 0;

	    if (entropy)
	      this.init(entropy, nonce, pers);
	  }

	  init(entropy, nonce, pers) {
	    if (nonce == null)
	      nonce = Buffer.alloc(0);

	    if (pers == null)
	      pers = Buffer.alloc(0);

	    assert(Buffer.isBuffer(entropy));
	    assert(Buffer.isBuffer(nonce));
	    assert(Buffer.isBuffer(pers));

	    for (let i = 0; i < this.V.length; i++) {
	      this.K[i] = 0x00;
	      this.V[i] = 0x01;
	    }

	    const seed = Buffer.concat([entropy, nonce, pers]);

	    if (seed.length < this.minEntropy)
	      throw new Error('Not enough entropy.');

	    this.update(seed);
	    this.rounds = 1;

	    return this;
	  }

	  reseed(entropy, add) {
	    if (add == null)
	      add = Buffer.alloc(0);

	    assert(Buffer.isBuffer(entropy));
	    assert(Buffer.isBuffer(add));

	    if (this.rounds === 0)
	      throw new Error('DRBG not initialized.');

	    const seed = Buffer.concat([entropy, add]);

	    if (seed.length < this.minEntropy)
	     throw new Error('Not enough entropy.');

	    this.update(seed);
	    this.rounds = 1;

	    return this;
	  }

	  generate(len, add) {
	    assert((len >>> 0) === len);
	    assert(add == null || Buffer.isBuffer(add));

	    if (this.rounds === 0)
	      throw new Error('DRBG not initialized.');

	    if (this.rounds > RESEED_INTERVAL)
	      throw new Error('Reseed is required.');

	    if (add && add.length > 0)
	      this.update(add);

	    const blocks = Math.ceil(len / this.hash.size);
	    const out = Buffer.alloc(blocks * this.hash.size);

	    for (let i = 0; i < blocks; i++) {
	      this.V = this.mac(this.V);
	      this.V.copy(out, i * this.hash.size);
	    }

	    this.update(add);
	    this.rounds += 1;

	    return out.slice(0, len);
	  }

	  randomBytes(size) {
	    return this.generate(size);
	  }

	  /*
	   * Helpers
	   */

	  mac(data) {
	    return this.hash.mac(data, this.K);
	  }

	  hmac() {
	    return this.hash.hmac().init(this.K);
	  }

	  update(seed) {
	    assert(seed == null || Buffer.isBuffer(seed));

	    const kmac = this.hmac();

	    kmac.update(this.V);
	    kmac.update(ZERO);

	    if (seed)
	      kmac.update(seed);

	    this.K = kmac.final();
	    this.V = this.mac(this.V);

	    if (seed && seed.length > 0) {
	      const kmac = this.hmac();

	      kmac.update(this.V);
	      kmac.update(ONE);
	      kmac.update(seed);

	      this.K = kmac.final();
	      this.V = this.mac(this.V);
	    }

	    return this;
	  }
	}

	/*
	 * Static
	 */

	HmacDRBG.native = 0;

	/*
	 * Expose
	 */

	hmacDrbg = HmacDRBG;
	return hmacDrbg;
}

var elliptic = {};

/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */

var hasRequiredElliptic;

function requireElliptic () {
	if (hasRequiredElliptic) return elliptic;
	hasRequiredElliptic = 1;

	const {custom} = requireCustom();
	const BN = requireBn();

	/*
	 * Constants
	 */

	const types = {
	  AFFINE: 0,
	  JACOBIAN: 1,
	  PROJECTIVE: 2,
	  EXTENDED: 3
	};

	const jsfIndex = [
	  -3, // -1 -1
	  -1, // -1 0
	  -5, // -1 1
	  -7, // 0 -1
	  0, // 0 0
	  7, // 0 1
	  5, // 1 -1
	  1, // 1 0
	  3  // 1 1
	];

	let uid = 0;

	/**
	 * Curve
	 */

	class Curve {
	  constructor(Point, type, conf) {
	    this.Point = null;
	    this.id = null;
	    this.uid = uid++;
	    this.ossl = null;
	    this.type = 'base';
	    this.endian = 'be';
	    this.hash = null;
	    this.prefix = null;
	    this.context = false;
	    this.prime = null;
	    this.p = null;
	    this.red = null;
	    this.fieldSize = 0;
	    this.fieldBits = 0;
	    this.adjustedSize = 0;
	    this.signBit = 0;
	    this.mask = 0;
	    this.n = null;
	    this.h = null;
	    this.q = null;
	    this.z = null;
	    this.g = null;
	    this.nh = null;
	    this.scalarSize = 0;
	    this.scalarBits = 0;
	    this.zero = null;
	    this.one = null;
	    this.two = null;
	    this.three = null;
	    this.four = null;
	    this.i2 = null;
	    this.i3 = null;
	    this.i4 = null;
	    this.i6 = null;
	    this.torsion = null;
	    this.endo = null;
	    this.hi = null;
	    this._init(Point, type, conf);
	  }

	  _init(Point, type, conf) {
	    assert(typeof Point === 'function');
	    assert(typeof type === 'string');
	    assert(conf && typeof conf === 'object');
	    assert(conf.red == null || (conf.red instanceof BN.Red));
	    assert(conf.p != null, 'Must pass a prime.');
	    assert(conf.id == null || typeof conf.id === 'string');
	    assert(conf.ossl == null || typeof conf.ossl === 'string');
	    assert(conf.endian == null || typeof conf.endian === 'string');
	    assert(conf.hash == null || typeof conf.hash === 'string');
	    assert(conf.prefix == null || typeof conf.prefix === 'string');
	    assert(conf.context == null || typeof conf.context === 'boolean');
	    assert(conf.prime == null || typeof conf.prime === 'string');
	    assert(conf.torsion == null || Array.isArray(conf.torsion));

	    // Point class.
	    this.Point = Point;

	    // Meta.
	    this.id = conf.id || null;
	    this.ossl = conf.ossl || null;
	    this.type = type;
	    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');
	    this.hash = conf.hash || null;
	    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;
	    this.context = conf.context || false;
	    this.prime = conf.prime || null;

	    // Prime.
	    this.p = BN.fromJSON(conf.p);

	    // Reduction.
	    if (conf.red) {
	      this.red = conf.red;
	    } else {
	      // Use Montgomery when there is no fast reduction for the prime.
	      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
	      this.red.precompute();
	    }

	    // Precalculate encoding length.
	    this.fieldSize = this.p.byteLength();
	    this.fieldBits = this.p.bitLength();
	    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);
	    this.signBit = this.adjustedSize * 8 - 1;
	    this.mask = 0xff;

	    if ((this.fieldBits & 7) !== 0)
	      this.mask = (1 << (this.fieldBits & 7)) - 1;

	    // Curve configuration, optional.
	    this.n = BN.fromJSON(conf.n || '0');
	    this.h = BN.fromJSON(conf.h || '1');
	    this.q = this.n.mul(this.h);
	    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);
	    this.g = null;
	    this.nh = this.n.ushrn(1);
	    this.scalarSize = this.n.byteLength();
	    this.scalarBits = this.n.bitLength();

	    // Useful for many curves.
	    this.zero = new BN(0).toRed(this.red);
	    this.one = new BN(1).toRed(this.red);
	    this.two = new BN(2).toRed(this.red);
	    this.three = new BN(3).toRed(this.red);
	    this.four = new BN(4).toRed(this.red);

	    // Inverses.
	    this.i2 = this.two.redInvert();
	    this.i3 = this.three.redInvert();
	    this.i4 = this.i2.redSqr();
	    this.i6 = this.i2.redMul(this.i3);

	    // Torsion.
	    this.torsion = new Array(this.h.word(0));

	    for (let i = 0; i < this.torsion.length; i++)
	      this.torsion[i] = this.point();

	    // Endomorphism.
	    this.endo = null;

	    // Cache.
	    this.hi = null;

	    // Memoize.
	    this._scale = memoize(this._scale, this);
	    this.isIsomorphic = memoize(this.isIsomorphic, this);
	    this.isIsogenous = memoize(this.isIsogenous, this);

	    // Sanity checks.
	    assert(this.p.sign() > 0 && this.p.isOdd());
	    assert(this.n.sign() >= 0);
	    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);
	    assert(this.endian === 'be' || this.endian === 'le');

	    return this;
	  }

	  _finalize(conf) {
	    assert(conf && typeof conf === 'object');

	    // Create base point.
	    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();

	    // Parse small order points.
	    if (conf.torsion) {
	      assert(conf.torsion.length === this.torsion.length);

	      for (let i = 0; i < this.torsion.length; i++)
	        this.torsion[i] = this.pointFromJSON(conf.torsion[i]);
	    }

	    return this;
	  }

	  _findTorsion() {
	    // Find all torsion points by grinding.
	    assert(!this.n.isZero());

	    const h = this.h.word(0);
	    const x = this.one.redNeg();
	    const out = [this.point()];
	    const set = new Set();

	    let len = h;

	    while (out.length < len) {
	      let p;

	      x.redIAdd(this.one);

	      try {
	        p = this.pointFromX(x.clone());
	      } catch (e) {
	        continue;
	      }

	      try {
	        p = p.mul(this.n);
	      } catch (e) {
	        len = 2;
	        continue;
	      }

	      if (p.isInfinity())
	        continue;

	      p.normalize();

	      for (const point of [p, p.neg()]) {
	        const key = point.key();

	        if (!set.has(key)) {
	          out.push(point);
	          set.add(key);
	        }
	      }
	    }

	    out.sort((a, b) => a.cmp(b));

	    while (out.length < h)
	      out.push(this.point());

	    return out;
	  }

	  _fixedMul(p, k) {
	    // Fixed-base method for point multiplication.
	    //
	    // [ECPM] "Windowed method".
	    // [GECC] Page 95, Section 3.3.
	    //
	    // Windows are appropriately shifted to avoid any
	    // doublings. This reduces a 256 bit multiplication
	    // down to 64 additions with a window size of 4.
	    assert(p instanceof Point);
	    assert(k instanceof BN);
	    assert(p.pre && p.pre.windows);

	    // Get precomputed windows.
	    const {width, points} = p._getWindows(0, 0);

	    // Recompute window size.
	    const size = 1 << width;

	    // Recompute steps.
	    const bits = k.bitLength();
	    const steps = ((bits + width - 1) / width) >>> 0;

	    // Multiply.
	    let acc = this.jpoint();

	    for (let i = 0; i < steps; i++) {
	      const bits = k.bits(i * width, width);

	      acc = acc.add(points[i * size + bits]);
	    }

	    // Adjust sign.
	    if (k.isNeg())
	      acc = acc.neg();

	    return acc;
	  }

	  _fixedNafMul(p, k) {
	    // Fixed-base NAF windowing method for point multiplication.
	    //
	    // [GECC] Algorithm 3.42, Page 105, Section 3.3.
	    assert(p instanceof Point);
	    assert(k instanceof BN);
	    assert(p.pre && p.pre.doubles);

	    // Get precomputed doubles.
	    const {step, points} = p._getDoubles(0, 0);

	    // Get fixed NAF (in a more windowed form).
	    const naf = getFixedNAF(k, 2, k.bitLength() + 1, step);

	    // Compute steps.
	    const I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3;

	    // Multiply.
	    let a = this.jpoint();
	    let b = this.jpoint();

	    for (let i = I; i > 0; i--) {
	      for (let j = 0; j < naf.length; j++) {
	        const nafW = naf[j];

	        if (nafW === i)
	          b = b.add(points[j]);
	        else if (nafW === -i)
	          b = b.sub(points[j]);
	      }

	      a = a.add(b);
	    }

	    return a;
	  }

	  _wnafMul(w, p, k) {
	    // Window NAF method for point multiplication.
	    //
	    // [GECC] Algorithm 3.36, Page 100, Section 3.3.
	    assert(p instanceof Point);
	    assert(k instanceof BN);

	    // Precompute window.
	    const {width, points} = p._safeNAF(w);

	    // Get NAF form.
	    const naf = getNAF(k, width, k.bitLength() + 1);

	    // Add `this`*(N+1) for every w-NAF index.
	    let acc = this.jpoint();

	    for (let i = naf.length - 1; i >= 0; i--) {
	      const z = naf[i];

	      if (i !== naf.length - 1)
	        acc = acc.dbl();

	      if (z > 0)
	        acc = acc.add(points[(z - 1) >> 1]);
	      else if (z < 0)
	        acc = acc.sub(points[(-z - 1) >> 1]);
	    }

	    return acc;
	  }

	  _wnafMulAdd(w, points, coeffs) {
	    // Multiple point multiplication, also known
	    // as "Shamir's trick" (with interleaved NAFs).
	    //
	    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.
	    //        Algorithm 3.51, Page 112, Section 3.3.
	    //
	    // This is particularly useful for signature
	    // verifications and mutiplications after an
	    // endomorphism split.
	    assert((w >>> 0) === w);
	    assert(Array.isArray(points));
	    assert(Array.isArray(coeffs));
	    assert(points.length === coeffs.length);

	    const length = points.length;
	    const wnd = new Array(length);
	    const naf = new Array(length);

	    // Check arrays and calculate size.
	    let max = 0;

	    for (let i = 0; i < length; i++) {
	      const point = points[i];
	      const coeff = coeffs[i];

	      assert(point instanceof Point);
	      assert(coeff instanceof BN);

	      if (i > 0 && point.type !== points[i - 1].type)
	        throw new Error('Cannot mix points.');

	      // Avoid sparse arrays.
	      wnd[i] = null;
	      naf[i] = null;

	      // Compute max scalar size.
	      max = Math.max(max, coeff.bitLength() + 1);
	    }

	    // Compute NAFs.
	    let ppoint = null;
	    let pcoeff = null;
	    let len = 0;

	    for (let i = 0; i < length; i++) {
	      const point = points[i];
	      const coeff = coeffs[i];
	      const pre = point._getNAF(0);

	      // Use precomputation if available.
	      if (pre) {
	        wnd[len] = pre.points;
	        naf[len] = getNAF(coeff, pre.width, max);
	        len += 1;
	        continue;
	      }

	      // Save last non-precomputed point.
	      if (!ppoint) {
	        ppoint = point;
	        pcoeff = coeff;
	        continue;
	      }

	      // Compute JSF in NAF form.
	      wnd[len] = ppoint._getJNAF(point);
	      naf[len] = getJNAF(pcoeff, coeff, max);

	      ppoint = null;
	      pcoeff = null;

	      len += 1;
	    }

	    // Regular NAF for odd points.
	    if (ppoint) {
	      const nafw = ppoint._safeNAF(w);

	      wnd[len] = nafw.points;
	      naf[len] = getNAF(pcoeff, nafw.width, max);

	      len += 1;
	    }

	    // Multiply and add.
	    let acc = this.jpoint();

	    for (let i = max - 1; i >= 0; i--) {
	      if (i !== max - 1)
	        acc = acc.dbl();

	      for (let j = 0; j < len; j++) {
	        const z = naf[j][i];

	        if (z > 0)
	          acc = acc.add(wnd[j][(z - 1) >> 1]);
	        else if (z < 0)
	          acc = acc.sub(wnd[j][(-z - 1) >> 1]);
	      }
	    }

	    return acc;
	  }

	  _endoWnafMulAdd(points, coeffs) {
	    throw new Error('Not implemented.');
	  }

	  _scale(curve, invert) {
	    assert(curve instanceof Curve);
	    assert(curve.p.eq(this.p));

	    switch (curve.type) {
	      case 'short':
	        return this._scaleShort(curve, invert);
	      case 'mont':
	        return this._scaleMont(curve, invert);
	      case 'edwards':
	        return this._scaleEdwards(curve, invert);
	      default:
	        throw new Error('Not implemented.');
	    }
	  }

	  _scaleShort(curve, invert) {
	    throw new Error('Not implemented.');
	  }

	  _scaleMont(curve, invert) {
	    throw new Error('Not implemented.');
	  }

	  _scaleEdwards(curve, invert) {
	    throw new Error('Not implemented.');
	  }

	  isElliptic() {
	    throw new Error('Not implemented.');
	  }

	  jinv() {
	    throw new Error('Not implemented.');
	  }

	  isComplete() {
	    return false;
	  }

	  precompute(rng) {
	    assert(!this.g.isInfinity(), 'Must have base point.');
	    assert(!this.n.isZero(), 'Must have order.');

	    this.g.precompute(this.n.bitLength(), rng);

	    return this;
	  }

	  scalar(num, base, endian) {
	    const k = new BN(num, base, endian);

	    assert(!k.red);

	    if (this.n.isZero())
	      return k;

	    return k.imod(this.n);
	  }

	  field(num, base, endian) {
	    const x = BN.cast(num, base, endian);

	    if (x.red)
	      return x.forceRed(this.red);

	    return x.toRed(this.red);
	  }

	  point(x, y) {
	    throw new Error('Not implemented.');
	  }

	  jpoint(x, y, z) {
	    throw new Error('Not implemented.');
	  }

	  xpoint(x, z) {
	    throw new Error('Not implemented.');
	  }

	  cpoint(xx, xz, yy, yz) {
	    assert(xx instanceof BN);
	    assert(xz instanceof BN);
	    assert(yy instanceof BN);
	    assert(yz instanceof BN);

	    if (xz.isZero() || yz.isZero())
	      return this.point();

	    const z = xz.redMul(yz).redInvert();
	    const x = xx.redMul(yz).redMul(z);
	    const y = yy.redMul(xz).redMul(z);

	    return this.point(x, y);
	  }

	  solveX2(y) {
	    throw new Error('Not implemented.');
	  }

	  solveX(y) {
	    return this.solveX2(y).redSqrt();
	  }

	  solveY2(x) {
	    throw new Error('Not implemented.');
	  }

	  solveY(x) {
	    return this.solveY2(x).redSqrt();
	  }

	  validate(point) {
	    throw new Error('Not implemented.');
	  }

	  pointFromX(x, sign) {
	    throw new Error('Not implemented.');
	  }

	  pointFromY(y, sign) {
	    throw new Error('Not implemented.');
	  }

	  isIsomorphic(curve) {
	    throw new Error('Not implemented.');
	  }

	  isIsogenous(curve) {
	    throw new Error('Not implemented.');
	  }

	  pointFromShort(point) {
	    throw new Error('Not implemented.');
	  }

	  pointFromMont(point, sign) {
	    throw new Error('Not implemented.');
	  }

	  pointFromEdwards(point) {
	    throw new Error('Not implemented.');
	  }

	  pointFromUniform(u) {
	    throw new Error('Not implemented.');
	  }

	  pointToUniform(p) {
	    throw new Error('Not implemented.');
	  }

	  pointFromHash(bytes, pake = false) {
	    // [H2EC] "Roadmap".
	    assert(Buffer.isBuffer(bytes));
	    assert(typeof pake === 'boolean');

	    if (bytes.length !== this.fieldSize * 2)
	      throw new Error('Invalid hash size.');

	    // Random oracle encoding.
	    // Ensure a proper distribution.
	    const s1 = bytes.slice(0, this.fieldSize);
	    const s2 = bytes.slice(this.fieldSize);
	    const u1 = this.decodeUniform(s1);
	    const u2 = this.decodeUniform(s2);
	    const p1 = this.pointFromUniform(u1);
	    const p2 = this.pointFromUniform(u2);
	    const p3 = p1.add(p2);

	    return pake ? p3.mulH() : p3;
	  }

	  pointToHash(p, subgroup, rng) {
	    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
	    assert(p instanceof this.Point);
	    assert((subgroup >>> 0) === subgroup);

	    // Add a random torsion component.
	    const i = subgroup % this.torsion.length;
	    const p0 = p.add(this.torsion[i]);

	    // Average Cost (R = sqrt):
	    //
	    //   SSWU (~4 iterations) => 8I + 16R
	    //   SVDW (~4 iterations) => 12I + 28R
	    //   Elligator 1 (~2 iterations) => 6I + 10R
	    //   Elligator 2 (~2 iterations) => 4I + 6R
	    //   Ristretto (~1 iteration) => 1I + 2R + h*1R
	    for (;;) {
	      const u1 = this.randomField(rng);
	      const p1 = this.pointFromUniform(u1);

	      // Avoid 2-torsion points:
	      //   Short Weierstrass: ((A / 3) / B, 0)
	      //   Montgomery: (0, 0)
	      //   Twisted Edwards: (0, -1)
	      if (p1.neg().eq(p1))
	        continue;

	      const p2 = p0.sub(p1);
	      const hint = randomInt(rng);

	      let u2;
	      try {
	        u2 = this.pointToUniform(p2, hint & 15);
	      } catch (e) {
	        if (e.message === 'Invalid point.')
	          continue;
	        throw e;
	      }

	      const s1 = this.encodeUniform(u1, hint >>> 8);
	      const s2 = this.encodeUniform(u2, hint >>> 16);

	      return Buffer.concat([s1, s2]);
	    }
	  }

	  randomScalar(rng) {
	    const max = this.n.isZero() ? this.p : this.n;
	    return BN.random(rng, 1, max);
	  }

	  randomField(rng) {
	    return BN.random(rng, 1, this.p).toRed(this.red);
	  }

	  randomPoint(rng) {
	    let p;

	    for (;;) {
	      const x = this.randomField(rng);
	      const sign = (randomInt(rng) & 1) !== 0;

	      try {
	        p = this.pointFromX(x, sign);
	      } catch (e) {
	        continue;
	      }

	      assert(p.validate());

	      return p.mulH();
	    }
	  }

	  mulAll(points, coeffs) {
	    return this.jmulAll(points, coeffs);
	  }

	  jmulAll(points, coeffs) {
	    assert(Array.isArray(points));
	    assert(points.length === 0 || (points[0] instanceof Point));

	    // Multiply with endomorphism if we're using affine points.
	    if (this.endo && points.length > 0 && points[0].type === types.AFFINE)
	      return this._endoWnafMulAdd(points, coeffs);

	    // Otherwise, a regular Shamir's trick.
	    return this._wnafMulAdd(5, points, coeffs);
	  }

	  mulH(k) {
	    assert(k instanceof BN);
	    return this.imulH(k.clone());
	  }

	  imulH(k) {
	    assert(k instanceof BN);
	    assert(!k.red);

	    const word = this.h.word(0);

	    // Optimize for powers of two.
	    if ((word & (word - 1)) === 0) {
	      const bits = this.h.bitLength();
	      return k.iushln(bits - 1).imod(this.n);
	    }

	    return k.imuln(word).imod(this.n);
	  }

	  normalizeAll(points) {
	    assert(Array.isArray(points));

	    const len = points.length;
	    const z = new Array(len);

	    for (let i = 0; i < len; i++) {
	      const p = points[i];

	      assert(p instanceof Point);
	      assert(p.curve === this);

	      if (p.type === types.AFFINE) {
	        z[i] = this.one;
	        continue;
	      }

	      z[i] = p.z;
	    }

	    const zi = this.red.invertAll(z);
	    const out = new Array(len);

	    for (let i = 0; i < len; i++)
	      out[i] = points[i].scale(zi[i]);

	    return out;
	  }

	  affinizeAll(points) {
	    return this.normalizeAll(points);
	  }

	  clamp(scalar) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    assert(Buffer.isBuffer(scalar));
	    assert(scalar.length === this.scalarSize);
	    assert(this.scalarSize <= this.fieldSize);

	    let top = (this.fieldBits & 7) || 8;
	    let lsb = 0;
	    let msb = this.scalarSize - 1;

	    // Swap endianness.
	    if (this.endian === 'be')
	      [lsb, msb] = [msb, lsb];

	    // Adjust for low order.
	    if (this.scalarSize < this.fieldSize)
	      top = 8;

	    // Ensure a multiple of the cofactor.
	    scalar[lsb] &= -this.h.word(0) & 0xff;

	    // Clamp to the prime.
	    scalar[msb] &= (1 << top) - 1;

	    // Set the high bit.
	    scalar[msb] |= 1 << (top - 1);

	    return scalar;
	  }

	  splitHash(bytes) {
	    // [RFC8032] Section 5.1.6 & 5.2.6.
	    assert(Buffer.isBuffer(bytes));
	    assert(bytes.length === this.adjustedSize * 2);
	    assert(this.scalarSize <= this.adjustedSize);

	    let off = 0;

	    if (this.endian === 'be')
	      off = this.adjustedSize - this.scalarSize;

	    const scalar = bytes.slice(off, off + this.scalarSize);
	    const prefix = bytes.slice(this.adjustedSize);

	    this.clamp(scalar);

	    return [scalar, prefix];
	  }

	  encodeField(x) {
	    // [SEC1] Page 12, Section 2.3.5.
	    assert(x instanceof BN);
	    assert(!x.red);

	    return x.encode(this.endian, this.fieldSize);
	  }

	  decodeField(bytes) {
	    // [SEC1] Page 13, Section 2.3.6.
	    assert(Buffer.isBuffer(bytes));

	    if (bytes.length !== this.fieldSize)
	      throw new Error('Invalid field element size.');

	    return BN.decode(bytes, this.endian);
	  }

	  encodeAdjusted(x) {
	    assert(x instanceof BN);
	    assert(!x.red);

	    return x.encode(this.endian, this.adjustedSize);
	  }

	  decodeAdjusted(bytes) {
	    assert(Buffer.isBuffer(bytes));

	    if (bytes.length !== this.adjustedSize)
	      throw new Error('Invalid field element size.');

	    return BN.decode(bytes, this.endian);
	  }

	  encodeScalar(k) {
	    // [SEC1] Page 13, Section 2.3.7.
	    assert(k instanceof BN);
	    assert(!k.red);

	    return k.encode(this.endian, this.scalarSize);
	  }

	  decodeScalar(bytes) {
	    // [SEC1] Page 14, Section 2.3.8.
	    assert(Buffer.isBuffer(bytes));

	    if (bytes.length !== this.scalarSize)
	      throw new Error('Invalid scalar size.');

	    return BN.decode(bytes, this.endian);
	  }

	  encodeClamped(k) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    return this.clamp(this.encodeScalar(k));
	  }

	  decodeClamped(bytes) {
	    // [RFC7748] Page 8, Section 5.
	    // [RFC8032] Section 5.1.5 & 5.2.5.
	    assert(Buffer.isBuffer(bytes));

	    if (bytes.length !== this.scalarSize)
	      throw new Error('Invalid scalar size.');

	    const clamped = this.clamp(Buffer.from(bytes));

	    return BN.decode(clamped, this.endian);
	  }

	  encodeUniform(x, bits) {
	    assert(x instanceof BN);
	    assert((bits >>> 0) === bits);

	    const msb = this.endian === 'le' ? this.fieldSize - 1 : 0;
	    const bytes = x.fromRed().encode(this.endian, this.fieldSize);

	    bytes[msb] |= (bits & ~this.mask) & 0xff;

	    return bytes;
	  }

	  decodeUniform(bytes) {
	    assert(Buffer.isBuffer(bytes));

	    if (bytes.length !== this.fieldSize)
	      throw new Error('Invalid field size.');

	    const x = BN.decode(bytes, this.endian);

	    x.iumaskn(this.fieldBits);

	    return x.toRed(this.red);
	  }

	  encodePoint(point, compact) {
	    assert(point instanceof Point);
	    return point.encode(compact);
	  }

	  decodePoint(bytes) {
	    throw new Error('Not implemented.');
	  }

	  encodeX(point) {
	    throw new Error('Not implemented.');
	  }

	  decodeX(bytes) {
	    throw new Error('Not implemented.');
	  }

	  decodeEven(bytes) {
	    throw new Error('Not implemented.');
	  }

	  decodeSquare(bytes) {
	    throw new Error('Not implemented.');
	  }

	  toShort() {
	    throw new Error('Not implemented.');
	  }

	  toMont(b0) {
	    throw new Error('Not implemented.');
	  }

	  toEdwards(a0) {
	    throw new Error('Not implemented.');
	  }

	  pointToJSON(point, pre) {
	    assert(point instanceof Point);
	    return point.toJSON(pre);
	  }

	  pointFromJSON(json) {
	    throw new Error('Not implemented.');
	  }

	  toJSON(pre) {
	    let prefix, context;
	    let n, z, endo;

	    if (this.type === 'edwards') {
	      prefix = this.prefix ? this.prefix.toString() : null;
	      context = this.context;
	    }

	    if (!this.n.isZero())
	      n = this.n.toJSON();

	    if (!this.z.isZero()) {
	      z = this.z.fromRed();

	      if (this.z.redIsHigh())
	        z.isub(this.p);

	      z = z.toString(16);
	    }

	    if (this.endo)
	      endo = this.endo.toJSON();

	    return {
	      id: this.id,
	      ossl: this.ossl,
	      type: this.type,
	      endian: this.endian,
	      hash: this.hash,
	      prefix,
	      context,
	      prime: this.prime,
	      p: this.p.toJSON(),
	      a: undefined,
	      b: undefined,
	      d: undefined,
	      n,
	      h: this.h.toString(16),
	      s: undefined,
	      z,
	      c: undefined,
	      g: this.g.toJSON(pre),
	      endo
	    };
	  }

	  static fromJSON(json) {
	    return new this(json);
	  }
	}

	/**
	 * Point
	 */

	class Point {
	  constructor(curve, type) {
	    assert(curve instanceof Curve);
	    assert((type >>> 0) === type);

	    this.curve = curve;
	    this.type = type;
	    this.pre = null;
	  }

	  _init() {
	    throw new Error('Not implemented.');
	  }

	  _safeNAF(width) {
	    assert((width >>> 0) === width);

	    if (this.pre && this.pre.naf)
	      return this.pre.naf;

	    if (width === 0)
	      return null;

	    const size = 1 << (width - 2);
	    const points = new Array(size);
	    const p = this.toJ();
	    const dbl = size === 1 ? null : p.dbl();

	    points[0] = p;

	    for (let i = 1; i < size; i++)
	      points[i] = points[i - 1].add(dbl);

	    return new NAF(width, points);
	  }

	  _getNAF(width) {
	    assert((width >>> 0) === width);

	    if (this.pre && this.pre.naf)
	      return this.pre.naf;

	    if (width === 0)
	      return null;

	    const odds = this._safeNAF(width).points;
	    const points = this.curve.affinizeAll(odds);

	    return new NAF(width, points);
	  }

	  _getWindows(width, bits) {
	    assert((width >>> 0) === width);
	    assert((bits >>> 0) === bits);

	    if (this.pre && this.pre.windows)
	      return this.pre.windows;

	    if (width === 0)
	      return null;

	    const size = 1 << width;
	    const steps = ((bits + width - 1) / width) >>> 0;
	    const wnds = new Array(steps * size);

	    let g = this.toJ();

	    for (let i = 0; i < steps; i++) {
	      wnds[i * size] = this.curve.jpoint();

	      for (let j = 1; j < size; j++)
	        wnds[i * size + j] = wnds[i * size + j - 1].add(g);

	      g = g.dblp(width);
	    }

	    const points = this.curve.affinizeAll(wnds);

	    return new Windows(width, bits, points);
	  }

	  _getDoubles(step, power) {
	    assert((step >>> 0) === step);
	    assert((power >>> 0) === power);

	    if (this.pre && this.pre.doubles)
	      return this.pre.doubles;

	    if (step === 0)
	      return null;

	    const len = Math.ceil(power / step) + 1;
	    const dbls = new Array(len);

	    let acc = this.toJ();
	    let k = 0;

	    dbls[k++] = acc;

	    for (let i = 0; i < power; i += step) {
	      for (let j = 0; j < step; j++)
	        acc = acc.dbl();

	      dbls[k++] = acc;
	    }

	    assert(k === len);

	    const points = this.curve.affinizeAll(dbls);

	    return new Doubles(step, points);
	  }

	  _getBeta() {
	    return null;
	  }

	  _getBlinding(rng) {
	    if (this.pre && this.pre.blinding)
	      return this.pre.blinding;

	    if (!rng)
	      return null;

	    if (this.curve.n.isZero())
	      return null;

	    // Pregenerate a random blinding value:
	    //
	    //   blind = random integer in [1,n-1]
	    //   unblind = G * blind
	    //
	    // We intend to subtract the blinding value
	    // from scalars before multiplication. We
	    // can add the unblinding point once the
	    // multiplication is complete.
	    const blind = this.curve.randomScalar(rng);
	    const unblind = this.mul(blind);

	    return new Blinding(blind, unblind);
	  }

	  _hasWindows(k) {
	    assert(k instanceof BN);

	    if (!this.pre || !this.pre.windows)
	      return false;

	    const {width, bits} = this.pre.windows;
	    const steps = ((bits + width - 1) / width) >>> 0;

	    return k.bitLength() <= steps * width;
	  }

	  _hasDoubles(k) {
	    assert(k instanceof BN);

	    if (!this.pre || !this.pre.doubles)
	      return false;

	    const {step, points} = this.pre.doubles;
	    const power = k.bitLength() + 1;

	    return points.length >= Math.ceil(power / step) + 1;
	  }

	  _getJNAF(point) {
	    assert(point instanceof Point);
	    assert(point.type === this.type);

	    // Create comb for JSF.
	    return [
	      this, // 1
	      this.add(point), // 3
	      this.sub(point), // 5
	      point // 7
	    ];
	  }

	  _blind(k, rng) {
	    // [SIDE1] Page 5, Section 4.
	    // [BLIND] Page 20, Section 7.
	    assert(k instanceof BN);
	    assert(!k.red);

	    // Scalar splitting (requires precomputation).
	    //
	    // Blind a multiplication by first subtracting
	    // a blinding value from the scalar. Example:
	    //
	    //   b = random integer in [1,n-1]
	    //   B = P * b (precomputed)
	    //   Q = P * (k - b) + B
	    //
	    // Note that Joye describes a different method
	    // (multiplier randomization) which computes:
	    //
	    //   B = random point in E
	    //   Q = (P + B) * k - B * k
	    //
	    // Our method is more similar to the "scalar
	    // splitting" technique described in the
	    // second source above.
	    //
	    // The blinding value and its corresponding
	    // point are randomly generated and computed
	    // on boot. As long as an attacker is not
	    // able to observe the boot, this should give
	    // a decent bit of protection against various
	    // channel attacks.
	    if (this.pre && this.pre.blinding) {
	      const {blind, unblind} = this.pre.blinding;
	      const t = k.sub(blind);

	      return [this, t, unblind];
	    }

	    // Randomization is not possible without
	    // an RNG. Do a normal multiplication.
	    if (!rng)
	      return [this, k, null];

	    // If we have no precomputed blinding
	    // factor, there are two possibilities
	    // for randomization:
	    //
	    // 1. Randomize the multiplier by adding
	    //    a random multiple of `n`.
	    //
	    // 2. Re-scale the point itself by a
	    //    random factor.
	    //
	    // The first option can be accomplished
	    // with some like:
	    //
	    //   a = random integer in [1,n-1]
	    //   r = a * n
	    //   Q = P * (k + r)
	    //
	    // The second is accomplished with:
	    //
	    //   a = random element in F(p)
	    //   R = (x * a^2, y * a^3, z * a)
	    //   Q = R * k
	    //
	    // If we have precomputed doubles / naf
	    // points, we opt for the first method
	    // to avoid randomizing everything.
	    if (this.pre) {
	      if (this.curve.n.isZero())
	        return [this, k, null];

	      const a = this.curve.randomScalar(rng);
	      const r = a.mul(this.curve.n);
	      const t = r.iadd(k);

	      return [this, t, null];
	    }

	    // If there is no precomputation _at all_,
	    // we opt for the second method.
	    const p = this.randomize(rng);

	    return [p, k, null];
	  }

	  clone() {
	    throw new Error('Not implemented.');
	  }

	  precompute(bits, rng) {
	    assert((bits >>> 0) === bits);

	    if (!this.pre)
	      this.pre = new Precomp();

	    if (!this.pre.naf)
	      this.pre.naf = this._getNAF(9);

	    if (!this.pre.doubles)
	      this.pre.doubles = this._getDoubles(4, bits + 1);

	    if (!this.pre.beta)
	      this.pre.beta = this._getBeta();

	    if (!this.pre.blinding)
	      this.pre.blinding = this._getBlinding(rng);

	    return this;
	  }

	  validate() {
	    return this.curve.validate(this);
	  }

	  normalize() {
	    return this;
	  }

	  scale(a) {
	    throw new Error('Not implemented.');
	  }

	  randomize(rng) {
	    const z = this.curve.randomField(rng);
	    return this.scale(z);
	  }

	  neg() {
	    throw new Error('Not implemented.');
	  }

	  add(point) {
	    throw new Error('Not implemented.');
	  }

	  sub(point) {
	    assert(point instanceof Point);
	    return this.add(point.neg());
	  }

	  dbl() {
	    throw new Error('Not implemented.');
	  }

	  dblp(pow) {
	    // Repeated doubling. This can
	    // be optimized by child classes.
	    assert((pow >>> 0) === pow);

	    let r = this;

	    for (let i = 0; i < pow; i++)
	      r = r.dbl();

	    return r;
	  }

	  diffAddDbl(p, q) {
	    throw new Error('Not implemented.');
	  }

	  getX() {
	    throw new Error('Not implemented.');
	  }

	  getY() {
	    throw new Error('Not implemented.');
	  }

	  eq(point) {
	    throw new Error('Not implemented.');
	  }

	  cmp(point) {
	    throw new Error('Not implemented.');
	  }

	  isInfinity() {
	    throw new Error('Not implemented.');
	  }

	  isOrder2() {
	    throw new Error('Not implemented.');
	  }

	  isOdd() {
	    throw new Error('Not implemented.');
	  }

	  isEven() {
	    throw new Error('Not implemented.');
	  }

	  isSquare() {
	    throw new Error('Not implemented.');
	  }

	  eqX(x) {
	    throw new Error('Not implemented.');
	  }

	  eqR(x) {
	    throw new Error('Not implemented.');
	  }

	  isSmall() {
	    // Test whether the point is of small order.
	    if (this.isInfinity())
	      return false;

	    // P * h = O
	    return this.jmulH().isInfinity();
	  }

	  hasTorsion() {
	    // Test whether the point is in another subgroup.
	    if (this.isInfinity())
	      return false;

	    // P * n != O
	    return !this.jmul(this.curve.n).isInfinity();
	  }

	  order() {
	    // Calculate point order.
	    const {h, n} = this.curve;

	    let p = this.toJ();
	    let q = new BN(1);

	    while (!p.isInfinity()) {
	      q.iaddn(1);

	      if (q.cmp(h) > 0) {
	        q = n.clone();
	        break;
	      }

	      p = p.add(this);
	    }

	    return q;
	  }

	  mul(k) {
	    return this.jmul(k);
	  }

	  muln(k) {
	    return this.jmuln(k);
	  }

	  mulBlind(k, rng) {
	    return this.jmulBlind(k, rng);
	  }

	  mulAdd(k1, p2, k2) {
	    return this.jmulAdd(k1, p2, k2);
	  }

	  mulH() {
	    return this.jmulH();
	  }

	  div(k) {
	    return this.jdiv(k);
	  }

	  divn(k) {
	    return this.jdivn(k);
	  }

	  divH() {
	    return this.jdivH();
	  }

	  jmul(k) {

	    if (this._hasDoubles(k))
	      return this.curve._fixedNafMul(this, k);

	    if (this.curve.endo && this.type === types.AFFINE)
	      return this.curve._endoWnafMulAdd([this], [k]);

	    return this.curve._wnafMul(5, this, k);
	  }

	  jmuln(k) {
	    assert((k | 0) === k);
	    return this.jmul(new BN(k));
	  }

	  jmulBlind(k, rng = null) {
	    const [p, t, unblind] = this._blind(k, rng);
	    const q = p.jmul(t);

	    if (unblind)
	      return q.add(unblind);

	    return q;
	  }

	  jmulAdd(k1, p2, k2) {
	    if (this.curve.endo && this.type === types.AFFINE)
	      return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);

	    return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);
	  }

	  jmulH() {
	    const word = this.curve.h.word(0);

	    // Optimize for powers of two.
	    if ((word & (word - 1)) === 0) {
	      const bits = this.curve.h.bitLength();
	      return this.toJ().dblp(bits - 1);
	    }

	    return this.jmul(this.curve.h);
	  }

	  jdiv(k) {
	    assert(k instanceof BN);
	    assert(!k.red);

	    return this.jmul(k.invert(this.curve.n));
	  }

	  jdivn(k) {
	    assert(!this.curve.n.isZero());

	    if (this.curve.h.cmpn(k) === 0)
	      return this.jdivH();

	    return this.jdiv(new BN(k));
	  }

	  jdivH() {
	    if (this.curve.n.isZero())
	      return this.toJ();

	    if (this.curve.h.cmpn(1) === 0)
	      return this.toJ();

	    if (this.curve.hi === null)
	      this.curve.hi = this.curve.h.invert(this.curve.n);

	    return this.jmul(this.curve.hi);
	  }

	  toP() {
	    return this.normalize();
	  }

	  toJ() {
	    return this;
	  }

	  toX() {
	    return this;
	  }

	  key() {
	    if (this.isInfinity())
	      return `${this.curve.uid}:oo`;

	    this.normalize();

	    const x = this.getX().toString(16);
	    const y = this.getY().toString(16);

	    return `${this.curve.uid}:${x},${y}`;
	  }

	  encode(compact) {
	    throw new Error('Not implemented.');
	  }

	  static decode(curve, bytes) {
	    throw new Error('Not implemented.');
	  }

	  encodeX() {
	    throw new Error('Not implemented.');
	  }

	  static decodeX(curve, bytes) {
	    throw new Error('Not implemented.');
	  }

	  static decodeEven(curve, bytes) {
	    throw new Error('Not implemented.');
	  }

	  static decodeSquare(curve, bytes) {
	    throw new Error('Not implemented.');
	  }

	  toJSON(pre) {
	    throw new Error('Not implemented.');
	  }

	  static fromJSON(curve, json) {
	    throw new Error('Not implemented.');
	  }

	  [custom]() {
	    return '<Point>';
	  }
	}

	/**
	 * ShortCurve
	 */

	class ShortCurve extends Curve {
	  constructor(conf) {
	    super(ShortPoint, 'short', conf);

	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.b = BN.fromJSON(conf.b).toRed(this.red);
	    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);
	    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();
	    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();

	    this.zeroA = this.a.isZero();
	    this.threeA = this.a.eq(this.three.redNeg());
	    this.redN = this.n.toRed(this.red);
	    this.pmodn = this.p.clone();
	    this.highOrder = this.n.cmp(this.p) >= 0;
	    this.smallGap = false;

	    this._finalize(conf);
	  }

	  _finalize(conf) {
	    super._finalize(conf);

	    // Precalculate endomorphism.
	    if (conf.endo != null)
	      this.endo = Endo.fromJSON(this, conf.endo);
	    else
	      this.endo = this._getEndomorphism();

	    if (!this.n.isZero()) {
	      this.pmodn = this.p.mod(this.n);

	      // Check for Maxwell's trick (see eqR).
	      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;
	    }

	    return this;
	  }

	  static _isomorphism(curveA, curveB, custom, odd) {
	    // Short Weierstrass Isomorphism.
	    //
	    // [GECC] Page 84, Section 3.1.5.
	    // [ARITH1] Page 274, Section 13.1.5.
	    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
	    //
	    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.
	    //
	    // Transformation:
	    //
	    //   u4 = a' / a
	    //   u2 = +-sqrt(u4)
	    //   u6 = u4 * u2
	    //   a' = a * u4
	    //   b' = b * u6
	    //
	    // Where `u2` is any root that is square.
	    //
	    // If a = 0, we can do:
	    //
	    //   a' = 0
	    //   b' = b'
	    //
	    // Where (b' / b)^(1 / 3) is square.
	    //
	    // If b = 0, we can do:
	    //
	    //   a' = a'
	    //   b' = 0
	    //
	    // Where sqrt(a' / a) is square.
	    assert(curveA instanceof BN);
	    assert(curveB instanceof BN);
	    assert(custom instanceof BN);
	    assert(odd == null || typeof odd === 'boolean');
	    assert(!curveA.isZero() || !curveB.isZero());

	    if (custom.isZero())
	      throw new Error('Invalid coefficient.');

	    if (curveA.isZero()) {
	      const customB = custom;
	      const u6 = customB.redDiv(curveB);
	      // Todo: allow index flag.
	      const u2 = uncube(u6);

	      // Already checked in uncube().
	      assert(u2.redJacobi() === 1);

	      return [curveA.clone(), customB.clone()];
	    }

	    if (curveB.isZero()) {
	      const customA = custom;
	      const u4 = customA.redDiv(curveA);
	      const u2 = u4.redSqrt();

	      // Todo: allow odd flag.
	      if (u2.redJacobi() !== 1)
	        u2.redINeg();

	      if (u2.redJacobi() !== 1)
	        throw new Error('Invalid `a` coefficient.');

	      return [customA.clone(), curveB.clone()];
	    }

	    const customA = custom;
	    const u4 = customA.redDiv(curveA);
	    const u2 = u4.redSqrt();

	    if (odd != null) {
	      if (u2.redIsOdd() !== odd)
	        u2.redINeg();
	    } else {
	      if (u2.redJacobi() !== 1)
	        u2.redINeg();
	    }

	    if (u2.redJacobi() !== 1)
	      throw new Error('Invalid `a` coefficient.');

	    const u6 = u4.redMul(u2);
	    const a = curveA.redMul(u4);
	    const b = curveB.redMul(u6);

	    assert(a.eq(customA));

	    return [a, b];
	  }

	  _short(a0, odd) {
	    return ShortCurve._isomorphism(this.a, this.b, a0, odd);
	  }

	  _mont(b0, odd) {
	    // Short Weierstrass->Montgomery Equivalence.
	    //
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    // [SAFE] "Ladders".
	    //
	    // Transformation:
	    //
	    //   r = A / (3 * B)
	    //   s = +-sqrt(3 * r^2 + a)
	    //   A = 3 * r / s
	    //   B = 1 / s
	    const [r, s] = this._findRS(odd);
	    const b = s.redInvert();
	    const a = r.redMuln(3).redMul(b);

	    if (b0 != null)
	      return MontCurve._isomorphism(a, b, b0);

	    return [a, b];
	  }

	  _edwards(a0, odd) {
	    // Short Weierstrass->Twisted Edwards Equivalence.
	    //
	    // [TWISTEQ] Section 1.
	    //
	    // Transformation:
	    //
	    //   r = (a' + d') / 6
	    //   s = +-sqrt(3 * r^2 + a)
	    //   a' = 3 * r + 2 * s
	    //   d' = 3 * r - 2 * s
	    const [r, s] = this._findRS(odd);
	    const r3 = r.redMuln(3);
	    const s2 = s.redMuln(2);
	    const a = r3.redAdd(s2);
	    const d = r3.redSub(s2);

	    if (a0 != null)
	      return EdwardsCurve._isomorphism(a, d, a0);

	    return [a, d];
	  }

	  _findRS(sign) {
	    // Find `r` and `s` for equivalence.
	    //
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    // [SAFE] "Ladders".
	    //
	    // Computation:
	    //
	    //   r = solve(r^3 + a * r + b == 0, r)
	    //   s = +-sqrt(3 * r^2 + a)
	    //
	    // Computing `r` is non-trivial. We need
	    // to solve `r^3 + a * r + b = 0`, but we
	    // don't have a polynomial solver, so we
	    // loop over random points until we find
	    // one with 2-torsion. Multiplying by the
	    // subgroup order should yield a point of
	    // ((A / 3) / B, 0) which is a solution.
	    assert(sign == null || typeof sign === 'boolean');
	    assert(this.h.word(0) >= 4);
	    assert(!this.n.isZero());

	    const x = this.one.redNeg();

	    let p;

	    for (;;) {
	      x.redIAdd(this.one);

	      try {
	        p = this.pointFromX(x.clone());
	      } catch (e) {
	        continue;
	      }

	      p = p.mul(this.n);

	      if (p.isInfinity())
	        continue;

	      if (!p.y.isZero())
	        continue;

	      break;
	    }

	    const r = p.x;
	    const r2 = r.redSqr();
	    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();

	    if (sign != null) {
	      if (s.redIsOdd() !== sign)
	        s.redINeg();
	    }

	    return [r, s];
	  }

	  _scale0(a, b) {
	    // We can extract the isomorphism factors with:
	    //
	    //   u4 = a' / a
	    //   u6 = b' / b
	    //   u2 = +-sqrt(u4)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // `u2` should be picked such that `u4 * u2 = u6`.
	    //
	    // If a = 0, we can do:
	    //
	    //   u6 = b' / b
	    //   u2 = u6^(1 / 3)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // Where `u2` is any root that is square.
	    //
	    // If b = 0, we can do:
	    //
	    //   u4 = a' / a
	    //   u2 = +-sqrt(u4)
	    //   u = +-sqrt(u2)
	    //   u3 = u2 * u
	    //
	    // Where `u2` is any root that is square.
	    assert(this.a.isZero() === a.isZero());
	    assert(this.b.isZero() === b.isZero());

	    if (this.a.isZero()) {
	      const u6 = this.b.redDiv(this.field(b));
	      // Todo: figure out how to check index.
	      const u2 = uncube(u6);
	      const u = u2.redSqrt();
	      const u3 = u2.redMul(u);

	      assert(u3.redSqr().eq(u6));
	      assert(!u.isZero());

	      return [u2, u3];
	    }

	    if (this.b.isZero()) {
	      const u4 = this.a.redDiv(this.field(a));
	      const u2 = u4.redSqrt();

	      // Todo: figure out how to check oddness.
	      if (u2.redJacobi() !== 1)
	        u2.redINeg();

	      const u = u2.redSqrt();
	      const u3 = u2.redMul(u);

	      assert(u3.redMul(u).eq(u4));
	      assert(!u.isZero());

	      return [u2, u3];
	    }

	    const u4 = this.a.redDiv(this.field(a));
	    const u6 = this.b.redDiv(this.field(b));
	    const u2 = u4.redSqrt();

	    if (!u4.redMul(u2).eq(u6))
	      u2.redINeg();

	    assert(u4.redMul(u2).eq(u6));

	    const u = u2.redSqrt();
	    const u3 = u2.redMul(u);

	    assert(!u.isZero());

	    return [u2, u3];
	  }

	  _scale1(x, y) {
	    // If base points are available, it is much
	    // easier, with:
	    //
	    //   u2 = x' / x
	    //   u3 = y' / y
	    //   u = +-sqrt(u2)
	    //
	    // `u` should be picked such that `u2 * u = u3`.
	    const u2 = this.g.x.redDiv(this.field(x));
	    const u3 = this.g.y.redDiv(this.field(y));
	    const u = u2.redSqrt();

	    if (!u2.redMul(u).eq(u3))
	      u.redINeg();

	    assert(u2.redMul(u).eq(u3));
	    assert(!u.isZero());

	    return [u2, u3];
	  }

	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);

	    if (this.g.isInfinity() || curve.g.isInfinity())
	      return this._scale0(curve.a, curve.b);

	    return this._scale1(curve.g.x, curve.g.y);
	  }

	  _scaleMont(curve) {
	    assert(curve instanceof MontCurve);

	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a, b] = curve._short();
	      return this._scale0(a, b);
	    }

	    const {x, y} = curve.g;
	    const nx = x.redAdd(curve.a3).redMul(curve.bi);
	    const ny = y.redMul(curve.bi);

	    return this._scale1(nx, ny);
	  }

	  _scaleEdwards(curve) {
	    assert(curve instanceof EdwardsCurve);

	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a, b] = curve._short();
	      return this._scale0(a, b);
	    }

	    const {x, y, z} = curve.g;
	    const a5 = curve.a.redMuln(5);
	    const d5 = curve.d.redMuln(5);
	    const dma = curve.d.redSub(curve.a);
	    const d5a = d5.redSub(curve.a);
	    const da5 = curve.d.redSub(a5);
	    const ypz = y.redAdd(z);
	    const ymz = y.redSub(z);
	    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
	    const xz = ymz.redMuln(12);
	    const yy = dma.redMul(ypz).redMul(z);
	    const yz = ymz.redMul(x).redIMuln(4);
	    const zi = xz.redMul(yz).redInvert();
	    const nx = xx.redMul(yz).redMul(zi);
	    const ny = yy.redMul(xz).redMul(zi);

	    return this._scale1(nx, ny);
	  }

	  _getEndomorphism(index = 0) {
	    // Compute endomorphism.
	    //
	    // [GECC] Example 3.76, Page 128, Section 3.5.

	    // No curve params.
	    if (this.n.isZero() || this.g.isInfinity())
	      return null;

	    // No efficient endomorphism.
	    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
	      return null;

	    // Solve beta^3 mod p = 1.
	    const [b1, b2] = this._getEndoRoots(this.p);

	    // Choose the smallest beta by default.
	    const beta = [b1, b2][index & 1].toRed(this.red);

	    // Solve lambda^3 mod n = 1.
	    const [l1, l2] = this._getEndoRoots(this.n);

	    // Choose the lambda matching selected beta.
	    // Note that P * lambda = (x * beta, y).
	    const p = this.point(this.g.x.redMul(beta), this.g.y);

	    let lambda;

	    if (this.g.mul(l1).eq(p)) {
	      lambda = l1;
	    } else {
	      assert(this.g.mul(l2).eq(p));
	      lambda = l2;
	    }

	    // Get basis vectors.
	    const basis = this._getEndoBasis(lambda);

	    // Precompute `g1` and `g2`.
	    const pre = this._getEndoPrecomp(basis);

	    return new Endo(beta, lambda, basis, pre);
	  }

	  _getEndoRoots(num) {
	    // Find roots for x^2 + x + 1 in F.
	    //
	    // [GECC] Example 3.76, Page 128, Section 3.5.
	    // [GLV] Page 192, Section 2 (Endomorphisms).
	    //
	    // The above document doesn't fully explain how
	    // to derive these and only "hints" at it, as
	    // mentioned by Hal Finney[1], but we're basically
	    // computing two possible cube roots of 1 here.
	    //
	    // Note that we could also compute[2]:
	    //
	    //   beta = 2^((p - 1) / 3) mod p
	    //   lambda = 3^((n - 1) / 3) mod n
	    //
	    // As an extension of Fermat's little theorem:
	    //
	    //   g^(p - 1) mod p == 1
	    //
	    // It is suspected[3] this is how Hal Finney[4]
	    // computed his original endomorphism roots.
	    //
	    // @indutny's method for computing cube roots
	    // of unity[5] appears to be the method described
	    // on wikipedia[6][7].
	    //
	    // Sage produces the same solution:
	    //
	    //   sage: solve(x^2 + x + 1 == 0, x)
	    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]
	    //
	    // This can be reduced to:
	    //
	    //   x = (+-sqrt(-3) - 1) / 2
	    //
	    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565
	    // [2] https://crypto.stackexchange.com/a/22739
	    // [3] https://bitcoin.stackexchange.com/a/35872
	    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5
	    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity
	    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example
	    // [7] http://mathworld.wolfram.com/SplittingField.html
	    const red = num === this.p ? this.red : BN.mont(num);
	    const two = new BN(2).toRed(red);
	    const three = new BN(3).toRed(red);
	    const i2 = two.redInvert();

	    // S1 = sqrt(-3) / 2
	    const s1 = three.redNeg().redSqrt().redMul(i2);

	    // S2 = -S1
	    const s2 = s1.redNeg();

	    // R1 = S1 - 1 / 2
	    const r1 = s1.redSub(i2).fromRed();

	    // R2 = S2 - 1 / 2
	    const r2 = s2.redSub(i2).fromRed();

	    return [r1, r2].sort(BN.cmp);
	  }

	  _getEndoBasis(lambda) {
	    // Compute endomorphic basis.
	    //
	    // This essentially computes Cornacchia's algorithm
	    // for solving x^2 + d * y^2 = m (d = lambda, m = order).
	    //
	    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm
	    //
	    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
	    // [GLV] Page 196, Section 4 (Decomposing K).
	    //
	    // Balanced length-two representation of a multiplier.
	    //
	    // 1. Run the extended euclidean algorithm with inputs n
	    //    and lambda. The algorithm produces a sequence of
	    //    equations si*n + ti*lam = ri where s0=1, t0=0,
	    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri
	    //    and are non-negative and strictly decreasing. Let
	    //    l be the greatest index for which rl >= sqrt(n).
	    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);

	    // 2. Set (a1, b1) <- (rl+1, -tl+1).
	    const a1 = rl1;
	    const b1 = tl1.neg();

	    // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)
	    //    then set (a2, b2) <- (rl, -tl).
	    //    else set (a2, b2) <- (rl+2, -tl+2).
	    const lhs = rl.sqr().iadd(tl.sqr());
	    const rhs = rl2.sqr().iadd(tl2.sqr());

	    let a2, b2;

	    if (lhs.cmp(rhs) <= 0) {
	      a2 = rl;
	      b2 = tl.neg();
	    } else {
	      a2 = rl2;
	      b2 = tl2.neg();
	    }

	    return [
	      new Vector(a1, b1),
	      new Vector(a2, b2)
	    ];
	  }

	  _egcdSqrt(lambda) {
	    // Extended Euclidean algorithm for integers.
	    //
	    // [GECC] Algorithm 2.19, Page 40, Section 2.2.
	    // [GLV] Page 196, Section 4 (Decomposing K).
	    assert(lambda instanceof BN);
	    assert(!lambda.red);
	    assert(lambda.sign() > 0);
	    assert(this.n.sign() > 0);

	    // Note that we insert the approximate square
	    // root checks as described in algorithm 3.74.
	    //
	    // Algorithm 2.19 is defined as:
	    //
	    // 1. u <- a
	    //    v <- b
	    //
	    // 2. x1 <- 1
	    //    y1 <- 0
	    //    x2 <- 0
	    //    y2 <- 1
	    //
	    // 3. while u != 0 do
	    //
	    // 3.1. q <- floor(v / u)
	    //      r <- v - q * u
	    //      x <- x2 - q * x1
	    //      y <- y2 - q * y1
	    //
	    // 3.2. v <- u
	    //      u <- r
	    //      x2 <- x1
	    //      x1 <- x
	    //      y2 <- y1
	    //      y1 <- y
	    //
	    // 4. d <- v
	    //    x <- x2
	    //    y <- y2
	    //
	    // 5. Return (d, x, y).

	    // Start with an approximate square root of n.
	    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);

	    let u = lambda; // r1
	    let v = this.n.clone(); // r0
	    let x1 = new BN(1); // t1
	    let y1 = new BN(0); // t0
	    let x2 = new BN(0); // s1
	    let y2 = new BN(1); // s0

	    // All vectors are roots of: a + b * lambda = 0 (mod n).
	    let rl, tl;

	    // First vector.
	    let rl1, tl1;

	    // Inner.
	    let i = 0;
	    let j = 0;
	    let p;

	    // Compute EGCD.
	    while (!u.isZero() && i < 2) {
	      const q = v.quo(u);
	      const r = v.sub(q.mul(u));
	      const x = x2.sub(q.mul(x1));
	      const y = y2.sub(q.mul(y1));

	      // Check for r < sqrt(n).
	      if (j === 0 && r.cmp(sqrtn) < 0) {
	        rl = p;
	        tl = x1;
	        rl1 = r;
	        tl1 = x;
	        j = 1; // 1 more round.
	      }

	      p = r;
	      v = u;
	      u = r;
	      x2 = x1;
	      x1 = x;
	      y2 = y1;
	      y1 = y;

	      i += j;
	    }

	    // Should never happen.
	    assert(j !== 0, 'Could not find r < sqrt(n).');

	    // Second vector.
	    const rl2 = x2;
	    const tl2 = x1;

	    return [
	      rl,
	      tl,
	      rl1,
	      tl1,
	      rl2,
	      tl2
	    ];
	  }

	  _getEndoPrecomp(basis) {
	    // Precompute `g1` and `g2` to avoid round division.
	    //
	    // [JCEN12] Page 5, Section 4.3.
	    //
	    // Computation:
	    //
	    //   d = a1 * b2 - b1 * a2
	    //   t = ceil(log2(d+1)) + p
	    //   g1 = round((2^t * b2) / d)
	    //   g2 = round((2^t * b1) / d)
	    //
	    // Where:
	    //
	    //   `p` is the number of precision bits.
	    //   `d` is equal to `n` (the curve order).
	    //
	    // The paper above uses 2 as the value of `p`,
	    // whereas libsecp256k1 uses 128 (total=384).
	    //
	    // We pick precision for `g1` and `g2` such that:
	    //
	    //   abs(g1) < n
	    //   abs(g2) < n
	    //
	    // This ensures maximum precision for the constants
	    // while also ensuring they fit into a fixed number
	    // of scalar limbs in more optimized implementations.
	    //
	    // Furthermore, we attempt to align to a limb width
	    // of 64 bits. This allows us to optimize the shift,
	    // a la libsecp256k1[1].
	    //
	    // [1] https://github.com/bitcoin-core/secp256k1/pull/822
	    assert(Array.isArray(basis));
	    assert(basis.length === 2);
	    assert(basis[0] instanceof Vector);
	    assert(basis[1] instanceof Vector);

	    const [v1, v2] = basis;
	    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));
	    const bits = d.bitLength();
	    const align = bits >= 160;

	    assert(d.eq(this.n));

	    // Start with a rough estimate.
	    let shift = bits + Math.ceil(bits / 2) + 1;
	    let g1, g2;

	    if (align)
	      shift -= shift & 63;

	    while (shift > bits) {
	      g1 = v2.b.ushln(shift).divRound(d);
	      g2 = v1.b.ushln(shift).divRound(d);

	      if (g1.ucmp(d) < 0 && g2.ucmp(d) < 0)
	        break;

	      if (align)
	        shift -= 64;
	      else
	        shift -= 1;
	    }

	    if (shift <= bits)
	      throw new Error('Could not calculate g1 and g2.');

	    return [shift, g1, g2];
	  }

	  _endoSplit(k) {
	    // Balanced length-two representation of a multiplier.
	    //
	    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
	    //
	    // Also note that it is possible to precompute[1]
	    // values in order to avoid the division[2][3][4].
	    //
	    // This involves precomputing `g1` and `g2 (see
	    // above). `c1` and `c2` can then be computed as
	    // follows:
	    //
	    //   t = ceil(log2(n+1)) + p
	    //   c1 = (k * g1) >> t
	    //   c2 = -((k * g2) >> t)
	    //
	    // Where `>>` is an _unsigned_ right shift. Also
	    // note that the last bit discarded in the shift
	    // must be stored. If it is 1, then add 1 to the
	    // scalar (absolute addition).
	    //
	    // It's worth noting that libsecp256k1 uses a
	    // different calculation along the lines of:
	    //
	    //   t = ceil(log2(n+1)) + p
	    //   c1 = ((k * g1) >> t) * -b1
	    //   c2 = ((k * -g2) >> t) * -b2
	    //   k2 = c1 + c2
	    //   k1 = k2 * -lambda + k
	    //
	    // So, in the future, we can consider changing
	    // step 4 to:
	    //
	    //   4. Compute c1 = (k * g1) >> t
	    //          and c2 = -((k * g2) >> t).
	    //
	    //   const [shift, g1, g2] = this.endo.pre;
	    //   const c1 = k.mulShift(g1, shift);
	    //   const c2 = k.mulShift(g2, shift).ineg();
	    //
	    // Once we're brave enough, that is.
	    //
	    // [1] [JCEN12] Page 5, Section 4.3.
	    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259
	    // [3] https://github.com/bitcoin-core/secp256k1/pull/21
	    // [4] https://github.com/bitcoin-core/secp256k1/pull/127
	    assert(k instanceof BN);
	    assert(!k.red);
	    assert(!this.n.isZero());

	    const [v1, v2] = this.endo.basis;

	    // 4. Compute c1 = round(b2 * k / n)
	    //        and c2 = round(-b1 * k / n).
	    const c1 = v2.b.mul(k).divRound(this.n);
	    const c2 = v1.b.neg().mul(k).divRound(this.n);

	    // 5. Compute k1 = k - c1 * a1 - c2 * a2
	    //        and k2 = -c1 * b1 - c2 * b2.
	    const p1 = c1.mul(v1.a);
	    const p2 = c2.mul(v2.a);
	    const q1 = c1.ineg().mul(v1.b);
	    const q2 = c2.mul(v2.b);

	    // Calculate answer.
	    const k1 = k.sub(p1).isub(p2);
	    const k2 = q1.isub(q2);

	    // 6. Return (k1, k2).
	    return [k1, k2];
	  }

	  _endoBeta(point) {
	    assert(point instanceof ShortPoint);
	    return [point, point._getBeta()];
	  }

	  _endoWnafMulAdd(points, coeffs) {
	    // Point multiplication with efficiently computable endomorphisms.
	    //
	    // [GECC] Algorithm 3.77, Page 129, Section 3.5.
	    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).
	    //
	    // Note it may be possible to do this 4-dimensionally [4GLV].
	    assert(Array.isArray(points));
	    assert(Array.isArray(coeffs));
	    assert(points.length === coeffs.length);
	    assert(this.endo != null);

	    const len = points.length;
	    const npoints = new Array(len * 2);
	    const ncoeffs = new Array(len * 2);

	    for (let i = 0; i < len; i++) {
	      const [p1, p2] = this._endoBeta(points[i]);
	      const [k1, k2] = this._endoSplit(coeffs[i]);

	      npoints[i * 2 + 0] = p1;
	      ncoeffs[i * 2 + 0] = k1;
	      npoints[i * 2 + 1] = p2;
	      ncoeffs[i * 2 + 1] = k2;
	    }

	    return this._wnafMulAdd(5, npoints, ncoeffs);
	  }

	  _sswu(u) {
	    // Simplified Shallue-Woestijne-Ulas Method.
	    //
	    // Distribution: 3/8.
	    //
	    // [SSWU1] Page 15-16, Section 7. Appendix G.
	    // [SSWU2] Page 5, Theorem 2.3.
	    // [H2EC] "Simplified Shallue-van de Woestijne-Ulas Method".
	    //
	    // Assumptions:
	    //
	    //   - a != 0, b != 0.
	    //   - Let z be a non-square in F(p).
	    //   - z != -1.
	    //   - The polynomial g(x) - z is irreducible over F(p).
	    //   - g(b / (z * a)) is square in F(p).
	    //   - u != 0, u != +-sqrt(-1 / z).
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + a * x + b
	    //   t1 = 1 / (z^2 * u^4 + z * u^2)
	    //   x1 = (-b / a) * (1 + t1)
	    //   x1 = b / (z * a), if t1 = 0
	    //   x2 = z * u^2 * x1
	    //   x = x1, if g(x1) is square
	    //     = x2, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const {b, z, ai, zi, one} = this;
	    const z2 = z.redSqr();
	    const ba = b.redNeg().redMul(ai);
	    const bza = b.redMul(zi).redMul(ai);
	    const u2 = u.redSqr();
	    const u4 = u2.redSqr();
	    const t0 = z2.redMul(u4).redIAdd(z.redMul(u2));
	    const t1 = t0.isZero() ? t0 : t0.redInvert();
	    const x1 = t1.isZero() ? bza : ba.redMul(one.redAdd(t1));
	    const x2 = z.redMul(u2).redMul(x1);
	    const y1 = this.solveY2(x1);
	    const y2 = this.solveY2(x2);
	    const alpha = y1.redIsSquare() | 0;
	    const x = [x1, x2][alpha ^ 1];
	    const y = [y1, y2][alpha ^ 1].redSqrt();

	    if (y.redIsOdd() !== u.redIsOdd())
	      y.redINeg();

	    return this.point(x, y);
	  }

	  _sswui(p, hint) {
	    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).
	    //
	    // Assumptions:
	    //
	    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).
	    //   - If r < 3 then x != -b / a.
	    //
	    // Unlike SVDW, the preimages here are evenly
	    // distributed (more or less). SSWU covers ~3/8
	    // of the curve points. Each preimage has a 1/2
	    // chance of mapping to either x1 or x2.
	    //
	    // Assuming the point is within that set, each
	    // point has a 1/4 chance of inverting to any
	    // of the preimages. This means we can simply
	    // randomly select a preimage if one exists.
	    //
	    // However, the [SVDW2] sampling method seems
	    // slighly faster in practice for [SQUARED].
	    //
	    // Map:
	    //
	    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)
	    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)
	    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)
	    //   u3 = -(a * x + b - c) / (2 * b * z)
	    //   u4 = -(a * x + b + c) / (2 * b * z)
	    //   r = random integer in [1,4]
	    //   u = sign(y) * abs(sqrt(ur))
	    const {a, b, z} = this;
	    const {x, y} = p;
	    const r = hint & 3;
	    const a2x2 = a.redSqr().redMul(x.redSqr());
	    const abx2 = a.redMul(b).redMul(x).redIMuln(2);
	    const b23 = b.redSqr().redMuln(3);
	    const axb = a.redMul(x).redIAdd(b);
	    const c = a2x2.redISub(abx2).redISub(b23).redSqrt();
	    const n0 = axb.redSub(c).redINeg();
	    const n1 = axb.redAdd(c).redINeg();
	    const d0 = axb.redMul(z).redIMuln(2);
	    const d1 = b.redMul(z).redIMuln(2);
	    const n = [n0, n1][r & 1]; // r = 1 or 3
	    const d = [d0, d1][r >>> 1]; // r = 2 or 3
	    const u = n.redDivSqrt(d);

	    if (u.redIsOdd() !== y.redIsOdd())
	      u.redINeg();

	    return u;
	  }

	  _svdwf(u) {
	    // Shallue-van de Woestijne Method.
	    //
	    // Distribution: 9/16.
	    //
	    // [SVDW1] Section 5.
	    // [SVDW2] Page 8, Section 3.
	    //         Page 15, Section 6, Algorithm 1.
	    // [H2EC] "Shallue-van de Woestijne Method".
	    //
	    // Assumptions:
	    //
	    //   - p = 1 (mod 3).
	    //   - a = 0, b != 0.
	    //   - Let z be a unique element in F(p).
	    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).
	    //   - u != 0, u != +-sqrt(-g(z)).
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + b
	    //   c = sqrt(-3 * z^2)
	    //   t1 = u^2 + g(z)
	    //   t2 = 1 / (u^2 * t1)
	    //   t3 = u^4 * t2 * c
	    //   x1 = (c - z) / 2 - t3
	    //   x2 = t3 - (c + z) / 2
	    //   x3 = z - t1^3 * t2 / (3 * z^2)
	    //   x = x1, if g(x1) is square
	    //     = x2, if g(x2) is square
	    //     = x3, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const {c, z, zi, i2, i3} = this;
	    const gz = this.solveY2(z);
	    const z3 = i3.redMul(zi.redSqr());
	    const u2 = u.redSqr();
	    const u4 = u2.redSqr();
	    const t1 = u2.redAdd(gz);
	    const u2t1 = u2.redMul(t1);
	    const t2 = u2t1.isZero() ? u2t1 : u2t1.redInvert();
	    const t3 = u4.redMul(t2).redMul(c);
	    const t4 = t1.redSqr().redMul(t1);
	    const x1 = c.redSub(z).redMul(i2).redISub(t3);
	    const x2 = t3.redSub(c.redAdd(z).redMul(i2));
	    const x3 = z.redSub(t4.redMul(t2).redMul(z3));
	    const y1 = this.solveY2(x1);
	    const y2 = this.solveY2(x2);
	    const y3 = this.solveY2(x3);
	    const alpha = y1.redJacobi() | 1;
	    const beta = y2.redJacobi() | 1;
	    const i = mod((alpha - 1) * beta, 3);
	    const x = [x1, x2, x3][i];
	    const y = [y1, y2, y3][i];

	    return [x, y];
	  }

	  _svdw(u) {
	    const [x, yy] = this._svdwf(u);
	    const y = yy.redSqrt();

	    if (y.redIsOdd() !== u.redIsOdd())
	      y.redINeg();

	    return this.point(x, y);
	  }

	  _svdwi(p, hint) {
	    // Inverting the Map (Shallue-van de Woestijne).
	    //
	    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
	    // [SVDW2] Page 12, Section 5.
	    // [SVDW3] "Inverting the map".
	    //
	    // Assumptions:
	    //
	    //   - If r = 1 then x != -(c + z) / 2.
	    //   - If r = 2 then x != (c - z) / 2.
	    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).
	    //   - f(f^-1(x)) = x where f is the map function.
	    //
	    // We use the sampling method from [SVDW2],
	    // _not_ [SQUARED]. This seems to have a
	    // better distribution in practice.
	    //
	    // Note that [SVDW3] also appears to be
	    // incorrect in terms of distribution.
	    //
	    // The distribution of f(u), assuming u is
	    // random, is (1/2, 1/4, 1/4).
	    //
	    // To mirror this, f^-1(x) should simply
	    // pick (1/2, 1/4, 1/8, 1/8).
	    //
	    // To anyone running the forward map, our
	    // strings will appear to be random.
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + b
	    //   c = sqrt(-3 * z^2)
	    //   t0 = 9 * (x^2 * z^2 + z^4)
	    //   t1 = 18 * x * z^3
	    //   t2 = 12 * g(z) * (x - z)
	    //   t3 = sqrt(t0 - t1 + t2)
	    //   t4 = t3 * z
	    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)
	    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)
	    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2
	    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2
	    //   r = random integer in [1,4]
	    //   u = sign(y) * abs(sqrt(ur))
	    const {b, c, z, zero, two} = this;
	    const {x, y} = p;
	    const r = hint & 3;
	    const z2 = z.redSqr();
	    const z3 = z2.redMul(z);
	    const z4 = z2.redSqr();
	    const gz = z3.redAdd(b);
	    const gz2 = gz.redMuln(2);
	    const xx = x.redSqr();
	    const x2z = x.redMuln(2).redIAdd(z);
	    const xz2 = x.redMul(z2);
	    const c0 = c.redSub(x2z);
	    const c1 = c.redAdd(x2z);
	    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);
	    const t1 = x.redMul(z3).redIMuln(18);
	    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);
	    const t3 = r >= 2 ? t0.redISub(t1).redIAdd(t2).redSqrt() : zero;
	    const t4 = t3.redMul(z);
	    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);
	    const n0 = gz.redMul(c0);
	    const n1 = gz.redMul(c1);
	    const n2 = t5.redAdd(t4);
	    const n3 = t5.redSub(t4);
	    const d2 = two;
	    const n = [n0, n1, n2, n3][r];
	    const d = [c1, c0, d2, d2][r];
	    const u = n.redDivSqrt(d);
	    const [x0] = this._svdwf(u);

	    if (!x0.eq(x))
	      throw new Error('Invalid point.');

	    if (u.redIsOdd() !== y.redIsOdd())
	      u.redINeg();

	    return u;
	  }

	  isElliptic() {
	    const {a, b} = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const d = b2.redMuln(27).redIAdd(a3.redMuln(4));

	    // 4 * a^3 + 27 * b^2 != 0
	    return !d.isZero();
	  }

	  jinv() {
	    // [ARITH1] Page 71, Section 4.4.
	    // http://mathworld.wolfram.com/j-Invariant.html
	    const {a, b} = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const t0 = a3.redMuln(4);
	    const lhs = t0.redMuln(1728);
	    const rhs = b2.redMuln(27).redIAdd(t0);

	    if (rhs.isZero())
	      throw new Error('Curve is not elliptic.');

	    // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)
	    return lhs.redDiv(rhs).fromRed();
	  }

	  point(x, y) {
	    return new ShortPoint(this, x, y);
	  }

	  jpoint(x, y, z) {
	    return new JPoint(this, x, y, z);
	  }

	  solveX(y) {
	    assert(y instanceof BN);

	    if (!this.a.isZero())
	      throw new Error('Not implemented.');

	    // x^3 = y^2 - b
	    const y2 = y.redSqr();
	    const x3 = y2.redSub(this.b);

	    return cubeRoots(x3);
	  }

	  solveY2(x) {
	    // [GECC] Page 89, Section 3.2.2.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html
	    assert(x instanceof BN);

	    // y^2 = x^3 + a * x + b
	    const x3 = x.redSqr().redMul(x);
	    const y2 = x3.redIAdd(this.b);

	    if (!this.zeroA) {
	      // Save some cycles for a = -3.
	      if (this.threeA)
	        y2.redIAdd(x.redMuln(-3));
	      else
	        y2.redIAdd(this.a.redMul(x));
	    }

	    return y2;
	  }

	  validate(point) {
	    assert(point instanceof ShortPoint);

	    if (point.inf)
	      return true;

	    const {x, y} = point;
	    const y2 = this.solveY2(x);

	    return y.redSqr().eq(y2);
	  }

	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');

	    if (!x.red)
	      x = x.toRed(this.red);

	    const y = this.solveY(x);

	    if (sign != null) {
	      if (this.h.cmpn(1) > 0) {
	        if (y.isZero() && sign)
	          throw new Error('Invalid point.');
	      }

	      if (y.redIsOdd() !== sign)
	        y.redINeg();
	    }

	    return this.point(x, y);
	  }

	  pointFromY(y, index = 0) {
	    assert(y instanceof BN);
	    assert((index >>> 0) === index);

	    if (!y.red)
	      y = y.toRed(this.red);

	    const coords = this.solveX(y);

	    if (index >= coords.length)
	      throw new Error('Invalid X coordinate index.');

	    const x = coords[index];

	    return this.point(x, y);
	  }

	  isIsomorphic(curve) {
	    // [GECC] Page 84, Section 3.1.5.
	    // [ARITH1] Page 286, Section 13.2.3.c.
	    assert(curve instanceof Curve);

	    if (!curve.p.eq(this.p))
	      return false;

	    let u2, u3;
	    try {
	      [u2, u3] = this._scale(curve);
	    } catch (e) {
	      return false;
	    }

	    // E(a,b) <-> E(au^4,bu^6)
	    if (curve.type === 'short') {
	      // a' = a * u^4, b' = b * u^6
	      const a = this.field(curve.a).redMul(u2.redSqr());
	      const b = this.field(curve.b).redMul(u3.redSqr());

	      return this.a.eq(a) && this.b.eq(b);
	    }

	    // E(a,b) <-> M(A,B)
	    if (curve.type === 'mont') {
	      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0
	      const {a3, bi} = curve;
	      const x = this.field(a3.redMul(bi)).redMul(u2);
	      const y2 = this.solveY2(x);

	      return y2.isZero();
	    }

	    // E(a,b) <-> E(a,d)
	    if (curve.type === 'edwards') {
	      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0
	      const x = this.field(curve.ad6).redMul(u2);
	      const y2 = this.solveY2(x);

	      return y2.isZero();
	    }

	    return false;
	  }

	  isIsogenous(curve) {
	    assert(curve instanceof Curve);
	    return false;
	  }

	  pointFromShort(point) {
	    // [GECC] Page 84, Section 3.1.5.
	    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
	    assert(point instanceof ShortPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):
	      //
	      //   x' = x * u^2
	      //   y' = y * u^3
	      //
	      // Where a * u^4 = a' and b * u^6 = b'.
	      if (point.isInfinity())
	        return this.point();

	      const [u2, u3] = this._scale(point.curve);
	      const x = this.field(point.x);
	      const y = this.field(point.y);
	      const nx = x.redMul(u2);
	      const ny = y.redMul(u3);

	      return this.point(nx, ny);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromMont(point) {
	    // [ALT] Appendix E.2 (Switching between Alternative Representations).
	    // [MONT2] "Equivalence with Weierstrass curves"
	    assert(point instanceof MontPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for M(A,B)->E(a,b):
	      //
	      //   x = (u + A / 3) / B
	      //   y = v / B
	      //
	      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
	      if (point.isInfinity())
	        return this.point();

	      const {a3, bi} = point.curve;
	      const [u2, u3] = this._scale(point.curve);
	      const nx = point.x.redAdd(a3).redMul(bi);
	      const ny = point.y.redMul(bi);

	      return this.point(this.field(nx).redMul(u2),
	                        this.field(ny).redMul(u3));
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromEdwards(point) {
	    // [TWISTEQ] Section 2.
	    assert(point instanceof EdwardsPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,d)->E(a',b'):
	      //
	      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))
	      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> ((a + d) / 6, 0)
	      //
	      // Unexceptional Cases:
	      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))
	      const {a, d, ad6} = point.curve;
	      const [u2, u3] = this._scale(point.curve);

	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero()) {
	        const x = this.field(ad6).redMul(u2);
	        return this.point(x, this.zero);
	      }

	      const {x, y, z} = point;
	      const a5 = a.redMuln(5);
	      const d5 = d.redMuln(5);
	      const dma = d.redSub(a);
	      const d5a = d5.redSub(a);
	      const da5 = d.redSub(a5);
	      const ypz = y.redAdd(z);
	      const ymz = y.redSub(z);
	      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
	      const xz = ymz.redMuln(12);
	      const yy = dma.redMul(ypz).redMul(z);
	      const yz = ymz.redMul(x).redIMuln(4);

	      return this.cpoint(this.field(xx).redMul(u2),
	                         this.field(xz),
	                         this.field(yy).redMul(u3),
	                         this.field(yz));
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromUniform(u) {
	    assert(u instanceof BN);

	    // z = 0 or b = 0
	    if (this.z.isZero() || this.b.isZero())
	      throw new Error('Not implemented.');

	    // a != 0, b != 0
	    if (!this.a.isZero())
	      return this._sswu(u);

	    // p = 1 mod 3, a = 0, b != 0
	    if (!this.c.isZero())
	      return this._svdw(u);

	    throw new Error('Not implemented.');
	  }

	  pointToUniform(p, hint) {
	    // Convert a short weierstrass point to a field
	    // element by inverting either the SSWU or SVDW
	    // map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof ShortPoint);
	    assert((hint >>> 0) === hint);

	    // z = 0 or b = 0
	    if (this.z.isZero() || this.b.isZero())
	      throw new Error('Not implemented.');

	    // P = O
	    if (p.isInfinity())
	      throw new Error('Invalid point.');

	    // Add a random torsion component.
	    const i = ((hint >>> 4) & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    return wrapErrors(() => {
	      // a != 0, b != 0
	      if (!this.a.isZero())
	        return this._sswui(q, hint);

	      // p = 1 mod 3, a = 0, b != 0
	      if (!this.c.isZero())
	        return this._svdwi(q, hint);

	      throw new Error('Not implemented.');
	    });
	  }

	  mulAll(points, coeffs) {
	    return super.mulAll(points, coeffs).toP();
	  }

	  affinizeAll(points) {
	    const out = this.normalizeAll(points);

	    for (let i = 0; i < out.length; i++)
	      out[i] = out[i].toP();

	    return out;
	  }

	  decodePoint(bytes) {
	    return ShortPoint.decode(this, bytes);
	  }

	  encodeX(point) {
	    assert(point instanceof Point);
	    return point.encodeX();
	  }

	  decodeEven(bytes) {
	    return ShortPoint.decodeEven(this, bytes);
	  }

	  decodeSquare(bytes) {
	    return ShortPoint.decodeSquare(this, bytes);
	  }

	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);

	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });

	    if (sign != null) {
	      const [, u3] = curve._scale(this);

	      if (u3.redIsOdd() !== sign)
	        u3.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromShort(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);

	    return curve;
	  }

	  toMont(b0, odd, sign = null) {
	    const [a, b] = this._mont(b0, odd);

	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });

	    if (sign != null) {
	      const [, u3] = this._scale(curve);

	      if (u3.redIsOdd() !== sign)
	        u3.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromShort(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);

	    return curve;
	  }

	  toEdwards(a0, odd, sign = null) {
	    const [a, d] = this._edwards(a0, odd);

	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h
	    });

	    if (sign != null) {
	      const [, u3] = this._scale(curve);

	      if (u3.redIsOdd() !== sign)
	        u3.redINeg();
	    }

	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromShort(this.g);
	      curve.g.normalize();
	    }

	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }

	    return curve;
	  }

	  pointFromJSON(json) {
	    return ShortPoint.fromJSON(this, json);
	  }

	  toJSON(pre) {
	    const json = super.toJSON(pre);

	    json.a = this.a.fromRed().toJSON();
	    json.b = this.b.fromRed().toJSON();

	    if (!this.c.isZero())
	      json.c = this.c.fromRed().toJSON();

	    return json;
	  }
	}

	/**
	 * ShortPoint
	 */

	class ShortPoint extends Point {
	  constructor(curve, x, y) {
	    assert(curve instanceof ShortCurve);

	    super(curve, types.AFFINE);

	    this.x = this.curve.zero;
	    this.y = this.curve.zero;
	    this.inf = true;

	    if (x != null)
	      this._init(x, y);
	  }

	  _init(x, y) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);

	    this.x = x;
	    this.y = y;

	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);

	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);

	    this.inf = false;
	  }

	  _getBeta() {
	    if (!this.curve.endo)
	      return null;

	    if (this.pre && this.pre.beta)
	      return this.pre.beta;

	    // Augment the point with our beta value.
	    // This is the counterpart to `k2` after
	    // the endomorphism split of `k`.
	    //
	    // Note that if we have precomputation,
	    // we have to clone and update all of the
	    // precomputed points below.
	    const xb = this.x.redMul(this.curve.endo.beta);
	    const beta = this.curve.point(xb, this.y);

	    if (this.pre) {
	      beta.pre = this.pre.map((point) => {
	        const xb = point.x.redMul(this.curve.endo.beta);
	        return this.curve.point(xb, point.y);
	      });

	      this.pre.beta = beta;
	    }

	    return beta;
	  }

	  _getJNAF(point) {
	    assert(point instanceof ShortPoint);

	    if (this.inf || point.inf)
	      return super._getJNAF(point);

	    // Create comb for JSF.
	    const comb = [
	      this, // 1
	      null, // 3
	      null, // 5
	      point // 7
	    ];

	    // Try to avoid Jacobian points, if possible.
	    if (this.y.eq(point.y)) {
	      comb[1] = this.add(point);
	      comb[2] = this.toJ().sub(point);
	    } else if (this.y.eq(point.y.redNeg())) {
	      comb[1] = this.toJ().add(point);
	      comb[2] = this.sub(point);
	    } else {
	      comb[1] = this.toJ().add(point);
	      comb[2] = this.toJ().sub(point);
	    }

	    return comb;
	  }

	  clone() {
	    if (this.inf)
	      return this.curve.point();

	    return this.curve.point(this.x, this.y);
	  }

	  scale(a) {
	    return this.toJ().scale(a);
	  }

	  neg() {
	    // P = O
	    if (this.inf)
	      return this;

	    // -(X1, Y1) = (X1, -Y1)
	    return this.curve.point(this.x, this.y.redNeg());
	  }

	  add(p) {
	    // [GECC] Page 80, Section 3.1.2.
	    //
	    // Addition Law:
	    //
	    //   l = (y1 - y2) / (x1 - x2)
	    //   x3 = l^2 - x1 - x2
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 1S + 6A
	    assert(p instanceof ShortPoint);

	    // O + P = P
	    if (this.inf)
	      return p;

	    // P + O = P
	    if (p.inf)
	      return this;

	    // P + P, P + -P
	    if (this.x.eq(p.x)) {
	      // P + -P = O
	      if (!this.y.eq(p.y))
	        return this.curve.point();

	      // P + P = 2P
	      return this.dbl();
	    }

	    // X1 != X2, Y1 = Y2
	    if (this.y.eq(p.y)) {
	      // X3 = -X1 - X2
	      const nx = this.x.redNeg().redISub(p.x);

	      // Y3 = -Y1
	      const ny = this.y.redNeg();

	      // Skip the inverse.
	      return this.curve.point(nx, ny);
	    }

	    // H = X1 - X2
	    const h = this.x.redSub(p.x);

	    // R = Y1 - Y2
	    const r = this.y.redSub(p.y);

	    // L = R / H
	    const l = r.redDiv(h);

	    // X3 = L^2 - X1 - X2
	    const nx = l.redSqr().redISub(this.x).redISub(p.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

	    return this.curve.point(nx, ny);
	  }

	  dbl() {
	    // [GECC] Page 80, Section 3.1.2.
	    //
	    // Addition Law (doubling):
	    //
	    //   l = (3 * x1^2 + a) / (2 * y1)
	    //   x3 = l^2 - 2 * x1
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 2S + 3A + 2*2 + 1*3

	    // P = O
	    if (this.inf)
	      return this;

	    // Y1 = 0
	    if (this.y.isZero())
	      return this.curve.point();

	    // XX = X1^2
	    const xx = this.x.redSqr();

	    // M = 3 * XX + a
	    const m = xx.redIMuln(3).redIAdd(this.curve.a);

	    // Z = 2 * Y1
	    const z = this.y.redMuln(2);

	    // L = M / Z
	    const l = m.redDiv(z);

	    // X3 = L^2 - 2 * X1
	    const nx = l.redSqr().redISub(this.x).redISub(this.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

	    return this.curve.point(nx, ny);
	  }

	  dblp(pow) {
	    return this.toJ().dblp(pow).toP();
	  }

	  getX() {
	    if (this.inf)
	      throw new Error('Invalid point.');

	    return this.x.fromRed();
	  }

	  getY() {
	    if (this.inf)
	      throw new Error('Invalid point.');

	    return this.y.fromRed();
	  }

	  eq(p) {
	    assert(p instanceof ShortPoint);

	    // P = Q
	    if (this === p)
	      return true;

	    // P = O
	    if (this.inf)
	      return p.inf;

	    // Q = O
	    if (p.inf)
	      return false;

	    // X1 = X2, Y1 = Y2
	    return this.x.eq(p.x)
	        && this.y.eq(p.y);
	  }

	  cmp(point) {
	    assert(point instanceof ShortPoint);

	    if (this.inf && !point.inf)
	      return -1;

	    if (!this.inf && point.inf)
	      return 1;

	    if (this.inf && point.inf)
	      return 0;

	    return this.order().cmp(point.order())
	        || this.getX().cmp(point.getX())
	        || this.getY().cmp(point.getY());
	  }

	  isInfinity() {
	    // Infinity cannot be represented in
	    // the affine space, except by a flag.
	    return this.inf;
	  }

	  isOrder2() {
	    if (this.inf)
	      return false;

	    return this.y.isZero();
	  }

	  isOdd() {
	    if (this.inf)
	      return false;

	    return this.y.redIsOdd();
	  }

	  isEven() {
	    if (this.inf)
	      return false;

	    return this.y.redIsEven();
	  }

	  isSquare() {
	    if (this.inf)
	      return false;

	    return this.y.redJacobi() !== -1;
	  }

	  eqX(x) {
	    assert(x instanceof BN);
	    assert(!x.red);

	    if (this.inf)
	      return false;

	    return this.getX().eq(x);
	  }

	  eqR(x) {
	    assert(x instanceof BN);
	    assert(!x.red);
	    assert(!this.curve.n.isZero());

	    if (this.inf)
	      return false;

	    return this.getX().imod(this.curve.n).eq(x);
	  }

	  mul(k) {
	    return super.mul(k).toP();
	  }

	  muln(k) {
	    return super.muln(k).toP();
	  }

	  mulBlind(k, rng) {
	    return super.mulBlind(k, rng).toP();
	  }

	  mulAdd(k1, p2, k2) {
	    return super.mulAdd(k1, p2, k2).toP();
	  }

	  mulH() {
	    return super.mulH().toP();
	  }

	  div(k) {
	    return super.div(k).toP();
	  }

	  divn(k) {
	    return super.divn(k).toP();
	  }

	  divH() {
	    return super.divH().toP();
	  }

	  toP() {
	    return this;
	  }

	  toJ() {
	    // (X3, Y3, Z3) = (1, 1, 0)
	    if (this.inf)
	      return this.curve.jpoint();

	    // (X3, Y3, Z3) = (X1, Y1, 1)
	    return this.curve.jpoint(this.x, this.y, this.curve.one);
	  }

	  encode(compact) {
	    // [SEC1] Page 10, Section 2.3.3.
	    if (compact == null)
	      compact = true;

	    assert(typeof compact === 'boolean');

	    const {fieldSize} = this.curve;

	    // We do not serialize points at infinity.
	    if (this.inf)
	      throw new Error('Invalid point.');

	    // Compressed form (0x02 = even, 0x03 = odd).
	    if (compact) {
	      const p = Buffer.alloc(1 + fieldSize);
	      const x = this.curve.encodeField(this.getX());

	      p[0] = 0x02 | this.y.redIsOdd();
	      x.copy(p, 1);

	      return p;
	    }

	    // Uncompressed form (0x04).
	    const p = Buffer.alloc(1 + fieldSize * 2);
	    const x = this.curve.encodeField(this.getX());
	    const y = this.curve.encodeField(this.getY());

	    p[0] = 0x04;
	    x.copy(p, 1);
	    y.copy(p, 1 + fieldSize);

	    return p;
	  }

	  static decode(curve, bytes) {
	    // [SEC1] Page 11, Section 2.3.4.
	    assert(curve instanceof ShortCurve);
	    assert(Buffer.isBuffer(bytes));

	    const len = curve.fieldSize;

	    if (bytes.length < 1 + len)
	      throw new Error('Not a point.');

	    // Point forms:
	    //
	    //   0x00 -> Infinity (openssl, unsupported)
	    //   0x02 -> Compressed Even
	    //   0x03 -> Compressed Odd
	    //   0x04 -> Uncompressed
	    //   0x06 -> Hybrid Even (openssl)
	    //   0x07 -> Hybrid Odd (openssl)
	    //
	    // Note that openssl supports serializing points
	    // at infinity as {0}. We choose not to support it
	    // because it's strange and not terribly useful.
	    const form = bytes[0];

	    switch (form) {
	      case 0x02:
	      case 0x03: {
	        if (bytes.length !== 1 + len)
	          throw new Error('Invalid point size for compressed.');

	        const x = curve.decodeField(bytes.slice(1, 1 + len));

	        if (x.cmp(curve.p) >= 0)
	          throw new Error('Invalid point.');

	        const p = curve.pointFromX(x, form === 0x03);

	        assert(!p.isInfinity());

	        return p;
	      }

	      case 0x04:
	      case 0x06:
	      case 0x07: {
	        if (bytes.length !== 1 + len * 2)
	          throw new Error('Invalid point size for uncompressed.');

	        const x = curve.decodeField(bytes.slice(1, 1 + len));
	        const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len));

	        // [GECC] Algorithm 4.3, Page 180, Section 4.
	        if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0)
	          throw new Error('Invalid point.');

	        // OpenSSL hybrid encoding.
	        if (form !== 0x04 && form !== (0x06 | y.isOdd()))
	          throw new Error('Invalid hybrid encoding.');

	        const p = curve.point(x, y);

	        if (!p.validate())
	          throw new Error('Invalid point.');

	        assert(!p.isInfinity());

	        return p;
	      }

	      default: {
	        throw new Error('Unknown point format.');
	      }
	    }
	  }

	  encodeX() {
	    // [SCHNORR] "Specification".
	    // [BIP340] "Specification".
	    return this.curve.encodeField(this.getX());
	  }

	  static decodeEven(curve, bytes) {
	    // [BIP340] "Specification".
	    assert(curve instanceof ShortCurve);

	    const x = curve.decodeField(bytes);

	    if (x.cmp(curve.p) >= 0)
	      throw new Error('Invalid point.');

	    return curve.pointFromX(x, false);
	  }

	  static decodeSquare(curve, bytes) {
	    // [SCHNORR] "Specification".
	    assert(curve instanceof ShortCurve);

	    const x = curve.decodeField(bytes);

	    if (x.cmp(curve.p) >= 0)
	      throw new Error('Invalid point.');

	    return curve.pointFromX(x);
	  }

	  toJSON(pre) {
	    if (this.inf)
	      return [];

	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();

	    if (pre === true && this.pre)
	      return [x, y, this.pre.toJSON()];

	    return [x, y];
	  }

	  toPretty() {
	    if (this.inf)
	      return [];

	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);

	    return [x, y];
	  }

	  static fromJSON(curve, json) {
	    assert(curve instanceof ShortCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0
	        || json.length === 2
	        || json.length === 3);

	    if (json.length === 0)
	      return curve.point();

	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);
	    const point = curve.point(x, y);

	    if (json.length > 2 && json[2] != null)
	      point.pre = Precomp.fromJSON(point, json[2]);

	    return point;
	  }

	  [custom]() {
	    if (this.inf)
	      return '<ShortPoint: Infinity>';

	    return '<ShortPoint:'
	         + ' x=' + this.x.fromRed().toString(16, 2)
	         + ' y=' + this.y.fromRed().toString(16, 2)
	         + '>';
	  }
	}

	/**
	 * JPoint
	 */

	class JPoint extends Point {
	  constructor(curve, x, y, z) {
	    assert(curve instanceof ShortCurve);

	    super(curve, types.JACOBIAN);

	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = this.curve.zero;
	    this.zOne = false;

	    if (x != null)
	      this._init(x, y, z);
	  }

	  _init(x, y, z) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    assert(z == null || (z instanceof BN));

	    this.x = x;
	    this.y = y;
	    this.z = z || this.curve.one;

	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);

	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);

	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);

	    this.zOne = this.z.eq(this.curve.one);
	  }

	  clone() {
	    return this.curve.jpoint(this.x, this.y, this.z);
	  }

	  validate() {
	    // [GECC] Example 3.20, Page 88, Section 3.
	    const {a, b} = this.curve;

	    // P = O
	    if (this.isInfinity())
	      return true;

	    // Z1 = 1
	    if (this.zOne)
	      return this.curve.validate(this.toP());

	    // y^2 = x^3 + a * x * z^4 + b * z^6
	    const lhs = this.y.redSqr();
	    const x3 = this.x.redSqr().redMul(this.x);
	    const z2 = this.z.redSqr();
	    const z4 = z2.redSqr();
	    const z6 = z4.redMul(z2);
	    const rhs = x3.redIAdd(b.redMul(z6));

	    if (!this.curve.zeroA) {
	      // Save some cycles for a = -3.
	      if (this.curve.threeA)
	        rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));
	      else
	        rhs.redIAdd(a.redMul(z4).redMul(this.x));
	    }

	    return lhs.eq(rhs);
	  }

	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z
	    // 1I + 3M + 1S

	    // Z = 1
	    if (this.zOne)
	      return this;

	    // P = O
	    if (this.isInfinity())
	      return this;

	    // A = 1 / Z1
	    const a = this.z.redInvert();

	    // AA = A^2
	    const aa = a.redSqr();

	    // X3 = X1 * AA
	    this.x = this.x.redMul(aa);

	    // Y3 = Y1 * AA * A
	    this.y = this.y.redMul(aa).redMul(a);

	    // Z3 = 1
	    this.z = this.curve.one;
	    this.zOne = true;

	    return this;
	  }

	  scale(a) {
	    assert(a instanceof BN);

	    // P = O
	    if (this.isInfinity())
	      return this.curve.jpoint();

	    // AA = A^2
	    const aa = a.redSqr();

	    // X3 = X1 * AA
	    const nx = this.x.redMul(aa);

	    // Y3 = Y1 * AA * A
	    const ny = this.y.redMul(aa).redMul(a);

	    // Z3 = Z1 * A
	    const nz = this.z.redMul(a);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  neg() {
	    // -(X1, Y1, Z1) = (X1, -Y1, Z1)
	    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	  }

	  add(p) {
	    assert(p instanceof Point);

	    if (p.type === types.AFFINE)
	      return this._mixedAdd(p);

	    return this._add(p);
	  }

	  _add(p) {
	    assert(p instanceof JPoint);

	    // O + P = P
	    if (this.isInfinity())
	      return p;

	    // P + O = P
	    if (p.isInfinity())
	      return this;

	    // Z1 = 1
	    if (this.zOne)
	      return p._addJA(this);

	    // Z2 = 1
	    if (p.zOne)
	      return this._addJA(p);

	    return this._addJJ(p);
	  }

	  _mixedAdd(p) {
	    assert(p instanceof ShortPoint);

	    // O + P = P
	    if (this.isInfinity())
	      return p.toJ();

	    // P + O = P
	    if (p.isInfinity())
	      return this;

	    return this._addJA(p);
	  }

	  _addJJ(p) {
	    // No assumptions.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2
	    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)

	    // Z1Z1 = Z1^2
	    const z1z1 = this.z.redSqr();

	    // Z2Z2 = Z2^2
	    const z2z2 = p.z.redSqr();

	    // U1 = X1 * Z2Z2
	    const u1 = this.x.redMul(z2z2);

	    // U2 = X2 * Z1Z1
	    const u2 = p.x.redMul(z1z1);

	    // S1 = Y1 * Z2 * Z2Z2
	    const s1 = this.y.redMul(p.z).redMul(z2z2);

	    // S2 = Y2 * Z1 * Z1Z1
	    const s2 = p.y.redMul(this.z).redMul(z1z1);

	    // H = U2 - U1
	    const h = u2.redISub(u1);

	    // r = S2 - S1
	    const r = s2.redISub(s1);

	    // H = 0
	    if (h.isZero()) {
	      if (!r.isZero())
	        return this.curve.jpoint();

	      return this.dbl();
	    }

	    // HH = H^2
	    const hh = h.redSqr();

	    // HHH = H * HH
	    const hhh = h.redMul(hh);

	    // V = U1 * HH
	    const v = u1.redMul(hh);

	    // X3 = r^2 - HHH - 2 * V
	    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);

	    // Y3 = r * (V - X3) - S1 * HHH
	    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));

	    // Z3 = Z1 * Z2 * H
	    const nz = this.z.redMul(p.z).redMul(h);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  _addJA(p) {
	    // Assumes Z2 = 1.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd
	    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)

	    // Z1Z1 = Z1^2
	    const z1z1 = this.z.redSqr();

	    // U2 = X2 * Z1Z1
	    const u2 = p.x.redMul(z1z1);

	    // S2 = Y2 * Z1 * Z1Z1
	    const s2 = p.y.redMul(this.z).redMul(z1z1);

	    // H = U2 - X1
	    const h = u2.redISub(this.x);

	    // r = 2 * (S2 - Y1)
	    const r = s2.redISub(this.y).redIMuln(2);

	    // H = 0
	    if (h.isZero()) {
	      if (!r.isZero())
	        return this.curve.jpoint();

	      return this.dbl();
	    }

	    // I = (2 * H)^2
	    const i = h.redMuln(2).redSqr();

	    // J = H * I
	    const j = h.redMul(i);

	    // V = X1 * I
	    const v = this.x.redMul(i);

	    // X3 = r^2 - J - 2 * V
	    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);

	    // Y3 = r * (V - X3) - 2 * Y1 * J
	    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));

	    // Z3 = 2 * Z1 * H
	    const nz = this.z.redMul(h).redIMuln(2);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  dbl() {
	    // P = O
	    if (this.isInfinity())
	      return this;

	    // Y1 = 0
	    if (this.y.isZero())
	      return this.curve.jpoint();

	    // a = 0
	    if (this.curve.zeroA)
	      return this._dbl0();

	    // a = -3
	    if (this.curve.threeA)
	      return this._dbl3();

	    return this._dblJ();
	  }

	  _dblJ() {
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2
	    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8
	    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)

	    // XX = X1^2
	    const xx = this.x.redSqr();

	    // YY = Y1^2
	    const yy = this.y.redSqr();

	    // ZZ = Z1^2
	    const zz = this.z.redSqr();

	    // S = 4 * X1 * YY
	    const s = this.x.redMul(yy).redIMuln(4);

	    // M = 3 * XX + a * ZZ^2
	    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));

	    // T = M^2 - 2 * S
	    const t = m.redSqr().redISub(s).redISub(s);

	    // X3 = T
	    const nx = t;

	    // Y3 = M * (S - T) - 8 * YY^2
	    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));

	    // Z3 = 2 * Y1 * Z1
	    const nz = this.y.redMul(this.z).redIMuln(2);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  _dbl0() {
	    // Assumes a = 0.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
	    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8
	    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)

	    // A = X1^2
	    const a = this.x.redSqr();

	    // B = Y1^2
	    const b = this.y.redSqr();

	    // C = B^2
	    const c = b.redSqr();

	    // + XB2 = (X1 + B)^2
	    const xb2 = b.redIAdd(this.x).redSqr();

	    // D = 2 * ((X1 + B)^2 - A - C)
	    const d = xb2.redISub(a).redISub(c).redIMuln(2);

	    // E = 3 * A
	    const e = a.redIMuln(3);

	    // F = E^2
	    const f = e.redSqr();

	    // X3 = F - 2 * D
	    const nx = f.redISub(d).redISub(d);

	    // Y3 = E * (D - X3) - 8 * C
	    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));

	    // Z3 = 2 * Y1 * Z1
	    const nz = this.y.redMul(this.z).redIMuln(2);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  _dbl3() {
	    // Assumes a = -3.
	    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8
	    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)

	    // delta = Z1^2
	    const delta = this.z.redSqr();

	    // gamma = Y1^2
	    const gamma = this.y.redSqr();

	    // beta = X1 * gamma
	    const beta = this.x.redMul(gamma);

	    // + xmdelta = X1 - delta
	    const xmdelta = this.x.redSub(delta);

	    // + xpdelta = X1 + delta
	    const xpdelta = this.x.redAdd(delta);

	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    const alpha = xmdelta.redMul(xpdelta).redIMuln(3);

	    // + beta4 = 4 * beta
	    const beta4 = beta.redIMuln(4);

	    // + beta8 = 2 * beta4
	    const beta8 = beta4.redMuln(2);

	    // + gamma28 = 8 * gamma^2
	    const gamma28 = gamma.redSqr().redIMuln(8);

	    // X3 = alpha^2 - 8 * beta
	    const nx = alpha.redSqr().redISub(beta8);

	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);

	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);

	    return this.curve.jpoint(nx, ny, nz);
	  }

	  getX() {
	    if (this.isInfinity())
	      throw new Error('Invalid point.');

	    this.normalize();

	    return this.x.fromRed();
	  }

	  getY() {
	    if (this.isInfinity())
	      throw new Error('Invalid point.');

	    this.normalize();

	    return this.y.fromRed();
	  }

	  eq(p) {
	    assert(p instanceof JPoint);

	    // P = Q
	    if (this === p)
	      return true;

	    // P = O
	    if (this.isInfinity())
	      return p.isInfinity();

	    // Q = O
	    if (p.isInfinity())
	      return false;

	    // Z1 = Z2
	    if (this.z.eq(p.z)) {
	      return this.x.eq(p.x)
	          && this.y.eq(p.y);
	    }

	    // X1 * Z2^2 = X2 * Z1^2
	    const zz1 = this.z.redSqr();
	    const zz2 = p.z.redSqr();
	    const x1 = this.x.redMul(zz2);
	    const x2 = p.x.redMul(zz1);

	    if (!x1.eq(x2))
	      return false;

	    // Y1 * Z2^3 = Y2 * Z1^3
	    const zzz1 = zz1.redMul(this.z);
	    const zzz2 = zz2.redMul(p.z);
	    const y1 = this.y.redMul(zzz2);
	    const y2 = p.y.redMul(zzz1);

	    return y1.eq(y2);
	  }

	  cmp(point) {
	    assert(point instanceof JPoint);

	    const inf1 = this.isInfinity();
	    const inf2 = point.isInfinity();

	    if (inf1 && !inf2)
	      return -1;

	    if (!inf1 && inf2)
	      return 1;

	    if (inf1 && inf2)
	      return 0;

	    return this.order().cmp(point.order())
	        || this.getX().cmp(point.getX())
	        || this.getY().cmp(point.getY());
	  }

	  isInfinity() {
	    // Z1 = 0
	    return this.z.isZero();
	  }

	  isOrder2() {
	    if (this.isInfinity())
	      return false;

	    return this.y.isZero();
	  }

	  isOdd() {
	    if (this.isInfinity())
	      return false;

	    this.normalize();

	    return this.y.redIsOdd();
	  }

	  isEven() {
	    if (this.isInfinity())
	      return false;

	    this.normalize();

	    return this.y.redIsEven();
	  }

	  isSquare() {
	    if (this.isInfinity())
	      return false;

	    return this.y.redMul(this.z).redJacobi() !== -1;
	  }

	  eqX(x) {
	    // Verify that integer `x` is equal to field
	    // element `x` by scaling it by our z coordinate.
	    // This optimization is mentioned in and used for
	    // bip-schnorr[1]. This avoids having to affinize
	    // the resulting point during verification.
	    //
	    // [1] [SCHNORR] "Optimizations".
	    assert(x instanceof BN);
	    assert(!x.red);

	    if (this.isInfinity())
	      return false;

	    const zz = this.z.redSqr();
	    const rx = x.toRed(this.curve.red).redMul(zz);

	    return this.x.eq(rx);
	  }

	  eqR(x) {
	    // Similar to the optimization above, this
	    // optimization, suggested by Maxwell[1],
	    // compares an integer to an X coordinate
	    // by scaling it.
	    //
	    // Since a signature's R value is modulo N
	    // in ECDSA, we may be dealing with an R
	    // value greater than N in actuality.
	    //
	    // If the equality check fails, we can
	    // scale N itself by Z and add it to the
	    // X field element.
	    //
	    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f
	    assert(x instanceof BN);
	    assert(!x.red);

	    if (!this.curve.smallGap)
	      return this.toP().eqR(x);

	    if (this.isInfinity())
	      return false;

	    if (x.cmp(this.curve.p) >= 0)
	      return false;

	    const zz = this.z.redSqr();
	    const rx = x.toRed(this.curve.red).redMul(zz);

	    if (this.x.eq(rx))
	      return true;

	    if (this.curve.highOrder)
	      return false;

	    if (x.cmp(this.curve.pmodn) >= 0)
	      return false;

	    const rn = this.curve.redN.redMul(zz);

	    rx.redIAdd(rn);

	    return this.x.eq(rx);
	  }

	  toP() {
	    // P = O
	    if (this.isInfinity())
	      return this.curve.point();

	    this.normalize();

	    // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)
	    return this.curve.point(this.x, this.y);
	  }

	  toJ() {
	    return this;
	  }

	  encode(compact) {
	    return this.toP().encode(compact);
	  }

	  static decode(curve, bytes) {
	    return ShortPoint.decode(curve, bytes).toJ();
	  }

	  encodeX() {
	    return this.toP().encodeX();
	  }

	  static decodeEven(curve, bytes) {
	    return ShortPoint.decodeEven(curve, bytes).toJ();
	  }

	  static decodeSquare(curve, bytes) {
	    return ShortPoint.decodeSquare(curve, bytes).toJ();
	  }

	  toJSON(pre) {
	    return this.toP().toJSON(pre);
	  }

	  toPretty() {
	    return this.toP().toPretty();
	  }

	  static fromJSON(curve, json) {
	    return ShortPoint.fromJSON(curve, json).toJ();
	  }

	  [custom]() {
	    if (this.isInfinity())
	      return '<JPoint: Infinity>';

	    return '<JPoint:'
	         + ' x=' + this.x.fromRed().toString(16, 2)
	         + ' y=' + this.y.fromRed().toString(16, 2)
	         + ' z=' + this.z.fromRed().toString(16, 2)
	         + '>';
	  }
	}

	/**
	 * MontCurve
	 */

	class MontCurve extends Curve {
	  constructor(conf) {
	    super(MontPoint, 'mont', conf);

	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.b = BN.fromJSON(conf.b).toRed(this.red);

	    this.bi = this.b.redInvert();
	    this.a2 = this.a.redAdd(this.two);
	    this.a24 = this.a2.redMul(this.i4);
	    this.a3 = this.a.redMul(this.i3);
	    this.a0 = this.a.redMul(this.bi);
	    this.b0 = this.bi.redSqr();

	    this._finalize(conf);
	  }

	  static _isomorphism(curveA, curveB, customB) {
	    // Montgomery Isomorphism.
	    //
	    // [MONT3] Page 3, Section 2.1.
	    //
	    // Transformation:
	    //
	    //   A' = A
	    //   B' = B'
	    //
	    // Where (B / B') is square.
	    assert(curveA instanceof BN);
	    assert(curveB instanceof BN);
	    assert(customB instanceof BN);

	    const a = curveA.clone();
	    const b = customB.clone();
	    const c = curveB.redDiv(customB);

	    if (c.redJacobi() !== 1)
	      throw new Error('Invalid `b` coefficient.');

	    return [a, b];
	  }

	  _short(a0, odd) {
	    // Montgomery->Short Weierstrass Equivalence.
	    //
	    // [MONT2] "Equivalence with Weierstrass curves".
	    //
	    // Transformation:
	    //
	    //   a = (3 - A^2) / (3 * B^2)
	    //   b = (2 * A^3 - 9 * A) / (27 * B^3)
	    const {a, b, three} = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const b2 = b.redSqr();
	    const b3 = b2.redMul(b);
	    const n0 = three.redSub(a2);
	    const d0 = b2.redMuln(3);
	    const n1 = a3.redMuln(2).redISub(a.redMuln(9));
	    const d1 = b3.redMuln(27);
	    const wa = n0.redDiv(d0);
	    const wb = n1.redDiv(d1);

	    if (a0 != null)
	      return ShortCurve._isomorphism(wa, wb, a0, odd);

	    return [wa, wb];
	  }

	  _mont(b0) {
	    return MontCurve._isomorphism(this.a, this.b, b0);
	  }

	  _edwards(a0, invert = false) {
	    // Montgomery->Twisted Edwards Transformation.
	    //
	    // [MONT1] Page 11, Section 4.3.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //
	    // Equivalence:
	    //
	    //   a = (A + 2) / B
	    //   d = (A - 2) / B
	    //
	    // Isomorphism:
	    //
	    //   a = a'
	    //   d = a' * (A - 2) / (A + 2)
	    //
	    // Where ((A + 2) / (B * a')) is square.
	    //
	    // If `d` is square, we can usually find
	    // a complete curve by using the `invert`
	    // option. This will create an isomorphism
	    // chain of: M(A,B)->E(a,d)->E(d,a).
	    //
	    // The equivalence between E(a,d) and
	    // E(d,a) is:
	    //
	    //   (x, y) = (x, 1 / y)
	    //
	    // Meaning our map to E(d,a) is:
	    //
	    //   x = u / v
	    //   y = 1 / ((u - 1) / (u + 1))
	    //     = (u + 1) / (u - 1)
	    assert(typeof invert === 'boolean');

	    const {two, bi} = this;
	    const a = this.a.redAdd(two).redMul(bi);
	    const d = this.a.redSub(two).redMul(bi);

	    if (invert)
	      a.swap(d);

	    if (a0 != null)
	      return EdwardsCurve._isomorphism(a, d, a0);

	    return [a, d];
	  }

	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);

	    const [u2, u3] = curve._scale(this);

	    return [this.field(u2.redInvert()),
	            this.field(u3.redInvert())];
	  }

	  _scaleMont(curve) {
	    // We can extract the isomorphism factor with:
	    //
	    //   c = +-sqrt(B / B')
	    //
	    // If base points are available, we can do:
	    //
	    //   c = v' / v
	    assert(curve instanceof MontCurve);

	    if (this.g.isInfinity() || curve.g.isInfinity())
	      return this.field(curve.b).redDivSqrt(this.b);

	    return this.g.y.redDiv(this.field(curve.g.y));
	  }

	  _scaleEdwards(curve, invert) {
	    // We _could_ do something like:
	    //
	    //   B = 4 / (a - d)
	    //   c = +-sqrt(B / B')
	    //
	    // Which can be reduced to:
	    //
	    //   c = +-sqrt(4 / ((a - d) * B'))
	    //
	    // If base points are available:
	    //
	    //   v = u' / x
	    //   c = v' / v
	    //
	    // Which can be reduced to:
	    //
	    //   c = v' * x / u'
	    //
	    // However, the way our maps are
	    // written, we can re-use the Edwards
	    // isomorphism factor when going the
	    // other direction.
	    assert(curve instanceof EdwardsCurve);

	    const c = curve._scale(this, invert);

	    return this.field(c);
	  }

	  _solveY0(x) {
	    assert(x instanceof BN);

	    // y^2 = x^3 + A * x^2 + B * x
	    const a = this.a0;
	    const b = this.b0;
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));

	    return y2;
	  }

	  _elligator2(u) {
	    // Elligator 2.
	    //
	    // Distribution: 1/2.
	    //
	    // [ELL2] Page 11, Section 5.2.
	    // [H2EC] "Elligator 2 Method".
	    //        "Mappings for Montgomery curves".
	    // [SAFE] "Indistinguishability from uniform random strings".
	    //
	    // Assumptions:
	    //
	    //   - y^2 = x^3 + A * x^2 + B * x.
	    //   - A != 0, B != 0.
	    //   - A^2 - 4 * B is non-zero and non-square in F(p).
	    //   - Let z be a non-square in F(p).
	    //   - u != +-sqrt(-1 / z).
	    //
	    // Note that Elligator 2 is defined over the form:
	    //
	    //   y'^2 = x'^3 + A' * x'^2 + B' * x'
	    //
	    // Instead of:
	    //
	    //   B * y^2 = x^3 + A * x^2 + x
	    //
	    // Where:
	    //
	    //   A' = A / B
	    //   B' = 1 / B^2
	    //   x' = x / B
	    //   y' = y / B
	    //
	    // And:
	    //
	    //   x = B * x'
	    //   y = B * y'
	    //
	    // This is presumably the result of Elligator 2
	    // being designed in long Weierstrass form. If
	    // we want to support B != 1, we need to do the
	    // conversion.
	    //
	    // Map:
	    //
	    //   g(x) = x^3 + A * x^2 + B * x
	    //   x1 = -A / (1 + z * u^2)
	    //   x1 = -A, if x1 = 0
	    //   x2 = -x1 - A
	    //   x = x1, if g(x1) is square
	    //     = x2, otherwise
	    //   y = sign(u) * abs(sqrt(g(x)))
	    const lhs = this.a0.redNeg();
	    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));

	    if (rhs.isZero())
	      rhs.inject(this.one);

	    const x1 = lhs.redMul(rhs.redInvert());
	    const x2 = x1.redNeg().redISub(this.a0);
	    const y1 = this._solveY0(x1);
	    const y2 = this._solveY0(x2);
	    const alpha = y1.redIsSquare() | 0;
	    const x0 = [x1, x2][alpha ^ 1];
	    const y0 = [y1, y2][alpha ^ 1].redSqrt();

	    if (y0.redIsOdd() !== u.redIsOdd())
	      y0.redINeg();

	    const x = this.b.redMul(x0);
	    const y = this.b.redMul(y0);

	    return this.point(x, y);
	  }

	  _invert2(p, hint) {
	    // Inverting the Map (Elligator 2).
	    //
	    // [ELL2] Page 12, Section 5.3.
	    //
	    // Assumptions:
	    //
	    //   - -z * x * (x + A) is square in F(p).
	    //   - If r = 1 then x != 0.
	    //   - If r = 2 then x != -A.
	    //
	    // Map:
	    //
	    //   u1 = -(x + A) / (x * z)
	    //   u2 = -x / ((x + A) * z)
	    //   r = random integer in [1,2]
	    //   u = sign(y) * abs(sqrt(ur))
	    //
	    // Note that `0 / 0` can only occur if A = 0
	    // (this violates the assumptions of Elligator 2).
	    const {x, y} = p;
	    const r = hint & 1;
	    const x0 = x.redMul(this.bi);
	    const y0 = y.redMul(this.bi);
	    const n = x0.redAdd(this.a0);
	    const d = x0;
	    const lhs = [n, d][r].redINeg();
	    const rhs = [d, n][r].redMul(this.z);
	    const u = lhs.redDivSqrt(rhs);

	    if (u.redIsOdd() !== y0.redIsOdd())
	      u.redINeg();

	    return u;
	  }

	  isElliptic() {
	    const a2 = this.a.redSqr();
	    const d = this.b.redMul(a2.redSub(this.four));

	    // B * (A^2 - 4) != 0
	    return !d.isZero();
	  }

	  jinv() {
	    // [MONT3] Page 3, Section 2.
	    const {a, three, four} = this;
	    const a2 = a.redSqr();
	    const t0 = a2.redSub(three);
	    const lhs = t0.redPown(3).redIMuln(256);
	    const rhs = a2.redSub(four);

	    if (rhs.isZero())
	      throw new Error('Curve is not elliptic.');

	    // (256 * (A^2 - 3)^3) / (A^2 - 4)
	    return lhs.redDiv(rhs).fromRed();
	  }

	  point(x, y) {
	    return new MontPoint(this, x, y);
	  }

	  jpoint(x, y, z) {
	    assert(x == null && y == null && z == null);
	    return this.point();
	  }

	  xpoint(x, z) {
	    return new XPoint(this, x, z);
	  }

	  solveY2(x) {
	    // [MONT3] Page 3, Section 2.
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html
	    assert(x instanceof BN);

	    // B * y^2 = x^3 + A * x^2 + x
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);
	    const y2 = by2.redMul(this.bi);

	    return y2;
	  }

	  validate(point) {
	    assert(point instanceof MontPoint);

	    if (point.isInfinity())
	      return true;

	    const {x, y} = point;
	    const y2 = this.solveY2(x);

	    return y.redSqr().eq(y2);
	  }

	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');

	    if (!x.red)
	      x = x.toRed(this.red);

	    const y = this.solveY(x);

	    if (sign != null) {
	      if (y.isZero() && sign)
	        throw new Error('Invalid point.');

	      if (y.redIsOdd() !== sign)
	        y.redINeg();
	    }

	    return this.point(x, y);
	  }

	  isIsomorphic(curve, invert) {
	    // [MONT3] Page 3, Section 2.1.
	    assert(curve instanceof Curve);

	    if (!curve.p.eq(this.p))
	      return false;

	    // M(A,B) <-> M(A,B')
	    if (curve.type === 'mont') {
	      const a = this.field(curve.a);
	      const b = this.field(curve.b);

	      // A' = A
	      if (!this.a.eq(a))
	        return false;

	      // B' != 0
	      if (this.b.isZero())
	        return false;

	      // jacobi(B / B') = 1
	      const c = b.redDiv(this.b);

	      return c.redJacobi() === 1;
	    }

	    return curve.isIsomorphic(this, invert);
	  }

	  isIsogenous(curve) {
	    assert(curve instanceof Curve);

	    if (curve.type === 'mont')
	      return false;

	    return curve.isIsogenous(this);
	  }

	  pointFromShort(point) {
	    // [ALT] Appendix E.2 (Switching between Alternative Representations).
	    // [MONT2] "Equivalence with Weierstrass curves"
	    assert(point instanceof ShortPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,b)->M(A,B):
	      //
	      //   u = B * x - A / 3
	      //   v = B * y
	      //
	      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
	      if (point.isInfinity())
	        return this.point();

	      const {a3, b} = this;
	      const [u2, u3] = this._scale(point.curve);
	      const x = this.field(point.x).redMul(u2);
	      const y = this.field(point.y).redMul(u3);
	      const u = b.redMul(x).redISub(a3);
	      const v = b.redMul(y);

	      return this.point(u, v);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromMont(point) {
	    // [MONT3] Page 3, Section 2.1.
	    assert(point instanceof MontPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for M(A,B)<->M(A,B'):
	      //
	      //   u' = u
	      //   v' = +-sqrt(B / B') * v
	      //
	      // Undefined if (B / B') is not square.
	      if (point.isInfinity())
	        return this.point();

	      const c = this._scale(point.curve);
	      const u = this.field(point.x);
	      const v = this.field(point.y);
	      const nu = u;
	      const nv = c.redMul(v);

	      return this.point(nu, nv);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromEdwards(point) {
	    // [RFC7748] Section 4.1 & 4.2.
	    // [MONT3] Page 6, Section 2.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    assert(point instanceof EdwardsPoint);
	    assert(point.curve.p.eq(this.p));

	    // Edwards `x`, `y`, `z`.
	    const x = this.field(point.x);
	    const y = this.field(point.y);
	    const z = this.field(point.z);

	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for E(1,d)->M(2-4d,1):
	      //
	      //   u = y^2 / x^2
	      //   v = (2 - x^2 - y^2) * y / x^3
	      //
	      // Undefined for x = 0.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-1, 0) -> (0, 0)
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point(this.zero, this.zero);

	      const c = z.redSqr().redIMuln(2);
	      const uu = y.redSqr();
	      const uz = x.redSqr();
	      const vv = c.redISub(uz).redISub(uu).redMul(y);
	      const vz = uz.redMul(x);

	      return this.cpoint(uu, uz, vv, vz);
	    }

	    if (this.isIsomorphic(point.curve, true)) {
	      // Isomorphic maps for E(d,a)->M(A,B):
	      //
	      //   u = (y + 1) / (y - 1)
	      //   v = +-sqrt((A - 2) / (B * a)) * u / x
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point(this.zero, this.zero);

	      const c = this._scale(point.curve, true);
	      const uu = y.redAdd(z);
	      const uz = y.redSub(z);
	      const vv = c.redMul(z).redMul(uu);
	      const vz = x.redMul(uz);

	      return this.cpoint(uu, uz, vv, vz);
	    }

	    if (this.isIsomorphic(point.curve, false)) {
	      // Isomorphic maps for E(a,d)->M(A,B):
	      //
	      //   u = (1 + y) / (1 - y)
	      //   v = +-sqrt((A + 2) / (B * a)) * u / x
	      //
	      // Undefined for x = 0 or y = 1.
	      //
	      // Exceptional Cases:
	      //   - (0, 1) -> O
	      //   - (0, -1) -> (0, 0)
	      //
	      // Unexceptional Cases:
	      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point(this.zero, this.zero);

	      const c = this._scale(point.curve, false);
	      const uu = z.redAdd(y);
	      const uz = z.redSub(y);
	      const vv = c.redMul(z).redMul(uu);
	      const vz = x.redMul(uz);

	      return this.cpoint(uu, uz, vv, vz);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromUniform(u) {
	    assert(u instanceof BN);

	    // z = 0 or A = 0
	    if (this.z.isZero() || this.a.isZero())
	      throw new Error('Not implemented.');

	    return this._elligator2(u);
	  }

	  pointToUniform(p, hint) {
	    // Convert a montgomery point to a field
	    // element by inverting the elligator2 map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof MontPoint);
	    assert((hint >>> 0) === hint);

	    // z = 0 or A = 0
	    if (this.z.isZero() || this.a.isZero())
	      throw new Error('Not implemented.');

	    // P = O
	    if (p.isInfinity())
	      throw new Error('Invalid point.');

	    // Add a random torsion component.
	    const i = ((hint >>> 4) & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    return wrapErrors(() => {
	      return this._invert2(q, hint);
	    });
	  }

	  decodePoint(bytes, sign) {
	    return MontPoint.decode(this, bytes, sign);
	  }

	  encodeX(point) {
	    assert(point instanceof XPoint);
	    return point.encode();
	  }

	  decodeX(bytes) {
	    return XPoint.decode(this, bytes);
	  }

	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);

	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });

	    if (sign != null) {
	      const [, u3] = curve._scale(this);

	      if (u3.redIsOdd() !== sign)
	        u3.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromMont(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);

	    return curve;
	  }

	  toMont(b0, sign = null) {
	    const [a, b] = this._mont(b0);

	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });

	    if (sign != null) {
	      const c = curve._scale(this);

	      if (c.redIsOdd() !== sign)
	        c.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromMont(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);

	    return curve;
	  }

	  toEdwards(a0, invert, sign = null) {
	    const [a, d] = this._edwards(a0, invert);

	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });

	    if (sign != null) {
	      const c = curve._scale(this, invert);

	      if (c.redIsOdd() !== sign)
	        c.redINeg();
	    }

	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromMont(this.g);
	      curve.g.normalize();
	    }

	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }

	    return curve;
	  }

	  pointFromJSON(json) {
	    return MontPoint.fromJSON(this, json);
	  }

	  toJSON(pre) {
	    const json = super.toJSON(pre);
	    json.a = this.a.fromRed().toJSON();
	    json.b = this.b.fromRed().toJSON();
	    return json;
	  }
	}

	/**
	 * MontPoint
	 */

	class MontPoint extends Point {
	  constructor(curve, x, y) {
	    assert(curve instanceof MontCurve);

	    super(curve, types.AFFINE);

	    this.x = this.curve.zero;
	    this.y = this.curve.zero;
	    this.inf = true;

	    if (x != null)
	      this._init(x, y);
	  }

	  _init(x, y) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);

	    this.x = x;
	    this.y = y;

	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);

	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);

	    this.inf = false;
	  }

	  clone() {
	    if (this.inf)
	      return this.curve.point();

	    return this.curve.point(this.x, this.y);
	  }

	  scale(a) {
	    return this.clone();
	  }

	  randomize(rng) {
	    return this.clone();
	  }

	  neg() {
	    // P = O
	    if (this.inf)
	      return this;

	    // -(X1, Y1) = (X1, -Y1)
	    return this.curve.point(this.x, this.y.redNeg());
	  }

	  add(p) {
	    // [MONT1] Page 8, Section 4.3.2.
	    //
	    // Addition Law:
	    //
	    //   l = (y2 - y1) / (x2 - x1)
	    //   x3 = b * l^2 - a - x1 - x2
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 2M + 1S + 7A + 1*b
	    assert(p instanceof MontPoint);

	    // O + P = P
	    if (this.inf)
	      return p;

	    // P + O = P
	    if (p.inf)
	      return this;

	    // P + P, P + -P
	    if (this.x.eq(p.x)) {
	      // P + -P = O
	      if (!this.y.eq(p.y))
	        return this.curve.point();

	      // P + P = 2P
	      return this.dbl();
	    }

	    // H = X2 - X1
	    const h = p.x.redSub(this.x);

	    // R = Y2 - Y1
	    const r = p.y.redSub(this.y);

	    // L = R / H
	    const l = r.redDiv(h);

	    // K = b * L^2
	    const k = this.curve.b.redMul(l.redSqr());

	    // X3 = K - a - X1 - X2
	    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

	    return this.curve.point(nx, ny);
	  }

	  dbl() {
	    // [MONT1] Page 8, Section 4.3.2.
	    //
	    // Addition Law (doubling):
	    //
	    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)
	    //   x3 = b * l^2 - a - 2 * x1
	    //   y3 = l * (x1 - x3) - y1
	    //
	    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3

	    // P = O
	    if (this.inf)
	      return this;

	    // Y1 = 0
	    if (this.y.isZero())
	      return this.curve.point();

	    // M1 = 3 * X1^2
	    const m1 = this.x.redSqr().redIMuln(3);

	    // M2 = 2 * a * X1
	    const m2 = this.curve.a.redMul(this.x).redIMuln(2);

	    // M = M1 + M2 + 1
	    const m = m1.redIAdd(m2).redIAdd(this.curve.one);

	    // Z = 2 * b * Y1
	    const z = this.curve.b.redMul(this.y).redIMuln(2);

	    // L = M / Z
	    const l = m.redDiv(z);

	    // K = b * L^2
	    const k = this.curve.b.redMul(l.redSqr());

	    // X3 = K - a - 2 * X1
	    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);

	    // Y3 = L * (X1 - X3) - Y1
	    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

	    return this.curve.point(nx, ny);
	  }

	  getX() {
	    if (this.inf)
	      throw new Error('Invalid point.');

	    return this.x.fromRed();
	  }

	  getY() {
	    if (this.inf)
	      throw new Error('Invalid point.');

	    return this.y.fromRed();
	  }

	  eq(p) {
	    assert(p instanceof MontPoint);

	    // P = Q
	    if (this === p)
	      return true;

	    // P = O
	    if (this.inf)
	      return p.inf;

	    // Q = O
	    if (p.inf)
	      return false;

	    // X1 = X2, Y1 = Y2
	    return this.x.eq(p.x)
	        && this.y.eq(p.y);
	  }

	  cmp(point) {
	    assert(point instanceof MontPoint);

	    if (this.inf && !point.inf)
	      return -1;

	    if (!this.inf && point.inf)
	      return 1;

	    if (this.inf && point.inf)
	      return 0;

	    return this.order().cmp(point.order())
	        || this.getX().cmp(point.getX())
	        || this.getY().cmp(point.getY());
	  }

	  isInfinity() {
	    // Infinity cannot be represented in
	    // the affine space, except by a flag.
	    return this.inf;
	  }

	  isOrder2() {
	    if (this.inf)
	      return false;

	    return this.y.isZero();
	  }

	  isOdd() {
	    if (this.inf)
	      return false;

	    return this.y.redIsOdd();
	  }

	  isEven() {
	    if (this.inf)
	      return false;

	    return this.y.redIsEven();
	  }

	  toP() {
	    return this;
	  }

	  toJ() {
	    return this;
	  }

	  toX() {
	    // (X3, Z3) = (1, 0)
	    if (this.inf)
	      return this.curve.xpoint();

	    // (X3, Z3) = (X1, 1)
	    return this.curve.xpoint(this.x, this.curve.one);
	  }

	  encode() {
	    return this.toX().encode();
	  }

	  static decode(curve, bytes, sign) {
	    assert(curve instanceof MontCurve);
	    return curve.decodeX(bytes).toP(sign);
	  }

	  toJSON(pre) {
	    if (this.inf)
	      return [];

	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();

	    return [x, y];
	  }

	  toPretty() {
	    if (this.inf)
	      return [];

	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);

	    return [x, y];
	  }

	  static fromJSON(curve, json) {
	    assert(curve instanceof MontCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0
	        || json.length === 2
	        || json.length === 3);

	    if (json.length === 0)
	      return curve.point();

	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);

	    return curve.point(x, y);
	  }

	  [custom]() {
	    if (this.inf)
	      return '<MontPoint: Infinity>';

	    return '<MontPoint:'
	         + ' x=' + this.x.fromRed().toString(16, 2)
	         + ' y=' + this.y.fromRed().toString(16, 2)
	         + '>';
	  }
	}

	/**
	 * XPoint
	 */

	class XPoint extends Point {
	  constructor(curve, x, z) {
	    assert(curve instanceof MontCurve);

	    super(curve, types.PROJECTIVE);

	    this.x = this.curve.one;
	    this.z = this.curve.zero;

	    if (x != null)
	      this._init(x, z);
	  }

	  _init(x, z) {
	    assert(x instanceof BN);
	    assert(z == null || (z instanceof BN));

	    this.x = x;
	    this.z = z || this.curve.one;

	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);

	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }

	  clone() {
	    return this.curve.xpoint(this.x, this.z);
	  }

	  precompute(power, rng) {
	    // No-op.
	    return this;
	  }

	  validate() {
	    if (this.isInfinity())
	      return true;

	    // B * y^2 * z = x^3 + A * x^2 * z + x * z^2
	    const {x, z} = this;
	    const x2 = x.redSqr();
	    const x3 = x2.redMul(x);
	    const z2 = z.redSqr();
	    const ax2 = this.curve.a.redMul(x2).redMul(z);
	    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));
	    const y2 = by2.redMul(this.curve.bi);

	    // sqrt(y^2 * z^4) = y * z^2
	    return y2.redMul(z).redJacobi() !== -1;
	  }

	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale
	    // 1I + 1M

	    // P = O
	    if (this.isInfinity())
	      return this;

	    // Z1 = 1
	    if (this.z.eq(this.curve.one))
	      return this;

	    // X3 = X1 / Z1
	    this.x = this.x.redDiv(this.z);

	    // Z3 = 1
	    this.z = this.curve.one;

	    return this;
	  }

	  scale(a) {
	    assert(a instanceof BN);

	    // P = O
	    if (this.isInfinity())
	      return this.curve.xpoint();

	    // X3 = X1 * A
	    const nx = this.x.redMul(a);

	    // Y3 = Y1 * A
	    const nz = this.z.redMul(a);

	    return this.curve.xpoint(nx, nz);
	  }

	  neg() {
	    // -(X1, Z1) = (X1, Z1)
	    return this;
	  }

	  dbl() {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	    // 2M + 2S + 4A + 1*a24

	    // A = X1 + Z1
	    const a = this.x.redAdd(this.z);

	    // AA = A^2
	    const aa = a.redSqr();

	    // B = X1 - Z1
	    const b = this.x.redSub(this.z);

	    // BB = B^2
	    const bb = b.redSqr();

	    // C = AA - BB
	    const c = aa.redSub(bb);

	    // X3 = AA * BB
	    const nx = aa.redMul(bb);

	    // Z3 = C * (BB + a24 * C)
	    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));

	    return this.curve.xpoint(nx, nz);
	  }

	  diffAddDbl(p2, p3) {
	    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3
	    // 6M + 4S + 8A + 1*a24
	    assert(p2 instanceof XPoint);
	    assert(p3 instanceof XPoint);

	    // A = X2 + Z2
	    const a = p2.x.redAdd(p2.z);

	    // AA = A^2
	    const aa = a.redSqr();

	    // B = X2 - Z2
	    const b = p2.x.redSub(p2.z);

	    // BB = B^2
	    const bb = b.redSqr();

	    // E = AA - BB
	    const e = aa.redSub(bb);

	    // C = X3 + Z3
	    const c = p3.x.redAdd(p3.z);

	    // D = X3 - Z3
	    const d = p3.x.redSub(p3.z);

	    // DA = D * A
	    const da = d.redMul(a);

	    // CB = C * B
	    const cb = c.redMul(b);

	    // X5 = Z1 * (DA + CB)^2
	    const x5 = this.z.redMul(da.redAdd(cb).redSqr());

	    // Z5 = X1 * (DA - CB)^2
	    const z5 = this.x.redMul(da.redISub(cb).redSqr());

	    // X4 = AA * BB
	    const x4 = aa.redMul(bb);

	    // Z4 = E * (BB + a24 * E)
	    const z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));

	    return [
	      this.curve.xpoint(x4, z4),
	      this.curve.xpoint(x5, z5)
	    ];
	  }

	  getX() {
	    if (this.isInfinity())
	      throw new Error('Invalid point.');

	    this.normalize();

	    return this.x.fromRed();
	  }

	  getY(sign) {
	    return this.toP(sign).getY();
	  }

	  eq(p) {
	    assert(p instanceof XPoint);

	    // P = Q
	    if (this === p)
	      return true;

	    // P = O
	    if (this.isInfinity())
	      return p.isInfinity();

	    // Q = O
	    if (p.isInfinity())
	      return false;

	    // Z1 = Z2
	    if (this.z.eq(p.z))
	      return this.x.eq(p.x);

	    // X1 * Z2 = X2 * Z1
	    const x1 = this.x.redMul(p.z);
	    const x2 = p.x.redMul(this.z);

	    return x1.eq(x2);
	  }

	  cmp(point) {
	    assert(point instanceof XPoint);

	    const inf1 = this.isInfinity();
	    const inf2 = point.isInfinity();

	    if (inf1 && !inf2)
	      return -1;

	    if (!inf1 && inf2)
	      return 1;

	    if (inf1 && inf2)
	      return 0;

	    return this.order().cmp(point.order())
	        || this.getX().cmp(point.getX());
	  }

	  isInfinity() {
	    // Z1 = 0
	    return this.z.isZero();
	  }

	  isOrder2() {
	    if (this.isInfinity())
	      return false;

	    return this.x.isZero();
	  }

	  isOdd() {
	    return false;
	  }

	  isEven() {
	    return false;
	  }

	  hasTorsion() {
	    if (this.isInfinity())
	      return false;

	    // X1 = 0, Z1 != 0 (edge case)
	    if (this.x.isZero())
	      return true;

	    return super.hasTorsion();
	  }

	  order() {
	    try {
	      return this.toP().order();
	    } catch (e) {
	      return new BN(1);
	    }
	  }

	  jmul(k) {
	    // Multiply with the Montgomery Ladder.
	    //
	    // [MONT3] Algorithm 4, Page 12, Section 4.2.
	    //
	    // Note that any clamping is meant to
	    // be done _outside_ of this function.
	    assert(k instanceof BN);
	    assert(!k.red);

	    const bits = k.bitLength();

	    let a = this.curve.xpoint();
	    let b = this;

	    for (let i = bits - 1; i >= 0; i--) {
	      const bit = k.bit(i);

	      if (bit === 0)
	        [a, b] = this.diffAddDbl(a, b);
	      else
	        [b, a] = this.diffAddDbl(b, a);
	    }

	    return a;
	  }

	  jmulBlind(k, rng) {
	    if (!rng)
	      return this.jmul(k);

	    // Randomize if available.
	    return this.randomize(rng).jmul(k);
	  }

	  jmulAdd(k1, p2, k2) {
	    throw new Error('Not implemented.');
	  }

	  toP(sign = null) {
	    assert(sign == null || typeof sign === 'boolean');

	    if (this.isInfinity())
	      return this.curve.point();

	    this.normalize();

	    return this.curve.pointFromX(this.x, sign);
	  }

	  toJ() {
	    return this;
	  }

	  toX() {
	    return this;
	  }

	  key() {
	    if (this.isInfinity())
	      return `${this.curve.uid}:oo`;

	    this.normalize();

	    const x = this.getX().toString(16);

	    return `${this.curve.uid}:${x}`;
	  }

	  encode() {
	    // [RFC7748] Section 5.
	    return this.curve.encodeField(this.getX());
	  }

	  static decode(curve, bytes) {
	    assert(curve instanceof MontCurve);

	    // [RFC7748] Section 5.
	    const x = curve.decodeField(bytes);

	    // We're supposed to ignore the hi bit
	    // on montgomery points... I think. If
	    // we don't, the X25519 test vectors
	    // break, which is pretty convincing
	    // evidence. This is a no-op for X448.
	    x.iumaskn(curve.fieldBits);

	    // Note: montgomery points are meant to be
	    // reduced by the prime and do not have to
	    // be explicitly validated in order to do
	    // the montgomery ladder.
	    const p = curve.xpoint(x, curve.one);

	    assert(!p.isInfinity());

	    return p;
	  }

	  toJSON(pre) {
	    return this.toP().toJSON(pre);
	  }

	  toPretty() {
	    return this.toP().toPretty();
	  }

	  static fromJSON(curve, json) {
	    return MontPoint.fromJSON(curve, json).toX();
	  }

	  [custom]() {
	    if (this.isInfinity())
	      return '<XPoint: Infinity>';

	    return '<XPoint:'
	        + ' x=' + this.x.fromRed().toString(16, 2)
	        + ' z=' + this.z.fromRed().toString(16, 2)
	        + '>';
	  }
	}

	/**
	 * EdwardsCurve
	 */

	class EdwardsCurve extends Curve {
	  constructor(conf) {
	    super(EdwardsPoint, 'edwards', conf);

	    this.a = BN.fromJSON(conf.a).toRed(this.red);
	    this.d = BN.fromJSON(conf.d).toRed(this.red);
	    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);
	    this.si = this.s.isZero() ? this.zero : this.s.redInvert();

	    this.k = this.d.redMuln(2);
	    this.smi = -this.d.redNeg().word(0);
	    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);

	    this.twisted = !this.a.eq(this.one);
	    this.oneA = this.a.eq(this.one);
	    this.mOneA = this.a.eq(this.one.redNeg());
	    this.smallD = this.prime != null && this.d.redNeg().length === 1;
	    this.alt = null;

	    this._finalize(conf);
	  }

	  static _isomorphism(curveA, curveD, customA) {
	    // Twisted Edwards Isomorphism.
	    //
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    //
	    // Transformation:
	    //
	    //   a' = a'
	    //   d' = a' * d / a
	    //
	    // Where (a / a') is square.
	    assert(curveA instanceof BN);
	    assert(curveD instanceof BN);
	    assert(customA instanceof BN);

	    const a = customA.clone();
	    const d = customA.redMul(curveD).redDiv(curveA);
	    const c = curveA.redDiv(customA);

	    if (c.redJacobi() !== 1)
	      throw new Error('Invalid `a` coefficient.');

	    return [a, d];
	  }

	  _short(a0, odd) {
	    // Twisted Edwards->Short Weierstrass Equivalence.
	    //
	    // [TWISTEQ] Section 2.
	    //
	    // Transformation:
	    //
	    //   a' = -(a^2 + 14 * a * d + d^2) / 48
	    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864
	    const {a, d} = this;
	    const a2 = a.redSqr();
	    const a3 = a2.redMul(a);
	    const d2 = d.redSqr();
	    const d3 = d2.redMul(d);
	    const ad14 = a.redMul(d).redIMuln(14);
	    const a2d = a2.redMul(d);
	    const ad2 = a.redMul(d2);
	    const t0 = a2d.redIAdd(ad2).redIMuln(33);
	    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);
	    const wb = t0.redISub(a3).redISub(d3).redDivn(864);

	    if (a0 != null)
	      return ShortCurve._isomorphism(wa, wb, a0, odd);

	    return [wa, wb];
	  }

	  _mont(b0, invert = false) {
	    // Twisted Edwards->Montgomery Transformation.
	    //
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //
	    // Equivalence:
	    //
	    //   A = 2 * (a + d) / (a - d)
	    //   B = 4 / (a - d)
	    //
	    // Isomorphism:
	    //
	    //   A = 2 * (a + d) / (a - d)
	    //   B = B'
	    //
	    // Where ((4 / (a - d)) / B') is square.
	    //
	    // If `4 / (a - d)` is non-square, we can
	    // usually force B=1 by using the `invert`
	    // option. This will create an isomorphism
	    // chain of: E(a,d)->E(d,a)->M(-A,-B).
	    //
	    // The equivalence between E(a,d) and E(d,a)
	    // is:
	    //
	    //   (x, y) = (x, 1 / y)
	    //
	    // Meaning our map to M(-A,-B) is:
	    //
	    //   u = (1 + 1 / y) / (1 - 1 / y)
	    //     = (y + 1) / (y - 1)
	    //   v = u / x
	    assert(typeof invert === 'boolean');

	    let apd, amd;

	    if (invert) {
	      apd = this.d.redAdd(this.a);
	      amd = this.d.redSub(this.a);
	    } else {
	      apd = this.a.redAdd(this.d);
	      amd = this.a.redSub(this.d);
	    }

	    const z = amd.redInvert();
	    const a = apd.redMuln(2).redMul(z);
	    const b = z.redMuln(4);

	    if (b0 != null)
	      return MontCurve._isomorphism(a, b, b0);

	    return [a, b];
	  }

	  _edwards(a0) {
	    return EdwardsCurve._isomorphism(this.a, this.d, a0);
	  }

	  _scaleShort(curve) {
	    assert(curve instanceof ShortCurve);

	    const [u2, u3] = curve._scale(this);

	    return [this.field(u2.redInvert()),
	            this.field(u3.redInvert())];
	  }

	  _scaleMont(curve, invert = false) {
	    // Calculate isomorphism factor between
	    // Twisted Edwards and Montgomery with:
	    //
	    //   a = (A + 2) / B
	    //   c = +-sqrt(a / a')
	    //
	    // Which can be reduced to:
	    //
	    //   c = +-sqrt((A + 2) / (B * a'))
	    //
	    // If base points are available, we can do:
	    //
	    //   x = u / v
	    //   c = x' / x
	    //
	    // Which can be reduced to:
	    //
	    //   c = v * x' / u
	    //
	    // We can now calculate the Edwards `x` with:
	    //
	    //   x' = c * u / v
	    //
	    // And likewise, the Montgomery `v`:
	    //
	    //   v = c * u / x'
	    assert(curve instanceof MontCurve);
	    assert(typeof invert === 'boolean');

	    if (this.g.isInfinity() || curve.g.isInfinity()) {
	      const [a] = curve._edwards(null, invert);

	      return this.field(a).redDivSqrt(this.a);
	    }

	    const x = curve.g.x.redDiv(curve.g.y);

	    return this.g.x.redDiv(this.field(x));
	  }

	  _scaleEdwards(curve) {
	    // We can extract the isomorphism factor with:
	    //
	    //   c = +-sqrt(a / a')
	    //
	    // If base points are available, we can do:
	    //
	    //   c = x' / x
	    assert(curve instanceof EdwardsCurve);

	    if (this.g.isInfinity() || curve.g.isInfinity())
	      return this.field(curve.a).redDivSqrt(this.a);

	    return this.g.x.redDiv(this.field(curve.g.x));
	  }

	  _mulA(num) {
	    assert(num instanceof BN);

	    // n * a = n
	    if (this.oneA)
	      return num.clone();

	    // n * a = -n
	    if (this.mOneA)
	      return num.redNeg();

	    return this.a.redMul(num);
	  }

	  _mulD(num) {
	    assert(num instanceof BN);

	    // -d < 0x4000000
	    if (this.smallD)
	      return num.redMuln(this.smi);

	    return this.d.redMul(num);
	  }

	  _elligator1(t) {
	    // Elligator 1.
	    //
	    // Distribution: 1/2.
	    //
	    // [ELL1] Page 6, Section 3.
	    //        Page 15, Appendix A.
	    // [ELL2] Page 7, Section 3.2.
	    //
	    // Assumptions:
	    //
	    //   - Let p be a prime power congruent to 3 mod 4.
	    //   - Let s be a nonzero element of F(p).
	    //   - Let c = 2 / s^2.
	    //   - Let r = c + 1 / c.
	    //   - Let d = -(c + 1)^2 / (c - 1)^2.
	    //   - (s^2 - 2) * (s^2 + 2) != 0.
	    //   - c * (c - 1) * (c + 1) != 0.
	    //   - r != 0.
	    //   - d is not square.
	    //   - x^2 + y^2 = 1 + d * x^2 * y^2.
	    //   - u * v * X * Y * x * (Y + 1) != 0.
	    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.
	    //
	    // Elligator 1, as devised by Fouque et al,
	    // takes place on the hyperelliptic curve of:
	    //
	    //   y^2 = x^5 + (r^2 - 2) * x^3 + x
	    //
	    // Not only must our Edwards curve be complete,
	    // with a prime congruent to 3 mod 4, and a = 1,
	    // our curve must be isomorphic to a hyperelliptic
	    // curve of the above form. Roughly one half of
	    // all Edwards curves are isomorphic to a curve
	    // of said form.
	    //
	    // We can derive the isomorphism with:
	    //
	    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)
	    //   s = +-sqrt(2 / c)
	    //   r = c + 1 / c
	    //
	    // Note that even if your curve is an Elligator 1
	    // curve, Elligator 2 is probably still preferable,
	    // as it has nearly the same properties (i.e. the
	    // same distribution), and is much less complex.
	    //
	    // Map:
	    //
	    //   f(a) = a^((p - 1) / 2)
	    //   u = (1 - t) / (1 + t)
	    //   v = u^5 + (r^2 - 2) * u^3 + u
	    //   X = f(v) * u
	    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)
	    //   Y = 1, if u = 0
	    //   x = (c - 1) * s * X * (1 + X) / Y
	    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)
	    //
	    // When t = +-1, we create the hyperelliptic
	    // 2-torsion point of (0, 0). This needs to be
	    // mapped to (0, -1) in Edwards form, but the x
	    // denominator becomes zero. As far as I can
	    // tell, this is the only exceptional case.
	    //
	    // The only other exceptional case initially
	    // appears to be when the y denominator sums to
	    // zero (when t = sqrt(4 / r + 1)), however, the
	    // hyperelliptic `X` is negated by the sign of
	    // `v`, making this impossible.
	    const {s, si, i2, one, two} = this;
	    const c = si.redSqr().redIMuln(2);
	    const ci = s.redSqr().redMul(i2);
	    const ci2 = ci.redSqr();
	    const r = c.redAdd(ci);
	    const r2 = r.redSqr().redISub(two);
	    const cm1 = c.redSub(one);
	    const uu = one.redSub(t);
	    const uz = one.redAdd(t);
	    const u = uz.isZero() ? uz : uu.redDiv(uz);
	    const u2 = u.redSqr();
	    const u3 = u2.redMul(u);
	    const u5 = u3.redMul(u2);
	    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);
	    const f0 = this.field(v.redJacobi());
	    const f1 = this.field(u2.redAdd(ci2).redJacobi());
	    const f2 = f0.redMul(f1);
	    const X = f0.redMul(u);
	    const Y = f0.redMul(v).redSqrt().redMul(f2);
	    const X1 = one.redAdd(X);
	    const rX = r.redMul(X);
	    const X12 = X1.redSqr();
	    const xx = cm1.redMul(s).redMul(X).redMul(X1);
	    const xz = u.isZero() ? this.one : Y;
	    const yy = rX.redSub(X12);
	    const yz = rX.redAdd(X12);

	    return this.cpoint(xx, xz, yy, yz);
	  }

	  _invert1(p, hint) {
	    // Inverting the Map (Elligator 1).
	    //
	    // [ELL1] Page 6, Section 3.
	    //        Page 15, Appendix A.
	    // [ELL2] Page 7, Section 3.3.
	    //
	    // Assumptions:
	    //
	    //   - y + 1 != 0.
	    //   - (1 + n * r)^2 - 1 is square in F(p).
	    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.
	    //   - Y = (c - 1) * s * X * (1 + X) / x.
	    //
	    // Map:
	    //
	    //   f(a) = a^((p - 1) / 2)
	    //   n = (y - 1) / (2 * (y + 1))
	    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)
	    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))
	    //   u = z * X
	    //   t = (1 - u) / (1 + u)
	    const {s, si, i2, one} = this;
	    const {x, y, z} = p;
	    const sign = hint & 1;
	    const c = si.redSqr().redIMuln(2);
	    const ci = s.redSqr().redMul(i2);
	    const ci2 = ci.redSqr();
	    const r = c.redAdd(ci);
	    const cm1 = c.redSub(one);
	    const nn = y.redSub(z);
	    const nz = y.redAdd(z).redIMuln(2);
	    const n = nz.isZero() ? nz : nn.redDiv(nz);
	    const nr1 = one.redAdd(n.redMul(r));
	    const w2 = nr1.redSqr().redISub(one);
	    const w = w2.redSqrt();
	    const X = w.redSub(nr1);
	    const X1 = one.redAdd(X);
	    const YY = cm1.redMul(s).redMul(X).redMul(X1);
	    const Y = YY.redMul(x.redMul(z));
	    const X2 = X.redSqr().redIAdd(ci2);
	    const Z = this.field(Y.redMul(X2).redJacobi());
	    const u = Z.redMul(X);
	    const tt = one.redSub(u);
	    const tz = one.redAdd(u);
	    const t = tz.isZero() ? tz : tt.redDiv(tz);

	    if (t.redIsOdd() !== Boolean(sign))
	      t.redINeg();

	    return t;
	  }

	  _alt() {
	    if (!this.alt)
	      this.alt = this.toMont();

	    return this.alt;
	  }

	  isElliptic() {
	    const ad = this.a.redMul(this.d);
	    const amd = this.a.redSub(this.d);

	    // a * d * (a - d) != 0
	    return !ad.redMul(amd).isZero();
	  }

	  jinv() {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    const {a, d} = this;
	    const ad = a.redMul(d);
	    const amd4 = a.redSub(d).redPown(4);
	    const a2 = a.redSqr();
	    const d2 = d.redSqr();
	    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);
	    const lhs = t0.redPown(3).redIMuln(16);
	    const rhs = ad.redMul(amd4);

	    if (rhs.isZero())
	      throw new Error('Curve is not elliptic.');

	    // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)
	    return lhs.redDiv(rhs).fromRed();
	  }

	  isComplete() {
	    return this.a.redJacobi() === 1
	        && this.d.redJacobi() === -1;
	  }

	  point(x, y, z, t) {
	    return new EdwardsPoint(this, x, y, z, t);
	  }

	  jpoint(x, y, z) {
	    assert(x == null && y == null && z == null);
	    return this.point();
	  }

	  cpoint(xx, xz, yy, yz) {
	    assert(xx instanceof BN);
	    assert(xz instanceof BN);
	    assert(yy instanceof BN);
	    assert(yz instanceof BN);

	    const x = xx.redMul(yz);
	    const y = yy.redMul(xz);
	    const z = xz.redMul(yz);
	    const t = xx.redMul(yy);

	    return this.point(x, y, z, t);
	  }

	  solveX2(y) {
	    // [RFC8032] Section 5.1.3 & 5.2.3.
	    assert(y instanceof BN);

	    // x^2 = (y^2 - 1) / (d * y^2 - a)
	    const y2 = y.redSqr();
	    const rhs = this._mulD(y2).redISub(this.a);
	    const lhs = y2.redISub(this.one);
	    const x2 = lhs.redDiv(rhs);

	    return x2;
	  }

	  solveX(y) {
	    // Optimize with inverse square root trick.
	    //
	    // Note that `0 / 0` can only occur if
	    // `a == d` (i.e. the curve is singular).
	    const y2 = y.redSqr();
	    const rhs = this._mulD(y2).redISub(this.a);
	    const lhs = y2.redISub(this.one);

	    return lhs.redDivSqrt(rhs);
	  }

	  solveY2(x) {
	    assert(x instanceof BN);

	    // y^2 = (a * x^2 - 1) / (d * x^2 - 1)
	    const x2 = x.redSqr();
	    const lhs = this._mulA(x2).redISub(this.one);
	    const rhs = this._mulD(x2).redISub(this.one);
	    const y2 = lhs.redDiv(rhs);

	    return y2;
	  }

	  solveY(x) {
	    // Optimize with inverse square root trick.
	    //
	    // Note that `0 / 0` can only occur if
	    // `a == d` (i.e. the curve is singular).
	    const x2 = x.redSqr();
	    const lhs = this._mulA(x2).redISub(this.one);
	    const rhs = this._mulD(x2).redISub(this.one);

	    return lhs.redDivSqrt(rhs);
	  }

	  validate(point) {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    //           Page 11, Section 6.
	    assert(point instanceof EdwardsPoint);

	    // Z1 = 1
	    if (point.zOne) {
	      // a * x^2 + y^2 = 1 + d * x^2 * y^2
	      const x2 = point.x.redSqr();
	      const y2 = point.y.redSqr();
	      const dxy = this._mulD(x2).redMul(y2);
	      const lhs = this._mulA(x2).redIAdd(y2);
	      const rhs = this.one.redAdd(dxy);
	      const tz = point.t;
	      const xy = point.x.redMul(point.y);

	      return lhs.eq(rhs) && tz.eq(xy);
	    }

	    // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2
	    const x2 = point.x.redSqr();
	    const y2 = point.y.redSqr();
	    const z2 = point.z.redSqr();
	    const z4 = z2.redSqr();
	    const dxy = this._mulD(x2).redMul(y2);
	    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);
	    const rhs = z4.redIAdd(dxy);
	    const tz = point.t.redMul(point.z);
	    const xy = point.x.redMul(point.y);

	    return lhs.eq(rhs) && tz.eq(xy);
	  }

	  pointFromX(x, sign = null) {
	    assert(x instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');

	    if (!x.red)
	      x = x.toRed(this.red);

	    const y = this.solveY(x);

	    if (sign != null) {
	      if (y.isZero() && sign)
	        throw new Error('Invalid point.');

	      if (y.redIsOdd() !== sign)
	        y.redINeg();
	    }

	    return this.point(x, y);
	  }

	  pointFromY(y, sign = null) {
	    assert(y instanceof BN);
	    assert(sign == null || typeof sign === 'boolean');

	    if (!y.red)
	      y = y.toRed(this.red);

	    const x = this.solveX(y);

	    if (sign != null) {
	      if (x.isZero() && sign)
	        throw new Error('Invalid point.');

	      if (x.redIsOdd() !== sign)
	        x.redINeg();
	    }

	    return this.point(x, y);
	  }

	  isIsomorphic(curve, invert = false) {
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    //           Definition 2.1, Page 3, Section 2.
	    assert(curve instanceof Curve);
	    assert(typeof invert === 'boolean');

	    if (!curve.p.eq(this.p))
	      return false;

	    // E(a,d) <-> E(a,b)
	    if (curve.type === 'short')
	      return curve.isIsomorphic(this);

	    // E(a,d) <-> M(A,B)
	    // E(a,d) <-> M(-A,-B)
	    if (curve.type === 'mont') {
	      // A * (a - d) = 2 * (a + d)
	      const a = this.field(curve.a);

	      let apd, amd;

	      if (invert) {
	        apd = this.d.redAdd(this.a);
	        amd = this.d.redSub(this.a);
	      } else {
	        apd = this.a.redAdd(this.d);
	        amd = this.a.redSub(this.d);
	      }

	      return a.redMul(amd).eq(apd.redIMuln(2));
	    }

	    // E(a,d) <-> E(a',a'd/a)
	    if (curve.type === 'edwards') {
	      // a' * d = a * d'
	      const a = this.field(curve.a);
	      const d = this.field(curve.d);

	      return this.a.redMul(d).eq(a.redMul(this.d));
	    }

	    return false;
	  }

	  isIsogenous(curve) {
	    // Check for the 4-isogenies described by Hamburg:
	    // https://moderncrypto.org/mail-archive/curves/2016/000806.html
	    assert(curve instanceof Curve);

	    if (!curve.p.eq(this.p))
	      return false;

	    // E(1,d) <-> M(2-4d,1)
	    if (curve.type === 'mont') {
	      if (!this.a.eq(this.one))
	        return false;

	      const a = this.field(curve.a);
	      const b = this.field(curve.b);
	      const d24 = this.two.redSub(this.d.redMuln(4));

	      return a.eq(d24) && b.eq(this.one);
	    }

	    // E(a,d) <-> E(-a,d-a)
	    if (curve.type === 'edwards') {
	      const a = this.field(curve.a);
	      const d = this.field(curve.d);

	      return a.eq(this.a.redNeg())
	          && d.eq(this.d.redSub(this.a));
	    }

	    return false;
	  }

	  pointFromShort(point) {
	    // [TWISTEQ] Section 1.
	    assert(point instanceof ShortPoint);

	    if (this.isIsomorphic(point.curve)) {
	      // Equivalence for E(a,b)->E(a',d'):
	      //
	      //   x' = (6 * x - a' - d') / (6 * y)
	      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')
	      //
	      // Undefined for x = (5 * d' - a') / 12 or y = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - ((a' + d') / 6, 0) -> (0, -1)
	      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)
	      //
	      // Unexceptional Cases:
	      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)
	      if (point.isInfinity())
	        return this.point();

	      if (point.y.isZero())
	        return this.point(this.zero, this.one.redNeg());

	      const {a, d} = this;
	      const [u2, u3] = this._scale(point.curve);
	      const a5 = a.redMuln(5);
	      const d5 = d.redMuln(5);
	      const x = this.field(point.x).redMul(u2);
	      const y = this.field(point.y).redMul(u3);
	      const x6 = x.redMuln(6);
	      const x12 = x.redMuln(12);
	      const xx = x6.redSub(a).redISub(d);
	      const xz = y.redMuln(6);
	      const yy = x12.redSub(a5).redIAdd(d);
	      const yz = x12.redAdd(a).redISub(d5);

	      return this.cpoint(xx, xz, yy, yz);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromMont(point) {
	    // [RFC7748] Section 4.1 & 4.2.
	    // [MONT3] Page 6, Section 2.5.
	    // [TWISTED] Theorem 3.2, Page 4, Section 3.
	    assert(point instanceof MontPoint);
	    assert(point.curve.p.eq(this.p));

	    // Montgomery `u`, `v`.
	    const u = this.field(point.x);
	    const v = this.field(point.y);

	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for M(2-4d,1)->E(1,d):
	      //
	      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)
	      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /
	      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)
	      //
	      // Undefined for u = 0 and v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, 1)
	      //
	      // Unexceptional Cases:
	      //   - (-1, +-sqrt(A - 2)) -> (0, 1)
	      //   - (1, +-sqrt(A + 2)) -> (0, -1)
	      //
	      // The point (1, v) is invalid on Curve448.
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point();

	      const u2 = u.redSqr();
	      const u3 = u2.redMul(u);
	      const u4 = u3.redMul(u);
	      const u5 = u4.redMul(u);
	      const v2 = v.redSqr();
	      const a = v.redMuln(4);
	      const b = u2.redSub(this.one);
	      const c = u2.redMuln(2);
	      const d = v2.redMuln(4);
	      const e = u3.redIMuln(2);
	      const f = u.redMul(v2).redIMuln(4);
	      const g = u2.redMul(v2).redIMuln(2);
	      const h = v2.redIMuln(2);
	      const xx = a.redMul(b);
	      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);
	      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();
	      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);

	      return this.cpoint(xx, xz, yy, yz).divn(4);
	    }

	    if (this.isIsomorphic(point.curve, true)) {
	      // Isomorphic maps for M(-A,-B)->E(a,d):
	      //
	      //   x = +-sqrt((A - 2) / (B * a)) * u / v
	      //   y = (u + 1) / (u - 1)
	      //
	      // Undefined for u = 1 or v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, -1)
	      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)
	      //
	      // Unexceptional Cases:
	      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)
	      //
	      // The point (1, v) is invalid on Curve448.
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point(this.zero, this.one.redNeg());

	      const c = this._scale(point.curve, true);
	      const xx = c.redMul(u);
	      const xz = v;
	      const yy = u.redAdd(this.one);
	      const yz = u.redSub(this.one);

	      return this.cpoint(xx, xz, yy, yz);
	    }

	    if (this.isIsomorphic(point.curve, false)) {
	      // Isomorphic maps for M(A,B)->E(a,d):
	      //
	      //   x = +-sqrt((A + 2) / (B * a)) * u / v
	      //   y = (u - 1) / (u + 1)
	      //
	      // Undefined for u = -1 or v = 0.
	      //
	      // Exceptional Cases:
	      //   - O -> (0, 1)
	      //   - (0, 0) -> (0, -1)
	      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)
	      //
	      // Unexceptional Cases:
	      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)
	      //
	      // The point (-1, v) is invalid on Curve25519.
	      if (point.isInfinity())
	        return this.point();

	      if (point.x.isZero())
	        return this.point(this.zero, this.one.redNeg());

	      const c = this._scale(point.curve, false);
	      const xx = c.redMul(u);
	      const xz = v;
	      const yy = u.redSub(this.one);
	      const yz = u.redAdd(this.one);

	      return this.cpoint(xx, xz, yy, yz);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromEdwards(point) {
	    // [TWISTED] Definition 2.1, Page 3, Section 2.
	    // [ISOGENY] Page 2, Section 2.
	    assert(point instanceof EdwardsPoint);
	    assert(point.curve.p.eq(this.p));

	    // Edwards `x`, `y`, `z`, `t`.
	    const a = this.field(point.curve.a);
	    const x = this.field(point.x);
	    const y = this.field(point.y);
	    const z = this.field(point.z);
	    const t = this.field(point.t);

	    if (this.isIsogenous(point.curve)) {
	      // 4-isogeny maps for E(a,d)<->E(-a,d-a):
	      //
	      //   x' = (2 * x * y) / (y^2 - a * x^2)
	      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)
	      //
	      // Undefined for y^2 - a * x^2 = 0
	      //            or y^2 + a * x^2 = 2.
	      const xy = x.redMul(y);
	      const x2 = x.redSqr();
	      const y2 = y.redSqr();
	      const z2 = z.redSqr();
	      const ax2 = a.redMul(x2);
	      const xx = xy.redIMuln(2);
	      const xz = y2.redSub(ax2);
	      const yy = y2.redAdd(ax2);
	      const yz = z2.redIMuln(2).redISub(yy);
	      const p = this.cpoint(xx, xz, yy, yz);

	      return !this.twisted ? p.divn(4) : p;
	    }

	    if (this.isIsomorphic(point.curve)) {
	      // Isomorphic maps for E(a,d)<->E(a',a'd/a):
	      //
	      //   x' = +-sqrt(a / a') * x
	      //   y' = y
	      //
	      // Undefined when (a / a') is not square.
	      const c = this._scale(point.curve);
	      const nx = c.redMul(x);
	      const ny = y;
	      const nz = z;
	      const nt = c.redMul(t);

	      return this.point(nx, ny, nz, nt);
	    }

	    throw new Error('Not implemented.');
	  }

	  pointFromUniform(u, curve = null) {
	    assert(u instanceof BN);
	    assert(u.red === this.red);
	    assert(curve == null || (curve instanceof MontCurve));

	    if (!curve)
	      curve = this._alt();

	    const u0 = curve.field(u);
	    const p0 = curve.pointFromUniform(u0);

	    return this.pointFromMont(p0);
	  }

	  pointToUniform(p, hint, curve = null) {
	    // Convert an edwards point to a field
	    // element by inverting the elligator2 map.
	    //
	    // Hint Layout:
	    //
	    //   [00000000] [0000] [0000]
	    //        |        |      |
	    //        |        |      +-- preimage index
	    //        |        +--- subgroup
	    //        +-- bits to OR with uniform bytes
	    assert(p instanceof EdwardsPoint);
	    assert((hint >>> 0) === hint);
	    assert(curve == null || (curve instanceof MontCurve));

	    if (!curve)
	      curve = this._alt();

	    // Add a random torsion component.
	    const i = ((hint >> 4) & 15) % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    // Convert and invert.
	    const p0 = curve.pointFromEdwards(q);
	    const u0 = curve.pointToUniform(p0, hint & 15);

	    return this.field(u0);
	  }

	  pointFromHash(bytes, pake, curve = null) {
	    assert(curve == null || (curve instanceof MontCurve));

	    if (!curve)
	      curve = this._alt();

	    const p0 = curve.pointFromHash(bytes, pake);

	    return this.pointFromMont(p0);
	  }

	  pointToHash(p, subgroup, rng, curve = null) {
	    assert(p instanceof EdwardsPoint);
	    assert((subgroup >>> 0) === subgroup);
	    assert(curve == null || (curve instanceof MontCurve));

	    if (!curve)
	      curve = this._alt();

	    // Add a random torsion component.
	    const i = subgroup % this.torsion.length;
	    const q = p.add(this.torsion[i]);

	    // Convert and invert.
	    const p0 = curve.pointFromEdwards(q);

	    return curve.pointToHash(p0, 0, rng);
	  }

	  decodePoint(bytes) {
	    return EdwardsPoint.decode(this, bytes);
	  }

	  toShort(a0, odd, sign = null) {
	    const [a, b] = this._short(a0, odd);

	    const curve = new ShortCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h
	    });

	    if (sign != null) {
	      const [, u3] = curve._scale(this);

	      if (u3.redIsOdd() !== sign)
	        u3.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromEdwards(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);

	    return curve;
	  }

	  toMont(b0, invert, sign = null) {
	    const [a, b] = this._mont(b0, invert);

	    const curve = new MontCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      b: b,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });

	    if (sign != null) {
	      const c = this._scale(curve, invert);

	      if (c.redIsOdd() !== sign)
	        c.redINeg();
	    }

	    if (!this.g.isInfinity())
	      curve.g = curve.pointFromEdwards(this.g);

	    for (let i = 0; i < this.h.word(0); i++)
	      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);

	    return curve;
	  }

	  toEdwards(a0, sign = null) {
	    const [a, d] = this._edwards(a0);

	    const curve = new EdwardsCurve({
	      red: this.red,
	      prime: this.prime,
	      p: this.p,
	      a: a,
	      d: d,
	      n: this.n,
	      h: this.h,
	      z: this.z
	    });

	    if (sign != null) {
	      const c = curve._scale(this);

	      if (c.redIsOdd() !== sign)
	        c.redINeg();
	    }

	    if (!this.g.isInfinity()) {
	      curve.g = curve.pointFromEdwards(this.g);
	      curve.g.normalize();
	    }

	    if (curve.isComplete()) {
	      for (let i = 0; i < this.h.word(0); i++) {
	        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
	        curve.torsion[i].normalize();
	      }
	    }

	    return curve;
	  }

	  pointFromJSON(json) {
	    return EdwardsPoint.fromJSON(this, json);
	  }

	  toJSON(pre) {
	    const json = super.toJSON(pre);

	    json.a = this.a.fromRed().toJSON();
	    json.d = this.d.fromRed().toJSON();

	    if (!this.s.isZero())
	      json.s = this.s.fromRed().toJSON();

	    return json;
	  }
	}

	/**
	 * EdwardsPoint
	 */

	class EdwardsPoint extends Point {
	  constructor(curve, x, y, z, t) {
	    assert(curve instanceof EdwardsCurve);

	    super(curve, types.EXTENDED);

	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;

	    if (x != null)
	      this._init(x, y, z, t);
	  }

	  _init(x, y, z, t) {
	    assert(x instanceof BN);
	    assert(y instanceof BN);
	    assert(z == null || (z instanceof BN));
	    assert(t == null || (t instanceof BN));

	    this.x = x;
	    this.y = y;
	    this.z = z || this.curve.one;
	    this.t = t || null;

	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);

	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);

	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);

	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);

	    this.zOne = this.z.eq(this.curve.one);

	    this._check();

	    if (!this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redDiv(this.z);
	    }
	  }

	  _check() {
	    // In order to achieve complete
	    // addition formulas, `a` must
	    // be a square (always the case
	    // for a=1), and `d` must be a
	    // non-square.
	    //
	    // If this is not the case, the
	    // addition formulas may have
	    // exceptional cases where Z3=0.
	    //
	    // In particular, this can occur
	    // when: Q*h = -P*h and Q != -P.
	    //
	    // This is assuming 4-torsion is
	    // involved (the 4-torsion point
	    // is _not_ representable when
	    // `d` is square).
	    if (this.z.isZero())
	      throw new Error('Invalid point.');
	  }

	  clone() {
	    return this.curve.point(this.x, this.y, this.z, this.t);
	  }

	  normalize() {
	    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z
	    // 1I + 2M (+ 1M if extended)

	    // Z1 = 1
	    if (this.zOne)
	      return this;

	    // A = 1 / Z1
	    const a = this.z.redInvert();

	    // X3 = X1 * A
	    this.x = this.x.redMul(a);

	    // Y3 = Y1 * A
	    this.y = this.y.redMul(a);

	    // T3 = T1 * A
	    this.t = this.t.redMul(a);

	    // Z3 = 1
	    this.z = this.curve.one;
	    this.zOne = true;

	    return this;
	  }

	  scale(a) {
	    assert(a instanceof BN);

	    // X3 = X1 * A
	    const nx = this.x.redMul(a);

	    // Y3 = Y1 * A
	    const ny = this.y.redMul(a);

	    // Z3 = Z1 * A
	    const nz = this.z.redMul(a);

	    // T3 = T1 * A
	    const nt = this.t.redMul(a);

	    return this.curve.point(nx, ny, nz, nt);
	  }

	  neg() {
	    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)
	    const nx = this.x.redNeg();
	    const ny = this.y;
	    const nz = this.z;
	    const nt = this.t.redNeg();

	    return this.curve.point(nx, ny, nz, nt);
	  }

	  add(p) {
	    assert(p instanceof EdwardsPoint);

	    // P = O
	    if (this.isInfinity())
	      return p;

	    // Q = O
	    if (p.isInfinity())
	      return this;

	    // Z1 = 1
	    if (this.zOne)
	      return p._add(this);

	    return this._add(p);
	  }

	  _add(p) {
	    // a = -1
	    if (this.curve.mOneA)
	      return this._addM1(p);

	    return this._addA(p);
	  }

	  _addM1(p) {
	    // Assumes a = -1.
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
	    // 8M + 8A + 1*k + 1*2
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3
	    // 7M + 8A + 1*k + 1*2

	    // A = (Y1 - X1) * (Y2 - X2)
	    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));

	    // B = (Y1 + X1) * (Y2 + X2)
	    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));

	    // C = T1 * k * T2
	    const c = this.t.redMul(this.curve.k).redMul(p.t);

	    // D = Z1 * 2 * Z2
	    const d = p.zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);

	    // E = B - A
	    const e = b.redSub(a);

	    // F = D - C
	    const f = d.redSub(c);

	    // G = D + C
	    const g = d.redIAdd(c);

	    // H = B + A
	    const h = b.redIAdd(a);

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);

	    return this.curve.point(nx, ny, nz, nt);
	  }

	  _addA(p) {
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
	    // 9M + 7A + 1*a + 1*d
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd
	    // 8M + 7A + 1*a + 1*d

	    // A = X1 * X2
	    const a = this.x.redMul(p.x);

	    // B = Y1 * Y2
	    const b = this.y.redMul(p.y);

	    // C = T1 * d * T2
	    const c = this.curve._mulD(this.t).redMul(p.t);

	    // D = Z1 * Z2
	    const d = p.zOne ? this.z.clone() : this.z.redMul(p.z);

	    // + XYXY = (X1 + Y1) * (X2 + Y2)
	    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));

	    // E = (X1 + Y1) * (X2 + Y2) - A - B
	    const e = xyxy.redISub(a).redISub(b);

	    // F = D - C
	    const f = d.redSub(c);

	    // G = D + C
	    const g = d.redIAdd(c);

	    // H = B - a * A
	    const h = b.redISub(this.curve._mulA(a));

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);

	    return this.curve.point(nx, ny, nz, nt);
	  }

	  dbl() {
	    // P = O
	    if (this.isInfinity())
	      return this;

	    return this._dbl();
	  }

	  _dbl() {
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
	    // 4M + 4S + 6A + 1*a + 1*2
	    //
	    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd
	    // 3M + 4S + 7A + 1*a + 1*2

	    // A = X1^2
	    const a = this.x.redSqr();

	    // B = Y1^2
	    const b = this.y.redSqr();

	    // C = 2 * Z1^2
	    const c = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2);

	    // D = a * A
	    const d = this.curve._mulA(a);

	    // E = (X1 + Y1)^2 - A - B
	    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);

	    // G = D + B
	    const g = d.redAdd(b);

	    // F = G - C
	    const f = g.redSub(c);

	    // H = D - B
	    const h = d.redISub(b);

	    // X3 = E * F
	    const nx = e.redMul(f);

	    // Y3 = G * H
	    const ny = g.redMul(h);

	    // T3 = E * H
	    const nt = e.redMul(h);

	    // Z3 = F * G
	    const nz = f.redMul(g);

	    return this.curve.point(nx, ny, nz, nt);
	  }

	  getX() {
	    this.normalize();
	    return this.x.fromRed();
	  }

	  getY() {
	    this.normalize();
	    return this.y.fromRed();
	  }

	  eq(p) {
	    assert(p instanceof EdwardsPoint);
	    assert(!this.z.isZero());
	    assert(!p.z.isZero());

	    // P = Q
	    if (this === p)
	      return true;

	    // Z1 = Z2
	    if (this.z.eq(p.z)) {
	      return this.x.eq(p.x)
	          && this.y.eq(p.y);
	    }

	    // X1 * Z2 = X2 * Z1
	    const x1 = this.x.redMul(p.z);
	    const x2 = p.x.redMul(this.z);

	    if (!x1.eq(x2))
	      return false;

	    const y1 = this.y.redMul(p.z);
	    const y2 = p.y.redMul(this.z);

	    return y1.eq(y2);
	  }

	  cmp(point) {
	    assert(point instanceof EdwardsPoint);

	    return this.order().cmp(point.order())
	        || this.getY().cmp(point.getY())
	        || this.getX().cmp(point.getX());
	  }

	  isInfinity() {
	    assert(!this.z.isZero());

	    // X1 = 0
	    if (!this.x.isZero())
	      return false;

	    // Y1 = Z1
	    return this.y.eq(this.z);
	  }

	  isOrder2() {
	    if (this.isInfinity())
	      return false;

	    return this.x.isZero();
	  }

	  isOdd() {
	    this.normalize();
	    return this.x.redIsOdd();
	  }

	  isEven() {
	    this.normalize();
	    return this.x.redIsEven();
	  }

	  toP() {
	    return this.normalize();
	  }

	  toJ() {
	    return this;
	  }

	  encode() {
	    // [RFC8032] Section 5.1.2.
	    const y = this.getY();

	    // Note: `x` normalized from `getY()` call.
	    y.setn(this.curve.signBit, this.x.redIsOdd());

	    return this.curve.encodeAdjusted(y);
	  }

	  static decode(curve, bytes) {
	    // [RFC8032] Section 5.1.3.
	    assert(curve instanceof EdwardsCurve);

	    const y = curve.decodeAdjusted(bytes);
	    const sign = y.testn(curve.signBit) !== 0;

	    y.setn(curve.signBit, 0);

	    if (y.cmp(curve.p) >= 0)
	      throw new Error('Invalid point.');

	    return curve.pointFromY(y, sign);
	  }

	  toJSON(pre) {
	    if (this.isInfinity())
	      return [];

	    const x = this.getX().toJSON();
	    const y = this.getY().toJSON();

	    if (pre === true && this.pre)
	      return [x, y, this.pre.toJSON()];

	    return [x, y];
	  }

	  toPretty() {
	    const size = this.curve.fieldSize * 2;
	    const x = toPretty(this.getX(), size);
	    const y = toPretty(this.getY(), size);

	    return [x, y];
	  }

	  static fromJSON(curve, json) {
	    assert(curve instanceof EdwardsCurve);
	    assert(Array.isArray(json));
	    assert(json.length === 0
	        || json.length === 2
	        || json.length === 3);

	    if (json.length === 0)
	      return curve.point();

	    const x = BN.fromJSON(json[0]);
	    const y = BN.fromJSON(json[1]);
	    const point = curve.point(x, y);

	    if (json.length > 2 && json[2] != null)
	      point.pre = Precomp.fromJSON(point, json[2]);

	    return point;
	  }

	  [custom]() {
	    if (this.isInfinity())
	      return '<EdwardsPoint: Infinity>';

	    return '<EdwardsPoint:'
	        + ' x=' + this.x.fromRed().toString(16, 2)
	        + ' y=' + this.y.fromRed().toString(16, 2)
	        + ' z=' + this.z.fromRed().toString(16, 2)
	        + '>';
	  }
	}

	/**
	 * Precomp
	 */

	class Precomp {
	  constructor() {
	    this.naf = null;
	    this.windows = null;
	    this.doubles = null;
	    this.blinding = null;
	    this.beta = null;
	  }

	  map(func) {
	    assert(typeof func === 'function');

	    const out = new this.constructor();

	    if (this.naf)
	      out.naf = this.naf.map(func);

	    if (this.doubles)
	      out.doubles = this.doubles.map(func);

	    return out;
	  }

	  toJSON() {
	    return {
	      naf: this.naf ? this.naf.toJSON() : null,
	      windows: this.windows ? this.windows.toJSON() : null,
	      doubles: this.doubles ? this.doubles.toJSON() : null,
	      blinding: this.blinding ? this.blinding.toJSON() : undefined
	    };
	  }

	  fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');

	    if (json.naf != null)
	      this.naf = NAF.fromJSON(point, json.naf);

	    if (json.windows != null)
	      this.windows = Windows.fromJSON(point, json.windows);

	    if (json.doubles != null)
	      this.doubles = Doubles.fromJSON(point, json.doubles);

	    if (json.blinding != null)
	      this.blinding = Blinding.fromJSON(point, json.blinding);

	    return this;
	  }

	  static fromJSON(point, json) {
	    return new this().fromJSON(point, json);
	  }
	}

	/**
	 * NAF
	 */

	class NAF {
	  constructor(width, points) {
	    this.width = width;
	    this.points = points;
	  }

	  map(func) {
	    assert(typeof func === 'function');

	    const {width} = this;
	    const points = [];

	    for (const point of this.points)
	      points.push(func(point));

	    return new this.constructor(width, points);
	  }

	  toJSON() {
	    return {
	      width: this.width,
	      points: this.points.slice(1).map((point) => {
	        return point.toJSON();
	      })
	    };
	  }

	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert((json.width >>> 0) === json.width);
	    assert(Array.isArray(json.points));

	    const {curve} = point;
	    const {width} = json;
	    const points = [point];

	    for (const item of json.points)
	      points.push(curve.pointFromJSON(item));

	    return new this(width, points);
	  }
	}

	/**
	 * Windows
	 */

	class Windows {
	  constructor(width, bits, points) {
	    this.width = width;
	    this.bits = bits;
	    this.points = points;
	  }

	  toJSON() {
	    return {
	      width: this.width,
	      bits: this.bits,
	      points: this.points.slice(1).map((point) => {
	        return point.toJSON();
	      })
	    };
	  }

	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert((json.width >>> 0) === json.width);
	    assert((json.bits >>> 0) === json.bits);
	    assert(Array.isArray(json.points));

	    const {curve} = point;
	    const {width, bits} = json;
	    const points = [point];

	    for (const item of json.points)
	      points.push(curve.pointFromJSON(item));

	    return new this(width, bits, points);
	  }
	}

	/**
	 * Doubles
	 */

	class Doubles {
	  constructor(step, points) {
	    this.step = step;
	    this.points = points;
	  }

	  map(func) {
	    assert(typeof func === 'function');

	    const {step} = this;
	    const points = [];

	    for (const point of this.points)
	      points.push(func(point));

	    return new this.constructor(step, points);
	  }

	  toJSON() {
	    return {
	      step: this.step,
	      points: this.points.slice(1).map((point) => {
	        return point.toJSON();
	      })
	    };
	  }

	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');
	    assert((json.step >>> 0) === json.step);
	    assert(Array.isArray(json.points));

	    const {curve} = point;
	    const {step} = json;
	    const points = [point];

	    for (const item of json.points)
	      points.push(curve.pointFromJSON(item));

	    return new this(step, points);
	  }
	}

	/**
	 * Blinding
	 */

	class Blinding {
	  constructor(blind, unblind) {
	    this.blind = blind;
	    this.unblind = unblind;
	  }

	  toJSON() {
	    return {
	      blind: this.blind.toJSON(),
	      unblind: this.unblind.toJSON()
	    };
	  }

	  static fromJSON(point, json) {
	    assert(point instanceof Point);
	    assert(json && typeof json === 'object');

	    const {curve} = point;
	    const blind = BN.fromJSON(json.blind);
	    const unblind = curve.pointFromJSON(json.unblind);

	    return new this(blind, unblind);
	  }
	}

	/**
	 * Endo
	 */

	class Endo {
	  constructor(beta, lambda, basis, pre) {
	    this.beta = beta;
	    this.lambda = lambda;
	    this.basis = basis;
	    this.pre = pre;
	  }

	  toJSON() {
	    return {
	      beta: this.beta.fromRed().toJSON(),
	      lambda: this.lambda.toJSON(),
	      basis: [
	        this.basis[0].toJSON(),
	        this.basis[1].toJSON()
	      ],
	      pre: [
	        this.pre[0],
	        this.pre[1].toJSON(),
	        this.pre[2].toJSON()
	      ]
	    };
	  }

	  static fromJSON(curve, json) {
	    assert(curve instanceof Curve);
	    assert(json && typeof json === 'object');
	    assert(Array.isArray(json.basis));
	    assert(Array.isArray(json.pre));
	    assert(json.basis.length === 2);
	    assert(json.pre.length === 3);
	    assert((json.pre[0] >>> 0) === json.pre[0]);

	    const beta = BN.fromJSON(json.beta).toRed(curve.red);
	    const lambda = BN.fromJSON(json.lambda);

	    const basis = [
	      Vector.fromJSON(json.basis[0]),
	      Vector.fromJSON(json.basis[1])
	    ];

	    const pre = [
	      json.pre[0],
	      BN.fromJSON(json.pre[1]),
	      BN.fromJSON(json.pre[2])
	    ];

	    return new this(beta, lambda, basis, pre);
	  }
	}

	/**
	 * Vector
	 */

	class Vector {
	  constructor(a, b) {
	    this.a = a;
	    this.b = b;
	  }

	  toJSON() {
	    return {
	      a: this.a.toJSON(),
	      b: this.b.toJSON()
	    };
	  }

	  static fromJSON(json) {
	    assert(json && typeof json === 'object');

	    const a = BN.fromJSON(json.a);
	    const b = BN.fromJSON(json.b);

	    return new this(a, b);
	  }
	}

	/**
	 * P192
	 * https://tinyurl.com/fips-186-2 (page 29)
	 * https://tinyurl.com/fips-186-3 (page 88)
	 */

	class P192 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P192',
	      ossl: 'prime192v1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'p192',
	      // 2^192 - 2^64 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff fffffffe',
	          'ffffffff ffffffff'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff fffffffe',
	          'ffffffff fffffffc'],
	      b: ['64210519 e59c80e7 0fa7e9ab 72243049',
	          'feb8deec c146b9b1'],
	      n: ['ffffffff ffffffff ffffffff 99def836',
	          '146bc9b1 b4d22831'],
	      h: '1',
	      // Icart
	      z: '-5',
	      g: [
	        ['188da80e b03090f6 7cbf20eb 43a18800',
	         'f4ff0afd 82ff1012'],
	        ['07192b95 ffc8da78 631011ed 6b24cdd5',
	         '73f977a1 1e794811'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * P224
	 * https://tinyurl.com/fips-186-2 (page 30)
	 * https://tinyurl.com/fips-186-3 (page 88)
	 */

	class P224 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P224',
	      ossl: 'secp224r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'p224',
	      // 2^224 - 2^96 + 1 (1 mod 16)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          '00000000 00000000 00000001'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff fffffffe',
	          'ffffffff ffffffff fffffffe'],
	      b: ['b4050a85 0c04b3ab f5413256 5044b0b7',
	          'd7bfd8ba 270b3943 2355ffb4'],
	      n: ['ffffffff ffffffff ffffffff ffff16a2',
	          'e0b8f03e 13dd2945 5c5c2a3d'],
	      h: '1',
	      // SSWU
	      z: '1f',
	      g: [
	        ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3',
	         '56c21122 343280d6 115c1d21'],
	        ['bd376388 b5f723fb 4c22dfe6 cd4375a0',
	         '5a074764 44d58199 85007e34'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * P256
	 * https://tinyurl.com/fips-186-2 (page 31)
	 * https://tinyurl.com/fips-186-3 (page 89)
	 */

	class P256 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P256',
	      ossl: 'prime256v1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: null,
	      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
	      p: ['ffffffff 00000001 00000000 00000000',
	          '00000000 ffffffff ffffffff ffffffff'],
	      // -3 mod p
	      a: ['ffffffff 00000001 00000000 00000000',
	          '00000000 ffffffff ffffffff fffffffc'],
	      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc',
	          '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],
	      n: ['ffffffff 00000000 ffffffff ffffffff',
	          'bce6faad a7179e84 f3b9cac2 fc632551'],
	      h: '1',
	      // SSWU
	      z: '-a',
	      g: [
	        ['6b17d1f2 e12c4247 f8bce6e5 63a440f2',
	         '77037d81 2deb33a0 f4a13945 d898c296'],
	        ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16',
	         '2bce3357 6b315ece cbb64068 37bf51f5'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * P384
	 * https://tinyurl.com/fips-186-2 (page 32)
	 * https://tinyurl.com/fips-186-3 (page 89)
	 */

	class P384 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P384',
	      ossl: 'secp384r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA384',
	      prime: null,
	      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff fffffffe',
	          'ffffffff 00000000 00000000 ffffffff'],
	      // -3 mod p
	      a: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff fffffffe',
	          'ffffffff 00000000 00000000 fffffffc'],
	      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19',
	          '181d9c6e fe814112 0314088f 5013875a',
	          'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],
	      n: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff c7634d81 f4372ddf',
	          '581a0db2 48b0a77a ecec196a ccc52973'],
	      h: '1',
	      // Icart
	      z: '-c',
	      g: [
	        ['aa87ca22 be8b0537 8eb1c71e f320ad74',
	         '6e1d3b62 8ba79b98 59f741e0 82542a38',
	         '5502f25d bf55296c 3a545e38 72760ab7'],
	        ['3617de4a 96262c6f 5d9e98bf 9292dc29',
	         'f8f41dbd 289a147c e9da3113 b5f0b8c0',
	         '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * P521
	 * https://tinyurl.com/fips-186-2 (page 33)
	 * https://tinyurl.com/fips-186-3 (page 90)
	 */

	class P521 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'P521',
	      ossl: 'secp521r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA512',
	      prime: 'p521',
	      // 2^521 - 1 (= 3 mod 4)
	      p: ['000001ff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff'],
	      // -3 mod p
	      a: ['000001ff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'fffffffc'],
	      b: ['00000051 953eb961 8e1c9a1f 929a21a0',
	          'b68540ee a2da725b 99b315f3 b8b48991',
	          '8ef109e1 56193951 ec7e937b 1652c0bd',
	          '3bb1bf07 3573df88 3d2c34f1 ef451fd4',
	          '6b503f00'],
	      n: ['000001ff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'fffffffa 51868783 bf2f966b 7fcc0148',
	          'f709a5d0 3bb5c9b8 899c47ae bb6fb71e',
	          '91386409'],
	      h: '1',
	      // SSWU
	      z: '-4',
	      g: [
	        ['000000c6 858e06b7 0404e9cd 9e3ecb66',
	         '2395b442 9c648139 053fb521 f828af60',
	         '6b4d3dba a14b5e77 efe75928 fe1dc127',
	         'a2ffa8de 3348b3c1 856a429b f97e7e31',
	         'c2e5bd66'],
	        ['00000118 39296a78 9a3bc004 5c8a5fb4',
	         '2c7d1bd9 98f54449 579b4468 17afbd17',
	         '273e662c 97ee7299 5ef42640 c550b901',
	         '3fad0761 353c7086 a272c240 88be9476',
	         '9fd16650'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * SECP256K1
	 * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)
	 * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)
	 */

	class SECP256K1 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'SECP256K1',
	      ossl: 'secp256k1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: 'k256',
	      // 2^256 - 2^32 - 977 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe fffffc2f'],
	      a: '0',
	      b: '7',
	      n: ['ffffffff ffffffff ffffffff fffffffe',
	          'baaedce6 af48a03b bfd25e8c d0364141'],
	      h: '1',
	      // SVDW
	      z: '1',
	      // sqrt(-3)
	      c: ['0a2d2ba9 3507f1df 233770c2 a797962c',
	          'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],
	      g: [
	        ['79be667e f9dcbbac 55a06295 ce870b07',
	         '029bfcdb 2dce28d9 59f2815b 16f81798'],
	        ['483ada77 26a3c465 5da4fbfc 0e1108a8',
	         'fd17b448 a6855419 9c47d08f fb10d4b8'],
	        pre
	      ],
	      // Precomputed endomorphism.
	      endo: {
	        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9',
	               '9cf04975 12f58995 c1396c28 719501ee'],
	        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a',
	                 '122e22ea 20816678 df02967c 1b23bd72'],
	        basis: [
	          {
	            a: '3086d221a7d46bcde86c90e49284eb15',
	            b: '-e4437ed6010e88286f547fa90abfe4c3'
	          },
	          {
	            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	            b: '3086d221a7d46bcde86c90e49284eb15'
	          }
	        ],
	        pre: [
	          384,
	          ['3086d221 a7d46bcd e86c90e4 9284eb15',
	           '3daa8a14 71e8ca7f e893209a 45dbb031'],
	          ['-',
	           'e4437ed6 010e8828 6f547fa9 0abfe4c4',
	           '221208ac 9df506c6 1571b4ae 8ac47f71']
	        ]
	      }
	    });
	  }
	}

	/**
	 * BRAINPOOLP256
	 * https://tools.ietf.org/html/rfc5639#section-3.4
	 */

	class BRAINPOOLP256 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP256',
	      ossl: 'brainpoolP256r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA256',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72',
	          '6e3bf623 d5262028 2013481d 1f6e5377'],
	      a: ['7d5a0975 fc2c3057 eef67530 417affe7',
	          'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],
	      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf',
	          '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],
	      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71',
	          '8c397aa3 b561a6f7 901e0e82 974856a7'],
	      h: '1',
	      // Icart
	      z: '-2',
	      g: [
	        ['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af',
	         'b9de27e1 e3bd23c2 3a4453bd 9ace3262'],
	        ['547ef835 c3dac4fd 97f8461a 14611dc9',
	         'c2774513 2ded8e54 5c1d54c7 2f046997'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * BRAINPOOLP384
	 * https://tools.ietf.org/html/rfc5639#section-3.6
	 */

	class BRAINPOOLP384 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP384',
	      ossl: 'brainpoolP384r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA384',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',
	          '152f7109 ed5456b4 12b1da19 7fb71123',
	          'acd3a729 901d1a71 87470013 3107ec53'],
	      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0',
	          'c2bea28e 4fb22787 139165ef ba91f90f',
	          '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],
	      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c',
	          '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5',
	          '7cb43902 95dbc994 3ab78696 fa504c11'],
	      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',
	          '152f7109 ed5456b3 1f166e6c ac0425a7',
	          'cf3ab6af 6b7fc310 3b883202 e9046565'],
	      h: '1',
	      // SSWU
	      z: '-5',
	      g: [
	        ['1d1c64f0 68cf45ff a2a63a81 b7c13f6b',
	         '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8',
	         'e826e034 36d646aa ef87b2e2 47d4af1e'],
	        ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552',
	         '62b70b29 feec5864 e19c054f f9912928',
	         '0e464621 77918111 42820341 263c5315'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * BRAINPOOLP512
	 * https://tools.ietf.org/html/rfc5639#section-3.7
	 */

	class BRAINPOOLP512 extends ShortCurve {
	  constructor(pre) {
	    super({
	      id: 'BRAINPOOLP512',
	      ossl: 'brainpoolP512r1',
	      type: 'short',
	      endian: 'be',
	      hash: 'SHA512',
	      prime: null,
	      // (= 3 mod 4)
	      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
	          'cb308db3 b3c9d20e d6639cca 70330871',
	          '7d4d9b00 9bc66842 aecda12a e6a380e6',
	          '2881ff2f 2d82c685 28aa6056 583a48f3'],
	      a: ['7830a331 8b603b89 e2327145 ac234cc5',
	          '94cbdd8d 3df91610 a83441ca ea9863bc',
	          '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5',
	          '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],
	      b: ['3df91610 a83441ca ea9863bc 2ded5d5a',
	          'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7',
	          '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67',
	          '984050b7 5ebae5dd 2809bd63 8016f723'],
	      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
	          'cb308db3 b3c9d20e d6639cca 70330870',
	          '553e5c41 4ca92619 41866119 7fac1047',
	          '1db1d381 085ddadd b5879682 9ca90069'],
	      h: '1',
	      // Icart
	      z: '7',
	      g: [
	        ['81aee4bd d82ed964 5a21322e 9c4c6a93',
	         '85ed9f70 b5d916c1 b43b62ee f4d0098e',
	         'ff3b1f78 e2d0d48d 50d1687b 93b97d5f',
	         '7c6d5047 406a5e68 8b352209 bcb9f822'],
	        ['7dde385d 566332ec c0eabfa9 cf7822fd',
	         'f209f700 24a57b1a a000c55b 881f8111',
	         'b2dcde49 4a5f485e 5bca4bd8 8a2763ae',
	         'd1ca2b2f a8f05406 78cd1e0f 3ad80892'],
	        pre
	      ]
	    });
	  }
	}

	/**
	 * X25519
	 * https://tools.ietf.org/html/rfc7748#section-4.1
	 */

	class X25519 extends MontCurve {
	  constructor() {
	    super({
	      id: 'X25519',
	      ossl: 'X25519',
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHA512',
	      prime: 'p25519',
	      // 2^255 - 19 (= 5 mod 8)
	      p: ['7fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffed'],
	      // 486662
	      a: '76d06',
	      b: '1',
	      n: ['10000000 00000000 00000000 00000000',
	          '14def9de a2f79cd6 5812631a 5cf5d3ed'],
	      h: '8',
	      // Elligator 2
	      z: '2',
	      g: [
	        ['00000000 00000000 00000000 00000000',
	         '00000000 00000000 00000000 00000009'],
	        // See: https://www.rfc-editor.org/errata/eid4730
	        ['5f51e65e 475f794b 1fe122d3 88b72eb3',
	         '6dc2b281 92839e4d d6163a5d 81312c14']
	      ],
	      torsion: [
	        [],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000001'],
	          ['6be4f497 f9a9c2af c21fa77a d7f4a6ef',
	           '635a11c7 284a9363 e9a248ef 9c884415']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000001'],
	          ['141b0b68 06563d50 3de05885 280b5910',
	           '9ca5ee38 d7b56c9c 165db710 6377bbd8']
	        ],
	        [
	          ['57119fd0 dd4e22d8 868e1c58 c45c4404',
	           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
	          ['68c59389 3d458e64 31c6ca00 45fb5015',
	           '20a44346 8eaa68dd 0f103842 048065b7']
	        ],
	        [
	          ['57119fd0 dd4e22d8 868e1c58 c45c4404',
	           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
	          ['173a6c76 c2ba719b ce3935ff ba04afea',
	           'df5bbcb9 71559722 f0efc7bd fb7f9a36']
	        ],
	        [
	          ['00b8495f 16056286 fdb1329c eb8d09da',
	           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
	          ['3931c129 569e83a5 29482c14 e628b457',
	           '933bfc29 ed801b4d 68871483 92507b1a']
	        ],
	        [
	          ['00b8495f 16056286 fdb1329c eb8d09da',
	           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
	          ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8',
	           '6cc403d6 127fe4b2 9778eb7c 6daf84d3']
	        ]
	      ]
	    });
	  }
	}

	/**
	 * X448
	 * https://tools.ietf.org/html/rfc7748#section-4.2
	 */

	class X448 extends MontCurve {
	  constructor() {
	    super({
	      id: 'X448',
	      ossl: 'X448',
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff'],
	      // 156326
	      a: '262a6',
	      b: '1',
	      n: ['3fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff 7cca23e9',
	          'c44edb49 aed63690 216cc272 8dc58f55',
	          '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [
	        ['00000000 00000000 00000000 00000000',
	         '00000000 00000000 00000000 00000000',
	         '00000000 00000000 00000000 00000000',
	         '00000000 00000005'],
	        ['7d235d12 95f5b1f6 6c98ab6e 58326fce',
	         'cbae5d34 f55545d0 60f75dc2 8df3f6ed',
	         'b8027e23 46430d21 1312c4b1 50677af7',
	         '6fd7223d 457b5b1a']
	      ],
	      torsion: [
	        [],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['ba4d3a08 29b6112f 8812e51b a0bb2abe',
	           'bc1cb08e b48e5569 36ba50fd d2e7d68a',
	           'f8cb3216 0522425b 3f990812 abbe635a',
	           'd37a21e1 7551b193']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['45b2c5f7 d649eed0 77ed1ae4 5f44d541',
	           '43e34f71 4b71aa96 c945af01 2d182975',
	           '0734cde9 faddbda4 c066f7ed 54419ca5',
	           '2c85de1e 8aae4e6c']
	        ]
	      ]
	    });
	  }
	}

	/**
	 * MONT448
	 * Isomorphic to Ed448-Goldilocks.
	 */

	class MONT448 extends MontCurve {
	  constructor() {
	    super({
	      id: 'MONT448',
	      ossl: null,
	      type: 'mont',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff'],
	      // -78160 / -39082 mod p
	      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5',
	          '5d93f8d2 22746997 60ccffc6 49961ed6',
	          'c5b05fca c24864ed 6fb59697 931b78da',
	          '84ddecd8 ca2b5cfb'],
	      b: '1',
	      n: ['3fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff 7cca23e9',
	          'c44edb49 aed63690 216cc272 8dc58f55',
	          '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [
	        ['ac0d24cc c6c75cb0 eb71f81e 7a6edf51',
	         '48e88aee 009a2a24 e795687e c28e125a',
	         '3e6730a6 0d46367b aa7fe99d 152128dc',
	         '41321bc7 7817f059'],
	        ['5a4437f6 80c0d0db 9b061276 d5d0ffcc',
	         'e786ff33 b6a53d30 98746425 82e66f09',
	         '4433dae7 7244a6e2 6b11e905 7228f483',
	         '556c41a5 913f55fe']
	      ],
	      torsion: [
	        [],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['bec92fd0 6da2acf2 b4e261e8 7cef0d34',
	           '22e75c18 3c589857 b71924e5 73c2f9ce',
	           'e18da5f2 466e2f39 3c2eedf0 f105a60a',
	           'b40c717d 4f1e1fd7']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['4136d02f 925d530d 4b1d9e17 8310f2cb',
	           'dd18a3e7 c3a767a8 48e6db19 8c3d0631',
	           '1e725a0d b991d0c6 c3d1120f 0efa59f5',
	           '4bf38e82 b0e1e028']
	        ]
	      ]
	    });
	  }
	}

	/**
	 * ED25519
	 * https://tools.ietf.org/html/rfc8032#section-5.1
	 */

	class ED25519 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ED25519',
	      ossl: 'ED25519',
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHA512',
	      prefix: 'SigEd25519 no Ed25519 collisions',
	      context: false,
	      prime: 'p25519',
	      // 2^255 - 19 (= 5 mod 8)
	      p: ['7fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff ffffffed'],
	      a: '-1',
	      // -121665 / 121666 mod p
	      d: ['52036cee 2b6ffe73 8cc74079 7779e898',
	          '00700a4d 4141d8ab 75eb4dca 135978a3'],
	      n: ['10000000 00000000 00000000 00000000',
	          '14def9de a2f79cd6 5812631a 5cf5d3ed'],
	      h: '8',
	      // Elligator 2
	      z: '2',
	      g: [
	        ['216936d3 cd6e53fe c0a4e231 fdd6dc5c',
	         '692cc760 9525a7b2 c9562d60 8f25d51a'],
	        // 4/5
	        ['66666666 66666666 66666666 66666666',
	         '66666666 66666666 66666666 66666658'],
	        pre
	      ],
	      torsion: [
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000001']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000'],
	          ['7fffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff ffffffff ffffffec']
	        ],
	        [
	          ['2b832480 4fc1df0b 2b4d0099 3dfbd7a7',
	           '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000']
	        ],
	        [
	          ['547cdb7f b03e20f4 d4b2ff66 c2042858',
	           'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000']
	        ],
	        [
	          ['1fd5b9a0 06394a28 e9339932 38de4abb',
	           '5c193c70 13e5e238 dea14646 c545d14a'],
	          ['05fc536d 880238b1 3933c6d3 05acdfd5',
	           'f098eff2 89f4c345 b027b2c2 8f95e826']
	        ],
	        [
	          ['602a465f f9c6b5d7 16cc66cd c721b544',
	           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
	          ['05fc536d 880238b1 3933c6d3 05acdfd5',
	           'f098eff2 89f4c345 b027b2c2 8f95e826']
	        ],
	        [
	          ['1fd5b9a0 06394a28 e9339932 38de4abb',
	           '5c193c70 13e5e238 dea14646 c545d14a'],
	          ['7a03ac92 77fdc74e c6cc392c fa53202a',
	           '0f67100d 760b3cba 4fd84d3d 706a17c7']
	        ],
	        [
	          ['602a465f f9c6b5d7 16cc66cd c721b544',
	           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
	          ['7a03ac92 77fdc74e c6cc392c fa53202a',
	           '0f67100d 760b3cba 4fd84d3d 706a17c7']
	        ]
	      ]
	    });
	  }
	}

	/**
	 * ISO448
	 * https://tools.ietf.org/html/rfc7748#section-4.2
	 * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658
	 */

	class ISO448 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ISO448',
	      ossl: null,
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prefix: 'SigEd448',
	      context: true,
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff'],
	      a: '1',
	      // 39082 / 39081 mod p
	      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc',
	          'ad461572 42a50f37 809b1da3 412a12e7',
	          '9ccc9c81 264cfe9a d0809970 58fb61c4',
	          '243cc32d baa156b9'],
	      n: ['3fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff 7cca23e9',
	          'c44edb49 aed63690 216cc272 8dc58f55',
	          '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [
	        ['79a70b2b 70400553 ae7c9df4 16c792c6',
	         '1128751a c9296924 0c25a07d 728bdc93',
	         'e21f7787 ed697224 9de732f3 8496cd11',
	         '69871309 3e9c04fc'],
	        // Note: the RFC has this wrong.
	        ['7fffffff ffffffff ffffffff ffffffff',
	         'ffffffff ffffffff ffffffff 80000000',
	         '00000000 00000000 00000000 00000000',
	         '00000000 00000001'],
	        pre
	      ],
	      torsion: [
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000001']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000001'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ]
	      ]
	    });
	  }
	}

	/**
	 * ED448
	 * https://tools.ietf.org/html/rfc8032#section-5.2
	 */

	class ED448 extends EdwardsCurve {
	  constructor(pre) {
	    super({
	      id: 'ED448',
	      ossl: 'ED448',
	      type: 'edwards',
	      endian: 'le',
	      hash: 'SHAKE256',
	      prefix: 'SigEd448',
	      context: true,
	      prime: 'p448',
	      // 2^448 - 2^224 - 1 (= 3 mod 4)
	      p: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff'],
	      a: '1',
	      // -39081 mod p
	      d: ['ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff fffffffe ffffffff',
	          'ffffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffff6756'],
	      n: ['3fffffff ffffffff ffffffff ffffffff',
	          'ffffffff ffffffff ffffffff 7cca23e9',
	          'c44edb49 aed63690 216cc272 8dc58f55',
	          '2378c292 ab5844f3'],
	      h: '4',
	      // Elligator 2
	      z: '-1',
	      g: [
	        ['4f1970c6 6bed0ded 221d15a6 22bf36da',
	         '9e146570 470f1767 ea6de324 a3d3a464',
	         '12ae1af7 2ab66511 433b80e1 8b00938e',
	         '2626a82b c70cc05e'],
	        ['693f4671 6eb6bc24 88762037 56c9c762',
	         '4bea7373 6ca39840 87789c1e 05a0c2d7',
	         '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',
	         '9808795b f230fa14'],
	        pre
	      ],
	      torsion: [
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000001']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000'],
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe']
	        ],
	        [
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000001'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ],
	        [
	          ['ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff ffffffff fffffffe ffffffff',
	           'ffffffff ffffffff ffffffff ffffffff',
	           'ffffffff fffffffe'],
	          ['00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000 00000000 00000000',
	           '00000000 00000000']
	        ]
	      ]
	    });
	  }
	}

	/*
	 * Curve Registry
	 */

	const curves = {
	  __proto__: null,
	  P192,
	  P224,
	  P256,
	  P384,
	  P521,
	  SECP256K1,
	  BRAINPOOLP256,
	  BRAINPOOLP384,
	  BRAINPOOLP512,
	  X25519,
	  X448,
	  MONT448,
	  ED25519,
	  ISO448,
	  ED448
	};

	const cache = {
	  __proto__: null,
	  P192: null,
	  P224: null,
	  P256: null,
	  P384: null,
	  P521: null,
	  SECP256K1: null,
	  BRAINPOOLP256: null,
	  BRAINPOOLP384: null,
	  BRAINPOOLP512: null,
	  X25519: null,
	  X448: null,
	  MONT448: null,
	  ED25519: null,
	  ISO448: null,
	  ED448: null
	};

	function curve(name, ...args) {
	  assert(typeof name === 'string');

	  const key = name.toUpperCase();

	  let curve = cache[key];

	  if (!curve) {
	    const Curve = curves[key];

	    if (!Curve)
	      throw new Error(`Curve not found: "${name}".`);

	    curve = new Curve(...args);
	    cache[key] = curve;
	  }

	  return curve;
	}

	function register(name, Curve) {
	  assert(typeof name === 'string');
	  assert(typeof Curve === 'function');

	  const key = name.toUpperCase();

	  if (curves[key])
	    throw new Error(`Curve already registered: "${name}".`);

	  curves[key] = Curve;
	  cache[key] = null;
	}

	/*
	 * Scalar Recoding
	 */

	function getNAF(k, width, max) {
	  // Computing the width-w NAF of a positive integer.
	  //
	  // [GECC] Algorithm 3.35, Page 100, Section 3.3.
	  //
	  // The above document describes a rather abstract
	  // method of recoding. The more optimal method
	  // below was ported from libsecp256k1.
	  assert(k instanceof BN);
	  assert(!k.red);
	  assert((width >>> 0) === width);
	  assert((max >>> 0) === max);

	  const naf = new Array(max);
	  const bits = k.bitLength() + 1;
	  const sign = k.sign() | 1;

	  assert(bits <= max);

	  for (let i = 0; i < max; i++)
	    naf[i] = 0;

	  let i = 0;
	  let carry = 0;
	  let word;

	  while (i < bits) {
	    if (k.bit(i) === carry) {
	      i += 1;
	      continue;
	    }

	    word = k.bits(i, width) + carry;
	    carry = (word >> (width - 1)) & 1;
	    word -= carry << width;

	    naf[i] = sign * word;

	    i += width;
	  }

	  assert(carry === 0);

	  return naf;
	}

	function getFixedNAF(k, width, max, step) {
	  assert((step >>> 0) === step);

	  // Recode to NAF.
	  const naf = getNAF(k, width, max);

	  // Translate into more windowed form.
	  const len = Math.ceil(naf.length / step);
	  const repr = new Array(len);

	  let i = 0;

	  for (let j = 0; j < naf.length; j += step) {
	    let nafW = 0;

	    for (let k = j + step - 1; k >= j; k--)
	      nafW = (nafW << 1) + naf[k];

	    repr[i++] = nafW;
	  }

	  assert(i === len);

	  return repr;
	}

	function getJSF(k1, k2, max) {
	  // Joint sparse form.
	  //
	  // [GECC] Algorithm 3.50, Page 111, Section 3.3.
	  assert(k1 instanceof BN);
	  assert(k2 instanceof BN);
	  assert(!k1.red);
	  assert(!k2.red);
	  assert((max >>> 0) === max);

	  const jsf = [new Array(max), new Array(max)];
	  const bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;
	  const s1 = k1.sign() | 1;
	  const s2 = k2.sign() | 1;

	  assert(bits <= max);

	  let d1 = 0;
	  let d2 = 0;

	  for (let i = 0; i < bits; i++) {
	    const b1 = k1.bits(i, 3);
	    const b2 = k2.bits(i, 3);

	    // First phase.
	    let m14 = ((b1 & 3) + d1) & 3;
	    let m24 = ((b2 & 3) + d2) & 3;
	    let u1 = 0;
	    let u2 = 0;

	    if (m14 === 3)
	      m14 = -1;

	    if (m24 === 3)
	      m24 = -1;

	    if (m14 & 1) {
	      const m8 = ((b1 & 7) + d1) & 7;

	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }

	    if (m24 & 1) {
	      const m8 = ((b2 & 7) + d2) & 7;

	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }

	    jsf[0][i] = u1 * s1;
	    jsf[1][i] = u2 * s2;

	    // Second phase.
	    if (2 * d1 === 1 + u1)
	      d1 = 1 - d1;

	    if (2 * d2 === 1 + u2)
	      d2 = 1 - d2;
	  }

	  for (let i = bits; i < max; i++) {
	    jsf[0][i] = 0;
	    jsf[1][i] = 0;
	  }

	  return jsf;
	}

	function getJNAF(c1, c2, max) {
	  const jsf = getJSF(c1, c2, max);
	  const naf = new Array(max);

	  // JSF -> NAF conversion.
	  for (let i = 0; i < max; i++) {
	    const ja = jsf[0][i];
	    const jb = jsf[1][i];

	    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
	  }

	  return naf;
	}

	/*
	 * Helpers
	 */

	function assert(val, msg) {
	  if (!val) {
	    const err = new Error(msg || 'Assertion failed');

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(err, assert);

	    throw err;
	  }
	}

	function wrapErrors(fn) {
	  assert(typeof fn === 'function');

	  try {
	    return fn();
	  } catch (e) {
	    if (e.message === 'X is not a square mod P.'
	        || e.message === 'Not invertible.') {
	      throw new Error('Invalid point.');
	    }
	    throw e;
	  }
	}

	function mod(x, y) {
	  // Euclidean modulo.
	  let r = x % y;

	  if (r < 0) {
	    r += y;
	  }

	  return r;
	}

	function cubeRoot(x) {
	  assert(x instanceof BN);
	  assert(x.red);

	  const p = x.red.m;

	  if (p.cmpn(3) <= 0)
	    return x.clone();

	  // p = 2 mod 3
	  if (p.modrn(3) === 2) {
	    // e = (2 * p - 1) / 3
	    const e = p.ushln(1).isubn(1).idivn(3);
	    return x.redPow(e);
	  }

	  const mod9 = p.modrn(9);

	  // p = 4 mod 9
	  if (mod9 === 4) {
	    // e = (2 * p + 1) / 9
	    const e = p.ushln(1).iaddn(1).idivn(9);
	    const r = x.redPow(e);
	    const c = r.redSqr().redMul(r);

	    if (!c.eq(x))
	      throw new Error('X is not a cube mod P.');

	    return r;
	  }

	  // p = 7 mod 9
	  if (mod9 === 7) {
	    // e = (p + 2) / 9
	    const e = p.addn(2).idivn(9);
	    const r = x.redPow(e);
	    const c = r.redSqr().redMul(r);

	    if (!c.eq(x))
	      throw new Error('X is not a cube mod P.');

	    return r;
	  }

	  throw new Error('Not implemented.');
	}

	function cubeRoots(x) {
	  const r0 = cubeRoot(x);

	  // p = 1 mod 3
	  if (x.red.m.modrn(3) === 1) {
	    // Multiply by roots of unity to find other roots.
	    const two = new BN(2).toRed(x.red);
	    const three = new BN(3).toRed(x.red);
	    const i2 = two.redInvert();
	    const s1 = three.redNeg().redSqrt().redMul(i2);
	    const s2 = s1.redNeg();
	    const u1 = s1.redSub(i2);
	    const u2 = s2.redSub(i2);
	    const r1 = r0.redMul(u1);
	    const r2 = r0.redMul(u2);

	    return [r0, r1, r2];
	  }

	  // p = 2 mod 3 guarantees 1 cube root per element.
	  return [r0];
	}

	function uncube(x) {
	  // Find a cube root which is also a quadratic residue.
	  for (const root of cubeRoots(x)) {
	    if (root.redJacobi() >= 0)
	      return root;
	  }

	  throw new Error('X^(1/3) is not a square mod P.');
	}

	function randomInt(rng) {
	  return BN.randomBits(rng, 32).toNumber();
	}

	function memoize(method, self) {
	  const cache = new WeakMap();

	  return function memoized(curve, invert) {
	    const i = invert & 1;
	    const item = cache.get(curve);

	    if (item && item[i] !== null)
	      return item[i];

	    const result = method.call(self, curve, invert);

	    if (!cache.has(curve))
	      cache.set(curve, [null, null]);

	    cache.get(curve)[i] = result;

	    return result;
	  };
	}

	function toPretty(x, size) {
	  assert(x instanceof BN);
	  assert((size >>> 0) === size);

	  if (size & 7)
	    size += 8 - (size & 7);

	  const str = x.toString(16, size);
	  const chunks = [];
	  const out = [];

	  assert((str.length & 7) === 0);

	  for (let i = 0; i < str.length; i += 8)
	    chunks.push(str.slice(i, i + 8));

	  for (let i = 0; i < chunks.length; i += 4)
	    out.push(chunks.slice(i, i + 4).join(' '));

	  return out;
	}

	/*
	 * Expose
	 */

	elliptic.Curve = Curve;
	elliptic.Point = Point;
	elliptic.ShortCurve = ShortCurve;
	elliptic.ShortPoint = ShortPoint;
	elliptic.JPoint = JPoint;
	elliptic.MontCurve = MontCurve;
	elliptic.MontPoint = MontPoint;
	elliptic.XPoint = XPoint;
	elliptic.EdwardsCurve = EdwardsCurve;
	elliptic.EdwardsPoint = EdwardsPoint;
	elliptic.curves = curves;
	elliptic.curve = curve;
	elliptic.register = register;
	return elliptic;
}

/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */

var ecdsa;
var hasRequiredEcdsa;

function requireEcdsa () {
	if (hasRequiredEcdsa) return ecdsa;
	hasRequiredEcdsa = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const rng = requireRandom();
	const asn1 = requireAsn1$1();
	const Schnorr = requireSchnorrLegacy();
	const HmacDRBG = requireHmacDrbg();
	const elliptic = requireElliptic();

	/**
	 * ECDSA
	 */

	class ECDSA {
	  constructor(name, hash, xof, pre) {
	    assert(typeof name === 'string');
	    assert(hash);
	    assert(xof);

	    this.id = name;
	    this.type = 'ecdsa';
	    this.hash = hash;
	    this.xof = xof;
	    this.native = 0;

	    this._pre = pre || null;
	    this._curve = null;
	    this._schnorr = null;
	  }

	  get curve() {
	    if (!this._curve) {
	      this._curve = elliptic.curve(this.id, this._pre);
	      this._curve.precompute(rng);
	      this._pre = null;
	    }
	    return this._curve;
	  }

	  get schnorr() {
	    if (!this._schnorr)
	      this._schnorr = new Schnorr(this.curve, this.xof);
	    return this._schnorr;
	  }

	  get size() {
	    return this.curve.fieldSize;
	  }

	  get bits() {
	    return this.curve.fieldBits;
	  }

	  privateKeyGenerate() {
	    const a = this.curve.randomScalar(rng);
	    return this.curve.encodeScalar(a);
	  }

	  privateKeyVerify(key) {
	    assert(Buffer.isBuffer(key));

	    let a;
	    try {
	      a = this.curve.decodeScalar(key);
	    } catch (e) {
	      return false;
	    }

	    return !a.isZero() && a.cmp(this.curve.n) < 0;
	  }

	  privateKeyExport(key) {
	    const pub = this.publicKeyCreate(key, false);
	    const {x, y} = this.publicKeyExport(pub);

	    return {
	      d: Buffer.from(key),
	      x,
	      y
	    };
	  }

	  privateKeyImport(json) {
	    assert(json && typeof json === 'object');

	    const a = BN.decode(json.d, this.curve.endian);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    return this.curve.encodeScalar(a);
	  }

	  privateKeyTweakAdd(key, tweak) {
	    const t = this.curve.decodeScalar(tweak);

	    if (t.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid scalar.');

	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    const k = a.add(t).imod(this.curve.n);

	    if (k.isZero())
	      throw new Error('Invalid private key.');

	    return this.curve.encodeScalar(k);
	  }

	  privateKeyTweakMul(key, tweak) {
	    const t = this.curve.decodeScalar(tweak);

	    if (t.isZero() || t.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid scalar.');

	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    const k = a.mul(t).imod(this.curve.n);

	    if (k.isZero())
	      throw new Error('Invalid private key.');

	    return this.curve.encodeScalar(k);
	  }

	  privateKeyNegate(key) {
	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    const k = a.neg().imod(this.curve.n);

	    return this.curve.encodeScalar(k);
	  }

	  privateKeyInvert(key) {
	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    const k = a.invert(this.curve.n);

	    return this.curve.encodeScalar(k);
	  }

	  publicKeyCreate(key, compress) {
	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    const A = this.curve.g.mulBlind(a);

	    return A.encode(compress);
	  }

	  publicKeyConvert(key, compress) {
	    const A = this.curve.decodePoint(key);
	    return A.encode(compress);
	  }

	  publicKeyFromUniform(bytes, compress) {
	    const u = this.curve.decodeUniform(bytes);
	    const A = this.curve.pointFromUniform(u);

	    return A.encode(compress);
	  }

	  publicKeyToUniform(key, hint = rng.randomInt()) {
	    const A = this.curve.decodePoint(key);
	    const u = this.curve.pointToUniform(A, hint);

	    return this.curve.encodeUniform(u, hint >>> 8);
	  }

	  publicKeyFromHash(bytes, compress) {
	    const A = this.curve.pointFromHash(bytes);
	    return A.encode(compress);
	  }

	  publicKeyToHash(key) {
	    const A = this.curve.decodePoint(key);
	    return this.curve.pointToHash(A, 0, rng);
	  }

	  publicKeyVerify(key) {
	    assert(Buffer.isBuffer(key));

	    try {
	      this.curve.decodePoint(key);
	    } catch (e) {
	      return false;
	    }

	    return true;
	  }

	  publicKeyExport(key) {
	    const {x, y} = this.curve.decodePoint(key);

	    return {
	      x: this.curve.encodeField(x.fromRed()),
	      y: this.curve.encodeField(y.fromRed())
	    };
	  }

	  publicKeyImport(json, compress) {
	    assert(json && typeof json === 'object');

	    const x = BN.decode(json.x, this.curve.endian);

	    if (x.cmp(this.curve.p) >= 0)
	      throw new Error('Invalid point.');

	    if (json.y != null) {
	      const y = BN.decode(json.y, this.curve.endian);

	      if (y.cmp(this.curve.p) >= 0)
	        throw new Error('Invalid point.');

	      const A = this.curve.point(x, y);

	      if (!A.validate())
	        throw new Error('Invalid point.');

	      return A.encode(compress);
	    }

	    const A = this.curve.pointFromX(x, json.sign);

	    return A.encode(compress);
	  }

	  publicKeyTweakAdd(key, tweak, compress) {
	    const t = this.curve.decodeScalar(tweak);

	    if (t.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid scalar.');

	    const A = this.curve.decodePoint(key);
	    const T = this.curve.g.jmul(t);
	    const P = T.add(A);

	    return P.encode(compress);
	  }

	  publicKeyTweakMul(key, tweak, compress) {
	    const t = this.curve.decodeScalar(tweak);

	    if (t.isZero() || t.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid scalar.');

	    const A = this.curve.decodePoint(key);
	    const P = A.mul(t);

	    return P.encode(compress);
	  }

	  publicKeyCombine(keys, compress) {
	    assert(Array.isArray(keys));

	    let P = this.curve.jpoint();

	    for (const key of keys) {
	      const A = this.curve.decodePoint(key);

	      P = P.add(A);
	    }

	    return P.encode(compress);
	  }

	  publicKeyNegate(key, compress) {
	    const A = this.curve.decodePoint(key);
	    const P = A.neg();

	    return P.encode(compress);
	  }

	  signatureNormalize(sig) {
	    const [r, s] = this._decodeCompact(sig);

	    if (s.cmp(this.curve.nh) > 0)
	      s.ineg().imod(this.curve.n);

	    return this._encodeCompact(r, s);
	  }

	  signatureNormalizeDER(sig) {
	    const [r, s] = this._decodeDER(sig, false);

	    if (s.cmp(this.curve.nh) > 0)
	      s.ineg().imod(this.curve.n);

	    return this._encodeDER(r, s);
	  }

	  signatureExport(sig) {
	    const [r, s] = this._decodeCompact(sig);
	    return this._encodeDER(r, s);
	  }

	  signatureImport(sig) {
	    const [r, s] = this._decodeDER(sig, false);
	    return this._encodeCompact(r, s);
	  }

	  isLowS(sig) {
	    assert(Buffer.isBuffer(sig));

	    let s;
	    try {
	      [, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return false;
	    }

	    return s.cmp(this.curve.nh) <= 0;
	  }

	  isLowDER(sig) {
	    assert(Buffer.isBuffer(sig));

	    let s;
	    try {
	      [, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return false;
	    }

	    return s.cmp(this.curve.nh) <= 0;
	  }

	  sign(msg, key) {
	    const [r, s] = this._sign(msg, key);
	    return this._encodeCompact(r, s);
	  }

	  signRecoverable(msg, key) {
	    const [r, s, param] = this._sign(msg, key);
	    return [this._encodeCompact(r, s), param];
	  }

	  signDER(msg, key) {
	    const [r, s] = this._sign(msg, key);
	    return this._encodeDER(r, s);
	  }

	  signRecoverableDER(msg, key) {
	    const [r, s, param] = this._sign(msg, key);
	    return [this._encodeDER(r, s), param];
	  }

	  _sign(msg, key) {
	    // ECDSA Signing.
	    //
	    // [SEC1] Page 44, Section 4.1.3.
	    // [GECC] Algorithm 4.29, Page 184, Section 4.4.1.
	    // [RFC6979] Page 9, Section 2.4.
	    // [RFC6979] Page 10, Section 3.2.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `a` be a secret non-zero scalar.
	    //   - Let `k` be a random non-zero scalar.
	    //   - R != O, r != 0, s != 0.
	    //
	    // Computation:
	    //
	    //   k = random integer in [1,n-1]
	    //   R = G * k
	    //   r = x(R) mod n
	    //   s = (r * a + m) / k mod n
	    //   s = -s mod n, if s > n / 2
	    //   S = (r, s)
	    //
	    // We can blind the scalar arithmetic
	    // with a random integer `b` like so:
	    //
	    //   b = random integer in [1,n-1]
	    //   s = (r * (a * b) + m * b) / (k * b) mod n
	    //
	    // Note that `k` must remain secret,
	    // otherwise an attacker can compute:
	    //
	    //   a = (s * k - m) / r mod n
	    //
	    // This means that if two signatures
	    // share the same `r` value, an attacker
	    // can compute:
	    //
	    //   k = (m1 - m2) / (+-s1 - +-s2) mod n
	    //   a = (s1 * k - m1) / r mod n
	    //
	    // Assuming:
	    //
	    //   s1 = (r * a + m1) / k mod n
	    //   s2 = (r * a + m2) / k mod n
	    //
	    // To mitigate this, `k` can be generated
	    // deterministically using the HMAC-DRBG
	    // construction described in [RFC6979].
	    const {n, nh} = this.curve;
	    const G = this.curve.g;
	    const a = this.curve.decodeScalar(key);

	    if (a.isZero() || a.cmp(n) >= 0)
	      throw new Error('Invalid private key.');

	    const m = this._reduce(msg);
	    const nonce = this.curve.encodeScalar(m);
	    const drbg = new HmacDRBG(this.hash, key, nonce);

	    for (;;) {
	      const bytes = drbg.generate(this.curve.scalarSize);
	      const k = this._truncate(bytes);

	      if (k.isZero() || k.cmp(n) >= 0)
	        continue;

	      const R = G.mulBlind(k);

	      if (R.isInfinity())
	        continue;

	      const x = R.getX();
	      const r = x.mod(n);

	      if (r.isZero())
	        continue;

	      const b = this.curve.randomScalar(rng);
	      const ki = k.mul(b).fermat(n);
	      const ba = a.mul(b).imod(n);
	      const bm = m.mul(b).imod(n);
	      const sk = r.mul(ba).iadd(bm).imod(n);
	      const s = sk.mul(ki).imod(n);

	      if (s.isZero())
	        continue;

	      let param = R.isOdd() | (!x.eq(r) << 1);

	      if (s.cmp(nh) > 0) {
	        s.ineg().imod(n);
	        param ^= 1;
	      }

	      return [r, s, param];
	    }
	  }

	  verify(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));

	    let r, s;
	    try {
	      [r, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return false;
	    }

	    try {
	      return this._verify(msg, r, s, key);
	    } catch (e) {
	      return false;
	    }
	  }

	  verifyDER(msg, sig, key) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert(Buffer.isBuffer(key));

	    let r, s;
	    try {
	      [r, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return false;
	    }

	    try {
	      return this._verify(msg, r, s, key);
	    } catch (e) {
	      return false;
	    }
	  }

	  _verify(msg, r, s, key) {
	    // ECDSA Verification.
	    //
	    // [SEC1] Page 46, Section 4.1.4.
	    // [GECC] Algorithm 4.30, Page 184, Section 4.4.1.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `A` be a valid group element.
	    //   - r != 0, r < n.
	    //   - s != 0, s < n.
	    //   - R != O.
	    //
	    // Computation:
	    //
	    //   u1 = m / s mod n
	    //   u2 = r / s mod n
	    //   R = G * u1 + A * u2
	    //   r == x(R) mod n
	    //
	    // Note that the signer can verify their
	    // own signatures more efficiently with:
	    //
	    //   R = G * ((u1 + u2 * a) mod n)
	    //
	    // Furthermore, we can avoid affinization
	    // of `R` by scaling `r` by `z^2` and
	    // repeatedly adding `n * z^2` to it up
	    // to a certain threshold.
	    const {n} = this.curve;
	    const G = this.curve.g;
	    const m = this._reduce(msg);
	    const A = this.curve.decodePoint(key);

	    if (r.isZero() || r.cmp(n) >= 0)
	      return false;

	    if (s.isZero() || s.cmp(n) >= 0)
	      return false;

	    const si = s.invert(n);
	    const u1 = m.mul(si).imod(n);
	    const u2 = r.mul(si).imod(n);
	    const R = G.jmulAdd(u1, A, u2);

	    return R.eqR(r);
	  }

	  recover(msg, sig, param, compress) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert((param >>> 0) === param);
	    assert((param & 3) === param, 'The recovery param is more than two bits.');

	    let r, s;
	    try {
	      [r, s] = this._decodeCompact(sig);
	    } catch (e) {
	      return null;
	    }

	    let A;
	    try {
	      A = this._recover(msg, r, s, param);
	    } catch (e) {
	      return null;
	    }

	    return A.encode(compress);
	  }

	  recoverDER(msg, sig, param, compress) {
	    assert(Buffer.isBuffer(msg));
	    assert(Buffer.isBuffer(sig));
	    assert((param >>> 0) === param);
	    assert((param & 3) === param, 'The recovery param is more than two bits.');

	    let r, s;
	    try {
	      [r, s] = this._decodeDER(sig, false);
	    } catch (e) {
	      return null;
	    }

	    let A;
	    try {
	      A = this._recover(msg, r, s, param);
	    } catch (e) {
	      return null;
	    }

	    return A.encode(compress);
	  }

	  _recover(msg, r, s, param) {
	    // ECDSA Public Key Recovery.
	    //
	    // [SEC1] Page 47, Section 4.1.6.
	    //
	    // Assumptions:
	    //
	    //   - Let `m` be an integer reduced from bytes.
	    //   - Let `r` and `s` be signature elements.
	    //   - Let `i` be an integer in [0,3].
	    //   - x^3 + a * x + b is square in F(p).
	    //   - If i > 1 then r < (p mod n).
	    //   - r != 0, r < n.
	    //   - s != 0, s < n.
	    //   - A != O.
	    //
	    // Computation:
	    //
	    //   x = r + n, if i > 1
	    //     = r, otherwise
	    //   R' = (x, sqrt(x^3 + a * x + b))
	    //   R = -R', if i mod 2 == 1
	    //     = +R', otherwise
	    //   s1 = m / r mod n
	    //   s2 = s / r mod n
	    //   A = R * s2 - G * s1
	    //
	    // Note that this implementation will have
	    // trouble on curves where `p / n > 1`.
	    const {n, pmodn} = this.curve;
	    const G = this.curve.g;
	    const m = this._reduce(msg);

	    if (r.isZero() || r.cmp(n) >= 0)
	      throw new Error('Invalid R value.');

	    if (s.isZero() || s.cmp(n) >= 0)
	      throw new Error('Invalid S value.');

	    const sign = (param & 1) !== 0;
	    const high = param >>> 1;

	    let x = r;

	    if (high) {
	      if (this.curve.highOrder)
	        throw new Error('Invalid high bit.');

	      if (x.cmp(pmodn) >= 0)
	        throw new Error('Invalid R value.');

	      x = x.add(n);
	    }

	    const R = this.curve.pointFromX(x, sign);
	    const ri = r.invert(n);
	    const s1 = m.mul(ri).ineg().imod(n);
	    const s2 = s.mul(ri).imod(n);
	    const A = G.mulAdd(s1, R, s2);

	    if (A.isInfinity())
	      throw new Error('Invalid point.');

	    return A;
	  }

	  derive(pub, priv, compress) {
	    const A = this.curve.decodePoint(pub);
	    const a = this.curve.decodeScalar(priv);

	    if (a.isZero() || a.cmp(this.curve.n) >= 0)
	      throw new Error('Invalid private key.');

	    if (this.curve.h.cmpn(1) > 0) {
	      if (A.isSmall())
	        throw new Error('Invalid point.');
	    }

	    const P = A.mulBlind(a, rng);

	    return P.encode(compress);
	  }

	  /*
	   * Schnorr
	   */

	  schnorrSign(msg, key) {
	    return this.schnorr.sign(msg, key);
	  }

	  schnorrVerify(msg, sig, key) {
	    return this.schnorr.verify(msg, sig, key);
	  }

	  schnorrVerifyBatch(batch) {
	    return this.schnorr.verifyBatch(batch);
	  }

	  /*
	   * Helpers
	   */

	  _encodeCompact(r, s) {
	    return Buffer.concat([
	      this.curve.encodeScalar(r),
	      this.curve.encodeScalar(s)
	    ]);
	  }

	  _decodeCompact(sig) {
	    assert(Buffer.isBuffer(sig));

	    const {n} = this.curve;
	    const size = this.curve.scalarSize;

	    if (sig.length !== size * 2)
	      throw new Error('Invalid signature size.');

	    const Rraw = sig.slice(0, size);
	    const Sraw = sig.slice(size, size * 2);
	    const r = this.curve.decodeScalar(Rraw);
	    const s = this.curve.decodeScalar(Sraw);

	    if (r.cmp(n) >= 0 || s.cmp(n) >= 0)
	      throw new Error('Invalid signature.');

	    return [r, s];
	  }

	  _encodeDER(r, s) {
	    const size = asn1.sizeInt(r) + asn1.sizeInt(s);
	    const out = Buffer.alloc(asn1.sizeSeq(size));

	    let pos = 0;

	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeInt(out, pos, r);
	    pos = asn1.writeInt(out, pos, s);

	    assert(pos === out.length);

	    return out;
	  }

	  _decodeDER(sig, strict) {
	    assert(Buffer.isBuffer(sig));
	    assert(typeof strict === 'boolean');

	    const {n} = this.curve;

	    let pos = 0;
	    let r, s;

	    pos = asn1.readSeq(sig, pos, strict);
	    [r, pos] = asn1.readInt(sig, pos, strict);
	    [s, pos] = asn1.readInt(sig, pos, strict);

	    if (strict && pos !== sig.length)
	      throw new Error('Trailing bytes.');

	    if (r.cmp(n) >= 0 || s.cmp(n) >= 0)
	      throw new Error('Invalid signature.');

	    return [r, s];
	  }

	  _truncate(msg) {
	    // Byte array to integer conversion.
	    //
	    // [SEC1] Step 5, Page 45, Section 4.1.3.
	    // [FIPS186] Page 25, Section B.2.
	    //
	    // The two sources above disagree on this.
	    //
	    // FIPS186 simply modulos the entire byte
	    // array by the order, whereas SEC1 takes
	    // the left-most ceil(log2(n+1)) bits modulo
	    // the order (and maybe does other stuff).
	    //
	    // Instead of trying to decipher all of
	    // this nonsense, we simply replicate the
	    // OpenSSL behavior (which, in actuality,
	    // is more similar to the SEC1 behavior).
	    assert(Buffer.isBuffer(msg));

	    const bits = this.curve.n.bitLength();
	    const bytes = (bits + 7) >>> 3;

	    if (msg.length > bytes)
	      msg = msg.slice(0, bytes);

	    const m = BN.decode(msg, this.curve.endian);
	    const d = msg.length * 8 - bits;

	    if (d > 0)
	      m.iushrn(d);

	    return m;
	  }

	  _reduce(msg) {
	    return this._truncate(msg).imod(this.curve.n);
	  }
	}

	/*
	 * Expose
	 */

	ecdsa = ECDSA;
	return ecdsa;
}

var naf = {
	width: 9,
	points: [
		[
			"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
			"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
		],
		[
			"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
			"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
		],
		[
			"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
			"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
		],
		[
			"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
			"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
		],
		[
			"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
			"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
		],
		[
			"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
			"0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
		],
		[
			"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
			"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
		],
		[
			"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
			"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
		],
		[
			"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
			"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
		],
		[
			"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
			"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
		],
		[
			"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
			"02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
		],
		[
			"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
			"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
		],
		[
			"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
			"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
		],
		[
			"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
			"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
		],
		[
			"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
			"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
		],
		[
			"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
			"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
		],
		[
			"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
			"02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
		],
		[
			"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
			"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
		],
		[
			"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
			"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
		],
		[
			"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
			"0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
		],
		[
			"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
			"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
		],
		[
			"049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
			"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
		],
		[
			"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
			"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
		],
		[
			"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
			"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
		],
		[
			"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
			"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
		],
		[
			"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
			"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
		],
		[
			"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
			"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
		],
		[
			"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
			"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
		],
		[
			"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
			"091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
		],
		[
			"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
			"0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
		],
		[
			"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
			"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
		],
		[
			"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
			"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
		],
		[
			"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
			"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
		],
		[
			"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
			"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
		],
		[
			"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
			"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
		],
		[
			"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
			"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
		],
		[
			"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
			"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
		],
		[
			"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
			"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
		],
		[
			"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
			"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
		],
		[
			"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
			"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
		],
		[
			"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
			"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
		],
		[
			"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
			"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
		],
		[
			"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
			"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
		],
		[
			"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
			"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
		],
		[
			"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
			"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
		],
		[
			"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
			"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
		],
		[
			"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
			"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
		],
		[
			"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
			"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
		],
		[
			"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
			"0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
		],
		[
			"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
			"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
		],
		[
			"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
			"09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
		],
		[
			"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
			"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
		],
		[
			"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
			"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
		],
		[
			"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
			"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
		],
		[
			"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
			"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
		],
		[
			"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
			"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
		],
		[
			"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
			"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
		],
		[
			"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
			"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
		],
		[
			"078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
			"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
		],
		[
			"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
			"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
		],
		[
			"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
			"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
		],
		[
			"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
			"04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
		],
		[
			"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
			"073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
		],
		[
			"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
			"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
		],
		[
			"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
			"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
		],
		[
			"0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
			"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
		],
		[
			"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
			"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
		],
		[
			"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
			"060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
		],
		[
			"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
			"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
		],
		[
			"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
			"0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
		],
		[
			"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
			"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
		],
		[
			"04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
			"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
		],
		[
			"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
			"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
		],
		[
			"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
			"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
		],
		[
			"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
			"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
		],
		[
			"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
			"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
		],
		[
			"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
			"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
		],
		[
			"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
			"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
		],
		[
			"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
			"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
		],
		[
			"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
			"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
		],
		[
			"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
			"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
		],
		[
			"0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
			"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
		],
		[
			"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
			"021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
		],
		[
			"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
			"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
		],
		[
			"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
			"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
		],
		[
			"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
			"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
		],
		[
			"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
			"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
		],
		[
			"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
			"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
		],
		[
			"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
			"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
		],
		[
			"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
			"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
		],
		[
			"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
			"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
		],
		[
			"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
			"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
		],
		[
			"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
			"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
		],
		[
			"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
			"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
		],
		[
			"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
			"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
		],
		[
			"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
			"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
		],
		[
			"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
			"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
		],
		[
			"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
			"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
		],
		[
			"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
			"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
		],
		[
			"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
			"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
		],
		[
			"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
			"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
		],
		[
			"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
			"0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
		],
		[
			"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
			"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
		],
		[
			"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
			"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
		],
		[
			"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
			"09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
		],
		[
			"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
			"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
		],
		[
			"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
			"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
		],
		[
			"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
			"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
		],
		[
			"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
			"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
		],
		[
			"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
			"0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
		],
		[
			"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
			"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
		],
		[
			"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
			"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
		],
		[
			"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
			"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
		],
		[
			"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
			"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
		],
		[
			"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
			"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
		],
		[
			"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
			"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
		],
		[
			"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
			"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
		],
		[
			"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
			"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
		],
		[
			"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
			"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
		],
		[
			"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
			"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
		],
		[
			"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
			"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
		],
		[
			"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
			"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
		],
		[
			"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
			"0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
		],
		[
			"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
			"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
		],
		[
			"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
			"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
		],
		[
			"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
			"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
		],
		[
			"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
			"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
		]
	]
};
var doubles = {
	step: 4,
	points: [
		[
			"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
			"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
		],
		[
			"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
			"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
		],
		[
			"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
			"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
		],
		[
			"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
			"04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
		],
		[
			"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
			"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
		],
		[
			"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
			"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
		],
		[
			"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
			"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
		],
		[
			"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
			"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
		],
		[
			"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
			"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
		],
		[
			"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
			"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
		],
		[
			"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
			"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
		],
		[
			"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
			"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
		],
		[
			"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
			"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
		],
		[
			"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
			"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
		],
		[
			"06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
			"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
		],
		[
			"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
			"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
		],
		[
			"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
			"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
		],
		[
			"0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
			"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
		],
		[
			"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
			"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
		],
		[
			"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
			"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
		],
		[
			"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
			"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
		],
		[
			"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
			"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
		],
		[
			"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
			"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
		],
		[
			"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
			"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
		],
		[
			"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
			"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
		],
		[
			"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
			"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
		],
		[
			"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
			"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
		],
		[
			"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
			"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
		],
		[
			"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
			"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
		],
		[
			"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
			"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
		],
		[
			"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
			"0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
		],
		[
			"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
			"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
		],
		[
			"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
			"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
		],
		[
			"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
			"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
		],
		[
			"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
			"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
		],
		[
			"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
			"067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
		],
		[
			"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
			"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
		],
		[
			"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
			"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
		],
		[
			"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
			"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
		],
		[
			"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
			"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
		],
		[
			"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
			"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
		],
		[
			"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
			"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
		],
		[
			"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
			"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
		],
		[
			"0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
			"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
		],
		[
			"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
			"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
		],
		[
			"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
			"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
		],
		[
			"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
			"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
		],
		[
			"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
			"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
		],
		[
			"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
			"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
		],
		[
			"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
			"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
		],
		[
			"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
			"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
		],
		[
			"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
			"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
		],
		[
			"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
			"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
		],
		[
			"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
			"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
		],
		[
			"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
			"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
		],
		[
			"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
			"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
		],
		[
			"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
			"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
		],
		[
			"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
			"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
		],
		[
			"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
			"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
		],
		[
			"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
			"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
		],
		[
			"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
			"0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
		],
		[
			"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
			"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
		],
		[
			"08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
			"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
		],
		[
			"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
			"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
		],
		[
			"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
			"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
		]
	]
};
var require$$2 = {
	naf: naf,
	doubles: doubles
};

/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var secp256k1;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1;
	hasRequiredSecp256k1 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();
	const pre = require$$2;

	/*
	 * Expose
	 */

	secp256k1 = new ECDSA('SECP256K1', SHA256, SHA256, pre);
	return secp256k1;
}

/*!
 * message.js - message signing utilities.
 * Copyright (c) 2019, The Bcoin Developers (MIT License).
 */

var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1;
	(function (exports) {

		const assert = require$$0$3;
		const bufio = require$$1;
		const hash256 = requireHash256();
		const secp256k1 = requireSecp256k1();

		/**
		 * @exports utils/message
		 */

		const message = exports;

		/**
		 * Bitcoin signing magic string.
		 * @const {String}
		 * @default
		 */

		message.MAGIC_STRING = 'eCash Signed Message:\n';

		/**
		 * Hash message with magic string.
		 * @param {String} message
		 * @param {String} [prefix = message.MAGIC_STRING]
		 * @returns {Hash}
		 */

		message.magicHash = (msg, prefix = message.MAGIC_STRING) => {
		  assert(typeof prefix === 'string', 'prefix must be a string.');
		  assert(typeof msg === 'string', 'message must be a string');

		  const bw = bufio.write();

		  bw.writeVarString(prefix);
		  bw.writeVarString(msg, 'utf8');

		  return hash256.digest(bw.render());
		};

		/**
		 * Sign message with key.
		 * @param {String} msg
		 * @param {KeyRing} ring
		 * @param {String} [prefix = message.MAGIC_STRING]
		 * @returns {Buffer}
		 */

		message.sign = (msg, ring, prefix) => {
		  assert(ring.getPrivateKey(), 'Cannot sign without private key.');

		  const hash = message.magicHash(msg, prefix);
		  const compress = 0x04 !== ring.getPublicKey().readInt8(0);
		  const [
		    signature,
		    recovery
		  ] = secp256k1.signRecoverable(hash, ring.getPrivateKey());

		  const bw = bufio.write();

		  bw.writeI8(recovery + 27 + (compress ? 4 : 0));
		  bw.writeBytes(signature);

		  return bw.render();
		};

		/**
		 * Recover raw public key from message and signature.
		 * @param {String} msg
		 * @param {Buffer} signature
		 * @param {String} [prefix = MAGIC_STRING]
		 */

		message.recover = (msg, signature, prefix) => {
		  assert(typeof msg === 'string', 'msg must be a string');
		  assert(Buffer.isBuffer(signature), 'sig must be a buffer');

		  const hash = message.magicHash(msg, prefix);

		  assert.strictEqual(signature.length, 65, 'Invalid signature length');

		  const flagByte = signature.readUInt8(0) - 27;

		  assert(flagByte < 8, 'Invalid signature parameter');

		  const compressed = Boolean(flagByte & 4);
		  const recovery = flagByte & 3;

		  return secp256k1.recover(hash, signature.slice(1), recovery, compressed);
		};

		/**
		 * Verify signature for message.
		 * @param {String} msg
		 * @param {Buffer} signature
		 * @param {Buffer} publicKey
		 * @param {String} [prefix = message.MAGIC_STRING]
		 */

		message.verify = (msg, signature, publicKey, prefix) => {
		    const recoveredKey = message.recover(msg, signature);

		    assert(Buffer.isBuffer(publicKey), 'publicKey must be a buffer');

		    if (Buffer.compare(publicKey, recoveredKey) !== 0)
		        return false;

		    return secp256k1.verify(
		        message.magicHash(msg, prefix),
		        signature.slice(1),
		        publicKey
		    );
		}; 
	} (message));
	return message;
}

/*!
 * utils/index.js - utils for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	/**
	 * @module utils
	 */

	utils.binary = requireBinary();
	utils.fixed = requireFixed();
	utils.util = requireUtil();
	utils.message = requireMessage();

	const {inspect: {custom}} = require$$4;
	utils.inspectSymbol = custom || 'inspect';
	return utils;
}

/*!
 * address.js - address object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var address;
var hasRequiredAddress;

function requireAddress () {
	if (hasRequiredAddress) return address;
	hasRequiredAddress = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {base58, cashaddr} = require$$2$1;
	const ecashaddr = require$$3;
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const {inspectSymbol} = requireUtils();

	/*
	 * Constants
	 */

	const ZERO_HASH160 = Buffer.alloc(20, 0x00);

	/**
	 * Address
	 * Represents an address.
	 * @alias module:primitives.Address
	 * @property {Buffer} hash
	 * @property {AddressPrefix} type
	 */

	class Address {
	  /**
	   * Create an address.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options, network) {
	    this.type = Address.types.PUBKEYHASH;
	    this.hash = ZERO_HASH160;

	    if (options)
	      this.fromOptions(options, network);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options, network) {
	    if (typeof options === 'string')
	      return this.fromString(options, network);

	    assert(options);

	    const {hash, type} = options;

	    return this.fromHash(hash, type);
	  }

	  /**
	   * Insantiate address from options.
	   * @param {Object} options
	   * @returns {Address}
	   */

	  static fromOptions(options, network) {
	    return new this().fromOptions(options, network);
	  }

	  /**
	   * Get the address hash.
	   * @param {String?} enc - Can be `"hex"` or `null`.
	   * @returns {Hash|Buffer}
	   */

	  getHash(enc) {
	    if (enc === 'hex')
	      return this.hash.toString('hex');
	    return this.hash;
	  }

	  /**
	   * Test whether the address is null.
	   * @returns {Boolean}
	   */

	  isNull() {
	    if (this.hash.length === 20)
	      return this.hash.equals(ZERO_HASH160);

	    if (this.hash.length === 32)
	      return this.hash.equals(consensus.ZERO_HASH);

	    for (let i = 0; i < this.hash.length; i++) {
	      if (this.hash[i] !== 0)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Test equality against another address.
	   * @param {Address} addr
	   * @returns {Boolean}
	   */

	  equals(addr) {
	    assert(addr instanceof Address);

	    return this.type === addr.type
	      && this.hash.equals(addr.hash);
	  }

	  /**
	   * Get the address type as a string.
	   * @returns {String}
	   */

	  getType() {
	    return Address.typesByVal[this.type].toLowerCase();
	  }

	  /**
	   * Get a network address prefix for the address.
	   * @param {Network?} network
	   * @returns {Number}
	   */

	  getPrefix(network) {
	    network = Network.get(network);

	    const prefixes = network.addressPrefix;

	    switch (this.type) {
	      case Address.types.PUBKEYHASH:
	        return prefixes.pubkeyhash;
	      case Address.types.SCRIPTHASH:
	        return prefixes.scripthash;
	    }

	    return -1;
	  }

	  /**
	   * Calculate size of serialized address.
	   * @returns {Number}
	   */

	  getSize() {
	    return 5 + this.hash.length;
	  }

	  /**
	   * Compile the address object to its raw serialization.
	   * @param {{NetworkType|Network)?} network
	   * @returns {Buffer}
	   * @throws Error on bad hash/prefix.
	   */

	  toRaw(network) {
	    const size = this.getSize();
	    const bw = bio.write(size);
	    const prefix = this.getPrefix(network);

	    assert(prefix !== -1, 'Not a valid address prefix.');

	    bw.writeU8(prefix);

	    bw.writeBytes(this.hash);
	    bw.writeChecksum(hash256.digest);

	    return bw.render();
	  }

	  /**
	   * Compile the address object to a base58 address.
	   * @param {{NetworkType|Network)?} network
	   * @returns {AddressString}
	   * @throws Error on bad hash/prefix.
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Compile the address object to a cashaddr address.
	   * @param {{NetworkType|Network)?} network
	   * @returns {String}
	   * @throws Error on bad hash/prefix.
	   */

	  toCashAddr(network) {
	    const type = this.type;
	    const hash = this.hash;

	    network = Network.get(network);

	    const prefix = network.addressPrefix.cashaddr;

	    return cashaddr.encode(prefix, type, hash);
	  }

	  /**
	   * Inject properties from string.
	   * @private
	   * @param {String} addr
	   * @param {(Network|NetworkType)?} network
	   * @returns {Address}
	   */

	  fromString(addr, network) {
	    assert(typeof addr === 'string');
	    assert(addr.length > 0);
	    assert(addr.length <= 100);

	    // If the address is mixed case,
	    // it can only ever be base58.
	    if (isMixedCase(addr))
	      return this.fromBase58(addr, network);

	    // Otherwise, it's most likely cashaddr.
	    try {
	      return this.fromCashAddr(addr, network);
	    } catch (e) {
	      return this.fromBase58(addr, network);
	    }
	  }

	  /**
	   * Instantiate address from string.
	   * @param {String} addr
	   * @param {(Network|NetworkType)?} network
	   * @returns {Address}
	   */

	  static fromString(addr, network) {
	    return new this().fromString(addr, network);
	  }

	  /**
	   * Return cashaddr by default
	   * @param {(Network|NetworkType)?} network
	   * @returns {AddressString}
	   */

	  toString(network) {
	    return this.toCashAddr(network);
	  }

	  /**
	   * Inspect the Address.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return '<Address:'
	      + ` type=${this.getType()}`
	      + ` str=${this.toString()}`
	      + '>';
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @throws Parse error
	   */

	  fromRaw(data, network) {
	    const br = bio.read(data, true);
	    const prefix = br.readU8();

	    network = Network.fromAddress(prefix, network);

	    const type = Address.getType(prefix, network);

	    if (data.length !== 25)
	      throw new Error('Address is too long.');

	    const hash = br.readBytes(br.left() - 4);

	    br.verifyChecksum(hash256.digest);

	    return this.fromHash(hash, type);
	  }

	  /**
	   * Create an address object from a serialized address.
	   * @param {Buffer} data
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Inject properties from base58 address.
	   * @private
	   * @param {AddressString} data
	   * @param {Network?} network
	   * @throws Parse error
	   */

	  fromBase58(data, network) {
	    assert(typeof data === 'string');

	    if (data.length > 55)
	      throw new Error('Address is too long.');

	    return this.fromRaw(base58.decode(data), network);
	  }

	  /**
	   * Create an address object from a base58 address.
	   * @param {AddressString} data
	   * @param {Network?} network
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromBase58(data, network) {
	    return new this().fromBase58(data, network);
	  }

	  /**
	   * Inject properties from cashaddr address.
	   * @private
	   * @param {String} data
	   * @param {Network?} network
	   * @throws Parse error
	   */

	  fromCashAddr(data, network) {
	    assert(typeof data === 'string');

	    network = Network.get(network);

	    network.addressPrefix.cashaddr;
	    const addr = ecashaddr.decode(data);
	    addr.type = addr.type === 'P2PKH' ? 'PUBKEYHASH' : 'SCRIPTHASH';

	    Network.fromCashAddr(addr.prefix, network);

	    return this.fromHash(Buffer.from(addr.hash), addr.type);
	  }

	  /**
	   * Create an address object from a cashaddr address.
	   * @param {String} data
	   * @param {Network?} network
	   * @returns {Address}
	   * @throws Parse error.
	   */

	  static fromCashAddr(data, network) {
	    return new this().fromCashAddr(data, network);
	  }

	  /**
	   * Inject properties from output script.
	   * @private
	   * @param {Script} script
	   */

	  fromScript(script) {
	    const pk = script.getPubkey();

	    if (pk) {
	      this.hash = hash160.digest(pk);
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }

	    const pkh = script.getPubkeyhash();

	    if (pkh) {
	      this.hash = pkh;
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }

	    const sh = script.getScripthash();

	    if (sh) {
	      this.hash = sh;
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }

	    // Put this last: it's the slowest to check.
	    if (script.isMultisig()) {
	      this.hash = script.hash160();
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }

	    return null;
	  }

	  /**
	   * Inject properties from input script.
	   * @private
	   * @param {Script} script
	   */

	  fromInputScript(script) {
	    const [, pk] = script.getPubkeyhashInput();

	    if (pk) {
	      this.hash = hash160.digest(pk);
	      this.type = Address.types.PUBKEYHASH;
	      return this;
	    }

	    const redeem = script.getScripthashInput();

	    if (redeem) {
	      this.hash = hash160.digest(redeem);
	      this.type = Address.types.SCRIPTHASH;
	      return this;
	    }

	    return null;
	  }

	  /**
	   * Create an Address from an input script.
	   * Attempt to extract address
	   * properties from an input script.
	   * @param {Script}
	   * @returns {Address|null}
	   */

	  static fromInputScript(script) {
	    return new this().fromInputScript(script);
	  }

	  /**
	   * Create an Address from an output script.
	   * Parse an output script and extract address
	   * properties. Converts pubkey and multisig
	   * scripts to pubkeyhash and scripthash addresses.
	   * @param {Script}
	   * @returns {Address|null}
	   */

	  static fromScript(script) {
	    return new this().fromScript(script);
	  }

	  /**
	   * Inject properties from a hash.
	   * @private
	   * @param {Buffer|Hash} hash
	   * @param {AddressPrefix} type
	   * @throws on bad hash size
	   */

	  fromHash(hash, type) {
	    if (typeof type === 'string') {
	      type = Address.types[type.toUpperCase()];
	      assert(type != null, 'Not a valid address type.');
	    }

	    if (type == null)
	      type = Address.types.PUBKEYHASH;

	    assert(Buffer.isBuffer(hash));
	    assert((type >>> 0) === type);

	    assert(type >= Address.types.PUBKEYHASH && type <= Address.types.SCRIPTHASH,
	      'Not a valid address type.');

	    assert(hash.length === 20, 'Hash is the wrong size.');

	    this.hash = hash;
	    this.type = type;

	    return this;
	  }

	  /**
	   * Create a naked address from hash/type.
	   * @param {Hash} hash
	   * @param {AddressPrefix} type
	   * @returns {Address}
	   * @throws on bad hash size
	   */

	  static fromHash(hash, type) {
	    return new this().fromHash(hash, type);
	  }

	  /**
	   * Inject properties from pubkeyhash.
	   * @private
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  fromPubkeyhash(hash) {
	    const type = Address.types.PUBKEYHASH;
	    assert(hash.length === 20, 'P2PKH must be 20 bytes.');
	    return this.fromHash(hash, type, -1);
	  }

	  /**
	   * Instantiate address from pubkeyhash.
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  static fromPubkeyhash(hash) {
	    return new this().fromPubkeyhash(hash);
	  }

	  /**
	   * Inject properties from scripthash.
	   * @private
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  fromScripthash(hash) {
	    const type = Address.types.SCRIPTHASH;
	    assert(hash && hash.length === 20, 'P2SH must be 20 bytes.');
	    return this.fromHash(hash, type, -1);
	  }

	  /**
	   * Instantiate address from scripthash.
	   * @param {Buffer} hash
	   * @returns {Address}
	   */

	  static fromScripthash(hash) {
	    return new this().fromScripthash(hash);
	  }

	  /**
	   * Test whether the address is pubkeyhash.
	   * @returns {Boolean}
	   */

	  isPubkeyhash() {
	    return this.type === Address.types.PUBKEYHASH;
	  }

	  /**
	   * Test whether the address is scripthash.
	   * @returns {Boolean}
	   */

	  isScripthash() {
	    return this.type === Address.types.SCRIPTHASH;
	  }

	  /**
	   * Get the hash of a base58 address or address-related object.
	   * @param {Address|Hash} data
	   * @param {String?} enc - Can be `"hex"` or `null`.
	   * @returns {Hash}
	   */

	  static getHash(data, enc) {
	    if (!data)
	      throw new Error('Object is not an address.');

	    let hash;

	    if (Buffer.isBuffer(data)) {
	      if (data.length !== 20)
	        throw new Error('Object is not an address.');
	      hash = data;
	    } else if (data instanceof Address) {
	      hash = data.hash;
	    } else {
	      throw new Error('Object is not an address.');
	    }

	    if (enc === 'hex')
	      return hash.toString('hex');

	    return hash;
	  }

	  /**
	   * Get an address type for a specified network address prefix.
	   * @param {Number} prefix
	   * @param {Network} network
	   * @returns {AddressType}
	   */

	  static getType(prefix, network) {
	    const prefixes = network.addressPrefix;

	    switch (prefix) {
	      case prefixes.pubkeyhash:
	        return Address.types.PUBKEYHASH;
	      case prefixes.scripthash:
	        return Address.types.SCRIPTHASH;
	      default:
	        throw new Error('Unknown address prefix.');
	    }
	  }
	}

	/**
	 * Address types.
	 * @enum {Number}
	 */

	Address.types = {
	  PUBKEYHASH: 0,
	  SCRIPTHASH: 1
	};

	/**
	 * Address types by value.
	 * @const {Object}
	 */

	Address.typesByVal = [
	  'PUBKEYHASH',
	  'SCRIPTHASH'
	];

	/*
	 * Helpers
	 */

	function isMixedCase(str) {
	  let lower = false;
	  let upper = false;

	  for (let i = 0; i < str.length; i++) {
	    const ch = str.charCodeAt(i);

	    if (ch >= 0x30 && ch <= 0x39)
	      continue;

	    // skip :
	    if (ch === 0x3a)
	      continue;

	    if (ch & 32) {
	      assert(ch >= 0x61 && ch <= 0x7a);
	      lower = true;
	    } else {
	      assert(ch >= 0x41 && ch <= 0x5a);
	      upper = true;
	    }

	    if (lower && upper)
	      return true;
	  }

	  return false;
	}

	/*
	 * Expose
	 */

	address = Address;
	return address;
}

/**
 * uri.js - bitcoin uri parsing for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	const assert = require$$0$3;
	const Address = requireAddress();
	const Amount = requireAmount();

	/**
	 * URI
	 * Represents a bitcoin URI.
	 * @alias module:btc.URI
	 * @property {Address} address
	 * @property {Amount} amount
	 * @property {String|null} label
	 * @property {String|null} message
	 * @property {String|null} request
	 */

	class URI {
	  /**
	   * Create a bitcoin URI.
	   * @alias module:btc.URI
	   * @constructor
	   * @param {Object|String} options
	   */

	  constructor(options) {
	    this.address = new Address();
	    this.amount = -1;
	    this.label = null;
	    this.message = null;
	    this.request = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object|String} options
	   * @returns {URI}
	   */

	  fromOptions(options) {
	    if (typeof options === 'string')
	      return this.fromString(options);

	    if (options.address)
	      this.address.fromOptions(options.address);

	    if (options.amount != null) {
	      assert(Number.isSafeInteger(options.amount) && options.amount >= 0,
	        'Amount must be a uint64.');
	      this.amount = options.amount;
	    }

	    if (options.label) {
	      assert(typeof options.label === 'string', 'Label must be a string.');
	      this.label = options.label;
	    }

	    if (options.message) {
	      assert(typeof options.message === 'string', 'Message must be a string.');
	      this.message = options.message;
	    }

	    if (options.request) {
	      assert(typeof options.request === 'string', 'Request must be a string.');
	      this.request = options.request;
	    }

	    return this;
	  }

	  /**
	   * Instantiate URI from options.
	   * @param {Object|String} options
	   * @returns {URI}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Parse and inject properties from string.
	   * @private
	   * @param {String} str
	   * @param {Network?} network
	   * @returns {URI}
	   */

	  fromString(str, network) {
	    assert(typeof str === 'string');
	    assert(str.length > 8, 'Not a bitcoin URI.');

	    const prefix = str.substring(0, 8);

	    assert(prefix === 'bitcoin:', 'Not a bitcoin URI.');

	    str = str.substring(8);

	    const index = str.indexOf('?');

	    let addr, qs;
	    if (index === -1) {
	      addr = str;
	    } else {
	      addr = str.substring(0, index);
	      qs = str.substring(index + 1);
	    }

	    this.address.fromString(addr, network);

	    if (!qs)
	      return this;

	    const query = parsePairs(qs);

	    if (query.amount) {
	      assert(query.amount.length > 0, 'Value is empty.');
	      assert(query.amount[0] !== '-', 'Value is negative.');
	      this.amount = Amount.value(query.amount);
	    }

	    if (query.label)
	      this.label = query.label;

	    if (query.message)
	      this.message = query.message;

	    if (query.r)
	      this.request = query.r;

	    return this;
	  }

	  /**
	   * Instantiate uri from string.
	   * @param {String} str
	   * @param {Network?} network
	   * @returns {URI}
	   */

	  static fromString(str, network) {
	    return new this().fromString(str, network);
	  }

	  /**
	   * Serialize uri to a string.
	   * @returns {String}
	   */

	  toString() {
	    let str = 'bitcoin:';

	    str += this.address.toString();

	    const query = [];

	    if (this.amount !== -1)
	      query.push(`amount=${Amount.btc(this.amount)}`);

	    if (this.label)
	      query.push(`label=${escape(this.label)}`);

	    if (this.message)
	      query.push(`message=${escape(this.message)}`);

	    if (this.request)
	      query.push(`r=${escape(this.request)}`);

	    if (query.length > 0)
	      str += '?' + query.join('&');

	    return str;
	  }

	  /**
	   * Inspect bitcoin uri.
	   * @returns {String}
	   */

	  inspect() {
	    return `<URI: ${this.toString()}>`;
	  }
	}

	/*
	 * Helpers
	 */

	class BitcoinQuery {
	  constructor() {
	    this.amount = null;
	    this.label = null;
	    this.message = null;
	    this.r = null;
	  }
	}

	function parsePairs(str) {
	  const parts = str.split('&');
	  const data = new BitcoinQuery();

	  let size = 0;

	  for (const pair of parts) {
	    const index = pair.indexOf('=');
	    let key, value;

	    if (index === -1) {
	      key = pair;
	      value = '';
	    } else {
	      key = pair.substring(0, index);
	      value = pair.substring(index + 1);
	    }

	    if (key.length === 0) {
	      assert(value.length === 0, 'Empty key in querystring.');
	      continue;
	    }

	    assert(size < 4, 'Too many keys in querystring.');

	    switch (key) {
	      case 'amount':
	        assert(data.amount == null, 'Duplicate key in querystring (amount).');
	        data.amount = unescape(value);
	        break;
	      case 'label':
	        assert(data.label == null, 'Duplicate key in querystring (label).');
	        data.label = unescape(value);
	        break;
	      case 'message':
	        assert(data.message == null, 'Duplicate key in querystring (message).');
	        data.message = unescape(value);
	        break;
	      case 'r':
	        assert(data.r == null, 'Duplicate key in querystring (r).');
	        data.r = unescape(value);
	        break;
	      default:
	        assert(false, `Unknown querystring key: ${value}.`);
	        break;
	    }

	    size += 1;
	  }

	  return data;
	}

	function unescape(str) {
	  try {
	    str = decodeURIComponent(str);
	    str = str.replace(/\+/g, ' ');
	  } catch (e) {
	    throw new Error('Malformed URI.');
	  }

	  if (str.indexOf('\0') !== -1)
	    throw new Error('Malformed URI.');

	  return str;
	}

	function escape(str) {
	  str = encodeURIComponent(str);
	  str = str.replace(/%20/g, '+');
	  return str;
	}

	/*
	 * Expose
	 */

	uri = URI;
	return uri;
}

/*!
 * btc/index.js - high-level btc objects for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBtc;

function requireBtc () {
	if (hasRequiredBtc) return btc;
	hasRequiredBtc = 1;

	/**
	 * @module btc
	 */

	btc.Amount = requireAmount();
	btc.URI = requireUri();
	return btc;
}

var coins$1 = {};

/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */

var sha1;
var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(8, 0x00);
	const PADDING = Buffer.alloc(64, 0x00);

	PADDING[0] = 0x80;

	const K = new Uint32Array([
	  0x5a827999,
	  0x6ed9eba1,
	  0x8f1bbcdc,
	  0xca62c1d6
	]);

	/**
	 * SHA1
	 */

	class SHA1 {
	  constructor() {
	    this.state = new Uint32Array(5);
	    this.msg = new Uint32Array(80);
	    this.block = Buffer.alloc(64);
	    this.size = FINALIZED;
	  }

	  init() {
	    this.state[0] = 0x67452301;
	    this.state[1] = 0xefcdab89;
	    this.state[2] = 0x98badcfe;
	    this.state[3] = 0x10325476;
	    this.state[4] = 0xc3d2e1f0;
	    this.size = 0;
	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }

	  final() {
	    return this._final(Buffer.alloc(20));
	  }

	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    let pos = this.size & 63;
	    let off = 0;

	    this.size += len;

	    if (pos > 0) {
	      let want = 64 - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < 64)
	        return;

	      this._transform(this.block, 0);
	    }

	    while (len >= 64) {
	      this._transform(data, off);
	      off += 64;
	      len -= 64;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);
	  }

	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    const pos = this.size & 63;
	    const len = this.size * 8;

	    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 0);
	    writeU32(DESC, len >>> 0, 4);

	    this._update(PADDING, 1 + ((119 - pos) & 63));
	    this._update(DESC, 8);

	    for (let i = 0; i < 5; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }

	    for (let i = 0; i < 80; i++)
	      this.msg[i] = 0;

	    for (let i = 0; i < 64; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;

	    return out;
	  }

	  _transform(chunk, pos) {
	    const W = this.msg;

	    let a = this.state[0];
	    let b = this.state[1];
	    let c = this.state[2];
	    let d = this.state[3];
	    let e = this.state[4];
	    let i = 0;

	    for (; i < 16; i++)
	      W[i] = readU32(chunk, pos + i * 4);

	    for (; i < 80; i++)
	      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	    for (i = 0; i < 80; i++) {
	      const s = i / 20 | 0;
	      const t = rotl32(a, 5) + ft_1(s, b, c, d) + e + W[i] + K[s];

	      e = d;
	      d = c;
	      c = rotl32(b, 30);
	      b = a;
	      a = t >>> 0;
	    }

	    this.state[0] += a;
	    this.state[1] += b;
	    this.state[2] += c;
	    this.state[3] += d;
	    this.state[4] += e;
	  }

	  static hash() {
	    return new SHA1();
	  }

	  static hmac() {
	    return new HMAC(SHA1, 64);
	  }

	  static digest(data) {
	    return SHA1.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 20);
	    assert(Buffer.isBuffer(right) && right.length === 20);
	    return SHA1.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = SHA1;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return SHA1.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA1.native = 0;
	SHA1.id = 'SHA1';
	SHA1.size = 20;
	SHA1.bits = 160;
	SHA1.blockSize = 64;
	SHA1.zero = Buffer.alloc(20, 0x00);
	SHA1.ctx = new SHA1();

	/*
	 * Helpers
	 */

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);

	  if (s === 1 || s === 3)
	    return p32(x, y, z);

	  if (s === 2)
	    return maj32(x, y, z);

	  return 0;
	}

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}

	function readU32(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha1 = SHA1;
	return sha1;
}

var policy = {};

/*!
 * policy.js - bitcoin constants for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredPolicy;

function requirePolicy () {
	if (hasRequiredPolicy) return policy;
	hasRequiredPolicy = 1;
	(function (exports) {

		/**
		 * @module protocol/policy
		 */

		const assert = require$$0$3;
		const consensus = requireConsensus();

		/**
		 * Maximum transaction version (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_VERSION = consensus.MAX_TX_VERSION;

		/**
		 * Maximum standard transaction size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIZE = consensus.MAX_TX_SIZE / 10;

		/**
		 * Maximum number of transaction sigops (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_TX_SIGOPS = consensus.MAX_TX_SIGOPS / 5;

		/**
		 * How much weight a sigop should
		 * add to virtual size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.BYTES_PER_SIGOP = 20;

		/**
		 * Minimum relay fee rate (policy).
		 * @const {Rate}
		 */

		exports.MIN_RELAY = 1000;

		/**
		 * Whether bare multisig outputs
		 * should be relayed (policy).
		 * @const {Boolean}
		 * @default
		 */

		exports.BARE_MULTISIG = true;

		/**
		 * Priority threshold for
		 * free transactions (policy).
		 * @const {Number}
		 * @default
		 */

		exports.FREE_THRESHOLD = consensus.COIN * 144 / 250;

		/**
		 * Max sigops per redeem script (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2SH_SIGOPS = 15;

		/**
		 * Max serialized nulldata size (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_OP_RETURN_BYTES = 223;

		/**
		 * Max pushdata size in nulldata (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_OP_RETURN = 220;

		/**
		 * Max p2wsh stack size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_STACK = 100;

		/**
		 * Max p2wsh push size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_PUSH = 80;

		/**
		 * Max serialized p2wsh size. Used for
		 * witness malleation checks (policy).
		 * @const {Number}
		 * @default
		 */

		exports.MAX_P2WSH_SIZE = 3600;

		/**
		 * Default ancestor limit. 
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_ANCESTORS = 50;

		/**
		 * Default maximum mempool size in bytes.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_SIZE = 100 * 1000000;

		/**
		 * Time at which transactions
		 * fall out of the mempool.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_EXPIRY_TIME = 72 * 60 * 60;

		/**
		 * Maximum number of orphan transactions.
		 * @const {Number}
		 * @default
		 */

		exports.MEMPOOL_MAX_ORPHANS = 100;

		/**
		 * Minimum block size to create. Block will be
		 * filled with free transactions until block
		 * reaches this weight.
		 * @const {Number}
		 * @default
		 */

		exports.MIN_BLOCK_SIZE = 0;

		/**
		 * Maximum block size to be mined.
		 * @const {Number}
		 * @default
		 */

		exports.MAX_BLOCK_SIZE = consensus.MAX_FORK_BLOCK_SIZE;

		/**
		 * How much of the block should be dedicated to
		 * high-priority transactions (included regardless
		 * of fee rate).
		 * @const {Number}
		 * @default
		 */

		exports.BLOCK_PRIORITY_SIZE = 0;

		/**
		 * Priority threshold to be reached before
		 * switching to fee rate comparison.
		 * @const {Number}
		 * @default
		 */

		exports.BLOCK_PRIORITY_THRESHOLD = exports.FREE_THRESHOLD;

		/**
		 * Calculate minimum fee based on rate and size.
		 * @param {Number?} size
		 * @param {Rate?} rate - Rate of satoshi per kB.
		 * @returns {Amount} fee
		 */

		exports.getMinFee = function getMinFee(size, rate) {
		  if (rate == null)
		    rate = exports.MIN_RELAY;

		  assert(size >= 0);
		  assert(rate >= 0);

		  if (size === 0)
		    return 0;

		  let fee = Math.floor(rate * size / 1000);

		  if (fee === 0 && rate > 0)
		    fee = rate;

		  return fee;
		};

		/**
		 * Calculate the minimum fee in order for the transaction
		 * to be relayable, but _round to the nearest kilobyte
		 * when taking into account size.
		 * @param {Number?} size
		 * @param {Rate?} rate - Rate of satoshi per kB.
		 * @returns {Amount} fee
		 */

		exports.getRoundFee = function getRoundFee(size, rate) {
		  if (rate == null)
		    rate = exports.MIN_RELAY;

		  assert(size >= 0);
		  assert(rate >= 0);

		  if (size === 0)
		    return 0;

		  let fee = rate * Math.ceil(size / 1000);

		  if (fee === 0 && rate > 0)
		    fee = rate;

		  return fee;
		};

		/**
		 * Calculate a fee rate based on size and fees.
		 * @param {Number} size
		 * @param {Amount} fee
		 * @returns {Rate}
		 */

		exports.getRate = function getRate(size, fee) {
		  assert(size >= 0);
		  assert(fee >= 0);

		  if (size === 0)
		    return 0;

		  return Math.floor(fee * 1000 / size);
		}; 
	} (policy));
	return policy;
}

/*!
 * scripterror.js - script error for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var scripterror;
var hasRequiredScripterror;

function requireScripterror () {
	if (hasRequiredScripterror) return scripterror;
	hasRequiredScripterror = 1;

	/**
	 * Script Error
	 * An error thrown from the scripting system,
	 * potentially pertaining to Script execution.
	 * @alias module:script.ScriptError
	 * @extends Error
	 * @property {String} message - Error message.
	 * @property {String} code - Original code passed in.
	 * @property {Number} op - Opcode.
	 * @property {Number} ip - Instruction pointer.
	 */

	class ScriptError extends Error {
	  /**
	   * Create an error.
	   * @constructor
	   * @param {String} code - Error code.
	   * @param {Opcode} op - Opcode.
	   * @param {Number?} ip - Instruction pointer.
	   */

	  constructor(code, op, ip) {
	    super();

	    this.type = 'ScriptError';
	    this.code = code;
	    this.message = code;
	    this.op = -1;
	    this.ip = -1;

	    if (typeof op === 'string') {
	      this.message = op;
	    } else if (op) {
	      this.message = `${code} (op=${op.toSymbol()}, ip=${ip})`;
	      this.op = op.value;
	      this.ip = ip;
	    }

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(this, ScriptError);
	  }
	}

	/*
	 * Expose
	 */

	scripterror = ScriptError;
	return scripterror;
}

/*!
 * scriptnum.js - script number object for bcoin.
 * Copyright (c) 2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var scriptnum;
var hasRequiredScriptnum;

function requireScriptnum () {
	if (hasRequiredScriptnum) return scriptnum;
	hasRequiredScriptnum = 1;

	const assert = require$$0$3;
	const {I64} = require$$1$1;
	const ScriptError = requireScripterror();

	/*
	 * Constants
	 */

	const EMPTY_ARRAY = Buffer.alloc(0);

	/**
	 * Script Number
	 * @see https://github.com/chjj/n64
	 * @alias module:script.ScriptNum
	 * @property {Number} hi
	 * @property {Number} lo
	 * @property {Number} sign
	 */

	class ScriptNum extends I64 {
	  /**
	   * Create a script number.
	   * @constructor
	   * @param {(Number|String|Buffer|Object)?} num
	   * @param {(String|Number)?} base
	   */

	  constructor(num, base) {
	    super(num, base);
	  }

	  /**
	   * Cast to int32.
	   * @returns {Number}
	   */

	  getInt() {
	    if (this.lt(I64.INT32_MIN))
	      return I64.LONG_MIN;

	    if (this.gt(I64.INT32_MAX))
	      return I64.LONG_MAX;

	    return this.toInt();
	  }

	  /**
	   * Serialize script number.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    let num = this;

	    // Zeroes are always empty arrays.
	    if (num.isZero())
	      return EMPTY_ARRAY;

	    // Need to append sign bit.
	    let neg = false;
	    if (num.isNeg()) {
	      num = num.neg();
	      neg = true;
	    }

	    // Calculate size.
	    const size = num.byteLength();

	    let offset = 0;

	    if (num.testn((size * 8) - 1))
	      offset = 1;

	    // Write number.
	    const data = Buffer.allocUnsafe(size + offset);

	    switch (size) {
	      case 8:
	        data[7] = (num.hi >>> 24) & 0xff;
	      case 7:
	        data[6] = (num.hi >> 16) & 0xff;
	      case 6:
	        data[5] = (num.hi >> 8) & 0xff;
	      case 5:
	        data[4] = num.hi & 0xff;
	      case 4:
	        data[3] = (num.lo >>> 24) & 0xff;
	      case 3:
	        data[2] = (num.lo >> 16) & 0xff;
	      case 2:
	        data[1] = (num.lo >> 8) & 0xff;
	      case 1:
	        data[0] = num.lo & 0xff;
	    }

	    // Append sign bit.
	    if (data[size - 1] & 0x80) {
	      assert(offset === 1);
	      assert(data.length === size + offset);
	      data[size] = neg ? 0x80 : 0;
	    } else if (neg) {
	      assert(offset === 0);
	      assert(data.length === size);
	      data[size - 1] |= 0x80;
	    } else {
	      assert(offset === 0);
	      assert(data.length === size);
	    }

	    return data;
	  }

	  /**
	   * Instantiate script number from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {ScriptNum}
	   */

	  fromRaw(data) {
	    assert(Buffer.isBuffer(data));

	    // Empty arrays are always zero.
	    if (data.length === 0)
	      return this;

	    // Read number (9 bytes max).
	    switch (data.length) {
	      case 8:
	        this.hi |= data[7] << 24;
	      case 7:
	        this.hi |= data[6] << 16;
	      case 6:
	        this.hi |= data[5] << 8;
	      case 5:
	        this.hi |= data[4];
	      case 4:
	        this.lo |= data[3] << 24;
	      case 3:
	        this.lo |= data[2] << 16;
	      case 2:
	        this.lo |= data[1] << 8;
	      case 1:
	        this.lo |= data[0];
	        break;
	      default:
	        for (let i = 0; i < data.length; i++)
	          this.orb(i, data[i]);
	        break;
	    }

	    // Remove high bit and flip sign.
	    if (data[data.length - 1] & 0x80) {
	      this.setn((data.length * 8) - 1, 0);
	      this.ineg();
	    }

	    return this;
	  }

	  /**
	   * Serialize script number.
	   * @returns {Buffer}
	   */

	  encode() {
	    return this.toRaw();
	  }

	  /**
	   * Decode and verify script number.
	   * @private
	   * @param {Buffer} data
	   * @param {Boolean?} minimal - Require minimal encoding.
	   * @param {Number?} limit - Size limit.
	   * @returns {ScriptNum}
	   */

	  decode(data, minimal, limit) {
	    assert(Buffer.isBuffer(data));

	    if (limit != null && data.length > limit)
	      throw new ScriptError('UNKNOWN_ERROR', 'Script number overflow.');

	    if (minimal && !ScriptNum.isMinimal(data))
	      throw new ScriptError('UNKNOWN_ERROR', 'Non-minimal script number.');

	    return this.fromRaw(data);
	  }

	  /**
	   * Inspect script number.
	   * @returns {String}
	   */

	  inspect() {
	    return `<ScriptNum: ${this.toString(10)}>`;
	  }

	  /**
	   * Test wether a serialized script
	   * number is in its most minimal form.
	   * @param {Buffer} data
	   * @returns {Boolean}
	   */

	  static isMinimal(data) {
	    assert(Buffer.isBuffer(data));

	    if (data.length === 0)
	      return true;

	    if ((data[data.length - 1] & 0x7f) === 0) {
	      if (data.length === 1)
	        return false;

	      if ((data[data.length - 2] & 0x80) === 0)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Encode serialized script number in its most minimal form.
	   * @param {Buffer} data
	   * @returns {Buffer} minimal encoded data
	   */

	  static toMinimal(data) {
	    assert(Buffer.isBuffer(data));

	    if (this.isMinimal(data))
	      return data;

	    const last = data[data.length - 1];

	    // We are not minimally encoded, we need to figure out how much to trim.
	    for (let i = data.length - 1; i > 0; i--) {
	      // We found a non zero byte, time to encode.
	      if (data[i - 1] !== 0) {
	        if (data[i - 1] & 0x80) {
	          // We found a byte with it sign bit set so we need one more
	          // byte.
	          data[i++] = last;
	        } else {
	          // the sign bit is clear, we can use it.
	          data[i - 1] |= last;
	        }

	        data = data.slice(0, i);
	        return data;
	      }
	    }

	    // If we the whole thing is zeros, then we have a zero.
	    data = Buffer.alloc(0);
	    return data;
	  }

	  /**
	   * Decode and verify script number.
	   * @param {Buffer} data
	   * @param {Boolean?} minimal - Require minimal encoding.
	   * @param {Number?} limit - Size limit.
	   * @returns {ScriptNum}
	   */

	  static decode(data, minimal, limit) {
	    return new this().decode(data, minimal, limit);
	  }

	  /**
	   * Test whether object is a script number.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isScriptNum(obj) {
	    return obj instanceof ScriptNum;
	  }
	}

	/*
	 * Expose
	 */

	scriptnum = ScriptNum;
	return scriptnum;
}

var common$1 = {};

/*!
 * common.js - common script functions for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	(function (exports) {

		/**
		 * @module script/common
		 */

		const assert = require$$0$3;
		const secp256k1 = requireSecp256k1();
		const ScriptNum = requireScriptnum();

		/**
		 * Script opcodes.
		 * @enum {Number}
		 * @default
		 */

		exports.opcodes = {
		  // Push
		  OP_0: 0x00,

		  OP_PUSHDATA1: 0x4c,
		  OP_PUSHDATA2: 0x4d,
		  OP_PUSHDATA4: 0x4e,

		  OP_1NEGATE: 0x4f,

		  OP_RESERVED: 0x50,

		  OP_1: 0x51,
		  OP_2: 0x52,
		  OP_3: 0x53,
		  OP_4: 0x54,
		  OP_5: 0x55,
		  OP_6: 0x56,
		  OP_7: 0x57,
		  OP_8: 0x58,
		  OP_9: 0x59,
		  OP_10: 0x5a,
		  OP_11: 0x5b,
		  OP_12: 0x5c,
		  OP_13: 0x5d,
		  OP_14: 0x5e,
		  OP_15: 0x5f,
		  OP_16: 0x60,

		  // Control
		  OP_NOP: 0x61,
		  OP_VER: 0x62,
		  OP_IF: 0x63,
		  OP_NOTIF: 0x64,
		  OP_VERIF: 0x65,
		  OP_VERNOTIF: 0x66,
		  OP_ELSE: 0x67,
		  OP_ENDIF: 0x68,
		  OP_VERIFY: 0x69,
		  OP_RETURN: 0x6a,

		  // Stack
		  OP_TOALTSTACK: 0x6b,
		  OP_FROMALTSTACK: 0x6c,
		  OP_2DROP: 0x6d,
		  OP_2DUP: 0x6e,
		  OP_3DUP: 0x6f,
		  OP_2OVER: 0x70,
		  OP_2ROT: 0x71,
		  OP_2SWAP: 0x72,
		  OP_IFDUP: 0x73,
		  OP_DEPTH: 0x74,
		  OP_DROP: 0x75,
		  OP_DUP: 0x76,
		  OP_NIP: 0x77,
		  OP_OVER: 0x78,
		  OP_PICK: 0x79,
		  OP_ROLL: 0x7a,
		  OP_ROT: 0x7b,
		  OP_SWAP: 0x7c,
		  OP_TUCK: 0x7d,

		  // Splice
		  OP_CAT: 0x7e,
		  OP_SPLIT: 0x7f,
		  OP_NUM2BIN: 0x80,
		  OP_BIN2NUM: 0x81,
		  OP_SIZE: 0x82,

		  // Bit
		  OP_INVERT: 0x83,
		  OP_AND: 0x84,
		  OP_OR: 0x85,
		  OP_XOR: 0x86,
		  OP_EQUAL: 0x87,
		  OP_EQUALVERIFY: 0x88,
		  OP_RESERVED1: 0x89,
		  OP_RESERVED2: 0x8a,

		  // Numeric
		  OP_1ADD: 0x8b,
		  OP_1SUB: 0x8c,
		  OP_2MUL: 0x8d,
		  OP_2DIV: 0x8e,
		  OP_NEGATE: 0x8f,
		  OP_ABS: 0x90,
		  OP_NOT: 0x91,
		  OP_0NOTEQUAL: 0x92,
		  OP_ADD: 0x93,
		  OP_SUB: 0x94,
		  OP_MUL: 0x95,
		  OP_DIV: 0x96,
		  OP_MOD: 0x97,
		  OP_LSHIFT: 0x98,
		  OP_RSHIFT: 0x99,
		  OP_BOOLAND: 0x9a,
		  OP_BOOLOR: 0x9b,
		  OP_NUMEQUAL: 0x9c,
		  OP_NUMEQUALVERIFY: 0x9d,
		  OP_NUMNOTEQUAL: 0x9e,
		  OP_LESSTHAN: 0x9f,
		  OP_GREATERTHAN: 0xa0,
		  OP_LESSTHANOREQUAL: 0xa1,
		  OP_GREATERTHANOREQUAL: 0xa2,
		  OP_MIN: 0xa3,
		  OP_MAX: 0xa4,
		  OP_WITHIN: 0xa5,

		  // Crypto
		  OP_RIPEMD160: 0xa6,
		  OP_SHA1: 0xa7,
		  OP_SHA256: 0xa8,
		  OP_HASH160: 0xa9,
		  OP_HASH256: 0xaa,
		  OP_CODESEPARATOR: 0xab,
		  OP_CHECKSIG: 0xac,
		  OP_CHECKSIGVERIFY: 0xad,
		  OP_CHECKMULTISIG: 0xae,
		  OP_CHECKMULTISIGVERIFY: 0xaf,

		  // Expansion
		  OP_NOP1: 0xb0,
		  OP_CHECKLOCKTIMEVERIFY: 0xb1,
		  OP_CHECKSEQUENCEVERIFY: 0xb2,
		  OP_NOP4: 0xb3,
		  OP_NOP5: 0xb4,
		  OP_NOP6: 0xb5,
		  OP_NOP7: 0xb6,
		  OP_NOP8: 0xb7,
		  OP_NOP9: 0xb8,
		  OP_NOP10: 0xb9,

		  // More Crypto
		  OP_CHECKDATASIG: 0xba,
		  OP_CHECKDATASIGVERIFY: 0xbb,

		  // additional byte-string operations
		  OP_REVERSEBYTES: 0xbc,

		  // Custom
		  OP_INVALIDOPCODE: 0xff
		};

		/**
		 * Opcodes by value.
		 * @const {Object}
		 */

		exports.opcodesByVal = {
		  // Push
		  0x00: 'OP_0',

		  0x4c: 'OP_PUSHDATA1',
		  0x4d: 'OP_PUSHDATA2',
		  0x4e: 'OP_PUSHDATA4',

		  0x4f: 'OP_1NEGATE',

		  0x50: 'OP_RESERVED',

		  0x51: 'OP_1',
		  0x52: 'OP_2',
		  0x53: 'OP_3',
		  0x54: 'OP_4',
		  0x55: 'OP_5',
		  0x56: 'OP_6',
		  0x57: 'OP_7',
		  0x58: 'OP_8',
		  0x59: 'OP_9',
		  0x5a: 'OP_10',
		  0x5b: 'OP_11',
		  0x5c: 'OP_12',
		  0x5d: 'OP_13',
		  0x5e: 'OP_14',
		  0x5f: 'OP_15',
		  0x60: 'OP_16',

		  // Control
		  0x61: 'OP_NOP',
		  0x62: 'OP_VER',
		  0x63: 'OP_IF',
		  0x64: 'OP_NOTIF',
		  0x65: 'OP_VERIF',
		  0x66: 'OP_VERNOTIF',
		  0x67: 'OP_ELSE',
		  0x68: 'OP_ENDIF',
		  0x69: 'OP_VERIFY',
		  0x6a: 'OP_RETURN',

		  // Stack
		  0x6b: 'OP_TOALTSTACK',
		  0x6c: 'OP_FROMALTSTACK',
		  0x6d: 'OP_2DROP',
		  0x6e: 'OP_2DUP',
		  0x6f: 'OP_3DUP',
		  0x70: 'OP_2OVER',
		  0x71: 'OP_2ROT',
		  0x72: 'OP_2SWAP',
		  0x73: 'OP_IFDUP',
		  0x74: 'OP_DEPTH',
		  0x75: 'OP_DROP',
		  0x76: 'OP_DUP',
		  0x77: 'OP_NIP',
		  0x78: 'OP_OVER',
		  0x79: 'OP_PICK',
		  0x7a: 'OP_ROLL',
		  0x7b: 'OP_ROT',
		  0x7c: 'OP_SWAP',
		  0x7d: 'OP_TUCK',

		  // Splice
		  0x7e: 'OP_CAT',
		  0x7f: 'OP_SPLIT',
		  0x80: 'OP_NUM2BIN',
		  0x81: 'OP_BIN2NUM',
		  0x82: 'OP_SIZE',

		  // Bit
		  0x83: 'OP_INVERT',
		  0x84: 'OP_AND',
		  0x85: 'OP_OR',
		  0x86: 'OP_XOR',
		  0x87: 'OP_EQUAL',
		  0x88: 'OP_EQUALVERIFY',
		  0x89: 'OP_RESERVED1',
		  0x8a: 'OP_RESERVED2',

		  // Numeric
		  0x8b: 'OP_1ADD',
		  0x8c: 'OP_1SUB',
		  0x8d: 'OP_2MUL',
		  0x8e: 'OP_2DIV',
		  0x8f: 'OP_NEGATE',
		  0x90: 'OP_ABS',
		  0x91: 'OP_NOT',
		  0x92: 'OP_0NOTEQUAL',
		  0x93: 'OP_ADD',
		  0x94: 'OP_SUB',
		  0x95: 'OP_MUL',
		  0x96: 'OP_DIV',
		  0x97: 'OP_MOD',
		  0x98: 'OP_LSHIFT',
		  0x99: 'OP_RSHIFT',
		  0x9a: 'OP_BOOLAND',
		  0x9b: 'OP_BOOLOR',
		  0x9c: 'OP_NUMEQUAL',
		  0x9d: 'OP_NUMEQUALVERIFY',
		  0x9e: 'OP_NUMNOTEQUAL',
		  0x9f: 'OP_LESSTHAN',
		  0xa0: 'OP_GREATERTHAN',
		  0xa1: 'OP_LESSTHANOREQUAL',
		  0xa2: 'OP_GREATERTHANOREQUAL',
		  0xa3: 'OP_MIN',
		  0xa4: 'OP_MAX',
		  0xa5: 'OP_WITHIN',

		  // Crypto
		  0xa6: 'OP_RIPEMD160',
		  0xa7: 'OP_SHA1',
		  0xa8: 'OP_SHA256',
		  0xa9: 'OP_HASH160',
		  0xaa: 'OP_HASH256',
		  0xab: 'OP_CODESEPARATOR',
		  0xac: 'OP_CHECKSIG',
		  0xad: 'OP_CHECKSIGVERIFY',
		  0xae: 'OP_CHECKMULTISIG',
		  0xaf: 'OP_CHECKMULTISIGVERIFY',

		  // Expansion
		  0xb0: 'OP_NOP1',
		  0xb1: 'OP_CHECKLOCKTIMEVERIFY',
		  0xb2: 'OP_CHECKSEQUENCEVERIFY',
		  0xb3: 'OP_NOP4',
		  0xb4: 'OP_NOP5',
		  0xb5: 'OP_NOP6',
		  0xb6: 'OP_NOP7',
		  0xb7: 'OP_NOP8',
		  0xb8: 'OP_NOP9',
		  0xb9: 'OP_NOP10',

		  // More Crypto
		  0xba: 'OP_CHECKDATASIG',
		  0xbb: 'OP_CHECKDATASIGVERIFY',

		  // Additional byte-string operation
		  0xbc: 'OP_REVERSEBYTES',

		  // Custom
		  0xff: 'OP_INVALIDOPCODE'
		};

		/**
		 * Small ints (1 indexed, 1==0).
		 * @const {Buffer[]}
		 */

		exports.small = [
		  Buffer.from([0x81]),
		  Buffer.from([]),
		  Buffer.from([0x01]),
		  Buffer.from([0x02]),
		  Buffer.from([0x03]),
		  Buffer.from([0x04]),
		  Buffer.from([0x05]),
		  Buffer.from([0x06]),
		  Buffer.from([0x07]),
		  Buffer.from([0x08]),
		  Buffer.from([0x09]),
		  Buffer.from([0x0a]),
		  Buffer.from([0x0b]),
		  Buffer.from([0x0c]),
		  Buffer.from([0x0d]),
		  Buffer.from([0x0e]),
		  Buffer.from([0x0f]),
		  Buffer.from([0x10])
		];

		/**
		 * Script and locktime flags. See {@link VerifyFlags}.
		 * @enum {Number}
		 */

		exports.flags = {
		  VERIFY_NONE: 0,
		  VERIFY_P2SH: 1 << 0,
		  VERIFY_STRICTENC: 1 << 1,
		  VERIFY_DERSIG: 1 << 2,
		  VERIFY_LOW_S: 1 << 3,
		  VERIFY_SIGPUSHONLY: 1 << 5,
		  VERIFY_MINIMALDATA: 1 << 6,
		  VERIFY_DISCOURAGE_UPGRADABLE_NOPS: 1 << 7,
		  VERIFY_CLEANSTACK: 1 << 8,
		  VERIFY_CHECKLOCKTIMEVERIFY: 1 << 9,
		  VERIFY_CHECKSEQUENCEVERIFY: 1 << 10,
		  VERIFY_MINIMALIF: 1 << 13,
		  VERIFY_NULLFAIL: 1 << 14,
		  VERIFY_COMPRESSED_PUBKEYTYPE: 1 << 15,
		  VERIFY_SIGHASH_FORKID: 1 << 16,
		  VERIFY_REPLAY_PROTECTION: 1 << 17,
		  VERIFY_CHECKDATASIG: 1 << 18,
		  VERIFY_SCHNORR: 1 << 19,
		  VERIFY_DISALLOW_SEGWIT_RECOVERY: 1 << 20,
		  VERIFY_SCHNORR_MULTISIG: 1 << 21,
		  VERIFY_INPUT_SIGCHECKS: 1 << 22,
		  VERIFY_REVERSEBYTES: 1 << 23,
		  VERIFY_ZERO_SIGOPS: 1 << 30,
		  REPORT_SIGCHECKS: 1 << 31
		};

		/**
		 * Consensus verify flags (used for block validation).
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.MANDATORY_VERIFY_FLAGS = exports.flags.VERIFY_P2SH;

		/**
		 * Standard verify flags (used for mempool validation).
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.STANDARD_VERIFY_FLAGS = 0
		  | exports.flags.MANDATORY_VERIFY_FLAGS
		  | exports.flags.VERIFY_DERSIG
		  | exports.flags.VERIFY_STRICTENC
		  | exports.flags.VERIFY_MINIMALDATA
		  | exports.flags.VERIFY_SIGPUSHONLY
		  | exports.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS
		  | exports.flags.VERIFY_CLEANSTACK
		  | exports.flags.VERIFY_MINIMALIF
		  | exports.flags.VERIFY_NULLFAIL
		  | exports.flags.VERIFY_CHECKLOCKTIMEVERIFY
		  | exports.flags.VERIFY_CHECKSEQUENCEVERIFY
		  | exports.flags.VERIFY_LOW_S
		  | exports.flags.VERIFY_SIGHASH_FORKID
		  | exports.flags.VERIFY_CHECKDATASIG
		  | exports.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY
		  | exports.flags.VERIFY_SCHNORR_MULTISIG;

		/**
		 * Standard flags without mandatory bits.
		 * @const {VerifyFlags}
		 * @default
		 */

		exports.flags.ONLY_STANDARD_VERIFY_FLAGS =
		  exports.flags.STANDARD_VERIFY_FLAGS & ~exports.flags.MANDATORY_VERIFY_FLAGS;

		/**
		 * Sighash Types.
		 * @enum {SighashType}
		 * @default
		 */

		exports.hashType = {
		  /*
		   * Sign all outputs.
		   */

		  ALL: 1,

		  /*
		   * Do not sign outputs (zero sequences).
		   */

		  NONE: 2,

		  /*
		   * Sign output at the same index (zero sequences).
		   */

		  SINGLE: 3,

		  /*
		   * Sighash fork ID.
		   */

		  SIGHASH_FORKID: 0x40,

		  /*
		   * Sign only the current input (mask).
		   */

		  ANYONECANPAY: 0x80
		};

		/**
		 * Sighash types by value.
		 * @const {Object}
		 */

		exports.hashTypeByVal = {
		  1: 'ALL',
		  2: 'NONE',
		  3: 'SINGLE',
		  0x80: 'ANYONECANPAY'
		};

		/**
		 * Output script types.
		 * @enum {Number}
		 */

		exports.types = {
		  NONSTANDARD: 0,
		  PUBKEY: 1,
		  PUBKEYHASH: 2,
		  SCRIPTHASH: 3,
		  MULTISIG: 4,
		  NULLDATA: 5
		};

		/**
		 * Output script types by value.
		 * @const {Object}
		 */

		exports.typesByVal = {
		  0: 'NONSTANDARD',
		  1: 'PUBKEY',
		  2: 'PUBKEYHASH',
		  3: 'SCRIPTHASH',
		  4: 'MULTISIG',
		  5: 'NULLDATA'
		};

		/**
		 * Test a signature to see whether it contains a valid sighash type.
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isHashType = function isHashType(sig) {
		  assert(Buffer.isBuffer(sig));

		  if (sig.length === 0)
		    return false;

		  const type = sig[sig.length - 1]
		    & ~(exports.hashType.ANYONECANPAY | exports.hashType.SIGHASH_FORKID);

		  if (type < exports.hashType.ALL || type > exports.hashType.SINGLE)
		    return false;

		  return true;
		};

		/**
		 * Bitfield calculation helper for signatures.
		 * @param {Number} bits
		 * @returns {Number}
		 */

		exports.countBits = function countBits(bits) {
		  bits = bits - ((bits >> 1) & 0x55555555);
		  bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);
		  return (((bits + (bits >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;
		};

		/**
		 * Test whether a signature is 64-bytes in length
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isSchnorr = function isSchnorr(sig)  {
		  assert(Buffer.isBuffer(sig));
		  return sig.length === 64;
		};

		/**
		 * Test a signature to see whether it contains a low S value.
		 * NOTE: signature MUST exclude sighash byte
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isLowDER = function isLowDER(sig) {
		  if (!exports.isDERSignatureEncoding(sig))
		    return false;

		  return secp256k1.isLowDER(sig);
		};

		/**
		 * Test whether the data element is a valid key.
		 * @param {Buffer} key
		 * @returns {Boolean}
		 */

		exports.isKeyEncoding = function isKeyEncoding(key) {
		  assert(Buffer.isBuffer(key));

		  if (key.length < 33)
		    return false;

		  if (key[0] === 0x04) {
		    if (key.length !== 65)
		      return false;
		  } else if (key[0] === 0x02 || key[0] === 0x03) {
		    if (key.length !== 33)
		      return false;
		  } else {
		    return false;
		  }

		  return true;
		};

		/**
		 * Test whether the data element is a compressed key.
		 * @param {Buffer} key
		 * @returns {Boolean}
		 */

		exports.isCompressedEncoding = function isCompressedEncoding(key) {
		  assert(Buffer.isBuffer(key));

		  if (key.length !== 33)
		    return false;

		  if (key[0] !== 0x02 && key[0] !== 0x03)
		    return false;

		  return true;
		};

		/**
		 * Test a signature to see if it abides by BIP66.
		 * NOTE: signature MUST exclude sighash byte
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
		 * @param {Buffer} sig
		 * @returns {Boolean}
		 */

		exports.isDERSignatureEncoding = function isDERSignatureEncoding(sig) {
		  assert(Buffer.isBuffer(sig));

		  // Format:
		  //   0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]
		  // * total-length: 1-byte length descriptor of everything that follows,
		  //   excluding the sighash byte.
		  // * R-length: 1-byte length descriptor of the R value that follows.
		  // * R: arbitrary-length big-endian encoded R value. It must use the shortest
		  //   possible encoding for a positive integers (which means no null bytes at
		  //   the start, except a single one when the next byte has its highest bit
		  //   set).
		  // * S-length: 1-byte length descriptor of the S value that follows.
		  // * S: arbitrary-length big-endian encoded S value. The same rules apply.
		  // * sighash: 1-byte value indicating what data is hashed (not part of the DER
		  //   signature)

		  // Minimum and maximum size constraints.
		  if (sig.length < 8)
		    return false;

		  if (sig.length > 72)
		    return false;

		  // A signature is of type 0x30 (compound).
		  if (sig[0] !== 0x30)
		    return false;

		  // Make sure the length covers the entire signature.
		  if (sig[1] !== sig.length - 2)
		    return false;

		  // Extract the length of the R element.
		  const lenR = sig[3];

		  // Make sure the length of the S element is still inside the signature.
		  if (5 + lenR >= sig.length)
		    return false;

		  // Extract the length of the S element.
		  const lenS = sig[5 + lenR];

		  // Verify that the length of the signature matches the sum of the length
		  // of the elements.
		  if (lenR + lenS + 6 !== sig.length)
		    return false;

		  // Check whether the R element is an integer.
		  if (sig[2] !== 0x02)
		    return false;

		  // Zero-length integers are not allowed for R.
		  if (lenR === 0)
		    return false;

		  // Negative numbers are not allowed for R.
		  if (sig[4] & 0x80)
		    return false;

		  // Null bytes at the start of R are not allowed, unless R would
		  // otherwise be interpreted as a negative number.
		  if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80))
		    return false;

		  // Check whether the S element is an integer.
		  if (sig[lenR + 4] !== 0x02)
		    return false;

		  // Zero-length integers are not allowed for S.
		  if (lenS === 0)
		    return false;

		  // Negative numbers are not allowed for S.
		  if (sig[lenR + 6] & 0x80)
		    return false;

		  // Null bytes at the start of S are not allowed, unless S would otherwise be
		  // interpreted as a negative number.
		  if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80))
		    return false;

		  return true;
		};

		/**
		 * Format stack item into bitcoind asm format.
		 * @param {Buffer} item
		 * @param {Boolean?} decode - Attempt to decode hash types.
		 * @returns {String} Human-readable string.
		 */

		exports.toASM = function toASM(item, decode) {
		  if (item.length <= 4) {
		    const num = ScriptNum.decode(item);
		    return num.toString(10);
		  }

		  if (decode && exports.isDERSignatureEncoding(item.slice(0, -1))) {
		    const type = item[item.length - 1];

		    let symbol = exports.hashTypeByVal[type & 0x1f] || '';

		    if (symbol) {
		      if (type & exports.hashType.ANYONECANPAY)
		        symbol += '|ANYONECANPAY';
		      symbol = `[${symbol}]`;
		    }

		    return item.slice(0, -1).toString('hex') + symbol;
		  }

		  return item.toString('hex');
		};

		/**
		 * Sighash with fork value for replay protection
		 * @param {SighashType} sighash
		 * @param {Number} value
		 * @returns {SighashType}
		 */

		exports.hashTypeWithForkValue = function hashTypeWithForkValue(sighash, value) {
		  return (value << 8) | (sighash & 0xff);
		};

		/**
		 * Get fork value from hashtype
		 * @param {SighashType} sighash
		 * @returns {Number}
		 */

		exports.getHashTypeForkValue = function getHashTypeForkValue(sighash) {
		  return (sighash >>> 8);
		}; 
	} (common$1));
	return common$1;
}

/*!
 * opcode.js - opcode object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var opcode;
var hasRequiredOpcode;

function requireOpcode () {
	if (hasRequiredOpcode) return opcode;
	hasRequiredOpcode = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const ScriptNum = requireScriptnum();
	const common = requireCommon$1();
	const opcodes = common.opcodes;

	const opCache = [];

	let PARSE_ERROR = null;

	/**
	 * Opcode
	 * A simple struct which contains
	 * an opcode and pushdata buffer.
	 * @alias module:script.Opcode
	 * @property {Number} value
	 * @property {Buffer|null} data
	 */

	class Opcode {
	  /**
	   * Create an opcode.
	   * Note: this should not be called directly.
	   * @constructor
	   * @param {Number} value - Opcode.
	   * @param {Buffer?} data - Pushdata buffer.
	   */

	  constructor(value, data) {
	    this.value = value || 0;
	    this.data = data || null;
	  }

	  /**
	   * Test whether a pushdata abides by minimaldata.
	   * @returns {Boolean}
	   */

	  isMinimal() {
	    assert(0 <= this.value && this.value <= opcodes.OP_PUSHDATA4);

	    if (!this.data)
	      return true;

	    if (this.data.length === 1) {
	      if (this.data[0] === 0x81)
	        return false;

	      if (this.data[0] >= 1 && this.data[0] <= 16)
	        return false;
	    }

	    if (this.data.length <= 0x4b)
	      return this.value === this.data.length;

	    if (this.data.length <= 0xff)
	      return this.value === opcodes.OP_PUSHDATA1;

	    if (this.data.length <= 0xffff)
	      return this.value === opcodes.OP_PUSHDATA2;

	    return true;
	  }

	  /**
	   * Test whether opcode is a disabled opcode.
	   * @param {Number?} flags - Script standard flags.
	   * @returns {Boolean}
	   */

	  isDisabled(flags) {
	    switch (this.value) {
	      case opcodes.OP_INVERT:
	      case opcodes.OP_2MUL:
	      case opcodes.OP_2DIV:
	      case opcodes.OP_MUL:
	      case opcodes.OP_LSHIFT:
	      case opcodes.OP_RSHIFT:
	        return true;
	    }

	    return false;
	  }

	  /**
	   * Test whether opcode is a branch (if/else/endif).
	   * @returns {Boolean}
	   */

	  isBranch() {
	    return this.value >= opcodes.OP_IF && this.value <= opcodes.OP_ENDIF;
	  }

	  /**
	   * Test opcode equality.
	   * @param {Opcode} op
	   * @returns {Boolean}
	   */

	  equals(op) {
	    assert(Opcode.isOpcode(op));

	    if (this.value !== op.value)
	      return false;

	    if (!this.data) {
	      assert(!op.data);
	      return true;
	    }

	    assert(op.data);

	    return this.data.equals(op.data);
	  }

	  /**
	   * Convert Opcode to opcode value.
	   * @returns {Number}
	   */

	  toOp() {
	    return this.value;
	  }

	  /**
	   * Covert opcode to data push.
	   * @returns {Buffer|null}
	   */

	  toData() {
	    return this.data;
	  }

	  /**
	   * Covert opcode to data length.
	   * @returns {Number}
	   */

	  toLength() {
	    return this.data ? this.data.length : -1;
	  }

	  /**
	   * Covert and _cast_ opcode to data push.
	   * @returns {Buffer|null}
	   */

	  toPush() {
	    if (this.value === opcodes.OP_0)
	      return common.small[0 + 1];

	    if (this.value === opcodes.OP_1NEGATE)
	      return common.small[-1 + 1];

	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
	      return common.small[this.value - 0x50 + 1];

	    return this.toData();
	  }

	  /**
	   * Get string for opcode.
	   * @param {String?} enc
	   * @returns {Buffer|null}
	   */

	  toString(enc) {
	    const data = this.toPush();

	    if (!data)
	      return null;

	    return data.toString(enc || 'utf8');
	  }

	  /**
	   * Convert opcode to small integer.
	   * @returns {Number}
	   */

	  toSmall() {
	    if (this.value === opcodes.OP_0)
	      return 0;

	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
	      return this.value - 0x50;

	    return -1;
	  }

	  /**
	   * Convert opcode to script number.
	   * @param {Boolean?} minimal
	   * @param {Number?} limit
	   * @returns {ScriptNum|null}
	   */

	  toNum(minimal, limit) {
	    if (this.value === opcodes.OP_0)
	      return ScriptNum.fromInt(0);

	    if (this.value === opcodes.OP_1NEGATE)
	      return ScriptNum.fromInt(-1);

	    if (this.value >= opcodes.OP_1 && this.value <= opcodes.OP_16)
	      return ScriptNum.fromInt(this.value - 0x50);

	    if (!this.data)
	      return null;

	    return ScriptNum.decode(this.data, minimal, limit);
	  }

	  /**
	   * Convert opcode to integer.
	   * @param {Boolean?} minimal
	   * @param {Number?} limit
	   * @returns {Number}
	   */

	  toInt(minimal, limit) {
	    const num = this.toNum(minimal, limit);

	    if (!num)
	      return -1;

	    return num.getInt();
	  }

	  /**
	   * Convert opcode to boolean.
	   * @returns {Boolean}
	   */

	  toBool() {
	    const smi = this.toSmall();

	    if (smi === -1)
	      return false;

	    return smi === 1;
	  }

	  /**
	   * Convert opcode to its symbolic representation.
	   * @returns {String}
	   */

	  toSymbol() {
	    if (this.value === -1)
	      return 'OP_INVALIDOPCODE';

	    const symbol = common.opcodesByVal[this.value];

	    if (!symbol)
	      return `0x${hex8(this.value)}`;

	    return symbol;
	  }

	  /**
	   * Calculate opcode size.
	   * @returns {Number}
	   */

	  getSize() {
	    if (!this.data)
	      return 1;

	    switch (this.value) {
	      case opcodes.OP_PUSHDATA1:
	        return 2 + this.data.length;
	      case opcodes.OP_PUSHDATA2:
	        return 3 + this.data.length;
	      case opcodes.OP_PUSHDATA4:
	        return 5 + this.data.length;
	      default:
	        return 1 + this.data.length;
	    }
	  }

	  /**
	   * Encode the opcode to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.value === -1)
	      throw new Error('Cannot reserialize a parse error.');

	    if (!this.data) {
	      bw.writeU8(this.value);
	      return bw;
	    }

	    switch (this.value) {
	      case opcodes.OP_PUSHDATA1:
	        bw.writeU8(this.value);
	        bw.writeU8(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      case opcodes.OP_PUSHDATA2:
	        bw.writeU8(this.value);
	        bw.writeU16(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      case opcodes.OP_PUSHDATA4:
	        bw.writeU8(this.value);
	        bw.writeU32(this.data.length);
	        bw.writeBytes(this.data);
	        break;
	      default:
	        assert(this.value === this.data.length);
	        bw.writeU8(this.value);
	        bw.writeBytes(this.data);
	        break;
	    }

	    return bw;
	  }

	  /**
	   * Encode the opcode.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Convert the opcode to a bitcoind test string.
	   * @returns {String} Human-readable script code.
	   */

	  toFormat() {
	    if (this.value === -1)
	      return '0x01';

	    if (this.data) {
	      // Numbers
	      if (this.data.length <= 4) {
	        const num = this.toNum();
	        if (this.equals(Opcode.fromNum(num)))
	          return num.toString(10);
	      }

	      const symbol = common.opcodesByVal[this.value];
	      const data = this.data.toString('hex');

	      // Direct push
	      if (!symbol) {
	        const size = hex8(this.value);
	        return `0x${size} 0x${data}`;
	      }

	      // Pushdatas
	      let size = this.data.length.toString(16);

	      while (size.length % 2 !== 0)
	        size = '0' + size;

	      return `${symbol} 0x${size} 0x${data}`;
	    }

	    // Opcodes
	    const symbol = common.opcodesByVal[this.value];
	    if (symbol)
	      return symbol;

	    // Unknown opcodes
	    const value = hex8(this.value);

	    return `0x${value}`;
	  }

	  /**
	   * Format the opcode as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    if (this.value === -1)
	      return '[error]';

	    if (this.data)
	      return common.toASM(this.data, decode);

	    return common.opcodesByVal[this.value] || 'OP_UNKNOWN';
	  }

	  /**
	   * Instantiate an opcode from a number opcode.
	   * @param {Number} op
	   * @returns {Opcode}
	   */

	  static fromOp(op) {
	    assert(typeof op === 'number');

	    const cached = opCache[op];

	    assert(cached, 'Bad opcode.');

	    return cached;
	  }

	  /**
	   * Instantiate a pushdata opcode from
	   * a buffer (will encode minimaldata).
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromData(data) {
	    assert(Buffer.isBuffer(data));

	    if (data.length === 1) {
	      if (data[0] === 0x81)
	        return this.fromOp(opcodes.OP_1NEGATE);

	      if (data[0] >= 1 && data[0] <= 16)
	        return this.fromOp(data[0] + 0x50);
	    }

	    return this.fromPush(data);
	  }

	  /**
	   * Instantiate a pushdata opcode from a
	   * buffer (this differs from fromData in
	   * that it will _always_ be a pushdata op).
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromPush(data) {
	    assert(Buffer.isBuffer(data));

	    if (data.length === 0)
	      return this.fromOp(opcodes.OP_0);

	    if (data.length <= 0x4b)
	      return new this(data.length, data);

	    if (data.length <= 0xff)
	      return new this(opcodes.OP_PUSHDATA1, data);

	    if (data.length <= 0xffff)
	      return new this(opcodes.OP_PUSHDATA2, data);

	    if (data.length <= 0xffffffff)
	      return new this(opcodes.OP_PUSHDATA4, data);

	    throw new Error('Pushdata size too large.');
	  }

	  /**
	   * Instantiate a pushdata opcode from a string.
	   * @param {String} str
	   * @param {String} [enc=utf8]
	   * @returns {Opcode}
	   */

	  static fromString(str, enc) {
	    assert(typeof str === 'string');
	    const data = Buffer.from(str, enc || 'utf8');
	    return this.fromData(data);
	  }

	  /**
	   * Instantiate an opcode from a small number.
	   * @param {Number} num
	   * @returns {Opcode}
	   */

	  static fromSmall(num) {
	    assert((num & 0xff) === num && num >= 0 && num <= 16);
	    return this.fromOp(num === 0 ? 0 : num + 0x50);
	  }

	  /**
	   * Instantiate an opcode from a ScriptNum.
	   * @param {ScriptNumber} num
	   * @returns {Opcode}
	   */

	  static fromNum(num) {
	    assert(ScriptNum.isScriptNum(num));
	    return this.fromData(num.encode());
	  }

	  /**
	   * Instantiate an opcode from a Number.
	   * @param {Number} num
	   * @returns {Opcode}
	   */

	  static fromInt(num) {
	    assert(Number.isSafeInteger(num));

	    if (num === 0)
	      return this.fromOp(opcodes.OP_0);

	    if (num === -1)
	      return this.fromOp(opcodes.OP_1NEGATE);

	    if (num >= 1 && num <= 16)
	      return this.fromOp(num + 0x50);

	    return this.fromNum(ScriptNum.fromNumber(num));
	  }

	  /**
	   * Instantiate an opcode from a Number.
	   * @param {Boolean} value
	   * @returns {Opcode}
	   */

	  static fromBool(value) {
	    assert(typeof value === 'boolean');
	    return this.fromSmall(value ? 1 : 0);
	  }

	  /**
	   * Instantiate a pushdata opcode from symbolic name.
	   * @example
	   *   Opcode.fromSymbol('checksequenceverify')
	   * @param {String} name
	   * @returns {Opcode}
	   */

	  static fromSymbol(name) {
	    assert(typeof name === 'string');
	    assert(name.length > 0);

	    if (name.charCodeAt(0) & 32)
	      name = name.toUpperCase();

	    if (!/^OP_/.test(name))
	      name = `OP_${name}`;

	    const op = common.opcodes[name];

	    if (op != null)
	      return this.fromOp(op);

	    assert(/^OP_0X/.test(name), 'Unknown opcode.');
	    assert(name.length === 7, 'Unknown opcode.');

	    const value = parseInt(name.substring(5), 16);

	    assert((value & 0xff) === value, 'Unknown opcode.');

	    return this.fromOp(value);
	  }

	  /**
	   * Instantiate opcode from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Opcode}
	   */

	  static fromReader(br) {
	    const value = br.readU8();
	    const op = opCache[value];

	    if (op)
	      return op;

	    switch (value) {
	      case opcodes.OP_PUSHDATA1: {
	        if (br.left() < 1)
	          return PARSE_ERROR;

	        const size = br.readU8();

	        if (br.left() < size) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const data = br.readBytes(size);

	        return new this(value, data);
	      }
	      case opcodes.OP_PUSHDATA2: {
	        if (br.left() < 2) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const size = br.readU16();

	        if (br.left() < size) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const data = br.readBytes(size);

	        return new this(value, data);
	      }
	      case opcodes.OP_PUSHDATA4: {
	        if (br.left() < 4) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const size = br.readU32();

	        if (br.left() < size) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const data = br.readBytes(size);

	        return new this(value, data);
	      }
	      default: {
	        if (br.left() < value) {
	          br.seek(br.left());
	          return PARSE_ERROR;
	        }

	        const data = br.readBytes(value);

	        return new this(value, data);
	      }
	    }
	  }

	  /**
	   * Instantiate opcode from serialized data.
	   * @param {Buffer} data
	   * @returns {Opcode}
	   */

	  static fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Test whether an object an Opcode.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOpcode(obj) {
	    return obj instanceof Opcode;
	  }
	}

	/*
	 * Helpers
	 */

	function hex8(num) {
	  if (num <= 0x0f)
	    return '0' + num.toString(16);
	  return num.toString(16);
	}

	/*
	 * Fill Cache
	 */

	PARSE_ERROR = Object.freeze(new Opcode(-1));

	for (let value = 0x00; value <= 0xff; value++) {
	  if (value >= 0x01 && value <= 0x4e) {
	    opCache.push(null);
	    continue;
	  }
	  const op = new Opcode(value);
	  opCache.push(Object.freeze(op));
	}

	/*
	 * Expose
	 */

	opcode = Opcode;
	return opcode;
}

/*!
 * stack.js - stack object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var stack;
var hasRequiredStack;

function requireStack () {
	if (hasRequiredStack) return stack;
	hasRequiredStack = 1;

	const assert = require$$0$3;
	const common = requireCommon$1();
	const ScriptNum = requireScriptnum();

	/**
	 * Stack
	 * Represents the stack of a Script during execution.
	 * @alias module:script.Stack
	 * @property {Buffer[]} items - Stack items.
	 * @property {Number} length - Size of stack.
	 */

	class Stack {
	  /**
	   * Create a stack.
	   * @constructor
	   * @param {Buffer[]?} items - Stack items.
	   */

	  constructor(items) {
	    this.items = items || [];
	  }

	  /**
	   * Get length.
	   * @returns {Number}
	   */

	  get length() {
	    return this.items.length;
	  }

	  /**
	   * Set length.
	   * @param {Number} value
	   */

	  set length(value) {
	    this.items.length = value;
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {StackIterator}
	   */

	  [Symbol.iterator]() {
	    return this.items[Symbol.iterator]();
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {StackIterator}
	   */

	  values() {
	    return this.items.values();
	  }

	  /**
	   * Instantiate a key and value iterator.
	   * @returns {StackIterator}
	   */

	  entries() {
	    return this.items.entries();
	  }

	  /**
	   * Inspect the stack.
	   * @returns {String} Human-readable stack.
	   */

	  inspect() {
	    return `<Stack: ${this.toString()}>`;
	  }

	  /**
	   * Convert the stack to a string.
	   * @returns {String} Human-readable stack.
	   */

	  toString() {
	    const out = [];

	    for (const item of this.items)
	      out.push(item.toString('hex'));

	    return out.join(' ');
	  }

	  /**
	   * Format the stack as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    const out = [];

	    for (const item of this.items)
	      out.push(common.toASM(item, decode));

	    return out.join(' ');
	  }

	  /**
	   * Clone the stack.
	   * @returns {Stack} Cloned stack.
	   */

	  clone() {
	    return new this.constructor(this.items.slice());
	  }

	  /**
	   * Clear the stack.
	   * @returns {Stack}
	   */

	  clear() {
	    this.items.length = 0;
	    return this;
	  }

	  /**
	   * Get a stack item by index.
	   * @param {Number} index
	   * @returns {Buffer|null}
	   */

	  get(index) {
	    if (index < 0)
	      index += this.items.length;

	    if (index < 0 || index >= this.items.length)
	      return null;

	    return this.items[index];
	  }

	  /**
	   * Pop a stack item.
	   * @see Array#pop
	   * @returns {Buffer|null}
	   */

	  pop() {
	    const item = this.items.pop();
	    return item || null;
	  }

	  /**
	   * Shift a stack item.
	   * @see Array#shift
	   * @returns {Buffer|null}
	   */

	  shift() {
	    const item = this.items.shift();
	    return item || null;
	  }

	  /**
	   * Remove an item.
	   * @param {Number} index
	   * @returns {Buffer}
	   */

	  remove(index) {
	    if (index < 0)
	      index += this.items.length;

	    if (index < 0 || index >= this.items.length)
	      return null;

	    const items = this.items.splice(index, 1);

	    if (items.length === 0)
	      return null;

	    return items[0];
	  }

	  /**
	   * Set stack item at index.
	   * @param {Number} index
	   * @param {Buffer} value
	   * @returns {Buffer}
	   */

	  set(index, item) {
	    if (index < 0)
	      index += this.items.length;

	    assert(Buffer.isBuffer(item));
	    assert(index >= 0 && index <= this.items.length);

	    this.items[index] = item;

	    return this;
	  }

	  /**
	   * Push item onto stack.
	   * @see Array#push
	   * @param {Buffer} item
	   * @returns {Number} Stack size.
	   */

	  push(item) {
	    assert(Buffer.isBuffer(item));
	    this.items.push(item);
	    return this;
	  }

	  /**
	   * Unshift item from stack.
	   * @see Array#unshift
	   * @param {Buffer} item
	   * @returns {Number}
	   */

	  unshift(item) {
	    assert(Buffer.isBuffer(item));
	    this.items.unshift(item);
	    return this;
	  }

	  /**
	   * Insert an item.
	   * @param {Number} index
	   * @param {Buffer} item
	   * @returns {Buffer}
	   */

	  insert(index, item) {
	    if (index < 0)
	      index += this.items.length;

	    assert(Buffer.isBuffer(item));
	    assert(index >= 0 && index <= this.items.length);

	    this.items.splice(index, 0, item);

	    return this;
	  }

	  /**
	   * Erase stack items.
	   * @param {Number} start
	   * @param {Number} end
	   * @returns {Buffer[]}
	   */

	  erase(start, end) {
	    if (start < 0)
	      start = this.items.length + start;

	    if (end < 0)
	      end = this.items.length + end;

	    this.items.splice(start, end - start);
	  }

	  /**
	   * Swap stack values.
	   * @param {Number} i1 - Index 1.
	   * @param {Number} i2 - Index 2.
	   */

	  swap(i1, i2) {
	    if (i1 < 0)
	      i1 = this.items.length + i1;

	    if (i2 < 0)
	      i2 = this.items.length + i2;

	    const v1 = this.items[i1];
	    const v2 = this.items[i2];

	    this.items[i1] = v2;
	    this.items[i2] = v1;
	  }

	  /*
	   * Data
	   */

	  getData(index) {
	    return this.get(index);
	  }

	  popData() {
	    return this.pop();
	  }

	  shiftData() {
	    return this.shift();
	  }

	  removeData(index) {
	    return this.remove(index);
	  }

	  setData(index, data) {
	    return this.set(index, data);
	  }

	  pushData(data) {
	    return this.push(data);
	  }

	  unshiftData(data) {
	    return this.unshift(data);
	  }

	  insertData(index, data) {
	    return this.insert(index, data);
	  }

	  /*
	   * Length
	   */

	  getLength(index) {
	    const item = this.get(index);
	    return item ? item.length : -1;
	  }

	  /*
	   * String
	   */

	  getString(index, enc) {
	    const item = this.get(index);
	    return item ? Stack.toString(item, enc) : null;
	  }

	  popString(enc) {
	    const item = this.pop();
	    return item ? Stack.toString(item, enc) : null;
	  }

	  shiftString(enc) {
	    const item = this.shift();
	    return item ? Stack.toString(item, enc) : null;
	  }

	  removeString(index, enc) {
	    const item = this.remove(index);
	    return item ? Stack.toString(item, enc) : null;
	  }

	  setString(index, str, enc) {
	    return this.set(index, Stack.fromString(str, enc));
	  }

	  pushString(str, enc) {
	    return this.push(Stack.fromString(str, enc));
	  }

	  unshiftString(str, enc) {
	    return this.unshift(Stack.fromString(str, enc));
	  }

	  insertString(index, str, enc) {
	    return this.insert(index, Stack.fromString(str, enc));
	  }

	  /*
	   * Num
	   */

	  getNum(index, minimal, limit) {
	    const item = this.get(index);
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }

	  popNum(minimal, limit) {
	    const item = this.pop();
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }

	  shiftNum(minimal, limit) {
	    const item = this.shift();
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }

	  removeNum(index, minimal, limit) {
	    const item = this.remove(index);
	    return item ? Stack.toNum(item, minimal, limit) : null;
	  }

	  setNum(index, num) {
	    return this.set(index, Stack.fromNum(num));
	  }

	  pushNum(num) {
	    return this.push(Stack.fromNum(num));
	  }

	  unshiftNum(num) {
	    return this.unshift(Stack.fromNum(num));
	  }

	  insertNum(index, num) {
	    return this.insert(index, Stack.fromNum(num));
	  }

	  /*
	   * Int
	   */

	  getInt(index, minimal, limit) {
	    const item = this.get(index);
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }

	  popInt(minimal, limit) {
	    const item = this.pop();
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }

	  shiftInt(minimal, limit) {
	    const item = this.shift();
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }

	  removeInt(index, minimal, limit) {
	    const item = this.remove(index);
	    return item ? Stack.toInt(item, minimal, limit) : -1;
	  }

	  setInt(index, num) {
	    return this.set(index, Stack.fromInt(num));
	  }

	  pushInt(num) {
	    return this.push(Stack.fromInt(num));
	  }

	  unshiftInt(num) {
	    return this.unshift(Stack.fromInt(num));
	  }

	  insertInt(index, num) {
	    return this.insert(index, Stack.fromInt(num));
	  }

	  /*
	   * Bool
	   */

	  getBool(index) {
	    const item = this.get(index);
	    return item ? Stack.toBool(item) : false;
	  }

	  popBool() {
	    const item = this.pop();
	    return item ? Stack.toBool(item) : false;
	  }

	  shiftBool() {
	    const item = this.shift();
	    return item ? Stack.toBool(item) : false;
	  }

	  removeBool(index) {
	    const item = this.remove(index);
	    return item ? Stack.toBool(item) : false;
	  }

	  setBool(index, value) {
	    return this.set(index, Stack.fromBool(value));
	  }

	  pushBool(value) {
	    return this.push(Stack.fromBool(value));
	  }

	  unshiftBool(value) {
	    return this.unshift(Stack.fromBool(value));
	  }

	  insertBool(index, value) {
	    return this.insert(index, Stack.fromBool(value));
	  }

	  /**
	   * Test an object to see if it is a Stack.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isStack(obj) {
	    return obj instanceof Stack;
	  }

	  /*
	   * Encoding
	   */

	  static toString(item, enc) {
	    assert(Buffer.isBuffer(item));
	    return item.toString(enc || 'utf8');
	  }

	  static fromString(str, enc) {
	    assert(typeof str === 'string');
	    return Buffer.from(str, enc || 'utf8');
	  }

	  static toNum(item, minimal, limit) {
	    return ScriptNum.decode(item, minimal, limit);
	  }

	  static fromNum(num) {
	    assert(ScriptNum.isScriptNum(num));
	    return num.encode();
	  }

	  static toInt(item, minimal, limit) {
	    const num = Stack.toNum(item, minimal, limit);
	    return num.getInt();
	  }

	  static fromInt(int) {
	    assert(typeof int === 'number');

	    if (int >= -1 && int <= 16)
	      return common.small[int + 1];

	    const num = ScriptNum.fromNumber(int);

	    return Stack.fromNum(num);
	  }

	  static toBool(item) {
	    assert(Buffer.isBuffer(item));

	    for (let i = 0; i < item.length; i++) {
	      if (item[i] !== 0) {
	        // Cannot be negative zero
	        if (i === item.length - 1 && item[i] === 0x80)
	          return false;
	        return true;
	      }
	    }

	    return false;
	  }

	  static fromBool(value) {
	    assert(typeof value === 'boolean');
	    return Stack.fromInt(value ? 1 : 0);
	  }
	}

	/*
	 * Expose
	 */

	stack = Stack;
	return stack;
}

var metrics;
var hasRequiredMetrics;

function requireMetrics () {
	if (hasRequiredMetrics) return metrics;
	hasRequiredMetrics = 1;

	class Metrics {
	   constructor(sigchecks) {
	     this.sigchecks = sigchecks || 0;
	     this.init();
	   }
	   init() {
	     return this.sigchecks;
	   }
	}

	metrics = Metrics;
	return metrics;
}

/*!
 * script.js - script interpreter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var script$1;
var hasRequiredScript$1;

function requireScript$1 () {
	if (hasRequiredScript$1) return script$1;
	hasRequiredScript$1 = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const ripemd160 = requireRipemd160();
	const sha1 = requireSha1();
	const sha256 = requireSha256();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const secp256k1 = requireSecp256k1();
	const consensus = requireConsensus();
	const policy = requirePolicy();
	const Opcode = requireOpcode();
	const Stack = requireStack();
	const ScriptError = requireScripterror();
	const ScriptNum = requireScriptnum();
	const common = requireCommon$1();
	const Address = requireAddress();
	const Metrics = requireMetrics();
	const opcodes = common.opcodes;
	const scriptTypes = common.types;
	const countBits = common.countBits;
	const {encoding} = bio;


	/*
	 * Constants
	 */

	const EMPTY_BUFFER = Buffer.alloc(0);
	const metrics = new Metrics();

	/**
	 * Script
	 * Represents a input or output script.
	 * @alias module:script.Script
	 * @property {Array} code - Parsed script code.
	 * @property {Buffer?} raw - Serialized script.
	 * @property {Number} length - Number of parsed opcodes.
	 */

	class Script {
	  /**
	   * Create a script.
	   * @constructor
	   * @param {Buffer|Array|Object} code
	   */

	  constructor(options) {
	    this.raw = EMPTY_BUFFER;
	    this.code = [];

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Get length.
	   * @returns {Number}
	   */

	  get length() {
	    return this.code.length;
	  }

	  /**
	   * Set length.
	   * @param {Number} value
	   */

	  set length(value) {
	    this.code.length = value;
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Script data is required.');

	    if (Buffer.isBuffer(options))
	      return this.fromRaw(options);

	    if (Array.isArray(options))
	      return this.fromArray(options);

	    if (options.raw) {
	      if (!options.code)
	        return this.fromRaw(options.raw);
	      assert(Buffer.isBuffer(options.raw), 'Raw must be a Buffer.');
	      this.raw = options.raw;
	    }

	    if (options.code) {
	      if (!options.raw)
	        return this.fromArray(options.code);
	      assert(Array.isArray(options.code), 'Code must be an array.');
	      this.code = options.code;
	    }

	    return this;
	  }

	  /**
	   * Insantiate script from options object.
	   * @param {Object} options
	   * @returns {Script}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {ScriptIterator}
	   */

	  values() {
	    return this.code.values();
	  }

	  /**
	   * Instantiate a key and value iterator.
	   * @returns {ScriptIterator}
	   */

	  entries() {
	    return this.code.entries();
	  }

	  /**
	   * Instantiate a value-only iterator.
	   * @returns {ScriptIterator}
	   */

	  [Symbol.iterator]() {
	    return this.code[Symbol.iterator]();
	  }

	  /**
	   * Convert the script to an array of
	   * Buffers (pushdatas) and Numbers
	   * (opcodes).
	   * @returns {Array}
	   */

	  toArray() {
	    return this.code.slice();
	  }

	  /**
	   * Inject properties from an array of
	   * of buffers and numbers.
	   * @private
	   * @param {Array} code
	   * @returns {Script}
	   */

	  fromArray(code) {
	    assert(Array.isArray(code));

	    this.clear();

	    for (const op of code)
	      this.push(op);

	    return this.compile();
	  }

	  /**
	   * Instantiate script from an array
	   * of buffers and numbers.
	   * @param {Array} code
	   * @returns {Script}
	   */

	  static fromArray(code) {
	    return new this().fromArray(code);
	  }

	  /**
	   * Convert script to stack items.
	   * @returns {Buffer[]}
	   */

	  toItems() {
	    const items = [];

	    for (const op of this.code) {
	      const data = op.toPush();

	      if (!data)
	        throw new Error('Non-push opcode in script.');

	      items.push(data);
	    }

	    return items;
	  }

	  /**
	   * Inject data from stack items.
	   * @private
	   * @param {Buffer[]} items
	   * @returns {Script}
	   */

	  fromItems(items) {
	    assert(Array.isArray(items));

	    this.clear();

	    for (const item of items)
	      this.pushData(item);

	    return this.compile();
	  }

	  /**
	   * Instantiate script from stack items.
	   * @param {Buffer[]} items
	   * @returns {Script}
	   */

	  static fromItems(items) {
	    return new this().fromItems(items);
	  }

	  /**
	   * Convert script to stack.
	   * @returns {Stack}
	   */

	  toStack() {
	    return new Stack(this.toItems());
	  }

	  /**
	   * Inject data from stack.
	   * @private
	   * @param {Stack} stack
	   * @returns {Script}
	   */

	  fromStack(stack) {
	    return this.fromItems(stack.items);
	  }

	  /**
	   * Instantiate script from stack.
	   * @param {Stack} stack
	   * @returns {Script}
	   */

	  static fromStack(stack) {
	    return new this().fromStack(stack);
	  }

	  /**
	   * Clone the script.
	   * @returns {Script} Cloned script.
	   */

	  clone() {
	    return new this.constructor().inject(this);
	  }

	  /**
	   * Inject properties from script.
	   * Used for cloning.
	   * @private
	   * @param {Script} script
	   * @returns {Script}
	   */

	  inject(script) {
	    this.raw = script.raw;
	    this.code = script.code.slice();
	    return this;
	  }

	  /**
	   * Test equality against script.
	   * @param {Script} script
	   * @returns {Boolean}
	   */

	  equals(script) {
	    assert(Script.isScript(script));
	    return this.raw.equals(script.raw);
	  }

	  /**
	   * Compare against another script.
	   * @param {Script} script
	   * @returns {Number}
	   */

	  compare(script) {
	    assert(Script.isScript(script));
	    return this.raw.compare(script.raw);
	  }

	  /**
	   * Clear the script.
	   * @returns {Script}
	   */

	  clear() {
	    this.raw = EMPTY_BUFFER;
	    this.code.length = 0;
	    return this;
	  }

	  /**
	   * Inspect the script.
	   * @returns {String} Human-readable script code.
	   */

	  inspect() {
	    return `<Script: ${this.toString()}>`;
	  }

	  /**
	   * Convert the script to a bitcoind test string.
	   * @returns {String} Human-readable script code.
	   */

	  toString() {
	    const out = [];

	    for (const op of this.code)
	      out.push(op.toFormat());

	    return out.join(' ');
	  }

	  /**
	   * Format the script as bitcoind asm.
	   * @param {Boolean?} decode - Attempt to decode hash types.
	   * @returns {String} Human-readable script.
	   */

	  toASM(decode) {
	    if (this.isNulldata())
	      decode = false;

	    const out = [];

	    for (const op of this.code)
	      out.push(op.toASM(decode));

	    return out.join(' ');
	  }

	  /**
	   * Re-encode the script internally. Useful if you
	   * changed something manually in the `code` array.
	   * @returns {Script}
	   */

	  compile() {
	    if (this.code.length === 0)
	      return this.clear();

	    let size = 0;

	    for (const op of this.code)
	      size += op.getSize();

	    const bw = bio.write(size);

	    for (const op of this.code)
	      op.toWriter(bw);

	    this.raw = bw.render();

	    return this;
	  }

	  /**
	   * Write the script to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeVarBytes(this.raw);
	    return bw;
	  }

	  /**
	   * Encode the script to a Buffer. See {@link Script#encode}.
	   * @param {String} enc - Encoding, either `'hex'` or `null`.
	   * @returns {Buffer|String} Serialized script.
	   */

	  toRaw() {
	    return this.raw;
	  }

	  /**
	   * Convert script to a hex string.
	   * @returns {String}
	   */

	  toJSON() {
	    return this.toRaw().toString('hex');
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {String} json
	   */

	  fromJSON(json) {
	    assert(typeof json === 'string', 'Code must be a string.');
	    return this.fromRaw(Buffer.from(json, 'hex'));
	  }

	  /**
	   * Instantiate script from a hex string.
	   * @params {String} json
	   * @returns {Script}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Get the script's "subscript" starting at a separator.
	   * @param {Number} index - The last separator to sign/verify beyond.
	   * @returns {Script} Subscript.
	   */

	  getSubscript(index) {
	    if (index === 0)
	      return this.clone();

	    const script = new Script();

	    for (let i = index; i < this.code.length; i++) {
	      const op = this.code[i];

	      if (op.value === -1)
	        break;

	      script.code.push(op);
	    }

	    return script.compile();
	  }

	  /**
	   * Get the script's "subscript" starting at a separator.
	   * Remove all OP_CODESEPARATORs if present. This bizarre
	   * behavior is necessary for signing and verification when
	   * code separators are present.
	   * @returns {Script} Subscript.
	   */

	  removeSeparators() {
	    let found = false;

	    // Optimizing for the common case:
	    // Check for any separators first.
	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      if (op.value === opcodes.OP_CODESEPARATOR) {
	        found = true;
	        break;
	      }
	    }

	    if (!found)
	      return this;

	    // Uncommon case: someone actually
	    // has a code separator. Go through
	    // and remove them all.
	    const script = new Script();

	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      if (op.value !== opcodes.OP_CODESEPARATOR)
	        script.code.push(op);
	    }

	    return script.compile();
	  }

	  /**
	   * Get the value of the checkBits while calculated as little endian.
	   * @param {Buffer} abkam - Stack depth of the dummy element.
	   * @param {Number?} nKeysCount - Stack depth of the top pubkeys.
	   * @returns {Number}
	   */

	  bitcalculator(abkam, nKeysCount) {
	    let checkBits = 0;

	    const bitfield_size = ((nKeysCount + 7) / 8);

	    for (let i = 0; i < bitfield_size; i++) {
	      checkBits |= abkam[i] << (8 * i);
	    }

	    return checkBits;
	  }

	  /**
	   * Execute and interpret the script.
	   * @param {Stack} stack - Script execution stack.
	   * @param {Number?} flags - Script standard flags.
	   * @param {TX?} tx - Transaction being verified.
	   * @param {Number?} index - Index of input being verified.
	   * @param {Amount?} value - Previous output value.
	   * @param {Number?} sigchecks
	   * @throws {ScriptError} Will be thrown on VERIFY failures.
	   */

	  execute(stack, flags, tx, index, value, sigchecks) {
	    if (flags == null)
	      flags = Script.flags.STANDARD_VERIFY_FLAGS;

	    if (this.getSize() > consensus.MAX_SCRIPT_SIZE)
	      throw new ScriptError('SCRIPT_SIZE');

	    const state = [];
	    const alt = [];

	    let lastSep = 0;
	    let opCount = 0;
	    let negate = 0;
	    let checkBits;
	    let minimal = false;

	    if (flags & Script.flags.VERIFY_MINIMALDATA)
	      minimal = true;

	    for (let ip = 0; ip < this.code.length; ip++) {
	      const op = this.code[ip];

	      if (op.value === -1)
	        throw new ScriptError('BAD_OPCODE', op, ip);

	      if (op.data && op.data.length > consensus.MAX_SCRIPT_PUSH)
	        throw new ScriptError('PUSH_SIZE', op, ip);

	      if (op.value > opcodes.OP_16 && ++opCount > consensus.MAX_SCRIPT_OPS)
	        throw new ScriptError('OP_COUNT', op, ip);

	      if (op.isDisabled(flags))
	        throw new ScriptError('DISABLED_OPCODE', op, ip);

	      if (negate && !op.isBranch()) {
	        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
	          throw new ScriptError('STACK_SIZE', op, ip);
	        continue;
	      }

	      if (op.data && 0 <= op.value <= opcodes.OP_PUSHDATA4) {
	        if (minimal && !op.isMinimal())
	          throw new ScriptError('MINIMALDATA', op, ip);

	        stack.push(op.data);

	        if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
	          throw new ScriptError('STACK_SIZE', op, ip);

	        continue;
	      }

	      switch (op.value) {
	        case opcodes.OP_0: {
	          stack.pushInt(0);
	          break;
	        }
	        case opcodes.OP_1NEGATE: {
	          stack.pushInt(-1);
	          break;
	        }
	        case opcodes.OP_1:
	        case opcodes.OP_2:
	        case opcodes.OP_3:
	        case opcodes.OP_4:
	        case opcodes.OP_5:
	        case opcodes.OP_6:
	        case opcodes.OP_7:
	        case opcodes.OP_8:
	        case opcodes.OP_9:
	        case opcodes.OP_10:
	        case opcodes.OP_11:
	        case opcodes.OP_12:
	        case opcodes.OP_13:
	        case opcodes.OP_14:
	        case opcodes.OP_15:
	        case opcodes.OP_16: {
	          stack.pushInt(op.value - 0x50);
	          break;
	        }
	        case opcodes.OP_NOP: {
	          break;
	        }
	        case opcodes.OP_CHECKLOCKTIMEVERIFY: {
	          // OP_CHECKLOCKTIMEVERIFY = OP_NOP2
	          if (!(flags & Script.flags.VERIFY_CHECKLOCKTIMEVERIFY)) {
	            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
	              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	            break;
	          }

	          if (!tx)
	            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const num = stack.getNum(-1, minimal, 5);

	          if (num.isNeg())
	            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);

	          const locktime = num.toDouble();

	          if (!tx.verifyLocktime(index, locktime))
	            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);

	          break;
	        }
	        case opcodes.OP_CHECKSEQUENCEVERIFY: {
	          // OP_CHECKSEQUENCEVERIFY = OP_NOP3
	          if (!(flags & Script.flags.VERIFY_CHECKSEQUENCEVERIFY)) {
	            if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
	              throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	            break;
	          }

	          if (!tx)
	            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const num = stack.getNum(-1, minimal, 5);

	          if (num.isNeg())
	            throw new ScriptError('NEGATIVE_LOCKTIME', op, ip);

	          const locktime = num.toDouble();

	          if (!tx.verifySequence(index, locktime))
	            throw new ScriptError('UNSATISFIED_LOCKTIME', op, ip);

	          break;
	        }
	        case opcodes.OP_NOP1:
	        case opcodes.OP_NOP4:
	        case opcodes.OP_NOP5:
	        case opcodes.OP_NOP6:
	        case opcodes.OP_NOP7:
	        case opcodes.OP_NOP8:
	        case opcodes.OP_NOP9:
	        case opcodes.OP_NOP10: {
	          if (flags & Script.flags.VERIFY_DISCOURAGE_UPGRADABLE_NOPS)
	            throw new ScriptError('DISCOURAGE_UPGRADABLE_NOPS', op, ip);
	          break;
	        }
	        case opcodes.OP_IF:
	        case opcodes.OP_NOTIF: {
	          let val = false;

	          if (!negate) {
	            if (stack.length < 1)
	              throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

	            if (flags & Script.flags.VERIFY_MINIMALIF) {
	              const item = stack.get(-1);

	              if (item.length > 1)
	                throw new ScriptError('MINIMALIF');

	              if (item.length === 1 && item[0] !== 1)
	                throw new ScriptError('MINIMALIF');
	            }

	            val = stack.getBool(-1);

	            if (op.value === opcodes.OP_NOTIF)
	              val = !val;

	            stack.pop();
	          }

	          state.push(val);

	          if (!val)
	            negate += 1;

	          break;
	        }
	        case opcodes.OP_ELSE: {
	          if (state.length === 0)
	            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

	          state[state.length - 1] = !state[state.length - 1];

	          if (!state[state.length - 1])
	            negate += 1;
	          else
	            negate -= 1;

	          break;
	        }
	        case opcodes.OP_ENDIF: {
	          if (state.length === 0)
	            throw new ScriptError('UNBALANCED_CONDITIONAL', op, ip);

	          if (!state.pop())
	            negate -= 1;

	          break;
	        }
	        case opcodes.OP_VERIFY: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          if (!stack.getBool(-1))
	            throw new ScriptError('VERIFY', op, ip);

	          stack.pop();

	          break;
	        }
	        case opcodes.OP_RETURN: {
	          throw new ScriptError('OP_RETURN', op, ip);
	        }
	        case opcodes.OP_TOALTSTACK: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          alt.push(stack.pop());
	          break;
	        }
	        case opcodes.OP_FROMALTSTACK: {
	          if (alt.length === 0)
	            throw new ScriptError('INVALID_ALTSTACK_OPERATION', op, ip);

	          stack.push(alt.pop());
	          break;
	        }
	        case opcodes.OP_2DROP: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.pop();
	          stack.pop();
	          break;
	        }
	        case opcodes.OP_2DUP: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-2);
	          const v2 = stack.get(-1);

	          stack.push(v1);
	          stack.push(v2);
	          break;
	        }
	        case opcodes.OP_3DUP: {
	          if (stack.length < 3)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-3);
	          const v2 = stack.get(-2);
	          const v3 = stack.get(-1);

	          stack.push(v1);
	          stack.push(v2);
	          stack.push(v3);
	          break;
	        }
	        case opcodes.OP_2OVER: {
	          if (stack.length < 4)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-4);
	          const v2 = stack.get(-3);

	          stack.push(v1);
	          stack.push(v2);
	          break;
	        }
	        case opcodes.OP_2ROT: {
	          if (stack.length < 6)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-6);
	          const v2 = stack.get(-5);

	          stack.erase(-6, -4);
	          stack.push(v1);
	          stack.push(v2);
	          break;
	        }
	        case opcodes.OP_2SWAP: {
	          if (stack.length < 4)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.swap(-4, -2);
	          stack.swap(-3, -1);
	          break;
	        }
	        case opcodes.OP_IFDUP: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          if (stack.getBool(-1)) {
	            const val = stack.get(-1);
	            stack.push(val);
	          }

	          break;
	        }
	        case opcodes.OP_DEPTH: {
	          stack.pushInt(stack.length);
	          break;
	        }
	        case opcodes.OP_DROP: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.pop();
	          break;
	        }
	        case opcodes.OP_DUP: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(stack.get(-1));
	          break;
	        }
	        case opcodes.OP_NIP: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.remove(-2);
	          break;
	        }
	        case opcodes.OP_OVER: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(stack.get(-2));
	          break;
	        }
	        case opcodes.OP_PICK:
	        case opcodes.OP_ROLL: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const num = stack.getInt(-1, minimal, 4);
	          stack.pop();

	          if (num < 0 || num >= stack.length)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const val = stack.get(-num - 1);

	          if (op.value === opcodes.OP_ROLL)
	            stack.remove(-num - 1);

	          stack.push(val);
	          break;
	        }
	        case opcodes.OP_ROT: {
	          if (stack.length < 3)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.swap(-3, -2);
	          stack.swap(-2, -1);
	          break;
	        }
	        case opcodes.OP_SWAP: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.swap(-2, -1);
	          break;
	        }
	        case opcodes.OP_TUCK: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.insert(-2, stack.get(-1));
	          break;
	        }
	        case opcodes.OP_SIZE: {
	          if (stack.length < 1)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.pushInt(stack.get(-1).length);
	          break;
	        }
	        case opcodes.OP_EQUAL:
	        case opcodes.OP_EQUALVERIFY: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-2);
	          const v2 = stack.get(-1);

	          const res = v1.equals(v2);

	          stack.pop();
	          stack.pop();

	          stack.pushBool(res);

	          if (op.value === opcodes.OP_EQUALVERIFY) {
	            if (!res)
	              throw new ScriptError('EQUALVERIFY', op, ip);
	            stack.pop();
	          }

	          break;
	        }
	        case opcodes.OP_1ADD:
	        case opcodes.OP_1SUB:
	        case opcodes.OP_NEGATE:
	        case opcodes.OP_ABS:
	        case opcodes.OP_NOT:
	        case opcodes.OP_0NOTEQUAL: {
	          if (stack.length < 1)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          let num = stack.getNum(-1, minimal, 4);
	          let cmp;

	          switch (op.value) {
	            case opcodes.OP_1ADD:
	              num.iaddn(1);
	              break;
	            case opcodes.OP_1SUB:
	              num.isubn(1);
	              break;
	            case opcodes.OP_NEGATE:
	              num.ineg();
	              break;
	            case opcodes.OP_ABS:
	              num.iabs();
	              break;
	            case opcodes.OP_NOT:
	              cmp = num.isZero();
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_0NOTEQUAL:
	              cmp = !num.isZero();
	              num = ScriptNum.fromBool(cmp);
	              break;
	            default:
	              assert(false, 'Fatal script error.');
	              break;
	          }

	          stack.pop();
	          stack.pushNum(num);

	          break;
	        }
	        case opcodes.OP_ADD:
	        case opcodes.OP_SUB:
	        case opcodes.OP_DIV:
	        case opcodes.OP_MOD:
	        case opcodes.OP_BOOLAND:
	        case opcodes.OP_BOOLOR:
	        case opcodes.OP_NUMEQUAL:
	        case opcodes.OP_NUMEQUALVERIFY:
	        case opcodes.OP_NUMNOTEQUAL:
	        case opcodes.OP_LESSTHAN:
	        case opcodes.OP_GREATERTHAN:
	        case opcodes.OP_LESSTHANOREQUAL:
	        case opcodes.OP_GREATERTHANOREQUAL:
	        case opcodes.OP_MIN:
	        case opcodes.OP_MAX: {
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const n1 = stack.getNum(-2, minimal, 4);
	          const n2 = stack.getNum(-1, minimal, 4);
	          let num, cmp;

	          switch (op.value) {
	            case opcodes.OP_ADD:
	              num = n1.iadd(n2);
	              break;
	            case opcodes.OP_SUB:
	              num = n1.isub(n2);
	              break;
	            case opcodes.OP_DIV:
	              if (n2.isZero())
	                throw new ScriptError('DIV_BY_ZERO', op, ip);
	              num = n1.div(n2);
	              break;
	            case opcodes.OP_MOD:
	              if (n2.isZero())
	                throw new ScriptError('MOD_BY_ZERO', op, ip);
	              num = n1.mod(n2);
	              break;
	            case opcodes.OP_BOOLAND:
	              cmp = n1.toBool() && n2.toBool();
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_BOOLOR:
	              cmp = n1.toBool() || n2.toBool();
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_NUMEQUAL:
	              cmp = n1.eq(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_NUMEQUALVERIFY:
	              cmp = n1.eq(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_NUMNOTEQUAL:
	              cmp = !n1.eq(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_LESSTHAN:
	              cmp = n1.lt(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_GREATERTHAN:
	              cmp = n1.gt(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_LESSTHANOREQUAL:
	              cmp = n1.lte(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_GREATERTHANOREQUAL:
	              cmp = n1.gte(n2);
	              num = ScriptNum.fromBool(cmp);
	              break;
	            case opcodes.OP_MIN:
	              num = ScriptNum.min(n1, n2);
	              break;
	            case opcodes.OP_MAX:
	              num = ScriptNum.max(n1, n2);
	              break;
	            default:
	              assert(false, 'Fatal script error.');
	              break;
	          }

	          stack.pop();
	          stack.pop();
	          stack.pushNum(num);

	          if (op.value === opcodes.OP_NUMEQUALVERIFY) {
	            if (!stack.getBool(-1))
	              throw new ScriptError('NUMEQUALVERIFY', op, ip);
	            stack.pop();
	          }

	          break;
	        }
	        case opcodes.OP_WITHIN: {
	          if (stack.length < 3)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const n1 = stack.getNum(-3, minimal, 4);
	          const n2 = stack.getNum(-2, minimal, 4);
	          const n3 = stack.getNum(-1, minimal, 4);

	          const val = n2.lte(n1) && n1.lt(n3);

	          stack.pop();
	          stack.pop();
	          stack.pop();

	          stack.pushBool(val);
	          break;
	        }
	        case opcodes.OP_RIPEMD160: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(ripemd160.digest(stack.pop()));
	          break;
	        }
	        case opcodes.OP_SHA1: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(sha1.digest(stack.pop()));
	          break;
	        }
	        case opcodes.OP_SHA256: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(sha256.digest(stack.pop()));
	          break;
	        }
	        case opcodes.OP_HASH160: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(hash160.digest(stack.pop()));
	          break;
	        }
	        case opcodes.OP_HASH256: {
	          if (stack.length === 0)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.push(hash256.digest(stack.pop()));
	          break;
	        }
	        case opcodes.OP_CODESEPARATOR: {
	          lastSep = ip + 1;
	          break;
	        }
	        case opcodes.OP_CHECKSIG:
	        case opcodes.OP_CHECKSIGVERIFY: {
	          if (!tx)
	            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const sig = stack.get(-2);
	          const key = stack.get(-1);

	          const subscript = this.getSubscript(lastSep);

	          if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)
	            || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))
	            subscript.findAndDelete(sig);

	          checkTransactionSignature(sig, flags);
	          validateKey(key, flags);

	          let res = false;

	          if (sig.length > 0) {
	            const type = sig[sig.length - 1];
	            const hash = tx.signatureHash(
	              index,
	              subscript,
	              value,
	              type,
	              flags
	            );
	            res = verifySignature(hash, sig.slice(0, -1), key, flags);
	            metrics.sigchecks += 1;
	            metrics.sigchecks;
	          }

	          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
	            if (sig.length !== 0)
	              throw new ScriptError('NULLFAIL', op, ip);
	          }

	          stack.pop();
	          stack.pop();

	          stack.pushBool(res);

	          if (op.value === opcodes.OP_CHECKSIGVERIFY) {
	            if (!res)
	              throw new ScriptError('CHECKSIGVERIFY', op, ip);
	            stack.pop();
	          }

	          break;
	        }
	        case opcodes.OP_CHECKDATASIG:
	        case opcodes.OP_CHECKDATASIGVERIFY: {
	          // (sig message pubkey -- bool)
	          if (stack.length < 3)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const sig = stack.get(-3);
	          const msg = stack.get(-2);
	          const key = stack.get(-1);

	          validateDataSignature(sig, flags);
	          validateKey(key, flags);

	          let res = false;

	          if (sig.length > 0) {
	            const hash = sha256.digest(msg);
	            res = verifySignature(hash, sig, key, flags);
	            metrics.sigchecks += 1;
		    metrics.sigchecks;
	          }

	          if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
	            if (sig.length !== 0)
	              throw new ScriptError('NULLFAIL', op, ip);
	          }

	          stack.pop();
	          stack.pop();
	          stack.pop();

	          stack.pushBool(res);

	          if (op.value === opcodes.OP_CHECKDATASIGVERIFY) {
	            if (!res)
	              throw new ScriptError('CHECKDATASIGVERIFY', op, ip);
	            stack.pop();
	          }

	          break;
	        }
	        case opcodes.OP_CHECKMULTISIG:
	        case opcodes.OP_CHECKMULTISIGVERIFY: {
	          if (!tx)
	            throw new ScriptError('UNKNOWN_ERROR', 'No TX passed in.');

	          let keyCount = 1;
	          let sigCount = 0;
	          let keyTop, sigTop;

	          if (stack.length < keyCount)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          let nKeysCount = stack.getInt(-keyCount, minimal, 4);
	          let okey = nKeysCount + 2;
	          let ikey, isig;

	          if (nKeysCount < 0 || nKeysCount > consensus.MAX_MULTISIG_PUBKEYS)
	            throw new ScriptError('PUBKEY_COUNT', op, ip);

	          opCount += nKeysCount;

	          if (opCount > consensus.MAX_SCRIPT_OPS)
	            throw new ScriptError('OP_COUNT', op, ip);

	          keyCount += 1;
	          keyTop = keyCount;

	          // stack depth of nSigsCount
	          sigCount = keyTop + nKeysCount;

	          ikey = keyCount;
	          keyCount += nKeysCount;

	          if (stack.length < sigCount)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          let nSigsCount = stack.getInt(-sigCount, minimal, 4);

	          if (nSigsCount < 0 || nSigsCount > nKeysCount)
	            throw new ScriptError('SIG_COUNT', op, ip);

	          // stack depth of the top signature
	          sigTop = sigCount + 1;

	          // stack depth of the dummy element
	          const dummy = sigTop + nSigsCount;

	          if (stack.length < dummy)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          keyCount += 1;
	          isig = keyCount;
	          keyCount += nSigsCount;

	          const subscript = this.getSubscript(lastSep);
	          let res = true;

	          if ((flags & Script.flags.VERIFY_SCHNORR_MULTISIG)
	             && stack.get(-dummy).length !== 0) {
	              assert(consensus.MAX_MULTISIG_PUBKEYS < 32);

	            if (nKeysCount > 32)
	              throw new ScriptError('INVALID_BITFIELD_SIZE', op, ip);

	            const bitfield_size = Math.floor((nKeysCount + 7) / 8);
	            const abkam = stack.get(-dummy);

	            if (abkam.length !== bitfield_size)
	              throw new ScriptError('BITFIELD_SIZE', op, ip);

	            checkBits = this.bitcalculator(abkam, nKeysCount);

	            const mask = (1 << nKeysCount) - 1;
	            const numBits = countBits(checkBits);

	            if ((checkBits & mask) !== checkBits)
	              throw new ScriptError('BIT_RANGE', op, ip);

	            if (numBits !== nSigsCount)
	              throw new ScriptError('INVALID_BIT_COUNT', op, ip);

	            const bKey = keyTop + nKeysCount - 1;
	            const bSig = sigTop + nSigsCount - 1;

	            let ik3y = 0;

	            for (let is1g = 0; is1g < nSigsCount; is1g++, ik3y++) {
	              if ((checkBits >> ik3y) === 0) {
	                throw new ScriptError('INVALID_BIT_RANGE', op, ip);
	              }

	              while (((checkBits >> ik3y) & 0x01) === 0) {
	                ik3y++;
	              }

	              if (ik3y >= nKeysCount)
	                throw new ScriptError('PUBKEY_COUNT', op, ip);

	              const sig = stack.get(-bSig + is1g);
	              const key = stack.get(-bKey + ik3y);

	              // Handle checkbits left over
	              if (!sig)
	                continue;

	              checkTransactionSchnorrSig(sig, flags);
	              validateKey(key, flags);

	              if (sig.length > 0) {
	                const type = sig[sig.length - 1];
	                const hash = tx.signatureHash(
	                  index,
	                  subscript,
	                  value,
	                  type,
	                  flags
	                );

	                res = verifySignature(hash, sig.slice(0, -1), key, flags);
	                metrics.sigchecks += 1;
			            metrics.sigchecks;
	              }

	              while (keyCount > 1) {
	                if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
	                  if (okey === 0 && stack.get(-1).length !== 0)
	                    throw new ScriptError('NULLFAIL', op, ip);
	                }
	    
	                if (okey > 0)
	                  okey -= 1;
	    
	                stack.pop();
	    
	                keyCount -= 1;
	              }

	            }


	            if ((checkBits >> ik3y) !== 0)
	              throw new ScriptError('INVALID_BIT_COUNT', op, ip);

	            stack.pop();
	            stack.pushBool(res);

	          } else {
	            // Legacy Multisig (ECDSA / NULL)
	            // A bug causes CHECKMULTISIG to consume one extra
	            // argument whose contents were not checked in any way.

	          for (let j = 0; j < nSigsCount; j++) {
	            const sig = stack.get(-sigTop - j);
	            if (!(flags & Script.flags.VERIFY_SIGHASH_FORKID)
	              || !(sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID))
	              subscript.findAndDelete(sig, flags);
	          }

	          while (res && nSigsCount > 0) {
	            const sig = stack.get(-isig);
	            const key = stack.get(-ikey);

	            checkTransactionECDSASignature(sig, flags);
	            validateKey(key, flags);

	            if (sig.length > 0) {
	              const type = sig[sig.length - 1];
	              const hash = tx.signatureHash(
	                index,
	                subscript,
	                value,
	                type,
	                flags
	              );

	              if (checksig(hash, sig, key)) {
	                isig += 1;
	                nSigsCount -= 1;
	              }
	            }

	            ikey += 1;
	            nKeysCount -= 1;

	            if (nSigsCount > nKeysCount)
	              res = false;
	          }

	          while (keyCount > 1) {
	            if (!res && (flags & Script.flags.VERIFY_NULLFAIL)) {
	              if (okey === 0 && stack.get(-1).length !== 0)
	                throw new ScriptError('NULLFAIL', op, ip);
	            }

	            if (okey > 0)
	              okey -= 1;

	            stack.pop();

	            keyCount -= 1;
	          }

	          if (stack.length < 1)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          stack.pop();

	          stack.pushBool(res);

	          if (op.value === opcodes.OP_CHECKMULTISIGVERIFY) {
	            if (!res)
	              throw new ScriptError('CHECKMULTISIGVERIFY', op, ip);
	            stack.pop();
	           }
	          }

	          break;
	        }

	        //
	        // Byte string operations
	        //
	        case opcodes.OP_CAT: {
	          // (x1 x2 -- out)
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-2);
	          const v2 = stack.get(-1);
	          if (v1.length + v2.length > consensus.MAX_SCRIPT_PUSH) {
	            throw new ScriptError('PUSH_SIZE', op, ip);
	          }
	          stack.pop();
	          stack.pop();

	          stack.push(Buffer.concat([v1, v2]));

	          break;
	        }

	        case opcodes.OP_SPLIT: {
	          // (in position -- x1 x2)
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const data = stack.get(-2);

	          // Make sure the split point is appropriate.
	          const pos = stack.getInt(-1, minimal, 4);
	          if (pos < 0 || pos > data.length)
	            throw new ScriptError('INVALID_SPLIT_RANGE', op, ip);

	          // Prepare the results in their own buffer as `data`
	          // will be invalidated.
	          const n1 = data.slice(0, pos);
	          const n2 = data.slice(pos);

	          // Replace existing stack values by the new values.
	          stack.set(-2, n1);
	          stack.set(-1, n2);
	          break;
	        }
	        case opcodes.OP_REVERSEBYTES: {
	         if (stack.length < 1)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const data = stack.get(-1);

	          data.reverse();

	          break;
	        }

	        //
	        // Bitwise logic
	        //
	        case opcodes.OP_AND:
	        case opcodes.OP_OR:
	        case opcodes.OP_XOR: {
	          // (x1 x2 - out)
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const v1 = stack.get(-2);
	          const v2 = stack.get(-1);

	          // Inputs must be the same size
	          if (v1.length !== v2.length)
	            throw new ScriptError('INVALID_OPERAND_SIZE', op, ip);

	          const raw = Buffer.alloc(v1.length);

	          switch (op.value) {
	            case opcodes.OP_AND:
	              for (let i = 0; i < v1.length; i++) {
	                raw[i] = v1[i] & v2[i];
	              }
	              break;
	            case opcodes.OP_OR:
	              for (let i = 0; i < v1.length; i++) {
	                raw[i] = v1[i] | v2[i];
	              }
	              break;
	            case opcodes.OP_XOR:
	              for (let i = 0; i < v1.length; i++) {
	                raw[i] = v1[i] ^ v2[i];
	              }
	              break;
	          }

	          // And pop v1 and v2.
	          stack.pop();
	          stack.pop();

	          stack.push(raw);

	          break;
	        }

	        //
	        // Conversion operations
	        //
	        case opcodes.OP_NUM2BIN: {
	          // (in size -- out)
	          if (stack.length < 2)
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);

	          const size = stack.getInt(-1, minimal, 4);
	          if (size < 0 || size > consensus.MAX_SCRIPT_PUSH)
	            throw new ScriptError('PUSH_SIZE', op, ip);

	          stack.pop();

	          const n = stack.get(-1);
	          const v = ScriptNum.toMinimal(Buffer.from(n));

	          // Try to see if we can fit that number in the number of
	          // byte requested.
	          if (v.length > size)
	            // We definitively cannot.
	            throw new ScriptError('IMPOSSIBLE_ENCODING', op, ip);

	          // We already have an element of the right size, we don't need to do
	          // anything.
	          if (v.length === size) {
	            stack.pop();
	            stack.push(v);
	            break;
	          }

	          const raw = Buffer.alloc(size);
	          v.copy(raw);

	          let signbit = 0x00;
	          if (v.length > 0) {
	            signbit = v[v.length - 1] & 0x80;
	            raw[v.length - 1] &= 0x7f;
	          }

	          raw[size-1] = signbit;

	          stack.pop();
	          stack.push(raw);

	          break;
	        }

	        case opcodes.OP_BIN2NUM: {
	          // (in -- out)
	          if (stack.length < 1) {
	            throw new ScriptError('INVALID_STACK_OPERATION', op, ip);
	          }

	          const n = stack.get(-1);
	          const v = ScriptNum.toMinimal(Buffer.from(n));

	          stack.pop();
	          stack.push(v);

	          // The resulting number must be a valid number.
	          if (!ScriptNum.isMinimal(v) || v.length > 4)
	            throw new ScriptError('INVALID_NUMBER_RANGE', op, ip);

	          break;
	        }

	        default: {
	          throw new ScriptError('BAD_OPCODE', op, ip);
	        }
	      }
	    }

	    if (stack.length + alt.length > consensus.MAX_SCRIPT_STACK)
	      throw new ScriptError('STACK_SIZE');

	    if (state.length !== 0)
	      throw new ScriptError('UNBALANCED_CONDITIONAL');
	  }

	  /**
	   * Remove all matched data elements from
	   * a script's code (used to remove signatures
	   * before verification). Note that this
	   * compares and removes data on the _byte level_.
	   * It also reserializes the data to a single
	   * script with minimaldata encoding beforehand.
	   * A signature will _not_ be removed if it is
	   * not minimaldata.
	   * @see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
	   * @see https://test.webbtc.com/tx/19aa42fee0fa57c45d3b16488198b27caaacc4ff5794510d0c17f173f05587ff
	   * @param {Buffer} data - Data element to match against.
	   * @returns {Number} Total.
	   */

	  findAndDelete(data) {
	    const target = Opcode.fromPush(data);

	    if (this.raw.length < target.getSize())
	      return 0;

	    let found = false;

	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      if (op.equals(target)) {
	        found = true;
	        break;
	      }
	    }

	    if (!found)
	      return 0;

	    const code = [];

	    let total = 0;

	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      if (op.equals(target)) {
	        total += 1;
	        continue;
	      }

	      code.push(op);
	    }

	    this.code = code;
	    this.compile();

	    return total;
	  }

	  /**
	   * Find a data element in a script.
	   * @param {Buffer} data - Data element to match against.
	   * @returns {Number} Index (`-1` if not present).
	   */

	  indexOf(data) {
	    for (let i = 0; i < this.code.length; i++) {
	      const op = this.code[i];

	      if (op.value === -1)
	        break;

	      if (!op.data)
	        continue;

	      if (op.data.equals(data))
	        return i;
	    }

	    return -1;
	  }

	  /**
	   * Test a script to see if it is likely
	   * to be script code (no weird opcodes).
	   * @param {Number?} flags - Script standard flags.
	   * @returns {Boolean}
	   */

	  isCode(flags) {
	    if (flags == null)
	      flags = Script.flags.STANDARD_VERIFY_FLAGS;

	    for (const op of this.code) {
	      if (op.value === -1)
	        return false;

	      if (op.isDisabled(flags))
	        return false;

	      switch (op.value) {
	        case opcodes.OP_RESERVED:
	        case opcodes.OP_NOP:
	        case opcodes.OP_VER:
	        case opcodes.OP_VERIF:
	        case opcodes.OP_VERNOTIF:
	        case opcodes.OP_RESERVED1:
	        case opcodes.OP_RESERVED2:
	        case opcodes.OP_NOP1:
	          return false;
	      }

	      if (op.value > opcodes.OP_CHECKSEQUENCEVERIFY)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Inject properties from a pay-to-pubkey script.
	   * @private
	   * @param {Buffer} key
	   */

	  fromPubkey(key) {
	    assert(Buffer.isBuffer(key) && (key.length === 33 || key.length === 65));

	    this.raw = Buffer.allocUnsafe(1 + key.length + 1);
	    this.raw[0] = key.length;
	    key.copy(this.raw, 1);
	    this.raw[1 + key.length] = opcodes.OP_CHECKSIG;

	    key = this.raw.slice(1, 1 + key.length);

	    this.code.length = 0;
	    this.code.push(Opcode.fromPush(key));
	    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));

	    return this;
	  }

	  /**
	   * Create a pay-to-pubkey script.
	   * @param {Buffer} key
	   * @returns {Script}
	   */

	  static fromPubkey(key) {
	    return new this().fromPubkey(key);
	  }

	  /**
	   * Inject properties from a pay-to-pubkeyhash script.
	   * @private
	   * @param {Buffer} hash
	   */

	  fromPubkeyhash(hash) {
	    assert(Buffer.isBuffer(hash) && hash.length === 20);

	    this.raw = Buffer.allocUnsafe(25);
	    this.raw[0] = opcodes.OP_DUP;
	    this.raw[1] = opcodes.OP_HASH160;
	    this.raw[2] = 0x14;
	    hash.copy(this.raw, 3);
	    this.raw[23] = opcodes.OP_EQUALVERIFY;
	    this.raw[24] = opcodes.OP_CHECKSIG;

	    hash = this.raw.slice(3, 23);

	    this.code.length = 0;
	    this.code.push(Opcode.fromOp(opcodes.OP_DUP));
	    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
	    this.code.push(Opcode.fromPush(hash));
	    this.code.push(Opcode.fromOp(opcodes.OP_EQUALVERIFY));
	    this.code.push(Opcode.fromOp(opcodes.OP_CHECKSIG));

	    return this;
	  }

	  /**
	   * Create a pay-to-pubkeyhash script.
	   * @param {Buffer} hash
	   * @returns {Script}
	   */

	  static fromPubkeyhash(hash) {
	    return new this().fromPubkeyhash(hash);
	  }

	  /**
	   * Inject properties from pay-to-multisig script.
	   * @private
	   * @param {Number} m
	   * @param {Number} n
	   * @param {Buffer[]} keys
	   */

	  fromMultisig(m, n, keys) {
	    assert((m & 0xff) === m && (n & 0xff) === n);
	    assert(Array.isArray(keys));
	    assert(keys.length === n, '`n` keys are required for multisig.');
	    assert(m >= 1 && m <= n);
	    assert(n >= 1 && n <= 15);

	    this.clear();

	    this.pushSmall(m);

	    for (const key of sortKeys(keys))
	      this.pushData(key);

	    this.pushSmall(n);
	    this.pushOp(opcodes.OP_CHECKMULTISIG);

	    return this.compile();
	  }

	  /**
	   * Create a pay-to-multisig script.
	   * @param {Number} m
	   * @param {Number} n
	   * @param {Buffer[]} keys
	   * @returns {Script}
	   */

	  static fromMultisig(m, n, keys) {
	    return new this().fromMultisig(m, n, keys);
	  }

	  /**
	   * Inject properties from a pay-to-scripthash script.
	   * @private
	   * @param {Buffer} hash
	   */

	  fromScripthash(hash) {
	    assert(Buffer.isBuffer(hash) && hash.length === 20);

	    this.raw = Buffer.allocUnsafe(23);
	    this.raw[0] = opcodes.OP_HASH160;
	    this.raw[1] = 0x14;
	    hash.copy(this.raw, 2);
	    this.raw[22] = opcodes.OP_EQUAL;

	    hash = this.raw.slice(2, 22);

	    this.code.length = 0;
	    this.code.push(Opcode.fromOp(opcodes.OP_HASH160));
	    this.code.push(Opcode.fromPush(hash));
	    this.code.push(Opcode.fromOp(opcodes.OP_EQUAL));

	    return this;
	  }

	  /**
	   * Create a pay-to-scripthash script.
	   * @param {Buffer} hash
	   * @returns {Script}
	   */

	  static fromScripthash(hash) {
	    return new this().fromScripthash(hash);
	  }

	  /**
	   * Inject properties from a nulldata/opreturn script.
	   * @private
	   * @param {Buffer} flags
	   */

	  fromNulldata(flags) {
	    assert(Buffer.isBuffer(flags));
	    assert(flags.length <= policy.MAX_OP_RETURN, 'Nulldata too large.');

	    this.clear();
	    this.pushOp(opcodes.OP_RETURN);
	    this.pushData(flags);

	    return this.compile();
	  }

	  /**
	   * Create a nulldata/opreturn script.
	   * @param {Buffer} flags
	   * @returns {Script}
	   */

	  static fromNulldata(flags) {
	    return new this().fromNulldata(flags);
	  }

	  /**
	   * Inject properties from an address.
	   * @private
	   * @param {Address|AddressString} address
	   */

	  fromAddress(address) {
	    if (typeof address === 'string')
	      address = Address.fromString(address);

	    assert(address instanceof Address, 'Not an address.');

	    if (address.isPubkeyhash())
	      return this.fromPubkeyhash(address.hash);

	    if (address.isScripthash())
	      return this.fromScripthash(address.hash);

	    throw new Error('Unknown address type.');
	  }

	  /**
	   * Create an output script from an address.
	   * @param {Address|AddressString} address
	   * @returns {Script}
	   */

	  static fromAddress(address) {
	    return new this().fromAddress(address);
	  }

	  /**
	   * Grab and deserialize the redeem script.
	   * @returns {Script|null} Redeem script.
	   */

	  getRedeem() {
	    let data = null;

	    for (const op of this.code) {
	      if (op.value === -1)
	        return null;

	      if (op.value > opcodes.OP_16)
	        return null;

	      data = op.data;
	    }

	    if (!data)
	      return null;

	    return Script.fromRaw(data);
	  }

	  /**
	   * Get the standard script type.
	   * @returns {ScriptType}
	   */

	  getType() {
	    if (this.isPubkey())
	      return scriptTypes.PUBKEY;

	    if (this.isPubkeyhash())
	      return scriptTypes.PUBKEYHASH;

	    if (this.isScripthash())
	      return scriptTypes.SCRIPTHASH;

	    if (this.isMultisig())
	      return scriptTypes.MULTISIG;

	    if (this.isNulldata())
	      return scriptTypes.NULLDATA;

	    return scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Test whether a script is of an unknown/non-standard type.
	   * @returns {Boolean}
	   */

	  isUnknown() {
	    return this.getType() === scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Test whether the script is standard by policy standards.
	   * @returns {Boolean}
	   */

	  isStandard() {
	    const [m, n] = this.getMultisig();

	    if (m !== -1) {
	      if (n < 1 || n > 3)
	        return false;

	      if (m < 1 || m > n)
	        return false;

	      return true;
	    }

	    if (this.isNulldata())
	      return this.raw.length <= policy.MAX_OP_RETURN_BYTES;

	    return this.getType() !== scriptTypes.NONSTANDARD;
	  }

	  /**
	   * Calculate the size of the script
	   * excluding the varint size bytes.
	   * @returns {Number}
	   */

	  getSize() {
	    return this.raw.length;
	  }

	  /**
	   * Calculate the size of the script
	   * including the varint size bytes.
	   * @returns {Number}
	   */

	  getVarSize() {
	    return encoding.sizeVarBytes(this.raw);
	  }

	  /**
	   * "Guess" the address of the input script.
	   * This method is not 100% reliable.
	   * @returns {Address|null}
	   */

	  getInputAddress() {
	    return Address.fromInputScript(this);
	  }

	  /**
	   * Get the address of the script if present. Note that
	   * pubkey and multisig scripts will be treated as though
	   * they are pubkeyhash and scripthashes respectively.
	   * @returns {Address|null}
	   */

	  getAddress() {
	    return Address.fromScript(this);
	  }

	  /**
	   * Get the hash160 of the raw script.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  hash160(enc) {
	    let hash = hash160.digest(this.toRaw());
	    if (enc === 'hex')
	      hash = hash.toString('hex');
	    return hash;
	  }

	  /**
	   * Get the sha256 of the raw script.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  sha256(enc) {
	    let hash = sha256.digest(this.toRaw());
	    if (enc === 'hex')
	      hash = hash.toString('hex');
	    return hash;
	  }

	  /**
	   * Test whether the output script is pay-to-pubkey.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isPubkey(minimal) {
	    if (minimal) {
	      return this.raw.length >= 35
	        && (this.raw[0] === 33 || this.raw[0] === 65)
	        && this.raw[0] + 2 === this.raw.length
	        && this.raw[this.raw.length - 1] === opcodes.OP_CHECKSIG;
	    }

	    if (this.code.length !== 2)
	      return false;

	    const size = this.getLength(0);

	    return (size === 33 || size === 65)
	      && this.getOp(1) === opcodes.OP_CHECKSIG;
	  }

	  /**
	   * Get P2PK key if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getPubkey(minimal) {
	    if (!this.isPubkey(minimal))
	      return null;

	    if (minimal)
	      return this.raw.slice(1, 1 + this.raw[0]);

	    return this.getData(0);
	  }

	  /**
	   * Test whether the output script is pay-to-pubkeyhash.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isPubkeyhash(minimal) {
	    if (minimal || this.raw.length === 25) {
	      return this.raw.length === 25
	        && this.raw[0] === opcodes.OP_DUP
	        && this.raw[1] === opcodes.OP_HASH160
	        && this.raw[2] === 0x14
	        && this.raw[23] === opcodes.OP_EQUALVERIFY
	        && this.raw[24] === opcodes.OP_CHECKSIG;
	    }

	    if (this.code.length !== 5)
	      return false;

	    return this.getOp(0) === opcodes.OP_DUP
	      && this.getOp(1) === opcodes.OP_HASH160
	      && this.getLength(2) === 20
	      && this.getOp(3) === opcodes.OP_EQUALVERIFY
	      && this.getOp(4) === opcodes.OP_CHECKSIG;
	  }

	  /**
	   * Get P2PKH hash if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getPubkeyhash(minimal) {
	    if (!this.isPubkeyhash(minimal))
	      return null;

	    if (minimal)
	      return this.raw.slice(3, 23);

	    return this.getData(2);
	  }

	/**
	   * Test whether the output script is pay-to-multisig.
	   * @param {Boolean} [minimal=true] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isMultisig(minimal) {
	    if (this.code.length < 4 || this.code.length > 19)
	      return false;

	    if (this.getOp(-1) !== opcodes.OP_CHECKMULTISIG)
	      return false;

	    const m = this.getSmall(0);

	    if (m < 1)
	      return false;

	    const n = this.getSmall(-2);


	    if (n < 1 || m > n)
	      return false;

	    if (this.code.length !== n + 3)
	      return false;

	    for (let i = 1; i < n + 1; i++) {
	      const op = this.code[i];
	      const size = op.toLength();

	      if (size !== 33 && size !== 65)
	        return false;

	      if (minimal && !op.isMinimal())
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Get multisig m and n values if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Array} [m, n]
	   */

	  getMultisig(minimal) {
	    if (!this.isMultisig(minimal))
	      return [-1, -1];

	    return [this.getSmall(0), this.getSmall(-2)];
	  }

	  /**
	   * Test whether the output script is pay-to-scripthash. Note that
	   * bitcoin itself requires scripthashes to be in strict minimaldata
	   * encoding. Using `OP_HASH160 OP_PUSHDATA1 [hash] OP_EQUAL` will
	   * _not_ be recognized as a scripthash.
	   * @returns {Boolean}
	   */

	  isScripthash() {
	    return this.raw.length === 23
	      && this.raw[0] === opcodes.OP_HASH160
	      && this.raw[1] === 0x14
	      && this.raw[22] === opcodes.OP_EQUAL;
	  }

	  /**
	   * Get P2SH hash if present.
	   * @returns {Buffer|null}
	   */

	  getScripthash() {
	    if (!this.isScripthash())
	      return null;

	    return this.getData(1);
	  }

	  /**
	   * Test whether the output script is nulldata/opreturn.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Boolean}
	   */

	  isNulldata(minimal) {
	    if (this.code.length === 0)
	      return false;

	    if (this.getOp(0) !== opcodes.OP_RETURN)
	      return false;

	    if (this.code.length === 1)
	      return true;

	    if (minimal) {
	      if (this.raw.length > policy.MAX_OP_RETURN_BYTES)
	        return false;
	    }

	    for (let i = 1; i < this.code.length; i++) {
	      const op = this.code[i];

	      if (op.value === -1)
	        return false;

	      if (op.value > opcodes.OP_16)
	        return false;

	      if (minimal && !op.isMinimal())
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Get OP_RETURN data if present.
	   * @param {Boolean} [minimal=false] - Minimaldata only.
	   * @returns {Buffer|null}
	   */

	  getNulldata(minimal) {
	    if (!this.isNulldata(minimal))
	      return null;

	    for (let i = 1; i < this.code.length; i++) {
	      const op = this.code[i];
	      const data = op.toPush();
	      if (data)
	        return data;
	    }

	    return EMPTY_BUFFER;
	  }

	  /**
	   * Test whether the output script is a witness program.
	   * Note that this will return true even for malformed
	   * witness v0 programs.
	   * @returns {Boolean}
	   */

	  isProgram() {
	    if (this.raw.length < 4 || this.raw.length > 42)
	      return false;

	    if (this.raw[0] !== opcodes.OP_0
	      && (this.raw[0] < opcodes.OP_1 || this.raw[0] > opcodes.OP_16)) {
	      return false;
	    }

	    if (this.raw[1] + 2 !== this.raw.length)
	      return false;

	    return true;
	  }

	  /**
	   * Test whether the output script is unspendable.
	   * @returns {Boolean}
	   */

	  isUnspendable() {
	    if (this.raw.length > consensus.MAX_SCRIPT_SIZE)
	      return true;

	    return this.raw.length > 0 && this.raw[0] === opcodes.OP_RETURN;
	  }

	  /**
	   * "Guess" the type of the input script.
	   * This method is not 100% reliable.
	   * @returns {ScriptType}
	   */

	  getInputType() {
	    if (this.isPubkeyInput())
	      return scriptTypes.PUBKEY;

	    if (this.isPubkeyhashInput())
	      return scriptTypes.PUBKEYHASH;

	    if (this.isScripthashInput())
	      return scriptTypes.SCRIPTHASH;

	    if (this.isMultisigInput())
	      return scriptTypes.MULTISIG;

	    return scriptTypes.NONSTANDARD;
	  }

	  /**
	   * "Guess" whether the input script is an unknown/non-standard type.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isUnknownInput() {
	    return this.getInputType() === scriptTypes.NONSTANDARD;
	  }

	  /**
	   * "Guess" whether the input script is pay-to-pubkey.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isPubkeyInput() {
	    if (this.code.length !== 1)
	      return false;

	    const size = this.getLength(0);

	    return size >= 9 && size <= 73;
	  }

	  /**
	   * Get P2PK signature if present.
	   * @returns {Buffer|null}
	   */

	  getPubkeyInput() {
	    if (!this.isPubkeyInput())
	      return null;

	    return this.getData(0);
	  }

	  /**
	   * "Guess" whether the input script is pay-to-pubkeyhash.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isPubkeyhashInput() {
	    if (this.code.length !== 2)
	      return false;

	    const sig = this.getLength(0);
	    const key = this.getLength(1);

	    return sig >= 9 && sig <= 73
	      && (key === 33 || key === 65);
	  }

	  /**
	   * Get P2PKH signature and key if present.
	   * @returns {Array} [sig, key]
	   */

	  getPubkeyhashInput() {
	    if (!this.isPubkeyhashInput())
	      return [null, null];

	    return [this.getData(0), this.getData(1)];
	  }

	  /**
	   * "Guess" whether the input script is pay-to-multisig.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isMultisigInput() {
	    if (this.code.length < 2)
	      return false;

	    if (this.getOp(0) !== opcodes.OP_0)
	      return false;

	    if (this.getOp(1) > opcodes.OP_PUSHDATA4)
	      return false;

	    // We need to rule out scripthash
	    // because it may look like multisig.
	    if (this.isScripthashInput())
	      return false;

	    for (let i = 1; i < this.code.length; i++) {
	      const size = this.getLength(i);
	      if (size < 9 || size > 73)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Get multisig signatures if present.
	   * @returns {Buffer[]|null}
	   */

	  getMultisigInput() {
	    if (!this.isMultisigInput())
	      return null;

	    const sigs = [];

	    for (let i = 1; i < this.code.length; i++)
	      sigs.push(this.getData(i));

	    return sigs;
	  }

	  /**
	   * "Guess" whether the input script is pay-to-scripthash.
	   * This method is not 100% reliable.
	   * @returns {Boolean}
	   */

	  isScripthashInput() {
	    if (this.code.length < 1)
	      return false;

	    // Grab the raw redeem script.
	    const raw = this.getData(-1);

	    // Last data element should be an array
	    // for the redeem script.
	    if (!raw)
	      return false;

	    // Testing for scripthash inputs requires
	    // some evil magic to work. We do it by
	    // ruling things _out_. This test will not
	    // be correct 100% of the time. We rule
	    // out that the last data element is: a
	    // null dummy, a valid signature, a valid
	    // key, and we ensure that it is at least
	    // a script that does not use undefined
	    // opcodes.
	    if (raw.length === 0)
	      return false;

	    if (common.isDERSignatureEncoding(raw.slice(0, -1)))
	      return false;

	    if (common.isKeyEncoding(raw))
	      return false;

	    const redeem = Script.fromRaw(raw);

	    if (!redeem.isCode())
	      return false;

	    if (redeem.isUnspendable())
	      return false;

	    if (!this.isPushOnly())
	      return false;

	    return true;
	  }

	  /**
	   * Get P2SH redeem script if present.
	   * @returns {Buffer|null}
	   */

	  getScripthashInput() {
	    if (!this.isScripthashInput())
	      return null;

	    return this.getData(-1);
	  }

	  /**
	   * Get coinbase height.
	   * @returns {Number} `-1` if not present.
	   */

	  getCoinbaseHeight() {
	    return Script.getCoinbaseHeight(this.raw);
	  }

	  /**
	   * Get coinbase height.
	   * @param {Buffer} raw - Raw script.
	   * @returns {Number} `-1` if not present.
	   */

	  static getCoinbaseHeight(raw) {
	    if (raw.length === 0)
	      return -1;

	    if (raw[0] >= opcodes.OP_1 && raw[0] <= opcodes.OP_16)
	      return raw[0] - 0x50;

	    if (raw[0] > 0x06)
	      return -1;

	    const op = Opcode.fromRaw(raw);
	    const num = op.toNum();

	    if (!num)
	      return 1;

	    if (num.isNeg())
	      return -1;

	    if (!op.equals(Opcode.fromNum(num)))
	      return -1;

	    return num.toDouble();
	  }

	  /**
	   * Test the script against a bloom filter.
	   * @param {Bloom} filter
	   * @returns {Boolean}
	   */

	  test(filter) {
	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      if (!op.data || op.data.length === 0)
	        continue;

	      if (filter.test(op.data))
	        return true;
	    }

	    return false;
	  }

	  /**
	   * Test the script to see if it contains only push ops.
	   * Push ops are: OP_1NEGATE, OP_0-OP_16 and all PUSHDATAs.
	   * @returns {Boolean}
	   */

	  isPushOnly() {
	    for (const op of this.code) {
	      if (op.value === -1)
	        return false;

	      if (op.value > opcodes.OP_16)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Count the sigops in the script.
	   * @param {Boolean} accurate - Whether to enable accurate counting. This will
	   * take into account the `n` value for OP_CHECKMULTISIG(VERIFY).
	   * @returns {Number} sigop count
	   */

	  getSigops(accurate, flags) {
	    if (flags & Script.flags.VERIFY_ZERO_SIGOPS)
	      return 0;

	    let total = 0;
	    let lastOp = -1;

	    for (const op of this.code) {
	      if (op.value === -1)
	        break;

	      switch (op.value) {
	        case opcodes.OP_CHECKSIG:
	        case opcodes.OP_CHECKSIGVERIFY:
	          total += 1;
	          break;
	        case opcodes.OP_CHECKSDATAIG:
	        case opcodes.OP_CHECKDATASIGVERIFY:
	          if (flags & Script.flags.VERIFY_CHECKDATASIG) {
	            total += 1;
	          }
	          break;
	        case opcodes.OP_CHECKMULTISIG:
	        case opcodes.OP_CHECKMULTISIGVERIFY:
	          if (accurate && lastOp >= opcodes.OP_1 && lastOp <= opcodes.OP_16)
	            total += lastOp - 0x50;
	          else
	            total += consensus.MAX_MULTISIG_PUBKEYS;
	          break;
	      }

	      lastOp = op.value;
	    }

	    return total;
	  }

	  /**
	   * Count the sigops in the script, taking into account redeem scripts.
	   * @param {Script} input - Input script, needed for access to redeem script.
	   * @param {VerifyFlags} flags
	   * @returns {Number} sigop count
	   */

	  getScripthashSigops(input, flags) {
	    if (!this.isScripthash())
	      return this.getSigops(true, flags);

	    const redeem = input.getRedeem();

	    if (!redeem)
	      return 0;

	    return redeem.getSigops(true, flags);
	  }

	  /*
	   * Mutation
	   */

	  get(index) {
	    if (index < 0)
	      index += this.code.length;

	    if (index < 0 || index >= this.code.length)
	      return null;

	    return this.code[index];
	  }

	  pop() {
	    const op = this.code.pop();
	    return op || null;
	  }

	  shift() {
	    const op = this.code.shift();
	    return op || null;
	  }

	  remove(index) {
	    if (index < 0)
	      index += this.code.length;

	    if (index < 0 || index >= this.code.length)
	      return null;

	    const items = this.code.splice(index, 1);

	    if (items.length === 0)
	      return null;

	    return items[0];
	  }

	  set(index, op) {
	    if (index < 0)
	      index += this.code.length;

	    assert(Opcode.isOpcode(op));
	    assert(index >= 0 && index <= this.code.length);

	    this.code[index] = op;

	    return this;
	  }

	  push(op) {
	    assert(Opcode.isOpcode(op));
	    this.code.push(op);
	    return this;
	  }

	  unshift(op) {
	    assert(Opcode.isOpcode(op));
	    this.code.unshift(op);
	    return this;
	  }

	  insert(index, op) {
	    if (index < 0)
	      index += this.code.length;

	    assert(Opcode.isOpcode(op));
	    assert(index >= 0 && index <= this.code.length);

	    this.code.splice(index, 0, op);

	    return this;
	  }

	  /*
	   * Op
	   */

	  getOp(index) {
	    const op = this.get(index);
	    return op ? op.value : -1;
	  }

	  popOp() {
	    const op = this.pop();
	    return op ? op.value : -1;
	  }

	  shiftOp() {
	    const op = this.shift();
	    return op ? op.value : -1;
	  }

	  removeOp(index) {
	    const op = this.remove(index);
	    return op ? op.value : -1;
	  }

	  setOp(index, value) {
	    return this.set(index, Opcode.fromOp(value));
	  }

	  pushOp(value) {
	    return this.push(Opcode.fromOp(value));
	  }

	  unshiftOp(value) {
	    return this.unshift(Opcode.fromOp(value));
	  }

	  insertOp(index, value) {
	    return this.insert(index, Opcode.fromOp(value));
	  }

	  /*
	   * Data
	   */

	  getData(index) {
	    const op = this.get(index);
	    return op ? op.data : null;
	  }

	  popData() {
	    const op = this.pop();
	    return op ? op.data : null;
	  }

	  shiftData() {
	    const op = this.shift();
	    return op ? op.data : null;
	  }

	  removeData(index) {
	    const op = this.remove(index);
	    return op ? op.data : null;
	  }

	  setData(index, data) {
	    return this.set(index, Opcode.fromData(data));
	  }

	  pushData(data) {
	    return this.push(Opcode.fromData(data));
	  }

	  unshiftData(data) {
	    return this.unshift(Opcode.fromData(data));
	  }

	  insertData(index, data) {
	    return this.insert(index, Opcode.fromData(data));
	  }

	  /*
	   * Length
	   */

	  getLength(index) {
	    const op = this.get(index);
	    return op ? op.toLength() : -1;
	  }

	  /*
	   * Push
	   */

	  getPush(index) {
	    const op = this.get(index);
	    return op ? op.toPush() : null;
	  }

	  popPush() {
	    const op = this.pop();
	    return op ? op.toPush() : null;
	  }

	  shiftPush() {
	    const op = this.shift();
	    return op ? op.toPush() : null;
	  }

	  removePush(index) {
	    const op = this.remove(index);
	    return op ? op.toPush() : null;
	  }

	  setPush(index, data) {
	    return this.set(index, Opcode.fromPush(data));
	  }

	  pushPush(data) {
	    return this.push(Opcode.fromPush(data));
	  }

	  unshiftPush(data) {
	    return this.unshift(Opcode.fromPush(data));
	  }

	  insertPush(index, data) {
	    return this.insert(index, Opcode.fromPush(data));
	  }

	  /*
	   * String
	   */

	  getString(index, enc) {
	    const op = this.get(index);
	    return op ? op.toString(enc) : null;
	  }

	  popString(enc) {
	    const op = this.pop();
	    return op ? op.toString(enc) : null;
	  }

	  shiftString(enc) {
	    const op = this.shift();
	    return op ? op.toString(enc) : null;
	  }

	  removeString(index, enc) {
	    const op = this.remove(index);
	    return op ? op.toString(enc) : null;
	  }

	  setString(index, str, enc) {
	    return this.set(index, Opcode.fromString(str, enc));
	  }

	  pushString(str, enc) {
	    return this.push(Opcode.fromString(str, enc));
	  }

	  unshiftString(str, enc) {
	    return this.unshift(Opcode.fromString(str, enc));
	  }

	  insertString(index, str, enc) {
	    return this.insert(index, Opcode.fromString(str, enc));
	  }

	  /*
	   * Small
	   */

	  getSmall(index) {
	    const op = this.get(index);
	    return op ? op.toSmall() : -1;
	  }

	  popSmall() {
	    const op = this.pop();
	    return op ? op.toSmall() : -1;
	  }

	  shiftSmall() {
	    const op = this.shift();
	    return op ? op.toSmall() : -1;
	  }

	  removeSmall(index) {
	    const op = this.remove(index);
	    return op ? op.toSmall() : -1;
	  }

	  setSmall(index, num) {
	    return this.set(index, Opcode.fromSmall(num));
	  }

	  pushSmall(num) {
	    return this.push(Opcode.fromSmall(num));
	  }

	  unshiftSmall(num) {
	    return this.unshift(Opcode.fromSmall(num));
	  }

	  insertSmall(index, num) {
	    return this.insert(index, Opcode.fromSmall(num));
	  }

	  /*
	   * Num
	   */

	  getNum(index, minimal, limit) {
	    const op = this.get(index);
	    return op ? op.toNum(minimal, limit) : null;
	  }

	  popNum(minimal, limit) {
	    const op = this.pop();
	    return op ? op.toNum(minimal, limit) : null;
	  }

	  shiftNum(minimal, limit) {
	    const op = this.shift();
	    return op ? op.toNum(minimal, limit) : null;
	  }

	  removeNum(index, minimal, limit) {
	    const op = this.remove(index);
	    return op ? op.toNum(minimal, limit) : null;
	  }

	  setNum(index, num) {
	    return this.set(index, Opcode.fromNum(num));
	  }

	  pushNum(num) {
	    return this.push(Opcode.fromNum(num));
	  }

	  unshiftNum(num) {
	    return this.unshift(Opcode.fromNum(num));
	  }

	  insertNum(index, num) {
	    return this.insert(index, Opcode.fromNum(num));
	  }

	  /*
	   * Int
	   */

	  getInt(index, minimal, limit) {
	    const op = this.get(index);
	    return op ? op.toInt(minimal, limit) : -1;
	  }

	  popInt(minimal, limit) {
	    const op = this.pop();
	    return op ? op.toInt(minimal, limit) : -1;
	  }

	  shiftInt(minimal, limit) {
	    const op = this.shift();
	    return op ? op.toInt(minimal, limit) : -1;
	  }

	  removeInt(index, minimal, limit) {
	    const op = this.remove(index);
	    return op ? op.toInt(minimal, limit) : -1;
	  }

	  setInt(index, num) {
	    return this.set(index, Opcode.fromInt(num));
	  }

	  pushInt(num) {
	    return this.push(Opcode.fromInt(num));
	  }

	  unshiftInt(num) {
	    return this.unshift(Opcode.fromInt(num));
	  }

	  insertInt(index, num) {
	    return this.insert(index, Opcode.fromInt(num));
	  }

	  /*
	   * Bool
	   */

	  getBool(index) {
	    const op = this.get(index);
	    return op ? op.toBool() : false;
	  }

	  popBool() {
	    const op = this.pop();
	    return op ? op.toBool() : false;
	  }

	  shiftBool() {
	    const op = this.shift();
	    return op ? op.toBool() : false;
	  }

	  removeBool(index) {
	    const op = this.remove(index);
	    return op ? op.toBool() : false;
	  }

	  setBool(index, value) {
	    return this.set(index, Opcode.fromBool(value));
	  }

	  pushBool(value) {
	    return this.push(Opcode.fromBool(value));
	  }

	  unshiftBool(value) {
	    return this.unshift(Opcode.fromBool(value));
	  }

	  insertBool(index, value) {
	    return this.insert(index, Opcode.fromBool(value));
	  }

	  /*
	   * Symbol
	   */

	  getSym(index) {
	    const op = this.get(index);
	    return op ? op.toSymbol() : null;
	  }

	  popSym() {
	    const op = this.pop();
	    return op ? op.toSymbol() : null;
	  }

	  shiftSym() {
	    const op = this.shift();
	    return op ? op.toSymbol() : null;
	  }

	  removeSym(index) {
	    const op = this.remove(index);
	    return op ? op.toSymbol() : null;
	  }

	  setSym(index, symbol) {
	    return this.set(index, Opcode.fromSymbol(symbol));
	  }

	  pushSym(symbol) {
	    return this.push(Opcode.fromSymbol(symbol));
	  }

	  unshiftSym(symbol) {
	    return this.unshift(Opcode.fromSymbol(symbol));
	  }

	  insertSym(index, symbol) {
	    return this.insert(index, Opcode.fromSymbol(symbol));
	  }

	  /**
	   * Inject properties from bitcoind test string.
	   * @private
	   * @param {String} items - Script string.
	   * @throws Parse error.
	   */

	  fromString(code) {
	    assert(typeof code === 'string');

	    code = code.trim();

	    if (code.length === 0)
	      return this;

	    const items = code.split(/\s+/);
	    const bw = bio.write();

	    for (const item of items) {
	      let symbol = item;

	      if (symbol.charCodeAt(0) & 32)
	        symbol = symbol.toUpperCase();

	      if (!/^OP_/.test(symbol))
	        symbol = `OP_${symbol}`;

	      const value = opcodes[symbol];

	      if (value == null) {
	        if (item[0] === '\'') {
	          assert(item[item.length - 1] === '\'', 'Invalid string.');
	          const str = item.slice(1, -1);
	          const op = Opcode.fromString(str);
	          bw.writeBytes(op.toRaw());
	          continue;
	        }

	        if (/^-?\d+$/.test(item)) {
	          const num = ScriptNum.fromString(item, 10);
	          const op = Opcode.fromNum(num);
	          bw.writeBytes(op.toRaw());
	          continue;
	        }

	        assert(item.indexOf('0x') === 0, 'Unknown opcode.');

	        const hex = item.substring(2);
	        const data = Buffer.from(hex, 'hex');

	        assert(data.length === hex.length / 2, 'Invalid hex string.');

	        bw.writeBytes(data);

	        continue;
	      }

	      bw.writeU8(value);
	    }

	    return this.fromRaw(bw.render());
	  }

	  /**
	   * Parse a bitcoind test script
	   * string into a script object.
	   * @param {String} items - Script string.
	   * @returns {Script}
	   * @throws Parse error.
	   */

	  static fromString(code) {
	    return new this().fromString(code);
	  }

	  /**
	   * Verify an input and output script, and a witness if present.
	   * @param {Script} input
	   * @param {Null} witness
	   * @param {Script} output
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Amount} value
	   * @param {VerifyFlags} flags
	   * @param {Number?} sigchecks
	   * @throws {ScriptError}
	   */

	  static verify(input, witness, output, tx, index, value, flags, sigchecks) {
	    if (flags == null)
	      flags = Script.flags.STANDARD_VERIFY_FLAGS;

	    if (flags & Script.flags.VERIFY_SIGPUSHONLY) {
	      if (!input.isPushOnly())
	        throw new ScriptError('SIG_PUSHONLY');
	    }

	    if (flags & Script.flags.VERIFY_SIGHASH_FORKID)
	      flags |= Script.flags.VERIFY_STRICTENC;

	    // Setup a stack.
	    let stack = new Stack();

	    // Execute the input script
	    input.execute(stack, flags, tx, index, value, metrics.sigchecks);

	    // Copy the stack for P2SH
	    let copy;
	    if (flags & Script.flags.VERIFY_P2SH)
	      copy = stack.clone();

	    // Execute the previous output script.
	    output.execute(stack, flags, tx, index, value, metrics.sigchecks);

	    // Verify the stack values.
	    if (stack.length === 0 || !stack.getBool(-1))
	      throw new ScriptError('EVAL_FALSE');

	    // If the script is P2SH, execute the real output script
	    if ((flags & Script.flags.VERIFY_P2SH) && output.isScripthash()) {
	      // P2SH can only have push ops in the scriptSig
	      if (!input.isPushOnly())
	        throw new ScriptError('SIG_PUSHONLY');

	      // Reset the stack
	      stack = copy;

	      // Stack should not be empty at this point
	      if (stack.length === 0)
	        throw new ScriptError('EVAL_FALSE');

	      // Grab the real redeem script
	      const raw = stack.pop();
	      const redeem = Script.fromRaw(raw);

	      if ((flags & Script.flags.VERIFY_DISALLOW_SEGWIT_RECOVERY) === 0
	         && stack.length === 0 && redeem.isProgram()) {

	        // Before activation all transaction count a value of 0
	        if (!(flags & Script.flags.REPORT_SIGCHECKS)) {
	          metrics.sigchecks = 0;
	        }
	        return;
	      }

	        // Execute the redeem script.
	      redeem.execute(stack, flags, tx, index, value, 0, metrics.sigchecks);

	      // Verify the the stack values.
	      if (stack.length === 0 || !stack.getBool(-1))
	        throw new ScriptError('EVAL_FALSE');
	    }

	    // Ensure there is nothing left on the stack.
	    if (flags & Script.flags.VERIFY_CLEANSTACK) {
	      assert((flags & Script.flags.VERIFY_P2SH) !== 0);
	      if (stack.length !== 1)
	        throw new ScriptError('CLEANSTACK');
	    }

	    if (flags & Script.flags.VERIFY_INPUT_SIGCHECKS) {
	      if (input.getSize() < metrics.sigchecks * 43 - 60)
	        throw new ScriptError('INPUT_SIGCHECKS');
	    }

	    if (!(flags & Script.flags.REPORT_SIGCHECKS)) {
	      metrics.sigchecks = 0;
	    }
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    return this.fromRaw(br.readVarBytes());
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer}
	   */

	  fromRaw(data) {
	    const br = bio.read(data);

	    this.raw = data;

	    while (br.left())
	      this.code.push(Opcode.fromReader(br));

	    return this;
	  }

	  /**
	   * Create a script from buffer reader.
	   * @param {BufferReader} br
	   * @param {String?} enc - Either `"hex"` or `null`.
	   * @returns {Script}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Create a script from a serialized buffer.
	   * @param {Buffer|String} data - Serialized script.
	   * @param {String?} enc - Either `"hex"` or `null`.
	   * @returns {Script}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object a Script.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isScript(obj) {
	    return obj instanceof Script;
	  }
	}

	/**
	 * Script opcodes.
	 * @enum {Number}
	 * @default
	 */

	Script.opcodes = common.opcodes;

	/**
	 * Opcodes by value.
	 * @const {RevMap}
	 */

	Script.opcodesByVal = common.opcodesByVal;

	/**
	 * Script and locktime flags. See {@link VerifyFlags}.
	 * @enum {Number}
	 */

	Script.flags = common.flags;

	/**
	 * Sighash Types.
	 * @enum {SighashType}
	 * @default
	 */

	Script.hashType = common.hashType;

	/**
	 * Sighash types by value.
	 * @const {RevMap}
	 */

	Script.hashTypeByVal = common.hashTypeByVal;

	/**
	 * Output script types.
	 * @enum {Number}
	 */

	Script.types = common.types;

	/**
	 * Output script types by value.
	 * @const {RevMap}
	 */

	Script.typesByVal = common.typesByVal;

	/*
	 * Helpers
	 */

	function sortKeys(keys) {
	  return keys.slice().sort((a, b) => {
	    return a.compare(b);
	  });
	}

	/**
	 * Test whether the data element is a valid key if VERIFY_STRICTENC is enabled.
	 * @param {Buffer} key
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateKey(key, flags) {
	  assert(Buffer.isBuffer(key));
	  assert(typeof flags === 'number');

	  if (flags & Script.flags.VERIFY_STRICTENC) {
	    if (!common.isKeyEncoding(key))
	      throw new ScriptError('PUBKEYTYPE');
	  }

	  if ((flags & Script.flags.VERIFY_COMPRESSED_PUBKEYTYPE)
	    && !common.isCompressedEncoding(key)) {
	    throw new ScriptError('NONCOMPRESSED_PUBKEY');
	  }
	  return true;
	}

	/**
	 * Test whether the raw element is a valid signature based
	 * on the encoding, S value, and sighash type.
	 * In an ECDSA-only context, 64-byte signatures are bannned
	 * when Schnorr Flag is set.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateECDSASignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  if (common.isSchnorr(sig))
	    throw new ScriptError('SIG_BADLENGTH');

	  if ((flags & Script.flags.VERIFY_DERSIG)
	      || (flags & Script.flags.VERIFY_LOW_S)
	      || (flags & Script.flags.VERIFY_STRICTENC)) {
	    if (!common.isDERSignatureEncoding(sig))
	      throw new ScriptError('SIG_DER');
	  }

	  if (flags & Script.flags.VERIFY_LOW_S) {
	    if (!common.isLowDER(sig))
	      throw new ScriptError('SIG_HIGH_S');
	  }

	  return true;
	}

	/**
	 * Test whether the tx element is a valid signature based
	 * on the encoding, S value, and sighash type. Requires
	 * VERIFY_STRICTENC, VERIFY_SIGHASH_FORKID to be enabled respectively.
	 * Note that this will allow zero-length signatures.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkSighashEncoding(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  if (flags & Script.flags.VERIFY_STRICTENC) {
	    if (!common.isHashType(sig))
	      throw new ScriptError('SIG_HASHTYPE');

	    const usesFork = sig[sig.length - 1] & Script.hashType.SIGHASH_FORKID;
	    const forkEnabled = flags & Script.flags.VERIFY_SIGHASH_FORKID;

	    if (!forkEnabled && usesFork)
	      throw new ScriptError('ILLEGAL_FORKID');

	    if (forkEnabled && !usesFork)
	      throw new ScriptError('MUST_USE_FORKID');
	  }

	  return true;
	}

	/**
	 * Test whether the transaction tested against
	 * the Sighash Encoding is a valid Schnorr Signature.
	 * Requires Sighash
	 * @param {Buffer} sig
	 * @param {VeirfyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkTransactionSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // allow empty sigs
	  if (sig.length === 0)
	    return true;

	  validateSchnorrSignature(sig.slice(0, -1), flags);

	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the transaction is tested
	 * against the sighash encoding w schnorr / ecdsa
	 * for multisig opcodes.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 */

	function checkTransactionSchnorrSig(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs.
	  if (sig.length === 0)
	    return true;

	  if (!isSchnorrEncoded(sig.slice(0, -1), flags))
	    return validateECDSASignature(sig.slice(0, -1), flags);

	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the transaction tested against
	 * the Sighash Encoding is a valid ECDSA Signature.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function checkTransactionECDSASignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs
	  if (sig.length === 0)
	    return true;

	  validateECDSASignature(sig.slice(0, -1), flags);

	  return checkSighashEncoding(sig, flags);
	}

	/**
	 * Test whether the data element is a valid signature based
	 * on the encoding, S value, and sighash type. Requires
	 * VERIFY_DERSIG|VERIFY_LOW_S|VERIFY_STRICTENC, and VERIFY_LOW_S
	 * to be enabled respectively. Note that this will allow zero-length
	 * signatures.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function validateDataSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  // Allow empty sigs
	  if (sig.length === 0)
	    return true;

	  return validateSchnorrSignature(sig.slice(0, sig.length), flags);
	}

	/**
	 * Test whether the Signature is valid in context
	 * 64-byte signatures are interpreted as schnorr signatures.
	 * Always correctly encoded when Verify_SCHNORR flag is set.
	 * @param {Buffer} sig
	 * @param {Buffer} msg - Signature hash.
	 * @param {VerifyFlags?} flags
	 * @returns {Promise}
	 * @throws {ScriptError}
	 */

	function validateSchnorrSignature(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  if (common.isSchnorr(sig))
	    return true;

	  return validateECDSASignature(sig, flags);
	}

	/**
	 * Test whether the current signature is schnorr encoded.
	 * @param {Buffer} sig
	 * @param {VerifyFlags?} flags
	 * @returns {Boolean}
	 * @throws {ScriptError}
	 */

	function isSchnorrEncoded(sig, flags) {
	  assert(Buffer.isBuffer(sig));
	  assert(typeof flags === 'number');

	  if (common.isSchnorr(sig))
	    return true;

	  throw new ScriptError('SIG_NONSCHNORR');
	}

	/**
	 * Test whether the signature from the stack
	 * is valid in either Schnorr or DER Format.
	 * Always encoded correctly when Schnorr flag is set.
	 * @param {Buffer} hash
	 * @param {Buffer} sig
	 * @param {Buffer} key
	 * @param {Number} flags
	 */

	function verifySignature(hash, sig, key, flags) {
	  assert(Buffer.isBuffer(hash));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));
	  assert(typeof flags === 'number');

	  let res = false;

	  if (sig.length === 64) {
	    res = secp256k1.schnorrVerify(hash, sig, key, flags);
	  } else {
	    res = secp256k1.verifyDER(hash, sig, key, flags);
	  }

	  return res;
	}

	/**
	 * Verify a signature, taking into account sighash type.
	 * @param {Buffer} msg - Signature hash.
	 * @param {Buffer} sig
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function checksig(msg, sig, key) {
	  return secp256k1.verifyDER(msg, sig.slice(0, -1), key);
	}

	/*
	 * Expose
	 */

	script$1 = Script;
	return script$1;
}

/*!
 * slp.js - simple ledger protocol script for bcash
 * Copyright (c) 2021, Vin Armani (MIT License).
 * https://github.com/badger-cash/bcash
 */

var slp;
var hasRequiredSlp;

function requireSlp () {
	if (hasRequiredSlp) return slp;
	hasRequiredSlp = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {U64} = require$$1$1;
	requireConsensus();
	const Script = requireScript$1();
	requireScriptnum();

	/**
	 * SLP Coin Record
	 */

	 const SLP_TYPES = {
	  GENESIS: 0x00,
	  MINT: 0x01,
	  SEND: 0x02,
	  BATON: 0x03,
	  BURN: 0x04
	};

	class SlpCoinRecord {
	  /**
	   * Create a record of SLP data for a given coin.
	   * @param {Buffer?} hash the output hash of the coin
	   * @param {Number?} vout the output index of the coin
	   * @param {Buffer?} tokenId 32 byte txid
	   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
	   * @param {Buffer} value big endian value of token base units
	   * @param {String} type GENESIS | MINT | SEND | BURN | BATON
	   * @param {Number?} version token type
	   * @constructor
	   */

	  constructor(options = {}) {
	    this.hash = options.hash;
	    this.vout = options.vout;
	    this.tokenId = options.tokenId;
	    this.tokenIndex = options.tokenIndex;
	    this.value = options.value;
	    this.type = options.type;
	    this.version = options.version;
	    
	  }

	  /**
	   * Get the value as 64 bit big-endian buffer
	   * @private
	   * @returns {Buffer}
	   */
	  getValueUInt64BE() {
	    assert(this.value.length <= 8, 'value buffer must be 8 bytes or less');
	    const padding = Buffer.alloc(8 - this.value.length);
	    return Buffer.concat([padding, this.value]);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromDbData(data) {
	    const br = bio.read(data);

	    this.tokenIndex = br.readBytes(4);
	    const valueBytes = br.readVarBytes();
	    const padding = Buffer.alloc(8 - valueBytes.length);
	    this.value = Buffer.concat([padding, valueBytes]);
	    this.type = Object.keys(SLP_TYPES)[br.readU8()];
	    // Get version and handle if out of bounds
	    try {
	      this.version = br.readU8();
	    } catch (err) {
	      if (err.code === 'ERR_ENCODING')
	        this.version = 1;
	      else throw(err)
	    }

	    assert(this.version >= 1 && this.version <= 2);
	    assert(Object.keys(SLP_TYPES).includes(this.type));

	    return this;
	  }

	  /**
	   * Instantiate SLP record from serialized data.
	   * @param {Buffer} data
	   * @returns {SlpCoinRecord}
	   */

	  static fromDbData(data) {
	    return new this().fromDbData(data);
	  }

	  /**
	   * Serialize the SLP record.
	   * @returns {Buffer}
	   */

	  toDbData() {
	    assert(this.tokenIndex, 'Missing tokenIndex');
	    assert(this.tokenIndex.length == 4, 'tokenId must be a sha256 hash');
	    // assert(this.value, 'Missing token amount (in base units)')
	    assert(this.value.byteLength, 'Token amount must be a buffer');
	    assert(Object.keys(SLP_TYPES).includes(this.type), 'Type must be GENESIS | MINT | SEND | BATON | BURN');
	    // Remove padding (minimal)
	    for (let i = 0; i < this.value.length; i++) {
	      if (this.value[i] != 0) {
	        this.value = this.value.slice(i);
	        break;
	      }
	    }
	    const bw = bio.write();

	    bw.writeBytes(this.tokenIndex);
	    bw.writeVarBytes(this.value);
	    bw.writeU8(SLP_TYPES[this.type]);
	    bw.writeU8(this.version || 1);

	    return bw.render();
	  }

	  /**
	   * Convert object to JSON.
	   * @returns {Object}
	   */

	  getJSON() {
	    assert(this.tokenId, 'tokenId must be defined');

	    const json = {
	      hash: this.hash ? Buffer.from(this.hash).reverse().toString('hex') : undefined,
	      vout: this.vout,
	      tokenId: this.tokenId.toString('hex'),
	      value: U64.fromBE(this.value).toString(10),
	      type: this.type,
	      version: this.version || 1

	    };
	    return json;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {SlpCoinRecord}
	   */

	   fromJSON(json) {

	    this.hash = Buffer.from(json.hash, 'hex').reverse();
	    this.vout = json.vout;
	    this.tokenId = Buffer.from(json.tokenId, 'hex');
	    this.value = U64.fromString(json.value).toBE(Buffer);
	    this.type = json.type;
	    this.version = json.version || 1;

	    return this
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {TokenRecord}
	   */

	   static fromJSON(json) {
	    return new this().fromJSON(json);
	  }
	}

	/**
	 * Token Record
	 */

	 class TokenRecord {
	  /**
	   * Create a token record.
	   * @constructor
	   * @param {Buffer?} tokenId
	   * @param {Buffer?} tokenIndex
	   * @param {String?} ticker
	   * @param {String?} name
	   * @param {String?} uri
	   * @param {String?} hash
	   * @param {Number} decimals
	   * @param {Number?} version
	   * @param {Buffer?} vaultScriptHash
	   */

	  constructor(options = {}) {
	    this.tokenId = options.tokenId;
	    this.tokenIndex = options.tokenIndex;
	    this.ticker = options.ticker || '';
	    this.name = options.name || '';
	    this.uri = options.uri || '';
	    this.hash = options.hash || '';
	    this.decimals = options.decimals;
	    this.version = options.version;
	    if (this.version === 2 )
	      this.vaultScriptHash = options.vaultScriptHash;

	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromDbData(data) {
	    const br = bio.read(data);

	    this.tokenId = br.readHash();
	    this.ticker = br.readVarString('utf8');
	    // assert(this.ticker.length > 0);

	    this.name = br.readVarString('utf8');
	    // assert(this.name.length > 0);

	    this.uri = br.readVarString('utf8');
	    this.hash = br.readVarString('hex');
	    this.decimals = br.readU8();
	    // Get version and handle if out of bounds
	    try {
	      this.version = br.readU8();
	    } catch(err) {
	      if (err.code === 'ERR_ENCODING') {
	        this.version = 1;
	      } else throw(err)
	    }

	    // Read MINT vault ScriptHash
	    if (this.version ===2)
	      this.vaultScriptHash = br.readBytes(20);

	    assert(this.version >= 1 && this.version <= 2);
	    // assert(this.decimals >= 0 && this.decimals < 9);

	    return this;
	  }

	  /**
	   * Instantiate token record from serialized data.
	   * @param {Buffer} data
	   * @returns {TokenRecord}
	   */

	  static fromDbData(data) {
	    return new this().fromDbData(data);
	  }

	  /**
	   * Serialize the token record.
	   * @returns {Buffer}
	   */

	  toDbData() {
	    const bw = bio.write();
	    const encoding = bio.encoding;

	    bw.writeHash(this.tokenId);
	    bw.writeVarString(this.ticker, 'utf8');
	    if (this.ticker.length === 0)
	      bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.name, 'utf8');
	    if (this.name.length === 0)
	      bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.uri, 'utf8');
	    if (this.uri.length === 0)
	      bw.offset += encoding.sizeVarint(0);
	    bw.writeVarString(this.hash, 'hex');
	    if (this.hash.length === 0)
	      bw.offset += encoding.sizeVarint(0);
	    bw.writeU8(this.decimals);
	    bw.writeU8(this.version || 1);

	    if (this.version === 2)
	      bw.writeBytes(this.vaultScriptHash);

	    return bw.render();
	  }

	  /**
	   * Convert object to JSON.
	   * @returns {Object}
	   */

	  getJSON() {
	    assert(this.tokenId, 'tokenId must be defined');

	    const json = {
	      tokenId: this.tokenId.toString('hex'),
	      ticker: this.ticker,
	      name: this.name,
	      uri: this.uri,
	      hash: this.hash,
	      decimals: this.decimals,
	      version: this.version || 1
	    };

	    if (json.version === 2 && this.vaultScriptHash)
	      json.vaultScriptHash = this.vaultScriptHash.toString('hex');
	    
	    return json;
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {SlpCoinRecord}
	   */

	   fromJSON(json) {

	    this.tokenId = Buffer.from(json.tokenId, 'hex');
	    this.ticker = json.ticker;
	    this.name = json.name;
	    this.uri = json.uri;
	    this.hash = json.hash;
	    this.decimals = json.decimals;
	    this.version = json.version;

	    if (json.version === 2 && json.vaultScriptHash)
	      this.vaultScriptHash = Buffer.from(json.vaultScriptHash, 'hex');

	    return this
	  }

	  /**
	   * Convert from JSON to Object.
	   * @param {Object} json
	   * @returns {TokenRecord}
	   */

	   static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	}


	/**
	 * SLP
	 * @alias module:script.SLP
	 * @extends Script
	 */

	class SLP extends Script {
	  /**
	   * Create an SLP script.
	   * @constructor
	   * @param {Buffer|Array|Object} code
	   */

	  constructor(options) {
	    super(options);

	    this.valid = null;
	  }

	  /**
	   * Is SLP script is of valid construction?
	   * Use this as opposed to calling property this.isValid
	   * @private
	   * @returns {Boolean}
	   */
	  isValidSlp() {
	    if (this.valid === null) {
	      this.valid = this.verifySlp();
	    }
	    return this.valid;
	  }

	  /**
	   * Test whether SLP script is of valid construction
	   * (Does not test if transaction is valid SLP transaction)
	   * @private
	   * @param {Script?} script
	   * @returns {Boolean}
	   */

	  verifySlp(script) {
	    if (script == undefined)
	      script = this;

	    if (script.getSym(0) != 'OP_RETURN')
	      return false;

	    // LOKAD_ID
	    if (script.getString(1, 'hex') != '534c5000')
	      return false;

	    // Check version
	    const versionHex = script.getString(2, 'hex');
	    if (versionHex != '01' && versionHex != '02') 
	      return false;

	    // Type
	    const type = script.getType();

	    switch (type) {
	      case 'GENESIS': {
	        if (script.code.length != 11)
	          return false;
	        // Hash
	        if (!script.getData(7))
	          return false;
	        if (script.getData(7).length != 0 && script.getData(7).length != 32)
	          return false;
	        // Decimals
	        if (!script.getData(8))
	          return false;
	        if (script.getData(8).length != 1 || script.getInt(8) > 9)
	          return false;
	        if (versionHex == '01') {
	          // Mint Baton
	          if (!script.getData(9))
	            return false;
	          if (script.getData(9).length > 1)
	            return false;
	          if (script.getData(9).length == 1 && script.getInt(9) < 2)
	            return false;
	        } else if (versionHex == '02') {
	          // Mint Vault ScriptHash
	          if (!script.getData(9))
	            return false;
	          if (script.getData(9).length != 20)
	            return false;
	        }
	        // Minted Tokens
	        if (script.getData(10).length != 8)
	          return false
	        break;
	      }
	      case 'MINT': {
	        if (versionHex == '01') {
	          if (script.code.length != 7)
	            return false;
	        }
	        if (versionHex == '02') {
	          if (script.code.length < 6)
	            return false;
	        }
	        // Token ID
	        if (script.getData(4).length != 32)
	          return false;
	        if (versionHex == '01') {
	          // Mint Baton
	          if (!script.getData(5))
	            return false;
	          if (script.getData(5).length > 1)
	            return false;
	          if (script.getData(5).length == 1 && script.getInt(5) < 2)
	            return false;
	          // Minted Tokens
	          if (script.getData(6).length != 8)
	            return false
	        } else if (versionHex == '02') {
	          const outputs = script.code.slice(5);
	          for (let i = 0; i < outputs.length; i++) {
	            const op = outputs[i];
	            // Sent Tokens
	            if (op.data.length != 8)
	              return false
	          }
	        }
	        break;
	      }
	      case 'SEND': {
	        if (script.code.length < 6)
	          return false;
	        // Token ID
	        if (script.getData(4).length != 32)
	          return false;
	        const outputs = script.code.slice(5);
	        for (let i = 0; i < outputs.length; i++) {
	          const op = outputs[i];
	          // Sent Tokens
	          if (op.data.length != 8)
	            return false
	        }
	        break;
	      }
	      case 'BURN': {
	        if (script.code.length != 6)
	          return false;
	        // Token ID
	        if (script.getData(4).length != 32)
	          return false;
	        // Sent Tokens
	        if (script.getData(5).length != 8)
	          return false
	        break;
	      }
	      default: {
	        return false;
	      }
	    }

	    return true;
	  }

	  /**
	   * Test whether script is of valid construction
	   * (Does not test if transaction is valid SLP transaction)
	   * @param {Script?} script
	   * @returns {Boolean}
	   */

	  static verifySlp(script) {
	    return new this().verifySlp(script);
	  }

	  /**
	   * Inject properties from a script
	   * @private
	   * @param {Script} code
	   * @returns {SLP}
	   */

	  fromScript(script) {
	    this.inject(script);
	    return this;
	  }

	  /**
	   * Inject properties from a script
	   * @param {Script} code
	   * @returns {SLP}
	   */

	   static fromScript(script) {
	    return new this().fromScript(script);
	  }

	  /**
	   * Get token ID for this script
	   * @private
	   * @returns {Hash}
	   */

	    getTokenId() {
	      assert(this.verifySlp(), 'This is not a valid SLP script');
	    
	      // Type
	      const type = this.getType();
	      assert(type != 'GENESIS', 'Cannot derive the tokenID from GENESIS script');
	      
	      // Return tokenId as buffer
	      return this.getData(4);
	    }

	  /**
	   * Get records for a this script
	   * @private
	   * @param {Buffer?} txId The txid of the transaction containing this script
	   * @returns {(SlpCoinRecord | TokenRecord)[]}
	   */

	  getRecords(txId) {
	    assert(this.isValidSlp(), 'Must be a valid SLP Script' );

	    const type = this.getType();
	    assert(Object.keys(SLP_TYPES).includes(type) && type != 'BATON', 'Type must be GENESIS | MINT | SEND | BURN');
	    assert(txId.byteLength, 'tokenId must be a buffer');
	    assert(txId.length == 32, 'tokenId must be a sha256 hash');

	    switch (type) {
	      case 'GENESIS': {
	        return this.getGenesisRecords(txId);
	      }
	      case 'MINT': {
	        return this.getMintRecords(txId);
	      }
	      case 'SEND': {
	        return this.getSendRecords(txId);
	      }
	      case 'BURN': {
	        return this.getBurnRecords(txId);
	      }
	      default: {
	        return null;
	      }
	    }
	  }

	  /**
	   * Get records for a GENESIS script
	   * @private
	   * @param {Buffer} tokenId The tokenId of the transaction containing this script
	   * @returns {(SlpCoinRecord | TokenRecord)[]}
	   */

	  getGenesisRecords(tokenId) {
	    assert(tokenId.byteLength, 'tokenId must be a buffer');
	    assert(tokenId.byteLength == 32, 'tokenId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'GENESIS', 'This is not a GENESIS transaction');

	    const versionInt = this.getInt(2);
	    const records = [];
	    // Create TokenRecord
	    records.push(this.constructor.TokenRecord({      
	      tokenId,      
	      version: versionInt,
	      ticker: this.getString(4, 'utf-8'),
	      name: this.getString(5, 'utf-8'),
	      uri: this.getString(6, 'utf-8'),
	      hash: this.getString(7, 'hex'),
	      decimals: this.getInt(8),
	      vaultScriptHash: versionInt === 2 ? this.getData(9) : undefined
	    }));
	    // Create Minted Tokens SLPCoinRecord
	    records.push(this.constructor.SlpCoinRecord({
	      hash: Buffer.from(tokenId).reverse(),
	      vout: 1,
	      tokenId,
	      value: this.getData(10),
	      type,
	      version: this.getInt(2)
	    }));
	    // Create Mint Baton SLPCoinRecord
	    if (versionInt === 1 && this.getInt(9) >= 2) {
	      const valBuf = Buffer.alloc(1);
	      valBuf.writeInt8(1);
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(tokenId).reverse(),
	        vout: this.getInt(9),
	        tokenId,
	        value: valBuf,
	        type: 'BATON',
	        version: this.getInt(2)
	      }));
	    }
	    return records;
	  }

	  /**
	   * Get records for a MINT script
	   * @private
	   * @param {Buffer} txId The txHash of the transaction containing this script
	   * @returns {SlpCoinRecord[]}
	   */

	  getMintRecords(txId) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'MINT', 'This is not a MINT transaction');

	    const versionInt = this.getInt(2);
	    const records = [];
	    // Create Minted Tokens SLPCoinRecord
	    if (versionInt === 1) {
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(txId).reverse(),
	        vout: 1,
	        tokenId: this.getData(4),
	        value: this.getData(6),
	        type,
	        version: versionInt
	      }));
	      // Create Mint Baton SLPCoinRecord
	      if (this.getInt(5) >= 2) {
	        const valBuf = U64.fromInt(1).toBE(Buffer);
	        records.push(this.constructor.SlpCoinRecord({
	          hash: Buffer.from(txId).reverse(),
	          vout: this.getInt(5),
	          tokenId: this.getData(4),
	          value: valBuf,
	          type: 'BATON',
	          version: versionInt
	        }));
	      }
	    } else if (versionInt === 2) {
	      // Mimic Token Type 1 SEND
	      const outputs = this.code.slice(5);
	      for (let i = 0; i < outputs.length; i++) {
	        const valueBuf = outputs[i].toData();
	        const vout = i + 1;
	      
	        // Create Token Type 2 Mint Tokens SLPCoinRecord
	        records.push(this.constructor.SlpCoinRecord({
	          hash: Buffer.from(txId).reverse(),
	          vout,
	          tokenId: this.getData(4),
	          value: valueBuf,
	          type,
	          version: this.getInt(2)
	        }));
	      }
	    }
	    return records;
	  }

	  /**
	   * Get records for a SEND script
	   * @private
	   * @param {Buffer} txId The txHash of the transaction containing this script
	   * @param {Boolean} nonStandardOuts OP_RETURN is located at an index other than 0
	   * @returns {SlpCoinRecord[]}
	   */

	  getSendRecords(txId, nonStandardOuts = false) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'SEND', 'This is not a SEND transaction');

	    const records = [];
	    const outputs = this.code.slice(5);
	    for (let i = 0; i < outputs.length; i++) {
	      const valueBuf = outputs[i].toData();
	      const vout = nonStandardOuts ? i : i + 1;
	    
	      // Create Send Tokens SLPCoinRecord
	      records.push(this.constructor.SlpCoinRecord({
	        hash: Buffer.from(txId).reverse(),
	        vout,
	        tokenId: this.getData(4),
	        value: valueBuf,
	        type,
	        version: this.getInt(2)
	      }));
	    }
	    return records;
	  }

	  getBurnRecords(txId, nonStandardOuts = false) {
	    assert(txId.byteLength, 'txId must be a buffer');
	    assert(txId.byteLength == 32, 'txId must be a sha256 hash');
	    const type = this.getType();
	    assert(type == 'BURN', 'This is not a BURN transaction');

	    const records = [];
	    const valueBuf = this.code[5].toData();
	  
	    // Create Send Tokens SLPCoinRecord
	    records.push(this.constructor.SlpCoinRecord({
	      hash: Buffer.from(txId).reverse(),
	      vout: 0,
	      tokenId: this.getData(4),
	      value: valueBuf,
	      type,
	      version: this.getInt(2)
	    }));

	    return records;
	  }
	  
	  /**
	   * Re-encode the script internally. Useful if you
	   * changed something manually in the `code` array.
	   * @returns {Script}
	   */

	  compile() {
	    super.compile();

	    this.valid = null;
	    this.isValidSlp();
	  }

	  /**
	   * Inspect the script.
	   * @returns {String} Human-readable script code.
	   */

	  inspect() {
	    return `<SLP: ${this.toString()}>`;
	  }

	  getType() {
	    return this.getString(3);
	  }

	  /**
	   * Create a new TokenRecord
	   * @param {Buffer?} tokenId
	   * @param {Buffer?} tokenIndex
	   * @param {String?} ticker
	   * @param {String?} name
	   * @param {String?} uri
	   * @param {String?} hash
	   * @param {Number} decimals
	   * @param {Number?} version
	   * @returns {TokenRecord}
	   */

	  static TokenRecord(options = {}) {
	    return new TokenRecord(options);
	  }

	  /**
	   * Create a new SlpCoinRecord
	   * @param {Buffer?} hash the output hash of the coin
	   * @param {Number?} vout the output index of the coin
	   * @param {Buffer?} tokenId 32 byte txid
	   * @param {Buffer?} tokenIndex 4 byte unsigned integer (index of tx hash in db)
	   * @param {Number} value
	   * @param {String} type GENESIS | MINT | SEND | BATON
	   * @param {Number?} version
	   * @returns {SlpCoinRecord}
	   */

	  static SlpCoinRecord(options = {}) {
	    return new SlpCoinRecord(options);
	  }

	}

	slp = SLP;
	return slp;
}

/*!
 * output.js - output object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var output;
var hasRequiredOutput;

function requireOutput () {
	if (hasRequiredOutput) return output;
	hasRequiredOutput = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const Amount = requireAmount();
	const Network = requireNetwork();
	const Address = requireAddress();
	const Script = requireScript$1();
	const SLP = requireSlp();
	const policy = requirePolicy();
	const {inspectSymbol} = requireUtils();

	/**
	 * Represents a transaction output.
	 * @alias module:primitives.Output
	 * @property {Amount} value
	 * @property {Script} script
	 * @property {SlpCoinRecord?} slp
	 */

	class Output {
	  /**
	   * Create an output.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.value = 0;
	    this.script = new Script();

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Output data is required.');

	    if (options.value) {
	      assert(Number.isSafeInteger(options.value) && options.value >= 0,
	        'Value must be a uint64.');
	      this.value = options.value;
	    }

	    if (options.script)
	      this.script.fromOptions(options.script);

	    if (options.address)
	      this.script.fromAddress(options.address);

	    if (options.slp) {
	      if (options.slp.constructor === SLP.SlpCoinRecord().constructor)
	        this.slp = options.slp;
	    }

	    return this;
	  }

	  /**
	   * Instantiate output from options object.
	   * @param {Object} options
	   * @returns {Output}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Inject properties from script/value pair.
	   * @private
	   * @param {Script|Address} script
	   * @param {Amount} value
	   * @returns {Output}
	   */

	  fromScript(script, value) {
	    if (typeof script === 'string')
	      script = Address.fromString(script);

	    if (script instanceof Address)
	      script = Script.fromAddress(script);

	    assert(script instanceof Script, 'Script must be a Script.');
	    assert(Number.isSafeInteger(value) && value >= 0,
	      'Value must be a uint64.');

	    this.script = script;
	    this.value = value;

	    return this;
	  }

	  /**
	   * Instantiate output from script/value pair.
	   * @param {Script|Address} script
	   * @param {Amount} value
	   * @returns {Output}
	   */

	  static fromScript(script, value) {
	    return new this().fromScript(script, value);
	  }

	  /**
	   * Clone the output.
	   * @returns {Output}
	   */

	  clone() {
	    const output = new this.constructor();
	    output.value = this.value;
	    output.script.inject(this.script);
	    return output;
	  }

	  /**
	   * Test equality against another output.
	   * @param {Output} output
	   * @returns {Boolean}
	   */

	  equals(output) {
	    assert(Output.isOutput(output));
	    return this.value === output.value
	      && this.script.equals(output.script);
	  }

	  /**
	   * Compare against another output (BIP69).
	   * @param {Output} output
	   * @returns {Number}
	   */

	  compare(output) {
	    assert(Output.isOutput(output));

	    const cmp = this.value - output.value;

	    if (cmp !== 0)
	      return cmp;

	    return this.script.compare(output.script);
	  }

	  /**
	   * Get the script type as a string.
	   * @returns {ScriptType} type
	   */

	  getType() {
	    return Script.typesByVal[this.script.getType()].toLowerCase();
	  }

	  /**
	   * Get the address.
	   * @returns {Address} address
	   */

	  getAddress() {
	    return this.script.getAddress();
	  }

	  /**
	   * Get the address hash.
	   * @param {String?} enc
	   * @returns {Hash} hash
	   */

	  getHash(enc) {
	    const addr = this.getAddress();

	    if (!addr)
	      return null;

	    return addr.getHash(enc);
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    const hr = {
	      type: this.getType(),
	      value: Amount.btc(this.value),
	      script: this.script,
	      address: this.getAddress()
	    };
	    if (this.slp) {
	      return {
	        ...hr,
	        slp: this.slp
	      }
	    }
	    return hr;
	  }

	  /**
	   * Convert the output to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the output to an object suitable
	   * for JSON serialization.
	   * @param {Network} network
	   * @returns {Object}
	   */

	  getJSON(network) {
	    let addr = this.getAddress();

	    network = Network.get(network);

	    if (addr)
	      addr = addr.toString(network);

	    const json = {
	      value: this.value,
	      script: this.script.toJSON(),
	      address: addr
	    };

	    if (this.slp) {
	      return {
	        ...json,
	        slp: this.slp.getJSON()
	      }
	    }
	    return json;
	  }

	  /**
	   * Calculate the dust threshold for this
	   * output, based on serialize size and rate.
	   * @param {Rate?} rate
	   * @returns {Amount}
	   */

	  getDustThreshold(rate) {
	    if (this.script.isUnspendable())
	      return 0;

	    let size = this.getSize();

	    size += 32 + 4 + 1 + 107 + 4;

	    return 3 * policy.getMinFee(size, rate);
	  }

	  /**
	   * Calculate size of serialized output.
	   * @returns {Number}
	   */

	  getSize() {
	    return 8 + this.script.getVarSize();
	  }

	  /**
	   * Test whether the output should be considered dust.
	   * @param {Rate?} rate
	   * @returns {Boolean}
	   */

	  isDust(rate) {
	    return this.value < this.getDustThreshold(rate);
	  }

	  /**
	   * Inject properties from a JSON object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Output data is required.');
	    assert(Number.isSafeInteger(json.value) && json.value >= 0,
	      'Value must be a uint64.');
	    this.value = json.value;
	    this.script.fromJSON(json.script);
	    if (json.slp) {
	      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);
	    }
	    return this;
	  }

	  /**
	   * Instantiate an Output from a jsonified output object.
	   * @param {Object} json - The jsonified output object.
	   * @returns {Output}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Write the output to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeI64(this.value);
	    bw.writeVarBytes(this.script.toRaw());
	    return bw;
	  }

	  /**
	   * Serialize the output.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.value = br.readI64();
	    this.script.fromRaw(br.readVarBytes());
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate an output from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Output}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate an output from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Output}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test an object to see if it is an Output.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOutput(obj) {
	    return obj instanceof Output;
	  }
	}

	/*
	 * Expose
	 */

	output = Output;
	return output;
}

/*!
 * outpoint.js - outpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var outpoint;
var hasRequiredOutpoint;

function requireOutpoint () {
	if (hasRequiredOutpoint) return outpoint;
	hasRequiredOutpoint = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const util = requireUtil();
	const consensus = requireConsensus();
	const {inspectSymbol} = requireUtils();

	/**
	 * Outpoint
	 * Represents a COutPoint.
	 * @alias module:primitives.Outpoint
	 * @property {Hash} hash
	 * @property {Number} index
	 */

	class Outpoint {
	  /**
	   * Create an outpoint.
	   * @constructor
	   * @param {Hash?} hash
	   * @param {Number?} index
	   */

	  constructor(hash, index) {
	    this.hash = consensus.ZERO_HASH;
	    this.index = 0xffffffff;

	    if (hash != null) {
	      assert(Buffer.isBuffer(hash));
	      assert((index >>> 0) === index, 'Index must be a uint32.');
	      this.hash = hash;
	      this.index = index;
	    }
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Outpoint data is required.');
	    assert(Buffer.isBuffer(options.hash));
	    assert((options.index >>> 0) === options.index, 'Index must be a uint32.');
	    this.hash = options.hash;
	    this.index = options.index;
	    return this;
	  }

	  /**
	   * Instantate outpoint from options object.
	   * @param {Object} options
	   * @returns {Outpoint}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the outpoint.
	   * @returns {Outpoint}
	   */

	  clone() {
	    const outpoint = new this.constructor();
	    outpoint.hash = this.hash;
	    outpoint.index = this.index;
	    return outpoint;
	  }

	  /**
	   * Test equality against another outpoint.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  equals(prevout) {
	    assert(Outpoint.isOutpoint(prevout));
	    return this.hash.equals(prevout.hash)
	      && this.index === prevout.index;
	  }

	  /**
	   * Compare against another outpoint (BIP69).
	   * @param {Outpoint} prevout
	   * @returns {Number}
	   */

	  compare(prevout) {
	    assert(Outpoint.isOutpoint(prevout));

	    const cmp = strcmp(this.txid(), prevout.txid());

	    if (cmp !== 0)
	      return cmp;

	    return this.index - prevout.index;
	  }

	  /**
	   * Test whether the outpoint is null (hash of zeroes
	   * with max-u32 index). Used to detect coinbases.
	   * @returns {Boolean}
	   */

	  isNull() {
	    return this.index === 0xffffffff && this.hash.equals(consensus.ZERO_HASH);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Serialize outpoint to a key
	   * suitable for a hash table.
	   * @returns {String}
	   */

	  toKey() {
	    return this.toRaw();
	  }

	  /**
	   * Inject properties from hash table key.
	   * @private
	   * @param {String} key
	   * @returns {Outpoint}
	   */

	  fromKey(key) {
	    this.hash = key.slice(0, 32);
	    this.index = bio.readU32(key, 32);
	    return this;
	  }

	  /**
	   * Instantiate outpoint from hash table key.
	   * @param {String} key
	   * @returns {Outpoint}
	   */

	  static fromKey(key) {
	    return new this().fromKey(key);
	  }

	  /**
	   * Write outpoint to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeHash(this.hash);
	    bw.writeU32(this.index);
	    return bw;
	  }

	  /**
	   * Calculate size of outpoint.
	   * @returns {Number}
	   */

	  getSize() {
	    return 36;
	  }

	  /**
	   * Serialize outpoint.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.toWriter(bio.write(36)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.hash = br.readHash();
	    this.index = br.readU32();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate outpoint from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Outpoint}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate outpoint from serialized data.
	   * @param {Buffer} data
	   * @returns {Outpoint}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @params {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Outpoint data is required.');
	    assert(typeof json.hash === 'string', 'Hash must be a string.');
	    assert((json.index >>> 0) === json.index, 'Index must be a uint32.');
	    this.hash = util.fromRev(json.hash);
	    this.index = json.index;
	    return this;
	  }

	  /**
	   * Convert the outpoint to an object suitable
	   * for JSON serialization. Note that the hash
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @returns {Object}
	   */

	  toJSON() {
	    return {
	      hash: util.revHex(this.hash),
	      index: this.index
	    };
	  }

	  /**
	   * Instantiate outpoint from json object.
	   * @param {Object} json
	   * @returns {Outpoint}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inject properties from tx.
	   * @private
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index) {
	    assert(tx);
	    assert(typeof index === 'number');
	    assert(index >= 0);
	    this.hash = tx.hash();
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate outpoint from tx.
	   * @param {TX} tx
	   * @param {Number} index
	   * @returns {Outpoint}
	   */

	  static fromTX(tx, index) {
	    return new this().fromTX(tx, index);
	  }

	  /**
	   * Serialize outpoint to a key
	   * suitable for a hash table.
	   * @param {Hash} hash
	   * @param {Number} index
	   * @returns {String}
	   */

	  static toKey(hash, index) {
	    return new Outpoint(hash, index).toKey();
	  }

	  /**
	   * Convert the outpoint to a user-friendly string.
	   * @returns {String}
	   */

	  [inspectSymbol]() {
	    return `<Outpoint: ${this.rhash()}/${this.index}>`;
	  }

	  /**
	   * Test an object to see if it is an outpoint.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isOutpoint(obj) {
	    return obj instanceof Outpoint;
	  }
	}

	/*
	 * Helpers
	 */

	function strcmp(a, b) {
	  const len = Math.min(a.length, b.length);

	  for (let i = 0; i < len; i++) {
	    if (a[i] < b[i])
	      return -1;
	    if (a[i] > b[i])
	      return 1;
	  }

	  if (a.length < b.length)
	    return -1;

	  if (a.length > b.length)
	    return 1;

	  return 0;
	}

	/*
	 * Expose
	 */

	outpoint = Outpoint;
	return outpoint;
}

/*!
 * coin.js - coin object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coin;
var hasRequiredCoin;

function requireCoin () {
	if (hasRequiredCoin) return coin;
	hasRequiredCoin = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const util = requireUtil();
	const Amount = requireAmount();
	const Output = requireOutput();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const Outpoint = requireOutpoint();
	const SLP = requireSlp();
	const {inspectSymbol} = requireUtils();

	/**
	 * Coin
	 * Represents an unspent output.
	 * @alias module:primitives.Coin
	 * @extends Output
	 * @property {Number} version
	 * @property {Number} height
	 * @property {Amount} value
	 * @property {Script} script
	 * @property {Boolean} coinbase
	 * @property {Hash} hash
	 * @property {Number} index
	 */

	class Coin extends Output {
	  /**
	   * Create a coin.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();

	    this.version = 1;
	    this.height = -1;
	    this.coinbase = false;
	    this.hash = consensus.ZERO_HASH;
	    this.index = 0;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject options into coin.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Coin data is required.');

	    if (options.version != null) {
	      assert((options.version >>> 0) === options.version,
	        'Version must be a uint32.');
	      this.version = options.version;
	    }

	    if (options.height != null) {
	      if (options.height !== -1) {
	        assert((options.height >>> 0) === options.height,
	          'Height must be a uint32.');
	        this.height = options.height;
	      } else {
	        this.height = -1;
	      }
	    }

	    if (options.value != null) {
	      assert(Number.isSafeInteger(options.value) && options.value >= 0,
	        'Value must be a uint64.');
	      this.value = options.value;
	    }

	    if (options.script)
	      this.script.fromOptions(options.script);

	    if (options.coinbase != null) {
	      assert(typeof options.coinbase === 'boolean',
	        'Coinbase must be a boolean.');
	      this.coinbase = options.coinbase;
	    }

	    if (options.hash != null) {
	      assert(Buffer.isBuffer(options.hash));
	      this.hash = options.hash;
	    }

	    if (options.index != null) {
	      assert((options.index >>> 0) === options.index,
	        'Index must be a uint32.');
	      this.index = options.index;
	    }

	    return this;
	  }

	  /**
	   * Instantiate Coin from options object.
	   * @private
	   * @param {Object} options
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the coin.
	   * @private
	   * @returns {Coin}
	   */

	  clone() {
	    assert(false, 'Coins are not cloneable.');
	  }

	  /**
	   * Calculate number of confirmations since coin was created.
	   * @param {Number?} height - Current chain height. Network
	   * height is used if not passed in.
	   * @return {Number}
	   */

	  getDepth(height) {
	    assert(typeof height === 'number', 'Must pass a height.');

	    if (this.height === -1)
	      return 0;

	    if (height === -1)
	      return 0;

	    if (height < this.height)
	      return 0;

	    return height - this.height + 1;
	  }

	  /**
	   * Serialize coin to a key
	   * suitable for a hash table.
	   * @returns {String}
	   */

	  toKey() {
	    return Outpoint.toKey(this.hash, this.index);
	  }

	  /**
	   * Inject properties from hash table key.
	   * @private
	   * @param {String} key
	   * @returns {Coin}
	   */

	  fromKey(key) {
	    const {hash, index} = Outpoint.fromKey(key);
	    this.hash = hash;
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate coin from hash table key.
	   * @param {String} key
	   * @returns {Coin}
	   */

	  static fromKey(key) {
	    return new this().fromKey(key);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Convert the coin to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    const hr = {
	      type: this.getType(),
	      version: this.version,
	      height: this.height,
	      value: Amount.btc(this.value),
	      script: this.script,
	      coinbase: this.coinbase,
	      hash: this.hash ? util.revHex(this.hash) : null,
	      index: this.index,
	      address: this.getAddress()
	    };
	    if (this.slp) {
	      return {
	        ...hr,
	        slp: this.slp
	      }
	    }
	    return hr;
	  }

	  /**
	   * Convert the coin to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the coin to an object suitable
	   * for JSON serialization. Note that the hash
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {Boolean} minimal
	   * @returns {Object}
	   */

	  getJSON(network, minimal) {
	    let addr = this.getAddress();

	    network = Network.get(network);

	    if (addr)
	      addr = addr.toString(network);

	    const json = {
	      version: this.version,
	      height: this.height,
	      value: this.value,
	      script: this.script.toJSON(),
	      address: addr,
	      coinbase: this.coinbase,
	      hash: !minimal ? this.rhash() : undefined,
	      index: !minimal ? this.index : undefined
	    };

	    if (this.slp) {
	      return {
	        ...json,
	        slp: this.slp.getJSON()
	      }
	    }
	    return json;
	  }

	  /**
	   * Inject JSON properties into coin.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Coin data required.');
	    assert((json.version >>> 0) === json.version, 'Version must be a uint32.');
	    assert(json.height === -1 || (json.height >>> 0) === json.height,
	      'Height must be a uint32.');
	    assert(Number.isSafeInteger(json.value) && json.value >= 0,
	      'Value must be a uint64.');
	    assert(typeof json.coinbase === 'boolean', 'Coinbase must be a boolean.');

	    this.version = json.version;
	    this.height = json.height;
	    this.value = json.value;
	    this.script.fromJSON(json.script);
	    this.coinbase = json.coinbase;

	    if (json.hash != null) {
	      assert(typeof json.hash === 'string', 'Hash must be a string.');
	      assert(json.hash.length === 64, 'Hash must be a string.');
	      assert((json.index >>> 0) === json.index, 'Index must be a uint32.');
	      this.hash = util.fromRev(json.hash);
	      this.index = json.index;
	    }

	    if (json.slp) {
	      json.slp.hash = json.hash;
	      this.slp = SLP.SlpCoinRecord().fromJSON(json.slp);
	    }

	    return this;
	  }

	  /**
	   * Instantiate an Coin from a jsonified coin object.
	   * @param {Object} json - The jsonified coin object.
	   * @returns {Coin}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate size of coin.
	   * @returns {Number}
	   */

	  getSize() {
	    return 17 + this.script.getVarSize();
	  }

	  /**
	   * Write the coin to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    let height = this.height;

	    if (height === -1)
	      height = 0x7fffffff;

	    bw.writeU32(this.version);
	    bw.writeU32(height);
	    bw.writeI64(this.value);
	    bw.writeVarBytes(this.script.toRaw());
	    bw.writeU8(this.coinbase ? 1 : 0);

	    return bw;
	  }

	  /**
	   * Serialize the coin.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from serialized buffer writer.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.version = br.readU32();
	    this.height = br.readU32();
	    this.value = br.readI64();
	    this.script.fromRaw(br.readVarBytes());
	    this.coinbase = br.readU8() === 1;

	    if (this.height === 0x7fffffff)
	      this.height = -1;

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a coin from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Coin}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Coin}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index, height) {
	    assert(typeof index === 'number');
	    assert(typeof height === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.version = tx.version;
	    this.height = height;
	    this.value = tx.outputs[index].value;
	    this.script = tx.outputs[index].script;
	    this.coinbase = tx.isCoinbase();
	    this.hash = tx.hash();
	    this.index = index;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {Coin}
	   */

	  static fromTX(tx, index, height) {
	    return new this().fromTX(tx, index, height);
	  }

	  /**
	   * Test an object to see if it is a Coin.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isCoin(obj) {
	    return obj instanceof Coin;
	  }
	}

	/*
	 * Expose
	 */

	coin = Coin;
	return coin;
}

var compress = {};

/*!
 * compress.js - coin compressor for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCompress;

function requireCompress () {
	if (hasRequiredCompress) return compress;
	hasRequiredCompress = 1;

	/**
	 * @module coins/compress
	 * @ignore
	 */

	const assert = require$$0$3;
	const {encoding} = require$$1;
	const secp256k1 = requireSecp256k1();
	const consensus = requireConsensus();

	/*
	 * Constants
	 */

	const COMPRESS_TYPES = 6;
	const EMPTY_BUFFER = Buffer.alloc(0);

	/**
	 * Compress a script, write directly to the buffer.
	 * @param {Script} script
	 * @param {BufferWriter} bw
	 */

	function compressScript(script, bw) {
	  // Attempt to compress the output scripts.
	  // We can _only_ ever compress them if
	  // they are serialized as minimaldata, as
	  // we need to recreate them when we read
	  // them.

	  // P2PKH -> 0 | key-hash
	  // Saves 5 bytes.
	  const pkh = script.getPubkeyhash(true);
	  if (pkh) {
	    bw.writeU8(0);
	    bw.writeBytes(pkh);
	    return bw;
	  }

	  // P2SH -> 1 | script-hash
	  // Saves 3 bytes.
	  const sh = script.getScripthash();
	  if (sh) {
	    bw.writeU8(1);
	    bw.writeBytes(sh);
	    return bw;
	  }

	  // P2PK -> 2-5 | compressed-key
	  // Only works if the key is valid.
	  // Saves up to 35 bytes.
	  const pk = script.getPubkey(true);
	  if (pk) {
	    if (publicKeyVerify(pk)) {
	      const key = compressKey(pk);
	      bw.writeBytes(key);
	      return bw;
	    }
	  }

	  // Raw -> varlen + 10 | script
	  bw.writeVarint(script.raw.length + COMPRESS_TYPES);
	  bw.writeBytes(script.raw);

	  return bw;
	}

	/**
	 * Decompress a script from buffer reader.
	 * @param {Script} script
	 * @param {BufferReader} br
	 */

	function decompressScript(script, br) {
	  // Decompress the script.
	  switch (br.readU8()) {
	    case 0: {
	      const hash = br.readBytes(20, true);
	      script.fromPubkeyhash(hash);
	      break;
	    }
	    case 1: {
	      const hash = br.readBytes(20, true);
	      script.fromScripthash(hash);
	      break;
	    }
	    case 2:
	    case 3:
	    case 4:
	    case 5: {
	      br.offset -= 1;
	      const data = br.readBytes(33, true);
	      // Decompress the key. If this fails,
	      // we have database corruption!
	      const key = decompressKey(data);
	      script.fromPubkey(key);
	      break;
	    }
	    default: {
	      br.offset -= 1;
	      const size = br.readVarint() - COMPRESS_TYPES;
	      if (size > consensus.MAX_SCRIPT_SIZE) {
	        // This violates consensus rules.
	        // We don't need to read it.
	        script.fromNulldata(EMPTY_BUFFER);
	        br.seek(size);
	      } else {
	        const data = br.readBytes(size);
	        script.fromRaw(data);
	      }
	      break;
	    }
	  }

	  return script;
	}

	/**
	 * Calculate script size.
	 * @returns {Number}
	 */

	function sizeScript(script) {
	  if (script.isPubkeyhash(true))
	    return 21;

	  if (script.isScripthash())
	    return 21;

	  const pk = script.getPubkey(true);
	  if (pk) {
	    if (publicKeyVerify(pk))
	      return 33;
	  }

	  let size = 0;
	  size += encoding.sizeVarint(script.raw.length + COMPRESS_TYPES);
	  size += script.raw.length;

	  return size;
	}

	/**
	 * Compress an output.
	 * @param {Output} output
	 * @param {BufferWriter} bw
	 */

	function compressOutput(output, bw) {
	  bw.writeVarint(output.value);
	  compressScript(output.script, bw);
	  return bw;
	}

	/**
	 * Decompress a script from buffer reader.
	 * @param {Output} output
	 * @param {BufferReader} br
	 */

	function decompressOutput(output, br) {
	  output.value = br.readVarint();
	  decompressScript(output.script, br);
	  return output;
	}

	/**
	 * Calculate output size.
	 * @returns {Number}
	 */

	function sizeOutput(output) {
	  let size = 0;
	  size += encoding.sizeVarint(output.value);
	  size += sizeScript(output.script);
	  return size;
	}

	/**
	 * Verify a public key (no hybrid keys allowed).
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function publicKeyVerify(key) {
	  if (key.length === 0)
	    return false;

	  switch (key[0]) {
	    case 0x02:
	    case 0x03:
	      return key.length === 33;
	    case 0x04:
	      if (key.length !== 65)
	        return false;

	      return secp256k1.publicKeyVerify(key);
	    default:
	      return false;
	  }
	}

	/**
	 * Compress a public key to coins compression format.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function compressKey(key) {
	  let out;

	  switch (key[0]) {
	    case 0x02:
	    case 0x03:
	      // Key is already compressed.
	      out = key;
	      break;
	    case 0x04:
	      // Compress the key normally.
	      out = secp256k1.publicKeyConvert(key, true);
	      // Store the oddness.
	      // Pseudo-hybrid format.
	      out[0] = 0x04 | (key[64] & 0x01);
	      break;
	    default:
	      throw new Error('Bad point format.');
	  }

	  assert(out.length === 33);

	  return out;
	}

	/**
	 * Decompress a public key from the coins compression format.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function decompressKey(key) {
	  const format = key[0];

	  assert(key.length === 33);

	  switch (format) {
	    case 0x02:
	    case 0x03:
	      return key;
	    case 0x04:
	      key[0] = 0x02;
	      break;
	    case 0x05:
	      key[0] = 0x03;
	      break;
	    default:
	      throw new Error('Bad point format.');
	  }

	  // Decompress the key.
	  const out = secp256k1.publicKeyConvert(key, false);

	  // Reset the first byte so as not to
	  // mutate the original buffer.
	  key[0] = format;

	  return out;
	}

	/*
	 * Expose
	 */

	compress.pack = compressOutput;
	compress.unpack = decompressOutput;
	compress.size = sizeOutput;
	return compress;
}

/*!
 * coinentry.js - coin entry object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coinentry;
var hasRequiredCoinentry;

function requireCoinentry () {
	if (hasRequiredCoinentry) return coinentry;
	hasRequiredCoinentry = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const Coin = requireCoin();
	const Output = requireOutput();
	const compress = requireCompress();
	const {encoding} = bio;

	/*
	 * Constants
	 */

	const NUM_FLAGS = 1;
	const MAX_HEIGHT = ((1 << (32 - NUM_FLAGS)) >>> 0) - 1;

	/**
	 * Coin Entry
	 * Represents an unspent output.
	 * @alias module:coins.CoinEntry
	 * @property {Number} version - Transaction version.
	 * @property {Number} height - Transaction height (-1 if unconfirmed).
	 * @property {Boolean} coinbase - Whether the containing
	 * transaction is a coinbase.
	 * @property {Output} output
	 * @property {Boolean} spent
	 * @property {Buffer} raw
	 */

	class CoinEntry {
	  /**
	   * Create a coin entry.
	   * @constructor
	   */

	  constructor() {
	    this.version = 1;
	    this.height = -1;
	    this.coinbase = false;
	    this.output = new Output();
	    this.spent = false;
	    this.raw = null;
	  }

	  /**
	   * Convert coin entry to an output.
	   * @returns {Output}
	   */

	  toOutput() {
	    return this.output;
	  }

	  /**
	   * Convert coin entry to a coin.
	   * @param {Outpoint} prevout
	   * @returns {Coin}
	   */

	  toCoin(prevout) {
	    const coin = new Coin();
	    coin.version = this.version;
	    coin.height = this.height;
	    coin.coinbase = this.coinbase;
	    coin.script = this.output.script;
	    coin.value = this.output.value;
	    coin.hash = prevout.hash;
	    coin.index = prevout.index;
	    return coin;
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromOutput(output) {
	    this.output = output;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromOutput(output) {
	    return new this().fromOutput(output);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromCoin(coin) {
	    this.version = coin.version;
	    this.height = coin.height;
	    this.coinbase = coin.coinbase;
	    this.output.script = coin.script;
	    this.output.value = coin.value;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromCoin(coin) {
	    return new this().fromCoin(coin);
	  }

	  /**
	   * Inject properties from TX.
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index, height) {
	    assert(typeof index === 'number');
	    assert(typeof height === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.version = tx.version;
	    this.height = height;
	    this.coinbase = tx.isCoinbase();
	    this.output = tx.outputs[index];
	    return this;
	  }

	  /**
	   * Instantiate a coin from a TX
	   * @param {TX} tx
	   * @param {Number} index - Output index.
	   * @returns {CoinEntry}
	   */

	  static fromTX(tx, index, height) {
	    return new this().fromTX(tx, index, height);
	  }

	  /**
	   * Calculate size of coin.
	   * @returns {Number}
	   */

	  getSize() {
	    if (this.raw)
	      return this.raw.length;

	    let size = 0;
	    size += encoding.sizeVarint(this.version);
	    size += 4;
	    size += compress.size(this.output);

	    return size;
	  }

	  /**
	   * Write the coin to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.raw) {
	      bw.writeBytes(this.raw);
	      return bw;
	    }

	    let height = this.height;
	    let field = 0;

	    if (this.coinbase)
	      field |= 1;

	    if (height === -1)
	      height = MAX_HEIGHT;

	    field |= height << NUM_FLAGS;

	    bw.writeVarint(this.version);
	    bw.writeU32(field);
	    compress.pack(this.output, bw);

	    return bw;
	  }

	  /**
	   * Serialize the coin.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    if (this.raw)
	      return this.raw;

	    const size = this.getSize();
	    const bw = bio.write(size);

	    this.toWriter(bw);

	    this.raw = bw.render();

	    return this.raw;
	  }

	  /**
	   * Inject properties from serialized buffer writer.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    const version = br.readVarint();
	    const field = br.readU32();

	    let height = field >>> NUM_FLAGS;

	    if (height === MAX_HEIGHT)
	      height = -1;

	    this.version = version;
	    this.coinbase = (field & 1) !== 0;
	    this.height = height;

	    compress.unpack(this.output, br);

	    return this;
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @returns {CoinEntry}
	   */

	  static fromReader(data) {
	    return new this().fromReader(data);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    this.fromReader(bio.read(data));
	    this.raw = data;
	    return this;
	  }

	  /**
	   * Instantiate a coin from a serialized Buffer.
	   * @param {Buffer} data
	   * @returns {CoinEntry}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }
	}

	/*
	 * Expose
	 */

	coinentry = CoinEntry;
	return coinentry;
}

/*!
 * coins.js - coins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coins;
var hasRequiredCoins$1;

function requireCoins$1 () {
	if (hasRequiredCoins$1) return coins;
	hasRequiredCoins$1 = 1;

	const assert = require$$0$3;
	const CoinEntry = requireCoinentry();

	/**
	 * Coins
	 * Represents the outputs for a single transaction.
	 * @alias module:coins.Coins
	 * @property {Map[]} outputs - Coins.
	 */

	class Coins {
	  /**
	   * Create coins.
	   * @constructor
	   */

	  constructor() {
	    this.outputs = new Map();
	  }

	  /**
	   * Add a single entry to the collection.
	   * @param {Number} index
	   * @param {CoinEntry} coin
	   * @returns {CoinEntry}
	   */

	  add(index, coin) {
	    assert((index >>> 0) === index);
	    assert(coin);
	    this.outputs.set(index, coin);
	    return coin;
	  }

	  /**
	   * Add a single output to the collection.
	   * @param {Number} index
	   * @param {Output} output
	   * @returns {CoinEntry}
	   */

	  addOutput(index, output) {
	    return this.add(index, CoinEntry.fromOutput(output));
	  }

	  /**
	   * Add an output to the collection by output index.
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Number} height
	   * @returns {CoinEntry}
	   */

	  addIndex(tx, index, height) {
	    return this.add(index, CoinEntry.fromTX(tx, index, height));
	  }

	  /**
	   * Add a single coin to the collection.
	   * @param {Coin} coin
	   * @returns {CoinEntry}
	   */

	  addCoin(coin) {
	    return this.add(coin.index, CoinEntry.fromCoin(coin));
	  }

	  /**
	   * Test whether the collection has a coin.
	   * @param {Number} index
	   * @returns {Boolean}
	   */

	  has(index) {
	    return this.outputs.has(index);
	  }

	  /**
	   * Test whether the collection has an unspent coin.
	   * @param {Number} index
	   * @returns {Boolean}
	   */

	  isUnspent(index) {
	    const coin = this.outputs.get(index);

	    if (!coin || coin.spent)
	      return false;

	    return true;
	  }

	  /**
	   * Get a coin entry.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  get(index) {
	    return this.outputs.get(index) || null;
	  }

	  /**
	   * Get an output.
	   * @param {Number} index
	   * @returns {Output|null}
	   */

	  getOutput(index) {
	    const coin = this.outputs.get(index);

	    if (!coin)
	      return null;

	    return coin.output;
	  }

	  /**
	   * Get a coin.
	   * @param {Outpoint} prevout
	   * @returns {Coin|null}
	   */

	  getCoin(prevout) {
	    const coin = this.outputs.get(prevout.index);

	    if (!coin)
	      return null;

	    return coin.toCoin(prevout);
	  }

	  /**
	   * Spend a coin entry and return it.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  spend(index) {
	    const coin = this.get(index);

	    if (!coin || coin.spent)
	      return null;

	    coin.spent = true;

	    return coin;
	  }

	  /**
	   * Remove a coin entry and return it.
	   * @param {Number} index
	   * @returns {CoinEntry|null}
	   */

	  remove(index) {
	    const coin = this.get(index);

	    if (!coin)
	      return null;

	    this.outputs.delete(index);

	    return coin;
	  }

	  /**
	   * Test whether the coins are fully spent.
	   * @returns {Boolean}
	   */

	  isEmpty() {
	    return this.outputs.size === 0;
	  }

	  /**
	   * Inject properties from tx.
	   * @private
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  fromTX(tx, height) {
	    assert(typeof height === 'number');

	    for (let i = 0; i < tx.outputs.length; i++) {
	      const output = tx.outputs[i];

	      if (output.script.isUnspendable())
	        continue;

	      const entry = CoinEntry.fromTX(tx, i, height);

	      this.outputs.set(i, entry);
	    }

	    return this;
	  }

	  /**
	   * Instantiate a coins object from a transaction.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  static fromTX(tx, height) {
	    return new this().fromTX(tx, height);
	  }
	}

	/*
	 * Expose
	 */

	coins = Coins;
	return coins;
}

/*!
 * undocoins.js - undocoins object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var undocoins;
var hasRequiredUndocoins;

function requireUndocoins () {
	if (hasRequiredUndocoins) return undocoins;
	hasRequiredUndocoins = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const CoinEntry = requireCoinentry();

	/**
	 * Undo Coins
	 * Coins need to be resurrected from somewhere
	 * during a reorg. The undo coins store all
	 * spent coins in a single record per block
	 * (in a compressed format).
	 * @alias module:coins.UndoCoins
	 * @property {UndoCoin[]} items
	 */

	class UndoCoins {
	  /**
	   * Create undo coins.
	   * @constructor
	   */

	  constructor() {
	    this.items = [];
	  }

	  /**
	   * Push coin entry onto undo coin array.
	   * @param {CoinEntry}
	   * @returns {Number}
	   */

	  push(coin) {
	    return this.items.push(coin);
	  }

	  /**
	   * Calculate undo coins size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;

	    size += 4;

	    for (const coin of this.items)
	      size += coin.getSize();

	    return size;
	  }

	  /**
	   * Serialize all undo coins.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    const bw = bio.write(size);

	    bw.writeU32(this.items.length);

	    for (const coin of this.items)
	      coin.toWriter(bw);

	    return bw.render();
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {UndoCoins}
	   */

	  fromRaw(data) {
	    const br = bio.read(data);
	    const count = br.readU32();

	    for (let i = 0; i < count; i++)
	      this.items.push(CoinEntry.fromReader(br));

	    return this;
	  }

	  /**
	   * Instantiate undo coins from serialized data.
	   * @param {Buffer} data
	   * @returns {UndoCoins}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether the undo coins have any members.
	   * @returns {Boolean}
	   */

	  isEmpty() {
	    return this.items.length === 0;
	  }

	  /**
	   * Render the undo coins.
	   * @returns {Buffer}
	   */

	  commit() {
	    const raw = this.toRaw();
	    this.items.length = 0;
	    return raw;
	  }

	  /**
	   * Re-apply undo coins to a view, effectively unspending them.
	   * @param {CoinView} view
	   * @param {Outpoint} prevout
	   */

	  apply(view, prevout) {
	    const undo = this.items.pop();

	    assert(undo);

	    view.addEntry(prevout, undo);
	  }
	}

	/*
	 * Expose
	 */

	undocoins = UndoCoins;
	return undocoins;
}

/*!
 * coinview.js - coin viewpoint object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var coinview;
var hasRequiredCoinview;

function requireCoinview () {
	if (hasRequiredCoinview) return coinview;
	hasRequiredCoinview = 1;

	const {BufferMap} = require$$2$2;
	const Coins = requireCoins$1();
	const UndoCoins = requireUndocoins();
	const CoinEntry = requireCoinentry();

	/**
	 * Coin View
	 * Represents a coin viewpoint:
	 * a snapshot of {@link Coins} objects.
	 * @alias module:coins.CoinView
	 * @property {Object} map
	 * @property {UndoCoins} undo
	 */

	class CoinView {
	  /**
	   * Create a coin view.
	   * @constructor
	   */

	  constructor() {
	    this.map = new BufferMap();
	    this.undo = new UndoCoins();
	  }

	  /**
	   * Get coins.
	   * @param {Hash} hash
	   * @returns {Coins} coins
	   */

	  get(hash) {
	    return this.map.get(hash);
	  }

	  /**
	   * Test whether the view has an entry.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  has(hash) {
	    return this.map.has(hash);
	  }

	  /**
	   * Add coins to the collection.
	   * @param {Hash} hash
	   * @param {Coins} coins
	   * @returns {Coins}
	   */

	  add(hash, coins) {
	    this.map.set(hash, coins);
	    return coins;
	  }

	  /**
	   * Ensure existence of coins object in the collection.
	   * @param {Hash} hash
	   * @returns {Coins}
	   */

	  ensure(hash) {
	    const coins = this.map.get(hash);

	    if (coins)
	      return coins;

	    return this.add(hash, new Coins());
	  }

	  /**
	   * Remove coins from the collection.
	   * @param {Coins} coins
	   * @returns {Coins|null}
	   */

	  remove(hash) {
	    const coins = this.map.get(hash);

	    if (!coins)
	      return null;

	    this.map.delete(hash);

	    return coins;
	  }

	  /**
	   * Add a tx to the collection.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  addTX(tx, height) {
	    const hash = tx.hash();
	    const coins = Coins.fromTX(tx, height);
	    return this.add(hash, coins);
	  }

	  /**
	   * Remove a tx from the collection.
	   * @param {TX} tx
	   * @param {Number} height
	   * @returns {Coins}
	   */

	  removeTX(tx, height) {
	    const hash = tx.hash();
	    const coins = Coins.fromTX(tx, height);

	    for (const coin of coins.outputs.values())
	      coin.spent = true;

	    return this.add(hash, coins);
	  }

	  /**
	   * Add an entry to the collection.
	   * @param {Outpoint} prevout
	   * @param {CoinEntry} coin
	   * @returns {CoinEntry|null}
	   */

	  addEntry(prevout, coin) {
	    const {hash, index} = prevout;
	    const coins = this.ensure(hash);
	    return coins.add(index, coin);
	  }

	  /**
	   * Add a coin to the collection.
	   * @param {Coin} coin
	   * @returns {CoinEntry|null}
	   */

	  addCoin(coin) {
	    const coins = this.ensure(coin.hash);
	    return coins.addCoin(coin);
	  }

	  /**
	   * Add an output to the collection.
	   * @param {Outpoint} prevout
	   * @param {Output} output
	   * @returns {CoinEntry|null}
	   */

	  addOutput(prevout, output) {
	    const {hash, index} = prevout;
	    const coins = this.ensure(hash);
	    return coins.addOutput(index, output);
	  }

	  /**
	   * Add an output to the collection by output index.
	   * @param {TX} tx
	   * @param {Number} index
	   * @param {Number} height
	   * @returns {CoinEntry|null}
	   */

	  addIndex(tx, index, height) {
	    const hash = tx.hash();
	    const coins = this.ensure(hash);
	    return coins.addIndex(tx, index, height);
	  }

	  /**
	   * Spend an output.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  spendEntry(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return null;

	    const coin = coins.spend(index);

	    if (!coin)
	      return null;

	    this.undo.push(coin);

	    return coin;
	  }

	  /**
	   * Remove an output.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  removeEntry(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return null;

	    return coins.remove(index);
	  }

	  /**
	   * Test whether the view has an entry by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  hasEntry(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return false;

	    return coins.has(index);
	  }

	  /**
	   * Get a single entry by prevout.
	   * @param {Outpoint} prevout
	   * @returns {CoinEntry|null}
	   */

	  getEntry(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return null;

	    return coins.get(index);
	  }

	  /**
	   * Test whether an entry has been spent by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  isUnspent(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return false;

	    return coins.isUnspent(index);
	  }

	  /**
	   * Get a single coin by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Coin|null}
	   */

	  getCoin(prevout) {
	    const coins = this.get(prevout.hash);

	    if (!coins)
	      return null;

	    return coins.getCoin(prevout);
	  }

	  /**
	   * Get a single output by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Output|null}
	   */

	  getOutput(prevout) {
	    const {hash, index} = prevout;
	    const coins = this.get(hash);

	    if (!coins)
	      return null;

	    return coins.getOutput(index);
	  }

	  /**
	   * Get coins height by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Number}
	   */

	  getHeight(prevout) {
	    const coin = this.getEntry(prevout);

	    if (!coin)
	      return -1;

	    return coin.height;
	  }

	  /**
	   * Get coins coinbase flag by prevout.
	   * @param {Outpoint} prevout
	   * @returns {Boolean}
	   */

	  isCoinbase(prevout) {
	    const coin = this.getEntry(prevout);

	    if (!coin)
	      return false;

	    return coin.coinbase;
	  }

	  /**
	   * Test whether the view has an entry by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  hasEntryFor(input) {
	    return this.hasEntry(input.prevout);
	  }

	  /**
	   * Get a single entry by input.
	   * @param {Input} input
	   * @returns {CoinEntry|null}
	   */

	  getEntryFor(input) {
	    return this.getEntry(input.prevout);
	  }

	  /**
	   * Test whether an entry has been spent by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  isUnspentFor(input) {
	    return this.isUnspent(input.prevout);
	  }

	  /**
	   * Get a single coin by input.
	   * @param {Input} input
	   * @returns {Coin|null}
	   */

	  getCoinFor(input) {
	    return this.getCoin(input.prevout);
	  }

	  /**
	   * Get a single output by input.
	   * @param {Input} input
	   * @returns {Output|null}
	   */

	  getOutputFor(input) {
	    return this.getOutput(input.prevout);
	  }

	  /**
	   * Get coins height by input.
	   * @param {Input} input
	   * @returns {Number}
	   */

	  getHeightFor(input) {
	    return this.getHeight(input.prevout);
	  }

	  /**
	   * Get coins coinbase flag by input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  isCoinbaseFor(input) {
	    return this.isCoinbase(input.prevout);
	  }

	  /**
	   * Retrieve coins from database.
	   * @method
	   * @param {ChainDB} db
	   * @param {Outpoint} prevout
	   * @returns {Promise} - Returns {@link CoinEntry}.
	   */

	  async readCoin(db, prevout) {
	    const cache = this.getEntry(prevout);

	    if (cache)
	      return cache;

	    const coin = await db.readCoin(prevout);

	    if (!coin)
	      return null;

	    return this.addEntry(prevout, coin);
	  }

	  /**
	   * Read all input coins into unspent map.
	   * @method
	   * @param {ChainDB} db
	   * @param {TX} tx
	   * @returns {Promise} - Returns {Boolean}.
	   */

	  async readInputs(db, tx) {
	    let found = true;

	    for (const {prevout} of tx.inputs) {
	      if (!await this.readCoin(db, prevout))
	        found = false;
	    }

	    return found;
	  }

	  /**
	   * Spend coins for transaction.
	   * @method
	   * @param {ChainDB} db
	   * @param {TX} tx
	   * @returns {Promise} - Returns {Boolean}.
	   */

	  async spendInputs(db, tx) {
	    let i = 0;

	    while (i < tx.inputs.length) {
	      const len = Math.min(i + 4, tx.inputs.length);
	      const jobs = [];

	      for (; i < len; i++) {
	        const {prevout} = tx.inputs[i];
	        jobs.push(this.readCoin(db, prevout));
	      }

	      const coins = await Promise.all(jobs);

	      for (const coin of coins) {
	        if (!coin || coin.spent)
	          return false;

	        coin.spent = true;
	        this.undo.push(coin);
	      }
	    }

	    return true;
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize(tx) {
	    let size = 0;

	    size += tx.inputs.length;

	    for (const {prevout} of tx.inputs) {
	      const coin = this.getEntry(prevout);

	      if (!coin)
	        continue;

	      size += coin.getSize();
	    }

	    return size;
	  }

	  /**
	   * Write coin data to buffer writer
	   * as it pertains to a transaction.
	   * @param {BufferWriter} bw
	   * @param {TX} tx
	   */

	  toWriter(bw, tx) {
	    for (const {prevout} of tx.inputs) {
	      const coin = this.getEntry(prevout);

	      if (!coin) {
	        bw.writeU8(0);
	        continue;
	      }

	      bw.writeU8(1);
	      coin.toWriter(bw);
	    }

	    return bw;
	  }

	  /**
	   * Read serialized view data from a buffer
	   * reader as it pertains to a transaction.
	   * @private
	   * @param {BufferReader} br
	   * @param {TX} tx
	   */

	  fromReader(br, tx) {
	    for (const {prevout} of tx.inputs) {
	      if (br.readU8() === 0)
	        continue;

	      const coin = CoinEntry.fromReader(br);

	      this.addEntry(prevout, coin);
	    }

	    return this;
	  }

	  /**
	   * Read serialized view data from a buffer
	   * reader as it pertains to a transaction.
	   * @param {BufferReader} br
	   * @param {TX} tx
	   * @returns {CoinView}
	   */

	  static fromReader(br, tx) {
	    return new this().fromReader(br, tx);
	  }
	}

	/*
	 * Expose
	 */

	coinview = CoinView;
	return coinview;
}

/*!
 * coins/index.js - utxo management for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCoins;

function requireCoins () {
	if (hasRequiredCoins) return coins$1;
	hasRequiredCoins = 1;

	/**
	 * @module coins
	 */

	coins$1.Coins = requireCoins$1();
	coins$1.CoinView = requireCoinview();
	coins$1.compress = requireCompress();
	coins$1.UndoCoins = requireUndocoins();
	return coins$1;
}

var hd$1 = {};

var common = {};

/*!
 * common.js - common functions for hd
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports) {

		const assert = require$$0$3;
		const LRU = require$$1$2;
		const common = exports;

		/**
		 * Index at which hardening begins.
		 * @const {Number}
		 * @default
		 */

		common.HARDENED = 0x80000000;

		/**
		 * Min entropy bits.
		 * @const {Number}
		 * @default
		 */

		common.MIN_ENTROPY = 128;

		/**
		 * Max entropy bits.
		 * @const {Number}
		 * @default
		 */

		common.MAX_ENTROPY = 512;

		/**
		 * LRU cache to avoid deriving keys twice.
		 * @type {LRU}
		 */

		common.cache = new LRU(500);

		/**
		 * Parse a derivation path and return an array of indexes.
		 * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
		 * @param {String} path
		 * @param {Boolean} hard
		 * @returns {Number[]}
		 */

		common.parsePath = function parsePath(path, hard) {
		  assert(typeof path === 'string');
		  assert(typeof hard === 'boolean');
		  assert(path.length >= 1);
		  assert(path.length <= 3062);

		  const parts = path.split('/');
		  const root = parts[0];

		  if (root !== 'm'
		      && root !== 'M'
		      && root !== 'm\''
		      && root !== 'M\'') {
		    throw new Error('Invalid path root.');
		  }

		  const result = [];

		  for (let i = 1; i < parts.length; i++) {
		    let part = parts[i];

		    const hardened = part[part.length - 1] === '\'';

		    if (hardened)
		      part = part.slice(0, -1);

		    if (part.length > 10)
		      throw new Error('Path index too large.');

		    if (!/^\d+$/.test(part))
		      throw new Error('Path index is non-numeric.');

		    let index = parseInt(part, 10);

		    if ((index >>> 0) !== index)
		      throw new Error('Path index out of range.');

		    if (hardened) {
		      index |= common.HARDENED;
		      index >>>= 0;
		    }

		    if (!hard && (index & common.HARDENED))
		      throw new Error('Path index cannot be hardened.');

		    result.push(index);
		  }

		  return result;
		};

		/**
		 * Test whether the key is a master key.
		 * @param {HDPrivateKey|HDPublicKey} key
		 * @returns {Boolean}
		 */

		common.isMaster = function isMaster(key) {
		  return key.depth === 0
		    && key.childIndex === 0
		    && key.parentFingerPrint === 0;
		};

		/**
		 * Test whether the key is (most likely) a BIP44 account key.
		 * @param {HDPrivateKey|HDPublicKey} key
		 * @param {Number?} account
		 * @returns {Boolean}
		 */

		common.isAccount = function isAccount(key, account) {
		  if (account != null) {
		    const index = (common.HARDENED | account) >>> 0;
		    if (key.childIndex !== index)
		      return false;
		  }
		  return key.depth === 3 && (key.childIndex & common.HARDENED) !== 0;
		};

		/**
		 * A compressed pubkey of all zeroes.
		 * @const {Buffer}
		 * @default
		 */

		common.ZERO_KEY = Buffer.alloc(33, 0x00); 
	} (common));
	return common;
}

/*!
 * cleanse.js - memzero for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var cleanse_1;
var hasRequiredCleanse;

function requireCleanse () {
	if (hasRequiredCleanse) return cleanse_1;
	hasRequiredCleanse = 1;

	const assert = requireAssert();
	const random = requireRandom();

	/**
	 * A maybe-secure memzero.
	 * @param {Buffer} data
	 */

	function cleanse(data) {
	  assert(Buffer.isBuffer(data));
	  random.randomFill(data, 0, data.length);
	}

	/*
	 * Static
	 */

	cleanse.native = 0;

	/*
	 * Expose
	 */

	cleanse_1 = cleanse;
	return cleanse_1;
}

var pbkdf2 = {};

/*!
 * pbkdf2.js - pbkdf2 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/PBKDF2
 *   https://tools.ietf.org/html/rfc2898
 *   https://tools.ietf.org/html/rfc2898#section-5.2
 *   https://tools.ietf.org/html/rfc6070
 *   https://www.emc.com/collateral/white-papers/h11302-pkcs5v2-1-password-based-cryptography-standard-wp.pdf
 *   http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 */

var hasRequiredPbkdf2;

function requirePbkdf2 () {
	if (hasRequiredPbkdf2) return pbkdf2;
	hasRequiredPbkdf2 = 1;

	const assert = requireAssert();
	const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto || {};
	const subtle = crypto.subtle || {};

	/**
	 * Perform key derivation using PBKDF2.
	 * @param {Function} hash
	 * @param {Buffer} pass
	 * @param {Buffer} salt
	 * @param {Number} iter
	 * @param {Number} len
	 * @returns {Buffer}
	 */

	function derive(hash, pass, salt, iter, len) {
	  if (typeof pass === 'string')
	    pass = Buffer.from(pass, 'utf8');

	  if (typeof salt === 'string')
	    salt = Buffer.from(salt, 'utf8');

	  if (salt == null)
	    salt = Buffer.alloc(0);

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(pass));
	  assert(Buffer.isBuffer(salt));
	  assert((iter >>> 0) === iter);
	  assert((len >>> 0) === len);

	  const size = hash.size;
	  const blocks = Math.ceil(len / size);
	  const out = Buffer.alloc(blocks * size);
	  const state = Buffer.alloc(salt.length + 4);

	  salt.copy(state, 0);

	  // Preemptively shorten key.
	  if (pass.length > hash.blockSize) {
	    pass = hash.digest(pass);
	    assert(pass.length <= hash.blockSize);
	  }

	  for (let i = 0; i < blocks; i++) {
	    const round = i + 1;

	    state[salt.length + 0] = round >>> 24;
	    state[salt.length + 1] = round >>> 16;
	    state[salt.length + 2] = round >>> 8;
	    state[salt.length + 3] = round;

	    const block = hash.mac(state, pass);

	    let mac = block;

	    for (let j = 1; j < iter; j++) {
	      mac = hash.mac(mac, pass);

	      for (let k = 0; k < size; k++)
	        block[k] ^= mac[k];
	    }

	    block.copy(out, i * size);
	  }

	  return out.slice(0, len);
	}

	/**
	 * Execute pbkdf2 asynchronously.
	 * @param {Function} hash
	 * @param {Buffer} pass
	 * @param {Buffer} salt
	 * @param {Number} iter
	 * @param {Number} len
	 * @returns {Promise}
	 */

	async function deriveAsync(hash, pass, salt, iter, len) {
	  if (typeof pass === 'string')
	    pass = Buffer.from(pass, 'utf8');

	  if (typeof salt === 'string')
	    salt = Buffer.from(salt, 'utf8');

	  if (salt == null)
	    salt = Buffer.alloc(0);

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(pass));
	  assert(Buffer.isBuffer(salt));
	  assert((iter >>> 0) === iter);
	  assert((len >>> 0) === len);

	  const name = getHash(hash);

	  if (!subtle.importKey || !subtle.deriveBits || !name)
	    return derive(hash, pass, salt, iter, len);

	  const algo = { name: 'PBKDF2' };
	  const use = ['deriveBits'];

	  const options = {
	    name: 'PBKDF2',
	    salt: salt,
	    iterations: iter,
	    hash: name
	  };

	  const key = await subtle.importKey('raw', pass, algo, false, use);
	  const out = await subtle.deriveBits(options, key, len * 8);

	  return Buffer.from(out);
	}

	/*
	 * Helpers
	 */

	function getHash(hash) {
	  switch (hash.id) {
	    case 'SHA1':
	      return 'SHA-1';
	    case 'SHA256':
	      return 'SHA-256';
	    case 'SHA384':
	      return 'SHA-384';
	    case 'SHA512':
	      return 'SHA-512';
	    default:
	      return null;
	  }
	}

	/*
	 * Expose
	 */

	pbkdf2.native = 0;
	pbkdf2.derive = derive;
	pbkdf2.deriveAsync = deriveAsync;
	return pbkdf2;
}

/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */

var sha512;
var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512;
	hasRequiredSha512 = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = -1;
	const DESC = Buffer.alloc(16, 0x00);
	const PADDING = Buffer.alloc(128, 0x00);

	PADDING[0] = 0x80;

	const K = new Uint32Array([
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	]);

	/**
	 * SHA512
	 */

	class SHA512 {
	  constructor() {
	    this.state = new Uint32Array(16);
	    this.msg = new Uint32Array(160);
	    this.block = Buffer.alloc(128);
	    this.size = FINALIZED;
	  }

	  init() {
	    this.state[0] = 0x6a09e667;
	    this.state[1] = 0xf3bcc908;
	    this.state[2] = 0xbb67ae85;
	    this.state[3] = 0x84caa73b;
	    this.state[4] = 0x3c6ef372;
	    this.state[5] = 0xfe94f82b;
	    this.state[6] = 0xa54ff53a;
	    this.state[7] = 0x5f1d36f1;
	    this.state[8] = 0x510e527f;
	    this.state[9] = 0xade682d1;
	    this.state[10] = 0x9b05688c;
	    this.state[11] = 0x2b3e6c1f;
	    this.state[12] = 0x1f83d9ab;
	    this.state[13] = 0xfb41bd6b;
	    this.state[14] = 0x5be0cd19;
	    this.state[15] = 0x137e2179;
	    this.size = 0;
	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));
	    this._update(data, data.length);
	    return this;
	  }

	  final() {
	    return this._final(Buffer.alloc(64));
	  }

	  _update(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    let pos = this.size & 127;
	    let off = 0;

	    this.size += len;

	    if (pos > 0) {
	      let want = 128 - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < 128)
	        return;

	      this._transform(this.block, 0);
	    }

	    while (len >= 128) {
	      this._transform(data, off);
	      off += 128;
	      len -= 128;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);
	  }

	  /**
	   * Finalize SHA512 context.
	   * @private
	   * @param {Buffer} out
	   * @returns {Buffer}
	   */

	  _final(out) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    const pos = this.size & 127;
	    const len = this.size * 8;

	    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 8);
	    writeU32(DESC, len >>> 0, 12);

	    this._update(PADDING, 1 + ((239 - pos) & 127));
	    this._update(DESC, 16);

	    for (let i = 0; i < 16; i++) {
	      writeU32(out, this.state[i], i * 4);
	      this.state[i] = 0;
	    }

	    for (let i = 0; i < 160; i++)
	      this.msg[i] = 0;

	    for (let i = 0; i < 128; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;

	    return out;
	  }

	  _prepare(chunk, pos) {
	    const W = this.msg;

	    let i = 0;

	    for (; i < 32; i++)
	      W[i] = readU32(chunk, pos + i * 4);

	    for (; i < 160; i += 2) {
	      const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
	      const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	      const c1_hi = W[i - 14];
	      const c1_lo = W[i - 13];
	      const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
	      const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	      const c3_hi = W[i - 32];
	      const c3_lo = W[i - 31];

	      W[i + 0] = sum64_4_hi(c0_hi, c0_lo,
	                            c1_hi, c1_lo,
	                            c2_hi, c2_lo,
	                            c3_hi, c3_lo);

	      W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
	                            c1_hi, c1_lo,
	                            c2_hi, c2_lo,
	                            c3_hi, c3_lo);
	    }
	  }

	  _transform(chunk, pos) {
	    const W = this.msg;

	    this._prepare(chunk, pos);

	    let ah = this.state[0];
	    let al = this.state[1];
	    let bh = this.state[2];
	    let bl = this.state[3];
	    let ch = this.state[4];
	    let cl = this.state[5];
	    let dh = this.state[6];
	    let dl = this.state[7];
	    let eh = this.state[8];
	    let el = this.state[9];
	    let fh = this.state[10];
	    let fl = this.state[11];
	    let gh = this.state[12];
	    let gl = this.state[13];
	    let hh = this.state[14];
	    let hl = this.state[15];

	    for (let i = 0; i < W.length; i += 2) {
	      let c0_hi = hh;
	      let c0_lo = hl;
	      let c1_hi = s1_512_hi(eh, el);
	      let c1_lo = s1_512_lo(eh, el);

	      const c2_hi = ch64_hi(eh, el, fh, fl, gh);
	      const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	      const c3_hi = K[i + 0];
	      const c3_lo = K[i + 1];
	      const c4_hi = W[i + 0];
	      const c4_lo = W[i + 1];

	      const T1_hi = sum64_5_hi(c0_hi, c0_lo,
	                               c1_hi, c1_lo,
	                               c2_hi, c2_lo,
	                               c3_hi, c3_lo,
	                               c4_hi, c4_lo);

	      const T1_lo = sum64_5_lo(c0_hi, c0_lo,
	                               c1_hi, c1_lo,
	                               c2_hi, c2_lo,
	                               c3_hi, c3_lo,
	                               c4_hi, c4_lo);

	      c0_hi = s0_512_hi(ah, al);
	      c0_lo = s0_512_lo(ah, al);
	      c1_hi = maj64_hi(ah, al, bh, bl, ch);
	      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	      const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	      const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	      hh = gh;
	      hl = gl;

	      gh = fh;
	      gl = fl;

	      fh = eh;
	      fl = el;

	      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	      el = sum64_lo(dl, dl, T1_hi, T1_lo);

	      dh = ch;
	      dl = cl;

	      ch = bh;
	      cl = bl;

	      bh = ah;
	      bl = al;

	      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	    }

	    sum64(this.state, 0, ah, al);
	    sum64(this.state, 2, bh, bl);
	    sum64(this.state, 4, ch, cl);
	    sum64(this.state, 6, dh, dl);
	    sum64(this.state, 8, eh, el);
	    sum64(this.state, 10, fh, fl);
	    sum64(this.state, 12, gh, gl);
	    sum64(this.state, 14, hh, hl);
	  }

	  static hash() {
	    return new SHA512();
	  }

	  static hmac() {
	    return new HMAC(SHA512, 128);
	  }

	  static digest(data) {
	    return SHA512.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 64);
	    assert(Buffer.isBuffer(right) && right.length === 64);
	    return SHA512.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = SHA512;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return SHA512.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA512.native = 0;
	SHA512.id = 'SHA512';
	SHA512.size = 64;
	SHA512.bits = 512;
	SHA512.blockSize = 128;
	SHA512.zero = Buffer.alloc(64, 0x00);
	SHA512.ctx = new SHA512();

	/*
	 * Helpers
	 */

	function sum64(buf, pos, ah, al) {
	  const bh = buf[pos + 0];
	  const bl = buf[pos + 1];

	  const lo = (al + bl) >>> 0;
	  const hi = (lo < al) + ah + bh;

	  buf[pos + 0] = hi >>> 0;
	  buf[pos + 1] = lo;
	}

	function sum64_hi(ah, al, bh, bl) {
	  const lo = (al + bl) >>> 0;
	  const hi = (lo < al) + ah + bh;
	  return hi >>> 0;
	}

	function sum64_lo(ah, al, bh, bl) {
	  const lo = al + bl;
	  return lo >>> 0;
	}

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  let carry = 0;
	  let lo = al;

	  lo = (lo + bl) >>> 0;
	  carry += (lo < al);

	  lo = (lo + cl) >>> 0;
	  carry += (lo < cl);

	  lo = (lo + dl) >>> 0;
	  carry += (lo < dl);

	  const hi = ah + bh + ch + dh + carry;

	  return hi >>> 0;
	}

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  const lo = al + bl + cl + dl;
	  return lo >>> 0;
	}

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  let carry = 0;
	  let lo = al;

	  lo = (lo + bl) >>> 0;
	  carry += (lo < al);

	  lo = (lo + cl) >>> 0;
	  carry += (lo < cl);

	  lo = (lo + dl) >>> 0;
	  carry += (lo < dl);

	  lo = (lo + el) >>> 0;
	  carry += (lo < el);

	  const hi = ah + bh + ch + dh + eh + carry;

	  return hi >>> 0;
	}

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  const lo = al + bl + cl + dl + el;
	  return lo >>> 0;
	}

	function rotr64_hi(ah, al, num) {
	  const r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}

	function rotr64_lo(ah, al, num) {
	  const r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}

	function shr64_lo(ah, al, num) {
	  const r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}

	function ch64_hi(xh, xl, yh, yl, zh, zl) {
	  const r = (xh & yh) ^ ((~xh) & zh);
	  return r >>> 0;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  const r = (xl & yl) ^ ((~xl) & zl);
	  return r >>> 0;
	}

	function maj64_hi(xh, xl, yh, yl, zh, zl) {
	  const r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  return r >>> 0;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  const r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  return r >>> 0;
	}

	function s0_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 28);
	  const c1_hi = rotr64_hi(xl, xh, 2); // 34
	  const c2_hi = rotr64_hi(xl, xh, 7); // 39
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}

	function s0_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 28);
	  const c1_lo = rotr64_lo(xl, xh, 2); // 34
	  const c2_lo = rotr64_lo(xl, xh, 7); // 39
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}

	function s1_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 14);
	  const c1_hi = rotr64_hi(xh, xl, 18);
	  const c2_hi = rotr64_hi(xl, xh, 9); // 41
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}

	function s1_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 14);
	  const c1_lo = rotr64_lo(xh, xl, 18);
	  const c2_lo = rotr64_lo(xl, xh, 9); // 41
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}

	function g0_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 1);
	  const c1_hi = rotr64_hi(xh, xl, 8);
	  const c2_hi = shr64_hi(xh, xl, 7);
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}

	function g0_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 1);
	  const c1_lo = rotr64_lo(xh, xl, 8);
	  const c2_lo = shr64_lo(xh, xl, 7);
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}

	function g1_512_hi(xh, xl) {
	  const c0_hi = rotr64_hi(xh, xl, 19);
	  const c1_hi = rotr64_hi(xl, xh, 29); // 61
	  const c2_hi = shr64_hi(xh, xl, 6);
	  const r = c0_hi ^ c1_hi ^ c2_hi;
	  return r >>> 0;
	}

	function g1_512_lo(xh, xl) {
	  const c0_lo = rotr64_lo(xh, xl, 19);
	  const c1_lo = rotr64_lo(xl, xh, 29); // 61
	  const c2_lo = shr64_lo(xh, xl, 6);
	  const r = c0_lo ^ c1_lo ^ c2_lo;
	  return r >>> 0;
	}

	function readU32(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function writeU32(data, num, off) {
	  data[off++] = num >>> 24;
	  data[off++] = num >>> 16;
	  data[off++] = num >>> 8;
	  data[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	sha512 = SHA512;
	return sha512;
}

var wordlist = {};

var chineseSimplified;
var hasRequiredChineseSimplified;

function requireChineseSimplified () {
	if (hasRequiredChineseSimplified) return chineseSimplified;
	hasRequiredChineseSimplified = 1;

	chineseSimplified = [
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  ''
	];
	return chineseSimplified;
}

var chineseTraditional;
var hasRequiredChineseTraditional;

function requireChineseTraditional () {
	if (hasRequiredChineseTraditional) return chineseTraditional;
	hasRequiredChineseTraditional = 1;

	chineseTraditional = [
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  ''
	];
	return chineseTraditional;
}

var english;
var hasRequiredEnglish;

function requireEnglish () {
	if (hasRequiredEnglish) return english;
	hasRequiredEnglish = 1;

	english = [
	  'abandon',
	  'ability',
	  'able',
	  'about',
	  'above',
	  'absent',
	  'absorb',
	  'abstract',
	  'absurd',
	  'abuse',
	  'access',
	  'accident',
	  'account',
	  'accuse',
	  'achieve',
	  'acid',
	  'acoustic',
	  'acquire',
	  'across',
	  'act',
	  'action',
	  'actor',
	  'actress',
	  'actual',
	  'adapt',
	  'add',
	  'addict',
	  'address',
	  'adjust',
	  'admit',
	  'adult',
	  'advance',
	  'advice',
	  'aerobic',
	  'affair',
	  'afford',
	  'afraid',
	  'again',
	  'age',
	  'agent',
	  'agree',
	  'ahead',
	  'aim',
	  'air',
	  'airport',
	  'aisle',
	  'alarm',
	  'album',
	  'alcohol',
	  'alert',
	  'alien',
	  'all',
	  'alley',
	  'allow',
	  'almost',
	  'alone',
	  'alpha',
	  'already',
	  'also',
	  'alter',
	  'always',
	  'amateur',
	  'amazing',
	  'among',
	  'amount',
	  'amused',
	  'analyst',
	  'anchor',
	  'ancient',
	  'anger',
	  'angle',
	  'angry',
	  'animal',
	  'ankle',
	  'announce',
	  'annual',
	  'another',
	  'answer',
	  'antenna',
	  'antique',
	  'anxiety',
	  'any',
	  'apart',
	  'apology',
	  'appear',
	  'apple',
	  'approve',
	  'april',
	  'arch',
	  'arctic',
	  'area',
	  'arena',
	  'argue',
	  'arm',
	  'armed',
	  'armor',
	  'army',
	  'around',
	  'arrange',
	  'arrest',
	  'arrive',
	  'arrow',
	  'art',
	  'artefact',
	  'artist',
	  'artwork',
	  'ask',
	  'aspect',
	  'assault',
	  'asset',
	  'assist',
	  'assume',
	  'asthma',
	  'athlete',
	  'atom',
	  'attack',
	  'attend',
	  'attitude',
	  'attract',
	  'auction',
	  'audit',
	  'august',
	  'aunt',
	  'author',
	  'auto',
	  'autumn',
	  'average',
	  'avocado',
	  'avoid',
	  'awake',
	  'aware',
	  'away',
	  'awesome',
	  'awful',
	  'awkward',
	  'axis',
	  'baby',
	  'bachelor',
	  'bacon',
	  'badge',
	  'bag',
	  'balance',
	  'balcony',
	  'ball',
	  'bamboo',
	  'banana',
	  'banner',
	  'bar',
	  'barely',
	  'bargain',
	  'barrel',
	  'base',
	  'basic',
	  'basket',
	  'battle',
	  'beach',
	  'bean',
	  'beauty',
	  'because',
	  'become',
	  'beef',
	  'before',
	  'begin',
	  'behave',
	  'behind',
	  'believe',
	  'below',
	  'belt',
	  'bench',
	  'benefit',
	  'best',
	  'betray',
	  'better',
	  'between',
	  'beyond',
	  'bicycle',
	  'bid',
	  'bike',
	  'bind',
	  'biology',
	  'bird',
	  'birth',
	  'bitter',
	  'black',
	  'blade',
	  'blame',
	  'blanket',
	  'blast',
	  'bleak',
	  'bless',
	  'blind',
	  'blood',
	  'blossom',
	  'blouse',
	  'blue',
	  'blur',
	  'blush',
	  'board',
	  'boat',
	  'body',
	  'boil',
	  'bomb',
	  'bone',
	  'bonus',
	  'book',
	  'boost',
	  'border',
	  'boring',
	  'borrow',
	  'boss',
	  'bottom',
	  'bounce',
	  'box',
	  'boy',
	  'bracket',
	  'brain',
	  'brand',
	  'brass',
	  'brave',
	  'bread',
	  'breeze',
	  'brick',
	  'bridge',
	  'brief',
	  'bright',
	  'bring',
	  'brisk',
	  'broccoli',
	  'broken',
	  'bronze',
	  'broom',
	  'brother',
	  'brown',
	  'brush',
	  'bubble',
	  'buddy',
	  'budget',
	  'buffalo',
	  'build',
	  'bulb',
	  'bulk',
	  'bullet',
	  'bundle',
	  'bunker',
	  'burden',
	  'burger',
	  'burst',
	  'bus',
	  'business',
	  'busy',
	  'butter',
	  'buyer',
	  'buzz',
	  'cabbage',
	  'cabin',
	  'cable',
	  'cactus',
	  'cage',
	  'cake',
	  'call',
	  'calm',
	  'camera',
	  'camp',
	  'can',
	  'canal',
	  'cancel',
	  'candy',
	  'cannon',
	  'canoe',
	  'canvas',
	  'canyon',
	  'capable',
	  'capital',
	  'captain',
	  'car',
	  'carbon',
	  'card',
	  'cargo',
	  'carpet',
	  'carry',
	  'cart',
	  'case',
	  'cash',
	  'casino',
	  'castle',
	  'casual',
	  'cat',
	  'catalog',
	  'catch',
	  'category',
	  'cattle',
	  'caught',
	  'cause',
	  'caution',
	  'cave',
	  'ceiling',
	  'celery',
	  'cement',
	  'census',
	  'century',
	  'cereal',
	  'certain',
	  'chair',
	  'chalk',
	  'champion',
	  'change',
	  'chaos',
	  'chapter',
	  'charge',
	  'chase',
	  'chat',
	  'cheap',
	  'check',
	  'cheese',
	  'chef',
	  'cherry',
	  'chest',
	  'chicken',
	  'chief',
	  'child',
	  'chimney',
	  'choice',
	  'choose',
	  'chronic',
	  'chuckle',
	  'chunk',
	  'churn',
	  'cigar',
	  'cinnamon',
	  'circle',
	  'citizen',
	  'city',
	  'civil',
	  'claim',
	  'clap',
	  'clarify',
	  'claw',
	  'clay',
	  'clean',
	  'clerk',
	  'clever',
	  'click',
	  'client',
	  'cliff',
	  'climb',
	  'clinic',
	  'clip',
	  'clock',
	  'clog',
	  'close',
	  'cloth',
	  'cloud',
	  'clown',
	  'club',
	  'clump',
	  'cluster',
	  'clutch',
	  'coach',
	  'coast',
	  'coconut',
	  'code',
	  'coffee',
	  'coil',
	  'coin',
	  'collect',
	  'color',
	  'column',
	  'combine',
	  'come',
	  'comfort',
	  'comic',
	  'common',
	  'company',
	  'concert',
	  'conduct',
	  'confirm',
	  'congress',
	  'connect',
	  'consider',
	  'control',
	  'convince',
	  'cook',
	  'cool',
	  'copper',
	  'copy',
	  'coral',
	  'core',
	  'corn',
	  'correct',
	  'cost',
	  'cotton',
	  'couch',
	  'country',
	  'couple',
	  'course',
	  'cousin',
	  'cover',
	  'coyote',
	  'crack',
	  'cradle',
	  'craft',
	  'cram',
	  'crane',
	  'crash',
	  'crater',
	  'crawl',
	  'crazy',
	  'cream',
	  'credit',
	  'creek',
	  'crew',
	  'cricket',
	  'crime',
	  'crisp',
	  'critic',
	  'crop',
	  'cross',
	  'crouch',
	  'crowd',
	  'crucial',
	  'cruel',
	  'cruise',
	  'crumble',
	  'crunch',
	  'crush',
	  'cry',
	  'crystal',
	  'cube',
	  'culture',
	  'cup',
	  'cupboard',
	  'curious',
	  'current',
	  'curtain',
	  'curve',
	  'cushion',
	  'custom',
	  'cute',
	  'cycle',
	  'dad',
	  'damage',
	  'damp',
	  'dance',
	  'danger',
	  'daring',
	  'dash',
	  'daughter',
	  'dawn',
	  'day',
	  'deal',
	  'debate',
	  'debris',
	  'decade',
	  'december',
	  'decide',
	  'decline',
	  'decorate',
	  'decrease',
	  'deer',
	  'defense',
	  'define',
	  'defy',
	  'degree',
	  'delay',
	  'deliver',
	  'demand',
	  'demise',
	  'denial',
	  'dentist',
	  'deny',
	  'depart',
	  'depend',
	  'deposit',
	  'depth',
	  'deputy',
	  'derive',
	  'describe',
	  'desert',
	  'design',
	  'desk',
	  'despair',
	  'destroy',
	  'detail',
	  'detect',
	  'develop',
	  'device',
	  'devote',
	  'diagram',
	  'dial',
	  'diamond',
	  'diary',
	  'dice',
	  'diesel',
	  'diet',
	  'differ',
	  'digital',
	  'dignity',
	  'dilemma',
	  'dinner',
	  'dinosaur',
	  'direct',
	  'dirt',
	  'disagree',
	  'discover',
	  'disease',
	  'dish',
	  'dismiss',
	  'disorder',
	  'display',
	  'distance',
	  'divert',
	  'divide',
	  'divorce',
	  'dizzy',
	  'doctor',
	  'document',
	  'dog',
	  'doll',
	  'dolphin',
	  'domain',
	  'donate',
	  'donkey',
	  'donor',
	  'door',
	  'dose',
	  'double',
	  'dove',
	  'draft',
	  'dragon',
	  'drama',
	  'drastic',
	  'draw',
	  'dream',
	  'dress',
	  'drift',
	  'drill',
	  'drink',
	  'drip',
	  'drive',
	  'drop',
	  'drum',
	  'dry',
	  'duck',
	  'dumb',
	  'dune',
	  'during',
	  'dust',
	  'dutch',
	  'duty',
	  'dwarf',
	  'dynamic',
	  'eager',
	  'eagle',
	  'early',
	  'earn',
	  'earth',
	  'easily',
	  'east',
	  'easy',
	  'echo',
	  'ecology',
	  'economy',
	  'edge',
	  'edit',
	  'educate',
	  'effort',
	  'egg',
	  'eight',
	  'either',
	  'elbow',
	  'elder',
	  'electric',
	  'elegant',
	  'element',
	  'elephant',
	  'elevator',
	  'elite',
	  'else',
	  'embark',
	  'embody',
	  'embrace',
	  'emerge',
	  'emotion',
	  'employ',
	  'empower',
	  'empty',
	  'enable',
	  'enact',
	  'end',
	  'endless',
	  'endorse',
	  'enemy',
	  'energy',
	  'enforce',
	  'engage',
	  'engine',
	  'enhance',
	  'enjoy',
	  'enlist',
	  'enough',
	  'enrich',
	  'enroll',
	  'ensure',
	  'enter',
	  'entire',
	  'entry',
	  'envelope',
	  'episode',
	  'equal',
	  'equip',
	  'era',
	  'erase',
	  'erode',
	  'erosion',
	  'error',
	  'erupt',
	  'escape',
	  'essay',
	  'essence',
	  'estate',
	  'eternal',
	  'ethics',
	  'evidence',
	  'evil',
	  'evoke',
	  'evolve',
	  'exact',
	  'example',
	  'excess',
	  'exchange',
	  'excite',
	  'exclude',
	  'excuse',
	  'execute',
	  'exercise',
	  'exhaust',
	  'exhibit',
	  'exile',
	  'exist',
	  'exit',
	  'exotic',
	  'expand',
	  'expect',
	  'expire',
	  'explain',
	  'expose',
	  'express',
	  'extend',
	  'extra',
	  'eye',
	  'eyebrow',
	  'fabric',
	  'face',
	  'faculty',
	  'fade',
	  'faint',
	  'faith',
	  'fall',
	  'false',
	  'fame',
	  'family',
	  'famous',
	  'fan',
	  'fancy',
	  'fantasy',
	  'farm',
	  'fashion',
	  'fat',
	  'fatal',
	  'father',
	  'fatigue',
	  'fault',
	  'favorite',
	  'feature',
	  'february',
	  'federal',
	  'fee',
	  'feed',
	  'feel',
	  'female',
	  'fence',
	  'festival',
	  'fetch',
	  'fever',
	  'few',
	  'fiber',
	  'fiction',
	  'field',
	  'figure',
	  'file',
	  'film',
	  'filter',
	  'final',
	  'find',
	  'fine',
	  'finger',
	  'finish',
	  'fire',
	  'firm',
	  'first',
	  'fiscal',
	  'fish',
	  'fit',
	  'fitness',
	  'fix',
	  'flag',
	  'flame',
	  'flash',
	  'flat',
	  'flavor',
	  'flee',
	  'flight',
	  'flip',
	  'float',
	  'flock',
	  'floor',
	  'flower',
	  'fluid',
	  'flush',
	  'fly',
	  'foam',
	  'focus',
	  'fog',
	  'foil',
	  'fold',
	  'follow',
	  'food',
	  'foot',
	  'force',
	  'forest',
	  'forget',
	  'fork',
	  'fortune',
	  'forum',
	  'forward',
	  'fossil',
	  'foster',
	  'found',
	  'fox',
	  'fragile',
	  'frame',
	  'frequent',
	  'fresh',
	  'friend',
	  'fringe',
	  'frog',
	  'front',
	  'frost',
	  'frown',
	  'frozen',
	  'fruit',
	  'fuel',
	  'fun',
	  'funny',
	  'furnace',
	  'fury',
	  'future',
	  'gadget',
	  'gain',
	  'galaxy',
	  'gallery',
	  'game',
	  'gap',
	  'garage',
	  'garbage',
	  'garden',
	  'garlic',
	  'garment',
	  'gas',
	  'gasp',
	  'gate',
	  'gather',
	  'gauge',
	  'gaze',
	  'general',
	  'genius',
	  'genre',
	  'gentle',
	  'genuine',
	  'gesture',
	  'ghost',
	  'giant',
	  'gift',
	  'giggle',
	  'ginger',
	  'giraffe',
	  'girl',
	  'give',
	  'glad',
	  'glance',
	  'glare',
	  'glass',
	  'glide',
	  'glimpse',
	  'globe',
	  'gloom',
	  'glory',
	  'glove',
	  'glow',
	  'glue',
	  'goat',
	  'goddess',
	  'gold',
	  'good',
	  'goose',
	  'gorilla',
	  'gospel',
	  'gossip',
	  'govern',
	  'gown',
	  'grab',
	  'grace',
	  'grain',
	  'grant',
	  'grape',
	  'grass',
	  'gravity',
	  'great',
	  'green',
	  'grid',
	  'grief',
	  'grit',
	  'grocery',
	  'group',
	  'grow',
	  'grunt',
	  'guard',
	  'guess',
	  'guide',
	  'guilt',
	  'guitar',
	  'gun',
	  'gym',
	  'habit',
	  'hair',
	  'half',
	  'hammer',
	  'hamster',
	  'hand',
	  'happy',
	  'harbor',
	  'hard',
	  'harsh',
	  'harvest',
	  'hat',
	  'have',
	  'hawk',
	  'hazard',
	  'head',
	  'health',
	  'heart',
	  'heavy',
	  'hedgehog',
	  'height',
	  'hello',
	  'helmet',
	  'help',
	  'hen',
	  'hero',
	  'hidden',
	  'high',
	  'hill',
	  'hint',
	  'hip',
	  'hire',
	  'history',
	  'hobby',
	  'hockey',
	  'hold',
	  'hole',
	  'holiday',
	  'hollow',
	  'home',
	  'honey',
	  'hood',
	  'hope',
	  'horn',
	  'horror',
	  'horse',
	  'hospital',
	  'host',
	  'hotel',
	  'hour',
	  'hover',
	  'hub',
	  'huge',
	  'human',
	  'humble',
	  'humor',
	  'hundred',
	  'hungry',
	  'hunt',
	  'hurdle',
	  'hurry',
	  'hurt',
	  'husband',
	  'hybrid',
	  'ice',
	  'icon',
	  'idea',
	  'identify',
	  'idle',
	  'ignore',
	  'ill',
	  'illegal',
	  'illness',
	  'image',
	  'imitate',
	  'immense',
	  'immune',
	  'impact',
	  'impose',
	  'improve',
	  'impulse',
	  'inch',
	  'include',
	  'income',
	  'increase',
	  'index',
	  'indicate',
	  'indoor',
	  'industry',
	  'infant',
	  'inflict',
	  'inform',
	  'inhale',
	  'inherit',
	  'initial',
	  'inject',
	  'injury',
	  'inmate',
	  'inner',
	  'innocent',
	  'input',
	  'inquiry',
	  'insane',
	  'insect',
	  'inside',
	  'inspire',
	  'install',
	  'intact',
	  'interest',
	  'into',
	  'invest',
	  'invite',
	  'involve',
	  'iron',
	  'island',
	  'isolate',
	  'issue',
	  'item',
	  'ivory',
	  'jacket',
	  'jaguar',
	  'jar',
	  'jazz',
	  'jealous',
	  'jeans',
	  'jelly',
	  'jewel',
	  'job',
	  'join',
	  'joke',
	  'journey',
	  'joy',
	  'judge',
	  'juice',
	  'jump',
	  'jungle',
	  'junior',
	  'junk',
	  'just',
	  'kangaroo',
	  'keen',
	  'keep',
	  'ketchup',
	  'key',
	  'kick',
	  'kid',
	  'kidney',
	  'kind',
	  'kingdom',
	  'kiss',
	  'kit',
	  'kitchen',
	  'kite',
	  'kitten',
	  'kiwi',
	  'knee',
	  'knife',
	  'knock',
	  'know',
	  'lab',
	  'label',
	  'labor',
	  'ladder',
	  'lady',
	  'lake',
	  'lamp',
	  'language',
	  'laptop',
	  'large',
	  'later',
	  'latin',
	  'laugh',
	  'laundry',
	  'lava',
	  'law',
	  'lawn',
	  'lawsuit',
	  'layer',
	  'lazy',
	  'leader',
	  'leaf',
	  'learn',
	  'leave',
	  'lecture',
	  'left',
	  'leg',
	  'legal',
	  'legend',
	  'leisure',
	  'lemon',
	  'lend',
	  'length',
	  'lens',
	  'leopard',
	  'lesson',
	  'letter',
	  'level',
	  'liar',
	  'liberty',
	  'library',
	  'license',
	  'life',
	  'lift',
	  'light',
	  'like',
	  'limb',
	  'limit',
	  'link',
	  'lion',
	  'liquid',
	  'list',
	  'little',
	  'live',
	  'lizard',
	  'load',
	  'loan',
	  'lobster',
	  'local',
	  'lock',
	  'logic',
	  'lonely',
	  'long',
	  'loop',
	  'lottery',
	  'loud',
	  'lounge',
	  'love',
	  'loyal',
	  'lucky',
	  'luggage',
	  'lumber',
	  'lunar',
	  'lunch',
	  'luxury',
	  'lyrics',
	  'machine',
	  'mad',
	  'magic',
	  'magnet',
	  'maid',
	  'mail',
	  'main',
	  'major',
	  'make',
	  'mammal',
	  'man',
	  'manage',
	  'mandate',
	  'mango',
	  'mansion',
	  'manual',
	  'maple',
	  'marble',
	  'march',
	  'margin',
	  'marine',
	  'market',
	  'marriage',
	  'mask',
	  'mass',
	  'master',
	  'match',
	  'material',
	  'math',
	  'matrix',
	  'matter',
	  'maximum',
	  'maze',
	  'meadow',
	  'mean',
	  'measure',
	  'meat',
	  'mechanic',
	  'medal',
	  'media',
	  'melody',
	  'melt',
	  'member',
	  'memory',
	  'mention',
	  'menu',
	  'mercy',
	  'merge',
	  'merit',
	  'merry',
	  'mesh',
	  'message',
	  'metal',
	  'method',
	  'middle',
	  'midnight',
	  'milk',
	  'million',
	  'mimic',
	  'mind',
	  'minimum',
	  'minor',
	  'minute',
	  'miracle',
	  'mirror',
	  'misery',
	  'miss',
	  'mistake',
	  'mix',
	  'mixed',
	  'mixture',
	  'mobile',
	  'model',
	  'modify',
	  'mom',
	  'moment',
	  'monitor',
	  'monkey',
	  'monster',
	  'month',
	  'moon',
	  'moral',
	  'more',
	  'morning',
	  'mosquito',
	  'mother',
	  'motion',
	  'motor',
	  'mountain',
	  'mouse',
	  'move',
	  'movie',
	  'much',
	  'muffin',
	  'mule',
	  'multiply',
	  'muscle',
	  'museum',
	  'mushroom',
	  'music',
	  'must',
	  'mutual',
	  'myself',
	  'mystery',
	  'myth',
	  'naive',
	  'name',
	  'napkin',
	  'narrow',
	  'nasty',
	  'nation',
	  'nature',
	  'near',
	  'neck',
	  'need',
	  'negative',
	  'neglect',
	  'neither',
	  'nephew',
	  'nerve',
	  'nest',
	  'net',
	  'network',
	  'neutral',
	  'never',
	  'news',
	  'next',
	  'nice',
	  'night',
	  'noble',
	  'noise',
	  'nominee',
	  'noodle',
	  'normal',
	  'north',
	  'nose',
	  'notable',
	  'note',
	  'nothing',
	  'notice',
	  'novel',
	  'now',
	  'nuclear',
	  'number',
	  'nurse',
	  'nut',
	  'oak',
	  'obey',
	  'object',
	  'oblige',
	  'obscure',
	  'observe',
	  'obtain',
	  'obvious',
	  'occur',
	  'ocean',
	  'october',
	  'odor',
	  'off',
	  'offer',
	  'office',
	  'often',
	  'oil',
	  'okay',
	  'old',
	  'olive',
	  'olympic',
	  'omit',
	  'once',
	  'one',
	  'onion',
	  'online',
	  'only',
	  'open',
	  'opera',
	  'opinion',
	  'oppose',
	  'option',
	  'orange',
	  'orbit',
	  'orchard',
	  'order',
	  'ordinary',
	  'organ',
	  'orient',
	  'original',
	  'orphan',
	  'ostrich',
	  'other',
	  'outdoor',
	  'outer',
	  'output',
	  'outside',
	  'oval',
	  'oven',
	  'over',
	  'own',
	  'owner',
	  'oxygen',
	  'oyster',
	  'ozone',
	  'pact',
	  'paddle',
	  'page',
	  'pair',
	  'palace',
	  'palm',
	  'panda',
	  'panel',
	  'panic',
	  'panther',
	  'paper',
	  'parade',
	  'parent',
	  'park',
	  'parrot',
	  'party',
	  'pass',
	  'patch',
	  'path',
	  'patient',
	  'patrol',
	  'pattern',
	  'pause',
	  'pave',
	  'payment',
	  'peace',
	  'peanut',
	  'pear',
	  'peasant',
	  'pelican',
	  'pen',
	  'penalty',
	  'pencil',
	  'people',
	  'pepper',
	  'perfect',
	  'permit',
	  'person',
	  'pet',
	  'phone',
	  'photo',
	  'phrase',
	  'physical',
	  'piano',
	  'picnic',
	  'picture',
	  'piece',
	  'pig',
	  'pigeon',
	  'pill',
	  'pilot',
	  'pink',
	  'pioneer',
	  'pipe',
	  'pistol',
	  'pitch',
	  'pizza',
	  'place',
	  'planet',
	  'plastic',
	  'plate',
	  'play',
	  'please',
	  'pledge',
	  'pluck',
	  'plug',
	  'plunge',
	  'poem',
	  'poet',
	  'point',
	  'polar',
	  'pole',
	  'police',
	  'pond',
	  'pony',
	  'pool',
	  'popular',
	  'portion',
	  'position',
	  'possible',
	  'post',
	  'potato',
	  'pottery',
	  'poverty',
	  'powder',
	  'power',
	  'practice',
	  'praise',
	  'predict',
	  'prefer',
	  'prepare',
	  'present',
	  'pretty',
	  'prevent',
	  'price',
	  'pride',
	  'primary',
	  'print',
	  'priority',
	  'prison',
	  'private',
	  'prize',
	  'problem',
	  'process',
	  'produce',
	  'profit',
	  'program',
	  'project',
	  'promote',
	  'proof',
	  'property',
	  'prosper',
	  'protect',
	  'proud',
	  'provide',
	  'public',
	  'pudding',
	  'pull',
	  'pulp',
	  'pulse',
	  'pumpkin',
	  'punch',
	  'pupil',
	  'puppy',
	  'purchase',
	  'purity',
	  'purpose',
	  'purse',
	  'push',
	  'put',
	  'puzzle',
	  'pyramid',
	  'quality',
	  'quantum',
	  'quarter',
	  'question',
	  'quick',
	  'quit',
	  'quiz',
	  'quote',
	  'rabbit',
	  'raccoon',
	  'race',
	  'rack',
	  'radar',
	  'radio',
	  'rail',
	  'rain',
	  'raise',
	  'rally',
	  'ramp',
	  'ranch',
	  'random',
	  'range',
	  'rapid',
	  'rare',
	  'rate',
	  'rather',
	  'raven',
	  'raw',
	  'razor',
	  'ready',
	  'real',
	  'reason',
	  'rebel',
	  'rebuild',
	  'recall',
	  'receive',
	  'recipe',
	  'record',
	  'recycle',
	  'reduce',
	  'reflect',
	  'reform',
	  'refuse',
	  'region',
	  'regret',
	  'regular',
	  'reject',
	  'relax',
	  'release',
	  'relief',
	  'rely',
	  'remain',
	  'remember',
	  'remind',
	  'remove',
	  'render',
	  'renew',
	  'rent',
	  'reopen',
	  'repair',
	  'repeat',
	  'replace',
	  'report',
	  'require',
	  'rescue',
	  'resemble',
	  'resist',
	  'resource',
	  'response',
	  'result',
	  'retire',
	  'retreat',
	  'return',
	  'reunion',
	  'reveal',
	  'review',
	  'reward',
	  'rhythm',
	  'rib',
	  'ribbon',
	  'rice',
	  'rich',
	  'ride',
	  'ridge',
	  'rifle',
	  'right',
	  'rigid',
	  'ring',
	  'riot',
	  'ripple',
	  'risk',
	  'ritual',
	  'rival',
	  'river',
	  'road',
	  'roast',
	  'robot',
	  'robust',
	  'rocket',
	  'romance',
	  'roof',
	  'rookie',
	  'room',
	  'rose',
	  'rotate',
	  'rough',
	  'round',
	  'route',
	  'royal',
	  'rubber',
	  'rude',
	  'rug',
	  'rule',
	  'run',
	  'runway',
	  'rural',
	  'sad',
	  'saddle',
	  'sadness',
	  'safe',
	  'sail',
	  'salad',
	  'salmon',
	  'salon',
	  'salt',
	  'salute',
	  'same',
	  'sample',
	  'sand',
	  'satisfy',
	  'satoshi',
	  'sauce',
	  'sausage',
	  'save',
	  'say',
	  'scale',
	  'scan',
	  'scare',
	  'scatter',
	  'scene',
	  'scheme',
	  'school',
	  'science',
	  'scissors',
	  'scorpion',
	  'scout',
	  'scrap',
	  'screen',
	  'script',
	  'scrub',
	  'sea',
	  'search',
	  'season',
	  'seat',
	  'second',
	  'secret',
	  'section',
	  'security',
	  'seed',
	  'seek',
	  'segment',
	  'select',
	  'sell',
	  'seminar',
	  'senior',
	  'sense',
	  'sentence',
	  'series',
	  'service',
	  'session',
	  'settle',
	  'setup',
	  'seven',
	  'shadow',
	  'shaft',
	  'shallow',
	  'share',
	  'shed',
	  'shell',
	  'sheriff',
	  'shield',
	  'shift',
	  'shine',
	  'ship',
	  'shiver',
	  'shock',
	  'shoe',
	  'shoot',
	  'shop',
	  'short',
	  'shoulder',
	  'shove',
	  'shrimp',
	  'shrug',
	  'shuffle',
	  'shy',
	  'sibling',
	  'sick',
	  'side',
	  'siege',
	  'sight',
	  'sign',
	  'silent',
	  'silk',
	  'silly',
	  'silver',
	  'similar',
	  'simple',
	  'since',
	  'sing',
	  'siren',
	  'sister',
	  'situate',
	  'six',
	  'size',
	  'skate',
	  'sketch',
	  'ski',
	  'skill',
	  'skin',
	  'skirt',
	  'skull',
	  'slab',
	  'slam',
	  'sleep',
	  'slender',
	  'slice',
	  'slide',
	  'slight',
	  'slim',
	  'slogan',
	  'slot',
	  'slow',
	  'slush',
	  'small',
	  'smart',
	  'smile',
	  'smoke',
	  'smooth',
	  'snack',
	  'snake',
	  'snap',
	  'sniff',
	  'snow',
	  'soap',
	  'soccer',
	  'social',
	  'sock',
	  'soda',
	  'soft',
	  'solar',
	  'soldier',
	  'solid',
	  'solution',
	  'solve',
	  'someone',
	  'song',
	  'soon',
	  'sorry',
	  'sort',
	  'soul',
	  'sound',
	  'soup',
	  'source',
	  'south',
	  'space',
	  'spare',
	  'spatial',
	  'spawn',
	  'speak',
	  'special',
	  'speed',
	  'spell',
	  'spend',
	  'sphere',
	  'spice',
	  'spider',
	  'spike',
	  'spin',
	  'spirit',
	  'split',
	  'spoil',
	  'sponsor',
	  'spoon',
	  'sport',
	  'spot',
	  'spray',
	  'spread',
	  'spring',
	  'spy',
	  'square',
	  'squeeze',
	  'squirrel',
	  'stable',
	  'stadium',
	  'staff',
	  'stage',
	  'stairs',
	  'stamp',
	  'stand',
	  'start',
	  'state',
	  'stay',
	  'steak',
	  'steel',
	  'stem',
	  'step',
	  'stereo',
	  'stick',
	  'still',
	  'sting',
	  'stock',
	  'stomach',
	  'stone',
	  'stool',
	  'story',
	  'stove',
	  'strategy',
	  'street',
	  'strike',
	  'strong',
	  'struggle',
	  'student',
	  'stuff',
	  'stumble',
	  'style',
	  'subject',
	  'submit',
	  'subway',
	  'success',
	  'such',
	  'sudden',
	  'suffer',
	  'sugar',
	  'suggest',
	  'suit',
	  'summer',
	  'sun',
	  'sunny',
	  'sunset',
	  'super',
	  'supply',
	  'supreme',
	  'sure',
	  'surface',
	  'surge',
	  'surprise',
	  'surround',
	  'survey',
	  'suspect',
	  'sustain',
	  'swallow',
	  'swamp',
	  'swap',
	  'swarm',
	  'swear',
	  'sweet',
	  'swift',
	  'swim',
	  'swing',
	  'switch',
	  'sword',
	  'symbol',
	  'symptom',
	  'syrup',
	  'system',
	  'table',
	  'tackle',
	  'tag',
	  'tail',
	  'talent',
	  'talk',
	  'tank',
	  'tape',
	  'target',
	  'task',
	  'taste',
	  'tattoo',
	  'taxi',
	  'teach',
	  'team',
	  'tell',
	  'ten',
	  'tenant',
	  'tennis',
	  'tent',
	  'term',
	  'test',
	  'text',
	  'thank',
	  'that',
	  'theme',
	  'then',
	  'theory',
	  'there',
	  'they',
	  'thing',
	  'this',
	  'thought',
	  'three',
	  'thrive',
	  'throw',
	  'thumb',
	  'thunder',
	  'ticket',
	  'tide',
	  'tiger',
	  'tilt',
	  'timber',
	  'time',
	  'tiny',
	  'tip',
	  'tired',
	  'tissue',
	  'title',
	  'toast',
	  'tobacco',
	  'today',
	  'toddler',
	  'toe',
	  'together',
	  'toilet',
	  'token',
	  'tomato',
	  'tomorrow',
	  'tone',
	  'tongue',
	  'tonight',
	  'tool',
	  'tooth',
	  'top',
	  'topic',
	  'topple',
	  'torch',
	  'tornado',
	  'tortoise',
	  'toss',
	  'total',
	  'tourist',
	  'toward',
	  'tower',
	  'town',
	  'toy',
	  'track',
	  'trade',
	  'traffic',
	  'tragic',
	  'train',
	  'transfer',
	  'trap',
	  'trash',
	  'travel',
	  'tray',
	  'treat',
	  'tree',
	  'trend',
	  'trial',
	  'tribe',
	  'trick',
	  'trigger',
	  'trim',
	  'trip',
	  'trophy',
	  'trouble',
	  'truck',
	  'true',
	  'truly',
	  'trumpet',
	  'trust',
	  'truth',
	  'try',
	  'tube',
	  'tuition',
	  'tumble',
	  'tuna',
	  'tunnel',
	  'turkey',
	  'turn',
	  'turtle',
	  'twelve',
	  'twenty',
	  'twice',
	  'twin',
	  'twist',
	  'two',
	  'type',
	  'typical',
	  'ugly',
	  'umbrella',
	  'unable',
	  'unaware',
	  'uncle',
	  'uncover',
	  'under',
	  'undo',
	  'unfair',
	  'unfold',
	  'unhappy',
	  'uniform',
	  'unique',
	  'unit',
	  'universe',
	  'unknown',
	  'unlock',
	  'until',
	  'unusual',
	  'unveil',
	  'update',
	  'upgrade',
	  'uphold',
	  'upon',
	  'upper',
	  'upset',
	  'urban',
	  'urge',
	  'usage',
	  'use',
	  'used',
	  'useful',
	  'useless',
	  'usual',
	  'utility',
	  'vacant',
	  'vacuum',
	  'vague',
	  'valid',
	  'valley',
	  'valve',
	  'van',
	  'vanish',
	  'vapor',
	  'various',
	  'vast',
	  'vault',
	  'vehicle',
	  'velvet',
	  'vendor',
	  'venture',
	  'venue',
	  'verb',
	  'verify',
	  'version',
	  'very',
	  'vessel',
	  'veteran',
	  'viable',
	  'vibrant',
	  'vicious',
	  'victory',
	  'video',
	  'view',
	  'village',
	  'vintage',
	  'violin',
	  'virtual',
	  'virus',
	  'visa',
	  'visit',
	  'visual',
	  'vital',
	  'vivid',
	  'vocal',
	  'voice',
	  'void',
	  'volcano',
	  'volume',
	  'vote',
	  'voyage',
	  'wage',
	  'wagon',
	  'wait',
	  'walk',
	  'wall',
	  'walnut',
	  'want',
	  'warfare',
	  'warm',
	  'warrior',
	  'wash',
	  'wasp',
	  'waste',
	  'water',
	  'wave',
	  'way',
	  'wealth',
	  'weapon',
	  'wear',
	  'weasel',
	  'weather',
	  'web',
	  'wedding',
	  'weekend',
	  'weird',
	  'welcome',
	  'west',
	  'wet',
	  'whale',
	  'what',
	  'wheat',
	  'wheel',
	  'when',
	  'where',
	  'whip',
	  'whisper',
	  'wide',
	  'width',
	  'wife',
	  'wild',
	  'will',
	  'win',
	  'window',
	  'wine',
	  'wing',
	  'wink',
	  'winner',
	  'winter',
	  'wire',
	  'wisdom',
	  'wise',
	  'wish',
	  'witness',
	  'wolf',
	  'woman',
	  'wonder',
	  'wood',
	  'wool',
	  'word',
	  'work',
	  'world',
	  'worry',
	  'worth',
	  'wrap',
	  'wreck',
	  'wrestle',
	  'wrist',
	  'write',
	  'wrong',
	  'yard',
	  'year',
	  'yellow',
	  'you',
	  'young',
	  'youth',
	  'zebra',
	  'zero',
	  'zone',
	  'zoo'
	];
	return english;
}

var french;
var hasRequiredFrench;

function requireFrench () {
	if (hasRequiredFrench) return french;
	hasRequiredFrench = 1;

	french = [
	  'abaisser',
	  'abandon',
	  'abdiquer',
	  'abeille',
	  'abolir',
	  'aborder',
	  'aboutir',
	  'aboyer',
	  'abrasif',
	  'abreuver',
	  'abriter',
	  'abroger',
	  'abrupt',
	  'absence',
	  'absolu',
	  'absurde',
	  'abusif',
	  'abyssal',
	  'academie',
	  'acajou',
	  'acarien',
	  'accabler',
	  'accepter',
	  'acclamer',
	  'accolade',
	  'accroche',
	  'accuser',
	  'acerbe',
	  'achat',
	  'acheter',
	  'aciduler',
	  'acier',
	  'acompte',
	  'acquerir',
	  'acronyme',
	  'acteur',
	  'actif',
	  'actuel',
	  'adepte',
	  'adequat',
	  'adhesif',
	  'adjectif',
	  'adjuger',
	  'admettre',
	  'admirer',
	  'adopter',
	  'adorer',
	  'adoucir',
	  'adresse',
	  'adroit',
	  'adulte',
	  'adverbe',
	  'aerer',
	  'aeronef',
	  'affaire',
	  'affecter',
	  'affiche',
	  'affreux',
	  'affubler',
	  'agacer',
	  'agencer',
	  'agile',
	  'agiter',
	  'agrafer',
	  'agreable',
	  'agrume',
	  'aider',
	  'aiguille',
	  'ailier',
	  'aimable',
	  'aisance',
	  'ajouter',
	  'ajuster',
	  'alarmer',
	  'alchimie',
	  'alerte',
	  'algebre',
	  'algue',
	  'aliener',
	  'aliment',
	  'alleger',
	  'alliage',
	  'allouer',
	  'allumer',
	  'alourdir',
	  'alpaga',
	  'altesse',
	  'alveole',
	  'amateur',
	  'ambigu',
	  'ambre',
	  'amenager',
	  'amertume',
	  'amidon',
	  'amiral',
	  'amorcer',
	  'amour',
	  'amovible',
	  'amphibie',
	  'ampleur',
	  'amusant',
	  'analyse',
	  'anaphore',
	  'anarchie',
	  'anatomie',
	  'ancien',
	  'aneantir',
	  'angle',
	  'angoisse',
	  'anguleux',
	  'animal',
	  'annexer',
	  'annonce',
	  'annuel',
	  'anodin',
	  'anomalie',
	  'anonyme',
	  'anormal',
	  'antenne',
	  'antidote',
	  'anxieux',
	  'apaiser',
	  'aperitif',
	  'aplanir',
	  'apologie',
	  'appareil',
	  'appeler',
	  'apporter',
	  'appuyer',
	  'aquarium',
	  'aqueduc',
	  'arbitre',
	  'arbuste',
	  'ardeur',
	  'ardoise',
	  'argent',
	  'arlequin',
	  'armature',
	  'armement',
	  'armoire',
	  'armure',
	  'arpenter',
	  'arracher',
	  'arriver',
	  'arroser',
	  'arsenic',
	  'arteriel',
	  'article',
	  'aspect',
	  'asphalte',
	  'aspirer',
	  'assaut',
	  'asservir',
	  'assiette',
	  'associer',
	  'assurer',
	  'asticot',
	  'astre',
	  'astuce',
	  'atelier',
	  'atome',
	  'atrium',
	  'atroce',
	  'attaque',
	  'attentif',
	  'attirer',
	  'attraper',
	  'aubaine',
	  'auberge',
	  'audace',
	  'audible',
	  'augurer',
	  'aurore',
	  'automne',
	  'autruche',
	  'avaler',
	  'avancer',
	  'avarice',
	  'avenir',
	  'averse',
	  'aveugle',
	  'aviateur',
	  'avide',
	  'avion',
	  'aviser',
	  'avoine',
	  'avouer',
	  'avril',
	  'axial',
	  'axiome',
	  'badge',
	  'bafouer',
	  'bagage',
	  'baguette',
	  'baignade',
	  'balancer',
	  'balcon',
	  'baleine',
	  'balisage',
	  'bambin',
	  'bancaire',
	  'bandage',
	  'banlieue',
	  'banniere',
	  'banquier',
	  'barbier',
	  'baril',
	  'baron',
	  'barque',
	  'barrage',
	  'bassin',
	  'bastion',
	  'bataille',
	  'bateau',
	  'batterie',
	  'baudrier',
	  'bavarder',
	  'belette',
	  'belier',
	  'belote',
	  'benefice',
	  'berceau',
	  'berger',
	  'berline',
	  'bermuda',
	  'besace',
	  'besogne',
	  'betail',
	  'beurre',
	  'biberon',
	  'bicycle',
	  'bidule',
	  'bijou',
	  'bilan',
	  'bilingue',
	  'billard',
	  'binaire',
	  'biologie',
	  'biopsie',
	  'biotype',
	  'biscuit',
	  'bison',
	  'bistouri',
	  'bitume',
	  'bizarre',
	  'blafard',
	  'blague',
	  'blanchir',
	  'blessant',
	  'blinder',
	  'blond',
	  'bloquer',
	  'blouson',
	  'bobard',
	  'bobine',
	  'boire',
	  'boiser',
	  'bolide',
	  'bonbon',
	  'bondir',
	  'bonheur',
	  'bonifier',
	  'bonus',
	  'bordure',
	  'borne',
	  'botte',
	  'boucle',
	  'boueux',
	  'bougie',
	  'boulon',
	  'bouquin',
	  'bourse',
	  'boussole',
	  'boutique',
	  'boxeur',
	  'branche',
	  'brasier',
	  'brave',
	  'brebis',
	  'breche',
	  'breuvage',
	  'bricoler',
	  'brigade',
	  'brillant',
	  'brioche',
	  'brique',
	  'brochure',
	  'broder',
	  'bronzer',
	  'brousse',
	  'broyeur',
	  'brume',
	  'brusque',
	  'brutal',
	  'bruyant',
	  'buffle',
	  'buisson',
	  'bulletin',
	  'bureau',
	  'burin',
	  'bustier',
	  'butiner',
	  'butoir',
	  'buvable',
	  'buvette',
	  'cabanon',
	  'cabine',
	  'cachette',
	  'cadeau',
	  'cadre',
	  'cafeine',
	  'caillou',
	  'caisson',
	  'calculer',
	  'calepin',
	  'calibre',
	  'calmer',
	  'calomnie',
	  'calvaire',
	  'camarade',
	  'camera',
	  'camion',
	  'campagne',
	  'canal',
	  'caneton',
	  'canon',
	  'cantine',
	  'canular',
	  'capable',
	  'caporal',
	  'caprice',
	  'capsule',
	  'capter',
	  'capuche',
	  'carabine',
	  'carbone',
	  'caresser',
	  'caribou',
	  'carnage',
	  'carotte',
	  'carreau',
	  'carton',
	  'cascade',
	  'casier',
	  'casque',
	  'cassure',
	  'causer',
	  'caution',
	  'cavalier',
	  'caverne',
	  'caviar',
	  'cedille',
	  'ceinture',
	  'celeste',
	  'cellule',
	  'cendrier',
	  'censurer',
	  'central',
	  'cercle',
	  'cerebral',
	  'cerise',
	  'cerner',
	  'cerveau',
	  'cesser',
	  'chagrin',
	  'chaise',
	  'chaleur',
	  'chambre',
	  'chance',
	  'chapitre',
	  'charbon',
	  'chasseur',
	  'chaton',
	  'chausson',
	  'chavirer',
	  'chemise',
	  'chenille',
	  'chequier',
	  'chercher',
	  'cheval',
	  'chien',
	  'chiffre',
	  'chignon',
	  'chimere',
	  'chiot',
	  'chlorure',
	  'chocolat',
	  'choisir',
	  'chose',
	  'chouette',
	  'chrome',
	  'chute',
	  'cigare',
	  'cigogne',
	  'cimenter',
	  'cinema',
	  'cintrer',
	  'circuler',
	  'cirer',
	  'cirque',
	  'citerne',
	  'citoyen',
	  'citron',
	  'civil',
	  'clairon',
	  'clameur',
	  'claquer',
	  'classe',
	  'clavier',
	  'client',
	  'cligner',
	  'climat',
	  'clivage',
	  'cloche',
	  'clonage',
	  'cloporte',
	  'cobalt',
	  'cobra',
	  'cocasse',
	  'cocotier',
	  'coder',
	  'codifier',
	  'coffre',
	  'cogner',
	  'cohesion',
	  'coiffer',
	  'coincer',
	  'colere',
	  'colibri',
	  'colline',
	  'colmater',
	  'colonel',
	  'combat',
	  'comedie',
	  'commande',
	  'compact',
	  'concert',
	  'conduire',
	  'confier',
	  'congeler',
	  'connoter',
	  'consonne',
	  'contact',
	  'convexe',
	  'copain',
	  'copie',
	  'corail',
	  'corbeau',
	  'cordage',
	  'corniche',
	  'corpus',
	  'correct',
	  'cortege',
	  'cosmique',
	  'costume',
	  'coton',
	  'coude',
	  'coupure',
	  'courage',
	  'couteau',
	  'couvrir',
	  'coyote',
	  'crabe',
	  'crainte',
	  'cravate',
	  'crayon',
	  'creature',
	  'crediter',
	  'cremeux',
	  'creuser',
	  'crevette',
	  'cribler',
	  'crier',
	  'cristal',
	  'critere',
	  'croire',
	  'croquer',
	  'crotale',
	  'crucial',
	  'cruel',
	  'crypter',
	  'cubique',
	  'cueillir',
	  'cuillere',
	  'cuisine',
	  'cuivre',
	  'culminer',
	  'cultiver',
	  'cumuler',
	  'cupide',
	  'curatif',
	  'curseur',
	  'cyanure',
	  'cycle',
	  'cylindre',
	  'cynique',
	  'daigner',
	  'damier',
	  'danger',
	  'danseur',
	  'dauphin',
	  'debattre',
	  'debiter',
	  'deborder',
	  'debrider',
	  'debutant',
	  'decaler',
	  'decembre',
	  'dechirer',
	  'decider',
	  'declarer',
	  'decorer',
	  'decrire',
	  'decupler',
	  'dedale',
	  'deductif',
	  'deesse',
	  'defensif',
	  'defiler',
	  'defrayer',
	  'degager',
	  'degivrer',
	  'deglutir',
	  'degrafer',
	  'dejeuner',
	  'delice',
	  'deloger',
	  'demander',
	  'demeurer',
	  'demolir',
	  'denicher',
	  'denouer',
	  'dentelle',
	  'denuder',
	  'depart',
	  'depenser',
	  'dephaser',
	  'deplacer',
	  'deposer',
	  'deranger',
	  'derober',
	  'desastre',
	  'descente',
	  'desert',
	  'designer',
	  'desobeir',
	  'dessiner',
	  'destrier',
	  'detacher',
	  'detester',
	  'detourer',
	  'detresse',
	  'devancer',
	  'devenir',
	  'deviner',
	  'devoir',
	  'diable',
	  'dialogue',
	  'diamant',
	  'dicter',
	  'differer',
	  'digerer',
	  'digital',
	  'digne',
	  'diluer',
	  'dimanche',
	  'diminuer',
	  'dioxyde',
	  'directif',
	  'diriger',
	  'discuter',
	  'disposer',
	  'dissiper',
	  'distance',
	  'divertir',
	  'diviser',
	  'docile',
	  'docteur',
	  'dogme',
	  'doigt',
	  'domaine',
	  'domicile',
	  'dompter',
	  'donateur',
	  'donjon',
	  'donner',
	  'dopamine',
	  'dortoir',
	  'dorure',
	  'dosage',
	  'doseur',
	  'dossier',
	  'dotation',
	  'douanier',
	  'double',
	  'douceur',
	  'douter',
	  'doyen',
	  'dragon',
	  'draper',
	  'dresser',
	  'dribbler',
	  'droiture',
	  'duperie',
	  'duplexe',
	  'durable',
	  'durcir',
	  'dynastie',
	  'eblouir',
	  'ecarter',
	  'echarpe',
	  'echelle',
	  'eclairer',
	  'eclipse',
	  'eclore',
	  'ecluse',
	  'ecole',
	  'economie',
	  'ecorce',
	  'ecouter',
	  'ecraser',
	  'ecremer',
	  'ecrivain',
	  'ecrou',
	  'ecume',
	  'ecureuil',
	  'edifier',
	  'eduquer',
	  'effacer',
	  'effectif',
	  'effigie',
	  'effort',
	  'effrayer',
	  'effusion',
	  'egaliser',
	  'egarer',
	  'ejecter',
	  'elaborer',
	  'elargir',
	  'electron',
	  'elegant',
	  'elephant',
	  'eleve',
	  'eligible',
	  'elitisme',
	  'eloge',
	  'elucider',
	  'eluder',
	  'emballer',
	  'embellir',
	  'embryon',
	  'emeraude',
	  'emission',
	  'emmener',
	  'emotion',
	  'emouvoir',
	  'empereur',
	  'employer',
	  'emporter',
	  'emprise',
	  'emulsion',
	  'encadrer',
	  'enchere',
	  'enclave',
	  'encoche',
	  'endiguer',
	  'endosser',
	  'endroit',
	  'enduire',
	  'energie',
	  'enfance',
	  'enfermer',
	  'enfouir',
	  'engager',
	  'engin',
	  'englober',
	  'enigme',
	  'enjamber',
	  'enjeu',
	  'enlever',
	  'ennemi',
	  'ennuyeux',
	  'enrichir',
	  'enrobage',
	  'enseigne',
	  'entasser',
	  'entendre',
	  'entier',
	  'entourer',
	  'entraver',
	  'enumerer',
	  'envahir',
	  'enviable',
	  'envoyer',
	  'enzyme',
	  'eolien',
	  'epaissir',
	  'epargne',
	  'epatant',
	  'epaule',
	  'epicerie',
	  'epidemie',
	  'epier',
	  'epilogue',
	  'epine',
	  'episode',
	  'epitaphe',
	  'epoque',
	  'epreuve',
	  'eprouver',
	  'epuisant',
	  'equerre',
	  'equipe',
	  'eriger',
	  'erosion',
	  'erreur',
	  'eruption',
	  'escalier',
	  'espadon',
	  'espece',
	  'espiegle',
	  'espoir',
	  'esprit',
	  'esquiver',
	  'essayer',
	  'essence',
	  'essieu',
	  'essorer',
	  'estime',
	  'estomac',
	  'estrade',
	  'etagere',
	  'etaler',
	  'etanche',
	  'etatique',
	  'eteindre',
	  'etendoir',
	  'eternel',
	  'ethanol',
	  'ethique',
	  'ethnie',
	  'etirer',
	  'etoffer',
	  'etoile',
	  'etonnant',
	  'etourdir',
	  'etrange',
	  'etroit',
	  'etude',
	  'euphorie',
	  'evaluer',
	  'evasion',
	  'eventail',
	  'evidence',
	  'eviter',
	  'evolutif',
	  'evoquer',
	  'exact',
	  'exagerer',
	  'exaucer',
	  'exceller',
	  'excitant',
	  'exclusif',
	  'excuse',
	  'executer',
	  'exemple',
	  'exercer',
	  'exhaler',
	  'exhorter',
	  'exigence',
	  'exiler',
	  'exister',
	  'exotique',
	  'expedier',
	  'explorer',
	  'exposer',
	  'exprimer',
	  'exquis',
	  'extensif',
	  'extraire',
	  'exulter',
	  'fable',
	  'fabuleux',
	  'facette',
	  'facile',
	  'facture',
	  'faiblir',
	  'falaise',
	  'fameux',
	  'famille',
	  'farceur',
	  'farfelu',
	  'farine',
	  'farouche',
	  'fasciner',
	  'fatal',
	  'fatigue',
	  'faucon',
	  'fautif',
	  'faveur',
	  'favori',
	  'febrile',
	  'feconder',
	  'federer',
	  'felin',
	  'femme',
	  'femur',
	  'fendoir',
	  'feodal',
	  'fermer',
	  'feroce',
	  'ferveur',
	  'festival',
	  'feuille',
	  'feutre',
	  'fevrier',
	  'fiasco',
	  'ficeler',
	  'fictif',
	  'fidele',
	  'figure',
	  'filature',
	  'filetage',
	  'filiere',
	  'filleul',
	  'filmer',
	  'filou',
	  'filtrer',
	  'financer',
	  'finir',
	  'fiole',
	  'firme',
	  'fissure',
	  'fixer',
	  'flairer',
	  'flamme',
	  'flasque',
	  'flatteur',
	  'fleau',
	  'fleche',
	  'fleur',
	  'flexion',
	  'flocon',
	  'flore',
	  'fluctuer',
	  'fluide',
	  'fluvial',
	  'folie',
	  'fonderie',
	  'fongible',
	  'fontaine',
	  'forcer',
	  'forgeron',
	  'formuler',
	  'fortune',
	  'fossile',
	  'foudre',
	  'fougere',
	  'fouiller',
	  'foulure',
	  'fourmi',
	  'fragile',
	  'fraise',
	  'franchir',
	  'frapper',
	  'frayeur',
	  'fregate',
	  'freiner',
	  'frelon',
	  'fremir',
	  'frenesie',
	  'frere',
	  'friable',
	  'friction',
	  'frisson',
	  'frivole',
	  'froid',
	  'fromage',
	  'frontal',
	  'frotter',
	  'fruit',
	  'fugitif',
	  'fuite',
	  'fureur',
	  'furieux',
	  'furtif',
	  'fusion',
	  'futur',
	  'gagner',
	  'galaxie',
	  'galerie',
	  'gambader',
	  'garantir',
	  'gardien',
	  'garnir',
	  'garrigue',
	  'gazelle',
	  'gazon',
	  'geant',
	  'gelatine',
	  'gelule',
	  'gendarme',
	  'general',
	  'genie',
	  'genou',
	  'gentil',
	  'geologie',
	  'geometre',
	  'geranium',
	  'germe',
	  'gestuel',
	  'geyser',
	  'gibier',
	  'gicler',
	  'girafe',
	  'givre',
	  'glace',
	  'glaive',
	  'glisser',
	  'globe',
	  'gloire',
	  'glorieux',
	  'golfeur',
	  'gomme',
	  'gonfler',
	  'gorge',
	  'gorille',
	  'goudron',
	  'gouffre',
	  'goulot',
	  'goupille',
	  'gourmand',
	  'goutte',
	  'graduel',
	  'graffiti',
	  'graine',
	  'grand',
	  'grappin',
	  'gratuit',
	  'gravir',
	  'grenat',
	  'griffure',
	  'griller',
	  'grimper',
	  'grogner',
	  'gronder',
	  'grotte',
	  'groupe',
	  'gruger',
	  'grutier',
	  'gruyere',
	  'guepard',
	  'guerrier',
	  'guide',
	  'guimauve',
	  'guitare',
	  'gustatif',
	  'gymnaste',
	  'gyrostat',
	  'habitude',
	  'hachoir',
	  'halte',
	  'hameau',
	  'hangar',
	  'hanneton',
	  'haricot',
	  'harmonie',
	  'harpon',
	  'hasard',
	  'helium',
	  'hematome',
	  'herbe',
	  'herisson',
	  'hermine',
	  'heron',
	  'hesiter',
	  'heureux',
	  'hiberner',
	  'hibou',
	  'hilarant',
	  'histoire',
	  'hiver',
	  'homard',
	  'hommage',
	  'homogene',
	  'honneur',
	  'honorer',
	  'honteux',
	  'horde',
	  'horizon',
	  'horloge',
	  'hormone',
	  'horrible',
	  'houleux',
	  'housse',
	  'hublot',
	  'huileux',
	  'humain',
	  'humble',
	  'humide',
	  'humour',
	  'hurler',
	  'hydromel',
	  'hygiene',
	  'hymne',
	  'hypnose',
	  'idylle',
	  'ignorer',
	  'iguane',
	  'illicite',
	  'illusion',
	  'image',
	  'imbiber',
	  'imiter',
	  'immense',
	  'immobile',
	  'immuable',
	  'impact',
	  'imperial',
	  'implorer',
	  'imposer',
	  'imprimer',
	  'imputer',
	  'incarner',
	  'incendie',
	  'incident',
	  'incliner',
	  'incolore',
	  'indexer',
	  'indice',
	  'inductif',
	  'inedit',
	  'ineptie',
	  'inexact',
	  'infini',
	  'infliger',
	  'informer',
	  'infusion',
	  'ingerer',
	  'inhaler',
	  'inhiber',
	  'injecter',
	  'injure',
	  'innocent',
	  'inoculer',
	  'inonder',
	  'inscrire',
	  'insecte',
	  'insigne',
	  'insolite',
	  'inspirer',
	  'instinct',
	  'insulter',
	  'intact',
	  'intense',
	  'intime',
	  'intrigue',
	  'intuitif',
	  'inutile',
	  'invasion',
	  'inventer',
	  'inviter',
	  'invoquer',
	  'ironique',
	  'irradier',
	  'irreel',
	  'irriter',
	  'isoler',
	  'ivoire',
	  'ivresse',
	  'jaguar',
	  'jaillir',
	  'jambe',
	  'janvier',
	  'jardin',
	  'jauger',
	  'jaune',
	  'javelot',
	  'jetable',
	  'jeton',
	  'jeudi',
	  'jeunesse',
	  'joindre',
	  'joncher',
	  'jongler',
	  'joueur',
	  'jouissif',
	  'journal',
	  'jovial',
	  'joyau',
	  'joyeux',
	  'jubiler',
	  'jugement',
	  'junior',
	  'jupon',
	  'juriste',
	  'justice',
	  'juteux',
	  'juvenile',
	  'kayak',
	  'kimono',
	  'kiosque',
	  'label',
	  'labial',
	  'labourer',
	  'lacerer',
	  'lactose',
	  'lagune',
	  'laine',
	  'laisser',
	  'laitier',
	  'lambeau',
	  'lamelle',
	  'lampe',
	  'lanceur',
	  'langage',
	  'lanterne',
	  'lapin',
	  'largeur',
	  'larme',
	  'laurier',
	  'lavabo',
	  'lavoir',
	  'lecture',
	  'legal',
	  'leger',
	  'legume',
	  'lessive',
	  'lettre',
	  'levier',
	  'lexique',
	  'lezard',
	  'liasse',
	  'liberer',
	  'libre',
	  'licence',
	  'licorne',
	  'liege',
	  'lievre',
	  'ligature',
	  'ligoter',
	  'ligue',
	  'limer',
	  'limite',
	  'limonade',
	  'limpide',
	  'lineaire',
	  'lingot',
	  'lionceau',
	  'liquide',
	  'lisiere',
	  'lister',
	  'lithium',
	  'litige',
	  'littoral',
	  'livreur',
	  'logique',
	  'lointain',
	  'loisir',
	  'lombric',
	  'loterie',
	  'louer',
	  'lourd',
	  'loutre',
	  'louve',
	  'loyal',
	  'lubie',
	  'lucide',
	  'lucratif',
	  'lueur',
	  'lugubre',
	  'luisant',
	  'lumiere',
	  'lunaire',
	  'lundi',
	  'luron',
	  'lutter',
	  'luxueux',
	  'machine',
	  'magasin',
	  'magenta',
	  'magique',
	  'maigre',
	  'maillon',
	  'maintien',
	  'mairie',
	  'maison',
	  'majorer',
	  'malaxer',
	  'malefice',
	  'malheur',
	  'malice',
	  'mallette',
	  'mammouth',
	  'mandater',
	  'maniable',
	  'manquant',
	  'manteau',
	  'manuel',
	  'marathon',
	  'marbre',
	  'marchand',
	  'mardi',
	  'maritime',
	  'marqueur',
	  'marron',
	  'marteler',
	  'mascotte',
	  'massif',
	  'materiel',
	  'matiere',
	  'matraque',
	  'maudire',
	  'maussade',
	  'mauve',
	  'maximal',
	  'mechant',
	  'meconnu',
	  'medaille',
	  'medecin',
	  'mediter',
	  'meduse',
	  'meilleur',
	  'melange',
	  'melodie',
	  'membre',
	  'memoire',
	  'menacer',
	  'mener',
	  'menhir',
	  'mensonge',
	  'mentor',
	  'mercredi',
	  'merite',
	  'merle',
	  'messager',
	  'mesure',
	  'metal',
	  'meteore',
	  'methode',
	  'metier',
	  'meuble',
	  'miauler',
	  'microbe',
	  'miette',
	  'mignon',
	  'migrer',
	  'milieu',
	  'million',
	  'mimique',
	  'mince',
	  'mineral',
	  'minimal',
	  'minorer',
	  'minute',
	  'miracle',
	  'miroiter',
	  'missile',
	  'mixte',
	  'mobile',
	  'moderne',
	  'moelleux',
	  'mondial',
	  'moniteur',
	  'monnaie',
	  'monotone',
	  'monstre',
	  'montagne',
	  'monument',
	  'moqueur',
	  'morceau',
	  'morsure',
	  'mortier',
	  'moteur',
	  'motif',
	  'mouche',
	  'moufle',
	  'moulin',
	  'mousson',
	  'mouton',
	  'mouvant',
	  'multiple',
	  'munition',
	  'muraille',
	  'murene',
	  'murmure',
	  'muscle',
	  'museum',
	  'musicien',
	  'mutation',
	  'muter',
	  'mutuel',
	  'myriade',
	  'myrtille',
	  'mystere',
	  'mythique',
	  'nageur',
	  'nappe',
	  'narquois',
	  'narrer',
	  'natation',
	  'nation',
	  'nature',
	  'naufrage',
	  'nautique',
	  'navire',
	  'nebuleux',
	  'nectar',
	  'nefaste',
	  'negation',
	  'negliger',
	  'negocier',
	  'neige',
	  'nerveux',
	  'nettoyer',
	  'neurone',
	  'neutron',
	  'neveu',
	  'niche',
	  'nickel',
	  'nitrate',
	  'niveau',
	  'noble',
	  'nocif',
	  'nocturne',
	  'noirceur',
	  'noisette',
	  'nomade',
	  'nombreux',
	  'nommer',
	  'normatif',
	  'notable',
	  'notifier',
	  'notoire',
	  'nourrir',
	  'nouveau',
	  'novateur',
	  'novembre',
	  'novice',
	  'nuage',
	  'nuancer',
	  'nuire',
	  'nuisible',
	  'numero',
	  'nuptial',
	  'nuque',
	  'nutritif',
	  'obeir',
	  'objectif',
	  'obliger',
	  'obscur',
	  'observer',
	  'obstacle',
	  'obtenir',
	  'obturer',
	  'occasion',
	  'occuper',
	  'ocean',
	  'octobre',
	  'octroyer',
	  'octupler',
	  'oculaire',
	  'odeur',
	  'odorant',
	  'offenser',
	  'officier',
	  'offrir',
	  'ogive',
	  'oiseau',
	  'oisillon',
	  'olfactif',
	  'olivier',
	  'ombrage',
	  'omettre',
	  'onctueux',
	  'onduler',
	  'onereux',
	  'onirique',
	  'opale',
	  'opaque',
	  'operer',
	  'opinion',
	  'opportun',
	  'opprimer',
	  'opter',
	  'optique',
	  'orageux',
	  'orange',
	  'orbite',
	  'ordonner',
	  'oreille',
	  'organe',
	  'orgueil',
	  'orifice',
	  'ornement',
	  'orque',
	  'ortie',
	  'osciller',
	  'osmose',
	  'ossature',
	  'otarie',
	  'ouragan',
	  'ourson',
	  'outil',
	  'outrager',
	  'ouvrage',
	  'ovation',
	  'oxyde',
	  'oxygene',
	  'ozone',
	  'paisible',
	  'palace',
	  'palmares',
	  'palourde',
	  'palper',
	  'panache',
	  'panda',
	  'pangolin',
	  'paniquer',
	  'panneau',
	  'panorama',
	  'pantalon',
	  'papaye',
	  'papier',
	  'papoter',
	  'papyrus',
	  'paradoxe',
	  'parcelle',
	  'paresse',
	  'parfumer',
	  'parler',
	  'parole',
	  'parrain',
	  'parsemer',
	  'partager',
	  'parure',
	  'parvenir',
	  'passion',
	  'pasteque',
	  'paternel',
	  'patience',
	  'patron',
	  'pavillon',
	  'pavoiser',
	  'payer',
	  'paysage',
	  'peigne',
	  'peintre',
	  'pelage',
	  'pelican',
	  'pelle',
	  'pelouse',
	  'peluche',
	  'pendule',
	  'penetrer',
	  'penible',
	  'pensif',
	  'penurie',
	  'pepite',
	  'peplum',
	  'perdrix',
	  'perforer',
	  'periode',
	  'permuter',
	  'perplexe',
	  'persil',
	  'perte',
	  'peser',
	  'petale',
	  'petit',
	  'petrir',
	  'peuple',
	  'pharaon',
	  'phobie',
	  'phoque',
	  'photon',
	  'phrase',
	  'physique',
	  'piano',
	  'pictural',
	  'piece',
	  'pierre',
	  'pieuvre',
	  'pilote',
	  'pinceau',
	  'pipette',
	  'piquer',
	  'pirogue',
	  'piscine',
	  'piston',
	  'pivoter',
	  'pixel',
	  'pizza',
	  'placard',
	  'plafond',
	  'plaisir',
	  'planer',
	  'plaque',
	  'plastron',
	  'plateau',
	  'pleurer',
	  'plexus',
	  'pliage',
	  'plomb',
	  'plonger',
	  'pluie',
	  'plumage',
	  'pochette',
	  'poesie',
	  'poete',
	  'pointe',
	  'poirier',
	  'poisson',
	  'poivre',
	  'polaire',
	  'policier',
	  'pollen',
	  'polygone',
	  'pommade',
	  'pompier',
	  'ponctuel',
	  'ponderer',
	  'poney',
	  'portique',
	  'position',
	  'posseder',
	  'posture',
	  'potager',
	  'poteau',
	  'potion',
	  'pouce',
	  'poulain',
	  'poumon',
	  'pourpre',
	  'poussin',
	  'pouvoir',
	  'prairie',
	  'pratique',
	  'precieux',
	  'predire',
	  'prefixe',
	  'prelude',
	  'prenom',
	  'presence',
	  'pretexte',
	  'prevoir',
	  'primitif',
	  'prince',
	  'prison',
	  'priver',
	  'probleme',
	  'proceder',
	  'prodige',
	  'profond',
	  'progres',
	  'proie',
	  'projeter',
	  'prologue',
	  'promener',
	  'propre',
	  'prospere',
	  'proteger',
	  'prouesse',
	  'proverbe',
	  'prudence',
	  'pruneau',
	  'psychose',
	  'public',
	  'puceron',
	  'puiser',
	  'pulpe',
	  'pulsar',
	  'punaise',
	  'punitif',
	  'pupitre',
	  'purifier',
	  'puzzle',
	  'pyramide',
	  'quasar',
	  'querelle',
	  'question',
	  'quietude',
	  'quitter',
	  'quotient',
	  'racine',
	  'raconter',
	  'radieux',
	  'ragondin',
	  'raideur',
	  'raisin',
	  'ralentir',
	  'rallonge',
	  'ramasser',
	  'rapide',
	  'rasage',
	  'ratisser',
	  'ravager',
	  'ravin',
	  'rayonner',
	  'reactif',
	  'reagir',
	  'realiser',
	  'reanimer',
	  'recevoir',
	  'reciter',
	  'reclamer',
	  'recolter',
	  'recruter',
	  'reculer',
	  'recycler',
	  'rediger',
	  'redouter',
	  'refaire',
	  'reflexe',
	  'reformer',
	  'refrain',
	  'refuge',
	  'regalien',
	  'region',
	  'reglage',
	  'regulier',
	  'reiterer',
	  'rejeter',
	  'rejouer',
	  'relatif',
	  'relever',
	  'relief',
	  'remarque',
	  'remede',
	  'remise',
	  'remonter',
	  'remplir',
	  'remuer',
	  'renard',
	  'renfort',
	  'renifler',
	  'renoncer',
	  'rentrer',
	  'renvoi',
	  'replier',
	  'reporter',
	  'reprise',
	  'reptile',
	  'requin',
	  'reserve',
	  'resineux',
	  'resoudre',
	  'respect',
	  'rester',
	  'resultat',
	  'retablir',
	  'retenir',
	  'reticule',
	  'retomber',
	  'retracer',
	  'reunion',
	  'reussir',
	  'revanche',
	  'revivre',
	  'revolte',
	  'revulsif',
	  'richesse',
	  'rideau',
	  'rieur',
	  'rigide',
	  'rigoler',
	  'rincer',
	  'riposter',
	  'risible',
	  'risque',
	  'rituel',
	  'rival',
	  'riviere',
	  'rocheux',
	  'romance',
	  'rompre',
	  'ronce',
	  'rondin',
	  'roseau',
	  'rosier',
	  'rotatif',
	  'rotor',
	  'rotule',
	  'rouge',
	  'rouille',
	  'rouleau',
	  'routine',
	  'royaume',
	  'ruban',
	  'rubis',
	  'ruche',
	  'ruelle',
	  'rugueux',
	  'ruiner',
	  'ruisseau',
	  'ruser',
	  'rustique',
	  'rythme',
	  'sabler',
	  'saboter',
	  'sabre',
	  'sacoche',
	  'safari',
	  'sagesse',
	  'saisir',
	  'salade',
	  'salive',
	  'salon',
	  'saluer',
	  'samedi',
	  'sanction',
	  'sanglier',
	  'sarcasme',
	  'sardine',
	  'saturer',
	  'saugrenu',
	  'saumon',
	  'sauter',
	  'sauvage',
	  'savant',
	  'savonner',
	  'scalpel',
	  'scandale',
	  'scelerat',
	  'scenario',
	  'sceptre',
	  'schema',
	  'science',
	  'scinder',
	  'score',
	  'scrutin',
	  'sculpter',
	  'seance',
	  'secable',
	  'secher',
	  'secouer',
	  'secreter',
	  'sedatif',
	  'seduire',
	  'seigneur',
	  'sejour',
	  'selectif',
	  'semaine',
	  'sembler',
	  'semence',
	  'seminal',
	  'senateur',
	  'sensible',
	  'sentence',
	  'separer',
	  'sequence',
	  'serein',
	  'sergent',
	  'serieux',
	  'serrure',
	  'serum',
	  'service',
	  'sesame',
	  'sevir',
	  'sevrage',
	  'sextuple',
	  'sideral',
	  'siecle',
	  'sieger',
	  'siffler',
	  'sigle',
	  'signal',
	  'silence',
	  'silicium',
	  'simple',
	  'sincere',
	  'sinistre',
	  'siphon',
	  'sirop',
	  'sismique',
	  'situer',
	  'skier',
	  'social',
	  'socle',
	  'sodium',
	  'soigneux',
	  'soldat',
	  'soleil',
	  'solitude',
	  'soluble',
	  'sombre',
	  'sommeil',
	  'somnoler',
	  'sonde',
	  'songeur',
	  'sonnette',
	  'sonore',
	  'sorcier',
	  'sortir',
	  'sosie',
	  'sottise',
	  'soucieux',
	  'soudure',
	  'souffle',
	  'soulever',
	  'soupape',
	  'source',
	  'soutirer',
	  'souvenir',
	  'spacieux',
	  'spatial',
	  'special',
	  'sphere',
	  'spiral',
	  'stable',
	  'station',
	  'sternum',
	  'stimulus',
	  'stipuler',
	  'strict',
	  'studieux',
	  'stupeur',
	  'styliste',
	  'sublime',
	  'substrat',
	  'subtil',
	  'subvenir',
	  'succes',
	  'sucre',
	  'suffixe',
	  'suggerer',
	  'suiveur',
	  'sulfate',
	  'superbe',
	  'supplier',
	  'surface',
	  'suricate',
	  'surmener',
	  'surprise',
	  'sursaut',
	  'survie',
	  'suspect',
	  'syllabe',
	  'symbole',
	  'symetrie',
	  'synapse',
	  'syntaxe',
	  'systeme',
	  'tabac',
	  'tablier',
	  'tactile',
	  'tailler',
	  'talent',
	  'talisman',
	  'talonner',
	  'tambour',
	  'tamiser',
	  'tangible',
	  'tapis',
	  'taquiner',
	  'tarder',
	  'tarif',
	  'tartine',
	  'tasse',
	  'tatami',
	  'tatouage',
	  'taupe',
	  'taureau',
	  'taxer',
	  'temoin',
	  'temporel',
	  'tenaille',
	  'tendre',
	  'teneur',
	  'tenir',
	  'tension',
	  'terminer',
	  'terne',
	  'terrible',
	  'tetine',
	  'texte',
	  'theme',
	  'theorie',
	  'therapie',
	  'thorax',
	  'tibia',
	  'tiede',
	  'timide',
	  'tirelire',
	  'tiroir',
	  'tissu',
	  'titane',
	  'titre',
	  'tituber',
	  'toboggan',
	  'tolerant',
	  'tomate',
	  'tonique',
	  'tonneau',
	  'toponyme',
	  'torche',
	  'tordre',
	  'tornade',
	  'torpille',
	  'torrent',
	  'torse',
	  'tortue',
	  'totem',
	  'toucher',
	  'tournage',
	  'tousser',
	  'toxine',
	  'traction',
	  'trafic',
	  'tragique',
	  'trahir',
	  'train',
	  'trancher',
	  'travail',
	  'trefle',
	  'tremper',
	  'tresor',
	  'treuil',
	  'triage',
	  'tribunal',
	  'tricoter',
	  'trilogie',
	  'triomphe',
	  'tripler',
	  'triturer',
	  'trivial',
	  'trombone',
	  'tronc',
	  'tropical',
	  'troupeau',
	  'tuile',
	  'tulipe',
	  'tumulte',
	  'tunnel',
	  'turbine',
	  'tuteur',
	  'tutoyer',
	  'tuyau',
	  'tympan',
	  'typhon',
	  'typique',
	  'tyran',
	  'ubuesque',
	  'ultime',
	  'ultrason',
	  'unanime',
	  'unifier',
	  'union',
	  'unique',
	  'unitaire',
	  'univers',
	  'uranium',
	  'urbain',
	  'urticant',
	  'usage',
	  'usine',
	  'usuel',
	  'usure',
	  'utile',
	  'utopie',
	  'vacarme',
	  'vaccin',
	  'vagabond',
	  'vague',
	  'vaillant',
	  'vaincre',
	  'vaisseau',
	  'valable',
	  'valise',
	  'vallon',
	  'valve',
	  'vampire',
	  'vanille',
	  'vapeur',
	  'varier',
	  'vaseux',
	  'vassal',
	  'vaste',
	  'vecteur',
	  'vedette',
	  'vegetal',
	  'vehicule',
	  'veinard',
	  'veloce',
	  'vendredi',
	  'venerer',
	  'venger',
	  'venimeux',
	  'ventouse',
	  'verdure',
	  'verin',
	  'vernir',
	  'verrou',
	  'verser',
	  'vertu',
	  'veston',
	  'veteran',
	  'vetuste',
	  'vexant',
	  'vexer',
	  'viaduc',
	  'viande',
	  'victoire',
	  'vidange',
	  'video',
	  'vignette',
	  'vigueur',
	  'vilain',
	  'village',
	  'vinaigre',
	  'violon',
	  'vipere',
	  'virement',
	  'virtuose',
	  'virus',
	  'visage',
	  'viseur',
	  'vision',
	  'visqueux',
	  'visuel',
	  'vital',
	  'vitesse',
	  'viticole',
	  'vitrine',
	  'vivace',
	  'vivipare',
	  'vocation',
	  'voguer',
	  'voile',
	  'voisin',
	  'voiture',
	  'volaille',
	  'volcan',
	  'voltiger',
	  'volume',
	  'vorace',
	  'vortex',
	  'voter',
	  'vouloir',
	  'voyage',
	  'voyelle',
	  'wagon',
	  'xenon',
	  'yacht',
	  'zebre',
	  'zenith',
	  'zeste',
	  'zoologie'
	];
	return french;
}

var italian;
var hasRequiredItalian;

function requireItalian () {
	if (hasRequiredItalian) return italian;
	hasRequiredItalian = 1;

	italian = [
	  'abaco',
	  'abbaglio',
	  'abbinato',
	  'abete',
	  'abisso',
	  'abolire',
	  'abrasivo',
	  'abrogato',
	  'accadere',
	  'accenno',
	  'accusato',
	  'acetone',
	  'achille',
	  'acido',
	  'acqua',
	  'acre',
	  'acrilico',
	  'acrobata',
	  'acuto',
	  'adagio',
	  'addebito',
	  'addome',
	  'adeguato',
	  'aderire',
	  'adipe',
	  'adottare',
	  'adulare',
	  'affabile',
	  'affetto',
	  'affisso',
	  'affranto',
	  'aforisma',
	  'afoso',
	  'africano',
	  'agave',
	  'agente',
	  'agevole',
	  'aggancio',
	  'agire',
	  'agitare',
	  'agonismo',
	  'agricolo',
	  'agrumeto',
	  'aguzzo',
	  'alabarda',
	  'alato',
	  'albatro',
	  'alberato',
	  'albo',
	  'albume',
	  'alce',
	  'alcolico',
	  'alettone',
	  'alfa',
	  'algebra',
	  'aliante',
	  'alibi',
	  'alimento',
	  'allagato',
	  'allegro',
	  'allievo',
	  'allodola',
	  'allusivo',
	  'almeno',
	  'alogeno',
	  'alpaca',
	  'alpestre',
	  'altalena',
	  'alterno',
	  'alticcio',
	  'altrove',
	  'alunno',
	  'alveolo',
	  'alzare',
	  'amalgama',
	  'amanita',
	  'amarena',
	  'ambito',
	  'ambrato',
	  'ameba',
	  'america',
	  'ametista',
	  'amico',
	  'ammasso',
	  'ammenda',
	  'ammirare',
	  'ammonito',
	  'amore',
	  'ampio',
	  'ampliare',
	  'amuleto',
	  'anacardo',
	  'anagrafe',
	  'analista',
	  'anarchia',
	  'anatra',
	  'anca',
	  'ancella',
	  'ancora',
	  'andare',
	  'andrea',
	  'anello',
	  'angelo',
	  'angolare',
	  'angusto',
	  'anima',
	  'annegare',
	  'annidato',
	  'anno',
	  'annuncio',
	  'anonimo',
	  'anticipo',
	  'anzi',
	  'apatico',
	  'apertura',
	  'apode',
	  'apparire',
	  'appetito',
	  'appoggio',
	  'approdo',
	  'appunto',
	  'aprile',
	  'arabica',
	  'arachide',
	  'aragosta',
	  'araldica',
	  'arancio',
	  'aratura',
	  'arazzo',
	  'arbitro',
	  'archivio',
	  'ardito',
	  'arenile',
	  'argento',
	  'argine',
	  'arguto',
	  'aria',
	  'armonia',
	  'arnese',
	  'arredato',
	  'arringa',
	  'arrosto',
	  'arsenico',
	  'arso',
	  'artefice',
	  'arzillo',
	  'asciutto',
	  'ascolto',
	  'asepsi',
	  'asettico',
	  'asfalto',
	  'asino',
	  'asola',
	  'aspirato',
	  'aspro',
	  'assaggio',
	  'asse',
	  'assoluto',
	  'assurdo',
	  'asta',
	  'astenuto',
	  'astice',
	  'astratto',
	  'atavico',
	  'ateismo',
	  'atomico',
	  'atono',
	  'attesa',
	  'attivare',
	  'attorno',
	  'attrito',
	  'attuale',
	  'ausilio',
	  'austria',
	  'autista',
	  'autonomo',
	  'autunno',
	  'avanzato',
	  'avere',
	  'avvenire',
	  'avviso',
	  'avvolgere',
	  'azione',
	  'azoto',
	  'azzimo',
	  'azzurro',
	  'babele',
	  'baccano',
	  'bacino',
	  'baco',
	  'badessa',
	  'badilata',
	  'bagnato',
	  'baita',
	  'balcone',
	  'baldo',
	  'balena',
	  'ballata',
	  'balzano',
	  'bambino',
	  'bandire',
	  'baraonda',
	  'barbaro',
	  'barca',
	  'baritono',
	  'barlume',
	  'barocco',
	  'basilico',
	  'basso',
	  'batosta',
	  'battuto',
	  'baule',
	  'bava',
	  'bavosa',
	  'becco',
	  'beffa',
	  'belgio',
	  'belva',
	  'benda',
	  'benevole',
	  'benigno',
	  'benzina',
	  'bere',
	  'berlina',
	  'beta',
	  'bibita',
	  'bici',
	  'bidone',
	  'bifido',
	  'biga',
	  'bilancia',
	  'bimbo',
	  'binocolo',
	  'biologo',
	  'bipede',
	  'bipolare',
	  'birbante',
	  'birra',
	  'biscotto',
	  'bisesto',
	  'bisnonno',
	  'bisonte',
	  'bisturi',
	  'bizzarro',
	  'blando',
	  'blatta',
	  'bollito',
	  'bonifico',
	  'bordo',
	  'bosco',
	  'botanico',
	  'bottino',
	  'bozzolo',
	  'braccio',
	  'bradipo',
	  'brama',
	  'branca',
	  'bravura',
	  'bretella',
	  'brevetto',
	  'brezza',
	  'briglia',
	  'brillante',
	  'brindare',
	  'broccolo',
	  'brodo',
	  'bronzina',
	  'brullo',
	  'bruno',
	  'bubbone',
	  'buca',
	  'budino',
	  'buffone',
	  'buio',
	  'bulbo',
	  'buono',
	  'burlone',
	  'burrasca',
	  'bussola',
	  'busta',
	  'cadetto',
	  'caduco',
	  'calamaro',
	  'calcolo',
	  'calesse',
	  'calibro',
	  'calmo',
	  'caloria',
	  'cambusa',
	  'camerata',
	  'camicia',
	  'cammino',
	  'camola',
	  'campale',
	  'canapa',
	  'candela',
	  'cane',
	  'canino',
	  'canotto',
	  'cantina',
	  'capace',
	  'capello',
	  'capitolo',
	  'capogiro',
	  'cappero',
	  'capra',
	  'capsula',
	  'carapace',
	  'carcassa',
	  'cardo',
	  'carisma',
	  'carovana',
	  'carretto',
	  'cartolina',
	  'casaccio',
	  'cascata',
	  'caserma',
	  'caso',
	  'cassone',
	  'castello',
	  'casuale',
	  'catasta',
	  'catena',
	  'catrame',
	  'cauto',
	  'cavillo',
	  'cedibile',
	  'cedrata',
	  'cefalo',
	  'celebre',
	  'cellulare',
	  'cena',
	  'cenone',
	  'centesimo',
	  'ceramica',
	  'cercare',
	  'certo',
	  'cerume',
	  'cervello',
	  'cesoia',
	  'cespo',
	  'ceto',
	  'chela',
	  'chiaro',
	  'chicca',
	  'chiedere',
	  'chimera',
	  'china',
	  'chirurgo',
	  'chitarra',
	  'ciao',
	  'ciclismo',
	  'cifrare',
	  'cigno',
	  'cilindro',
	  'ciottolo',
	  'circa',
	  'cirrosi',
	  'citrico',
	  'cittadino',
	  'ciuffo',
	  'civetta',
	  'civile',
	  'classico',
	  'clinica',
	  'cloro',
	  'cocco',
	  'codardo',
	  'codice',
	  'coerente',
	  'cognome',
	  'collare',
	  'colmato',
	  'colore',
	  'colposo',
	  'coltivato',
	  'colza',
	  'coma',
	  'cometa',
	  'commando',
	  'comodo',
	  'computer',
	  'comune',
	  'conciso',
	  'condurre',
	  'conferma',
	  'congelare',
	  'coniuge',
	  'connesso',
	  'conoscere',
	  'consumo',
	  'continuo',
	  'convegno',
	  'coperto',
	  'copione',
	  'coppia',
	  'copricapo',
	  'corazza',
	  'cordata',
	  'coricato',
	  'cornice',
	  'corolla',
	  'corpo',
	  'corredo',
	  'corsia',
	  'cortese',
	  'cosmico',
	  'costante',
	  'cottura',
	  'covato',
	  'cratere',
	  'cravatta',
	  'creato',
	  'credere',
	  'cremoso',
	  'crescita',
	  'creta',
	  'criceto',
	  'crinale',
	  'crisi',
	  'critico',
	  'croce',
	  'cronaca',
	  'crostata',
	  'cruciale',
	  'crusca',
	  'cucire',
	  'cuculo',
	  'cugino',
	  'cullato',
	  'cupola',
	  'curatore',
	  'cursore',
	  'curvo',
	  'cuscino',
	  'custode',
	  'dado',
	  'daino',
	  'dalmata',
	  'damerino',
	  'daniela',
	  'dannoso',
	  'danzare',
	  'datato',
	  'davanti',
	  'davvero',
	  'debutto',
	  'decennio',
	  'deciso',
	  'declino',
	  'decollo',
	  'decreto',
	  'dedicato',
	  'definito',
	  'deforme',
	  'degno',
	  'delegare',
	  'delfino',
	  'delirio',
	  'delta',
	  'demenza',
	  'denotato',
	  'dentro',
	  'deposito',
	  'derapata',
	  'derivare',
	  'deroga',
	  'descritto',
	  'deserto',
	  'desiderio',
	  'desumere',
	  'detersivo',
	  'devoto',
	  'diametro',
	  'dicembre',
	  'diedro',
	  'difeso',
	  'diffuso',
	  'digerire',
	  'digitale',
	  'diluvio',
	  'dinamico',
	  'dinnanzi',
	  'dipinto',
	  'diploma',
	  'dipolo',
	  'diradare',
	  'dire',
	  'dirotto',
	  'dirupo',
	  'disagio',
	  'discreto',
	  'disfare',
	  'disgelo',
	  'disposto',
	  'distanza',
	  'disumano',
	  'dito',
	  'divano',
	  'divelto',
	  'dividere',
	  'divorato',
	  'doblone',
	  'docente',
	  'doganale',
	  'dogma',
	  'dolce',
	  'domato',
	  'domenica',
	  'dominare',
	  'dondolo',
	  'dono',
	  'dormire',
	  'dote',
	  'dottore',
	  'dovuto',
	  'dozzina',
	  'drago',
	  'druido',
	  'dubbio',
	  'dubitare',
	  'ducale',
	  'duna',
	  'duomo',
	  'duplice',
	  'duraturo',
	  'ebano',
	  'eccesso',
	  'ecco',
	  'eclissi',
	  'economia',
	  'edera',
	  'edicola',
	  'edile',
	  'editoria',
	  'educare',
	  'egemonia',
	  'egli',
	  'egoismo',
	  'egregio',
	  'elaborato',
	  'elargire',
	  'elegante',
	  'elencato',
	  'eletto',
	  'elevare',
	  'elfico',
	  'elica',
	  'elmo',
	  'elsa',
	  'eluso',
	  'emanato',
	  'emblema',
	  'emesso',
	  'emiro',
	  'emotivo',
	  'emozione',
	  'empirico',
	  'emulo',
	  'endemico',
	  'enduro',
	  'energia',
	  'enfasi',
	  'enoteca',
	  'entrare',
	  'enzima',
	  'epatite',
	  'epilogo',
	  'episodio',
	  'epocale',
	  'eppure',
	  'equatore',
	  'erario',
	  'erba',
	  'erboso',
	  'erede',
	  'eremita',
	  'erigere',
	  'ermetico',
	  'eroe',
	  'erosivo',
	  'errante',
	  'esagono',
	  'esame',
	  'esanime',
	  'esaudire',
	  'esca',
	  'esempio',
	  'esercito',
	  'esibito',
	  'esigente',
	  'esistere',
	  'esito',
	  'esofago',
	  'esortato',
	  'esoso',
	  'espanso',
	  'espresso',
	  'essenza',
	  'esso',
	  'esteso',
	  'estimare',
	  'estonia',
	  'estroso',
	  'esultare',
	  'etilico',
	  'etnico',
	  'etrusco',
	  'etto',
	  'euclideo',
	  'europa',
	  'evaso',
	  'evidenza',
	  'evitato',
	  'evoluto',
	  'evviva',
	  'fabbrica',
	  'faccenda',
	  'fachiro',
	  'falco',
	  'famiglia',
	  'fanale',
	  'fanfara',
	  'fango',
	  'fantasma',
	  'fare',
	  'farfalla',
	  'farinoso',
	  'farmaco',
	  'fascia',
	  'fastoso',
	  'fasullo',
	  'faticare',
	  'fato',
	  'favoloso',
	  'febbre',
	  'fecola',
	  'fede',
	  'fegato',
	  'felpa',
	  'feltro',
	  'femmina',
	  'fendere',
	  'fenomeno',
	  'fermento',
	  'ferro',
	  'fertile',
	  'fessura',
	  'festivo',
	  'fetta',
	  'feudo',
	  'fiaba',
	  'fiducia',
	  'fifa',
	  'figurato',
	  'filo',
	  'finanza',
	  'finestra',
	  'finire',
	  'fiore',
	  'fiscale',
	  'fisico',
	  'fiume',
	  'flacone',
	  'flamenco',
	  'flebo',
	  'flemma',
	  'florido',
	  'fluente',
	  'fluoro',
	  'fobico',
	  'focaccia',
	  'focoso',
	  'foderato',
	  'foglio',
	  'folata',
	  'folclore',
	  'folgore',
	  'fondente',
	  'fonetico',
	  'fonia',
	  'fontana',
	  'forbito',
	  'forchetta',
	  'foresta',
	  'formica',
	  'fornaio',
	  'foro',
	  'fortezza',
	  'forzare',
	  'fosfato',
	  'fosso',
	  'fracasso',
	  'frana',
	  'frassino',
	  'fratello',
	  'freccetta',
	  'frenata',
	  'fresco',
	  'frigo',
	  'frollino',
	  'fronde',
	  'frugale',
	  'frutta',
	  'fucilata',
	  'fucsia',
	  'fuggente',
	  'fulmine',
	  'fulvo',
	  'fumante',
	  'fumetto',
	  'fumoso',
	  'fune',
	  'funzione',
	  'fuoco',
	  'furbo',
	  'furgone',
	  'furore',
	  'fuso',
	  'futile',
	  'gabbiano',
	  'gaffe',
	  'galateo',
	  'gallina',
	  'galoppo',
	  'gambero',
	  'gamma',
	  'garanzia',
	  'garbo',
	  'garofano',
	  'garzone',
	  'gasdotto',
	  'gasolio',
	  'gastrico',
	  'gatto',
	  'gaudio',
	  'gazebo',
	  'gazzella',
	  'geco',
	  'gelatina',
	  'gelso',
	  'gemello',
	  'gemmato',
	  'gene',
	  'genitore',
	  'gennaio',
	  'genotipo',
	  'gergo',
	  'ghepardo',
	  'ghiaccio',
	  'ghisa',
	  'giallo',
	  'gilda',
	  'ginepro',
	  'giocare',
	  'gioiello',
	  'giorno',
	  'giove',
	  'girato',
	  'girone',
	  'gittata',
	  'giudizio',
	  'giurato',
	  'giusto',
	  'globulo',
	  'glutine',
	  'gnomo',
	  'gobba',
	  'golf',
	  'gomito',
	  'gommone',
	  'gonfio',
	  'gonna',
	  'governo',
	  'gracile',
	  'grado',
	  'grafico',
	  'grammo',
	  'grande',
	  'grattare',
	  'gravoso',
	  'grazia',
	  'greca',
	  'gregge',
	  'grifone',
	  'grigio',
	  'grinza',
	  'grotta',
	  'gruppo',
	  'guadagno',
	  'guaio',
	  'guanto',
	  'guardare',
	  'gufo',
	  'guidare',
	  'ibernato',
	  'icona',
	  'identico',
	  'idillio',
	  'idolo',
	  'idra',
	  'idrico',
	  'idrogeno',
	  'igiene',
	  'ignaro',
	  'ignorato',
	  'ilare',
	  'illeso',
	  'illogico',
	  'illudere',
	  'imballo',
	  'imbevuto',
	  'imbocco',
	  'imbuto',
	  'immane',
	  'immerso',
	  'immolato',
	  'impacco',
	  'impeto',
	  'impiego',
	  'importo',
	  'impronta',
	  'inalare',
	  'inarcare',
	  'inattivo',
	  'incanto',
	  'incendio',
	  'inchino',
	  'incisivo',
	  'incluso',
	  'incontro',
	  'incrocio',
	  'incubo',
	  'indagine',
	  'india',
	  'indole',
	  'inedito',
	  'infatti',
	  'infilare',
	  'inflitto',
	  'ingaggio',
	  'ingegno',
	  'inglese',
	  'ingordo',
	  'ingrosso',
	  'innesco',
	  'inodore',
	  'inoltrare',
	  'inondato',
	  'insano',
	  'insetto',
	  'insieme',
	  'insonnia',
	  'insulina',
	  'intasato',
	  'intero',
	  'intonaco',
	  'intuito',
	  'inumidire',
	  'invalido',
	  'invece',
	  'invito',
	  'iperbole',
	  'ipnotico',
	  'ipotesi',
	  'ippica',
	  'iride',
	  'irlanda',
	  'ironico',
	  'irrigato',
	  'irrorare',
	  'isolato',
	  'isotopo',
	  'isterico',
	  'istituto',
	  'istrice',
	  'italia',
	  'iterare',
	  'labbro',
	  'labirinto',
	  'lacca',
	  'lacerato',
	  'lacrima',
	  'lacuna',
	  'laddove',
	  'lago',
	  'lampo',
	  'lancetta',
	  'lanterna',
	  'lardoso',
	  'larga',
	  'laringe',
	  'lastra',
	  'latenza',
	  'latino',
	  'lattuga',
	  'lavagna',
	  'lavoro',
	  'legale',
	  'leggero',
	  'lembo',
	  'lentezza',
	  'lenza',
	  'leone',
	  'lepre',
	  'lesivo',
	  'lessato',
	  'lesto',
	  'letterale',
	  'leva',
	  'levigato',
	  'libero',
	  'lido',
	  'lievito',
	  'lilla',
	  'limatura',
	  'limitare',
	  'limpido',
	  'lineare',
	  'lingua',
	  'liquido',
	  'lira',
	  'lirica',
	  'lisca',
	  'lite',
	  'litigio',
	  'livrea',
	  'locanda',
	  'lode',
	  'logica',
	  'lombare',
	  'londra',
	  'longevo',
	  'loquace',
	  'lorenzo',
	  'loto',
	  'lotteria',
	  'luce',
	  'lucidato',
	  'lumaca',
	  'luminoso',
	  'lungo',
	  'lupo',
	  'luppolo',
	  'lusinga',
	  'lusso',
	  'lutto',
	  'macabro',
	  'macchina',
	  'macero',
	  'macinato',
	  'madama',
	  'magico',
	  'maglia',
	  'magnete',
	  'magro',
	  'maiolica',
	  'malafede',
	  'malgrado',
	  'malinteso',
	  'malsano',
	  'malto',
	  'malumore',
	  'mana',
	  'mancia',
	  'mandorla',
	  'mangiare',
	  'manifesto',
	  'mannaro',
	  'manovra',
	  'mansarda',
	  'mantide',
	  'manubrio',
	  'mappa',
	  'maratona',
	  'marcire',
	  'maretta',
	  'marmo',
	  'marsupio',
	  'maschera',
	  'massaia',
	  'mastino',
	  'materasso',
	  'matricola',
	  'mattone',
	  'maturo',
	  'mazurca',
	  'meandro',
	  'meccanico',
	  'mecenate',
	  'medesimo',
	  'meditare',
	  'mega',
	  'melassa',
	  'melis',
	  'melodia',
	  'meninge',
	  'meno',
	  'mensola',
	  'mercurio',
	  'merenda',
	  'merlo',
	  'meschino',
	  'mese',
	  'messere',
	  'mestolo',
	  'metallo',
	  'metodo',
	  'mettere',
	  'miagolare',
	  'mica',
	  'micelio',
	  'michele',
	  'microbo',
	  'midollo',
	  'miele',
	  'migliore',
	  'milano',
	  'milite',
	  'mimosa',
	  'minerale',
	  'mini',
	  'minore',
	  'mirino',
	  'mirtillo',
	  'miscela',
	  'missiva',
	  'misto',
	  'misurare',
	  'mitezza',
	  'mitigare',
	  'mitra',
	  'mittente',
	  'mnemonico',
	  'modello',
	  'modifica',
	  'modulo',
	  'mogano',
	  'mogio',
	  'mole',
	  'molosso',
	  'monastero',
	  'monco',
	  'mondina',
	  'monetario',
	  'monile',
	  'monotono',
	  'monsone',
	  'montato',
	  'monviso',
	  'mora',
	  'mordere',
	  'morsicato',
	  'mostro',
	  'motivato',
	  'motosega',
	  'motto',
	  'movenza',
	  'movimento',
	  'mozzo',
	  'mucca',
	  'mucosa',
	  'muffa',
	  'mughetto',
	  'mugnaio',
	  'mulatto',
	  'mulinello',
	  'multiplo',
	  'mummia',
	  'munto',
	  'muovere',
	  'murale',
	  'musa',
	  'muscolo',
	  'musica',
	  'mutevole',
	  'muto',
	  'nababbo',
	  'nafta',
	  'nanometro',
	  'narciso',
	  'narice',
	  'narrato',
	  'nascere',
	  'nastrare',
	  'naturale',
	  'nautica',
	  'naviglio',
	  'nebulosa',
	  'necrosi',
	  'negativo',
	  'negozio',
	  'nemmeno',
	  'neofita',
	  'neretto',
	  'nervo',
	  'nessuno',
	  'nettuno',
	  'neutrale',
	  'neve',
	  'nevrotico',
	  'nicchia',
	  'ninfa',
	  'nitido',
	  'nobile',
	  'nocivo',
	  'nodo',
	  'nome',
	  'nomina',
	  'nordico',
	  'normale',
	  'norvegese',
	  'nostrano',
	  'notare',
	  'notizia',
	  'notturno',
	  'novella',
	  'nucleo',
	  'nulla',
	  'numero',
	  'nuovo',
	  'nutrire',
	  'nuvola',
	  'nuziale',
	  'oasi',
	  'obbedire',
	  'obbligo',
	  'obelisco',
	  'oblio',
	  'obolo',
	  'obsoleto',
	  'occasione',
	  'occhio',
	  'occidente',
	  'occorrere',
	  'occultare',
	  'ocra',
	  'oculato',
	  'odierno',
	  'odorare',
	  'offerta',
	  'offrire',
	  'offuscato',
	  'oggetto',
	  'oggi',
	  'ognuno',
	  'olandese',
	  'olfatto',
	  'oliato',
	  'oliva',
	  'ologramma',
	  'oltre',
	  'omaggio',
	  'ombelico',
	  'ombra',
	  'omega',
	  'omissione',
	  'ondoso',
	  'onere',
	  'onice',
	  'onnivoro',
	  'onorevole',
	  'onta',
	  'operato',
	  'opinione',
	  'opposto',
	  'oracolo',
	  'orafo',
	  'ordine',
	  'orecchino',
	  'orefice',
	  'orfano',
	  'organico',
	  'origine',
	  'orizzonte',
	  'orma',
	  'ormeggio',
	  'ornativo',
	  'orologio',
	  'orrendo',
	  'orribile',
	  'ortensia',
	  'ortica',
	  'orzata',
	  'orzo',
	  'osare',
	  'oscurare',
	  'osmosi',
	  'ospedale',
	  'ospite',
	  'ossa',
	  'ossidare',
	  'ostacolo',
	  'oste',
	  'otite',
	  'otre',
	  'ottagono',
	  'ottimo',
	  'ottobre',
	  'ovale',
	  'ovest',
	  'ovino',
	  'oviparo',
	  'ovocito',
	  'ovunque',
	  'ovviare',
	  'ozio',
	  'pacchetto',
	  'pace',
	  'pacifico',
	  'padella',
	  'padrone',
	  'paese',
	  'paga',
	  'pagina',
	  'palazzina',
	  'palesare',
	  'pallido',
	  'palo',
	  'palude',
	  'pandoro',
	  'pannello',
	  'paolo',
	  'paonazzo',
	  'paprica',
	  'parabola',
	  'parcella',
	  'parere',
	  'pargolo',
	  'pari',
	  'parlato',
	  'parola',
	  'partire',
	  'parvenza',
	  'parziale',
	  'passivo',
	  'pasticca',
	  'patacca',
	  'patologia',
	  'pattume',
	  'pavone',
	  'peccato',
	  'pedalare',
	  'pedonale',
	  'peggio',
	  'peloso',
	  'penare',
	  'pendice',
	  'penisola',
	  'pennuto',
	  'penombra',
	  'pensare',
	  'pentola',
	  'pepe',
	  'pepita',
	  'perbene',
	  'percorso',
	  'perdonato',
	  'perforare',
	  'pergamena',
	  'periodo',
	  'permesso',
	  'perno',
	  'perplesso',
	  'persuaso',
	  'pertugio',
	  'pervaso',
	  'pesatore',
	  'pesista',
	  'peso',
	  'pestifero',
	  'petalo',
	  'pettine',
	  'petulante',
	  'pezzo',
	  'piacere',
	  'pianta',
	  'piattino',
	  'piccino',
	  'picozza',
	  'piega',
	  'pietra',
	  'piffero',
	  'pigiama',
	  'pigolio',
	  'pigro',
	  'pila',
	  'pilifero',
	  'pillola',
	  'pilota',
	  'pimpante',
	  'pineta',
	  'pinna',
	  'pinolo',
	  'pioggia',
	  'piombo',
	  'piramide',
	  'piretico',
	  'pirite',
	  'pirolisi',
	  'pitone',
	  'pizzico',
	  'placebo',
	  'planare',
	  'plasma',
	  'platano',
	  'plenario',
	  'pochezza',
	  'poderoso',
	  'podismo',
	  'poesia',
	  'poggiare',
	  'polenta',
	  'poligono',
	  'pollice',
	  'polmonite',
	  'polpetta',
	  'polso',
	  'poltrona',
	  'polvere',
	  'pomice',
	  'pomodoro',
	  'ponte',
	  'popoloso',
	  'porfido',
	  'poroso',
	  'porpora',
	  'porre',
	  'portata',
	  'posa',
	  'positivo',
	  'possesso',
	  'postulato',
	  'potassio',
	  'potere',
	  'pranzo',
	  'prassi',
	  'pratica',
	  'precluso',
	  'predica',
	  'prefisso',
	  'pregiato',
	  'prelievo',
	  'premere',
	  'prenotare',
	  'preparato',
	  'presenza',
	  'pretesto',
	  'prevalso',
	  'prima',
	  'principe',
	  'privato',
	  'problema',
	  'procura',
	  'produrre',
	  'profumo',
	  'progetto',
	  'prolunga',
	  'promessa',
	  'pronome',
	  'proposta',
	  'proroga',
	  'proteso',
	  'prova',
	  'prudente',
	  'prugna',
	  'prurito',
	  'psiche',
	  'pubblico',
	  'pudica',
	  'pugilato',
	  'pugno',
	  'pulce',
	  'pulito',
	  'pulsante',
	  'puntare',
	  'pupazzo',
	  'pupilla',
	  'puro',
	  'quadro',
	  'qualcosa',
	  'quasi',
	  'querela',
	  'quota',
	  'raccolto',
	  'raddoppio',
	  'radicale',
	  'radunato',
	  'raffica',
	  'ragazzo',
	  'ragione',
	  'ragno',
	  'ramarro',
	  'ramingo',
	  'ramo',
	  'randagio',
	  'rantolare',
	  'rapato',
	  'rapina',
	  'rappreso',
	  'rasatura',
	  'raschiato',
	  'rasente',
	  'rassegna',
	  'rastrello',
	  'rata',
	  'ravveduto',
	  'reale',
	  'recepire',
	  'recinto',
	  'recluta',
	  'recondito',
	  'recupero',
	  'reddito',
	  'redimere',
	  'regalato',
	  'registro',
	  'regola',
	  'regresso',
	  'relazione',
	  'remare',
	  'remoto',
	  'renna',
	  'replica',
	  'reprimere',
	  'reputare',
	  'resa',
	  'residente',
	  'responso',
	  'restauro',
	  'rete',
	  'retina',
	  'retorica',
	  'rettifica',
	  'revocato',
	  'riassunto',
	  'ribadire',
	  'ribelle',
	  'ribrezzo',
	  'ricarica',
	  'ricco',
	  'ricevere',
	  'riciclato',
	  'ricordo',
	  'ricreduto',
	  'ridicolo',
	  'ridurre',
	  'rifasare',
	  'riflesso',
	  'riforma',
	  'rifugio',
	  'rigare',
	  'rigettato',
	  'righello',
	  'rilassato',
	  'rilevato',
	  'rimanere',
	  'rimbalzo',
	  'rimedio',
	  'rimorchio',
	  'rinascita',
	  'rincaro',
	  'rinforzo',
	  'rinnovo',
	  'rinomato',
	  'rinsavito',
	  'rintocco',
	  'rinuncia',
	  'rinvenire',
	  'riparato',
	  'ripetuto',
	  'ripieno',
	  'riportare',
	  'ripresa',
	  'ripulire',
	  'risata',
	  'rischio',
	  'riserva',
	  'risibile',
	  'riso',
	  'rispetto',
	  'ristoro',
	  'risultato',
	  'risvolto',
	  'ritardo',
	  'ritegno',
	  'ritmico',
	  'ritrovo',
	  'riunione',
	  'riva',
	  'riverso',
	  'rivincita',
	  'rivolto',
	  'rizoma',
	  'roba',
	  'robotico',
	  'robusto',
	  'roccia',
	  'roco',
	  'rodaggio',
	  'rodere',
	  'roditore',
	  'rogito',
	  'rollio',
	  'romantico',
	  'rompere',
	  'ronzio',
	  'rosolare',
	  'rospo',
	  'rotante',
	  'rotondo',
	  'rotula',
	  'rovescio',
	  'rubizzo',
	  'rubrica',
	  'ruga',
	  'rullino',
	  'rumine',
	  'rumoroso',
	  'ruolo',
	  'rupe',
	  'russare',
	  'rustico',
	  'sabato',
	  'sabbiare',
	  'sabotato',
	  'sagoma',
	  'salasso',
	  'saldatura',
	  'salgemma',
	  'salivare',
	  'salmone',
	  'salone',
	  'saltare',
	  'saluto',
	  'salvo',
	  'sapere',
	  'sapido',
	  'saporito',
	  'saraceno',
	  'sarcasmo',
	  'sarto',
	  'sassoso',
	  'satellite',
	  'satira',
	  'satollo',
	  'saturno',
	  'savana',
	  'savio',
	  'saziato',
	  'sbadiglio',
	  'sbalzo',
	  'sbancato',
	  'sbarra',
	  'sbattere',
	  'sbavare',
	  'sbendare',
	  'sbirciare',
	  'sbloccato',
	  'sbocciato',
	  'sbrinare',
	  'sbruffone',
	  'sbuffare',
	  'scabroso',
	  'scadenza',
	  'scala',
	  'scambiare',
	  'scandalo',
	  'scapola',
	  'scarso',
	  'scatenare',
	  'scavato',
	  'scelto',
	  'scenico',
	  'scettro',
	  'scheda',
	  'schiena',
	  'sciarpa',
	  'scienza',
	  'scindere',
	  'scippo',
	  'sciroppo',
	  'scivolo',
	  'sclerare',
	  'scodella',
	  'scolpito',
	  'scomparto',
	  'sconforto',
	  'scoprire',
	  'scorta',
	  'scossone',
	  'scozzese',
	  'scriba',
	  'scrollare',
	  'scrutinio',
	  'scuderia',
	  'scultore',
	  'scuola',
	  'scuro',
	  'scusare',
	  'sdebitare',
	  'sdoganare',
	  'seccatura',
	  'secondo',
	  'sedano',
	  'seggiola',
	  'segnalato',
	  'segregato',
	  'seguito',
	  'selciato',
	  'selettivo',
	  'sella',
	  'selvaggio',
	  'semaforo',
	  'sembrare',
	  'seme',
	  'seminato',
	  'sempre',
	  'senso',
	  'sentire',
	  'sepolto',
	  'sequenza',
	  'serata',
	  'serbato',
	  'sereno',
	  'serio',
	  'serpente',
	  'serraglio',
	  'servire',
	  'sestina',
	  'setola',
	  'settimana',
	  'sfacelo',
	  'sfaldare',
	  'sfamato',
	  'sfarzoso',
	  'sfaticato',
	  'sfera',
	  'sfida',
	  'sfilato',
	  'sfinge',
	  'sfocato',
	  'sfoderare',
	  'sfogo',
	  'sfoltire',
	  'sforzato',
	  'sfratto',
	  'sfruttato',
	  'sfuggito',
	  'sfumare',
	  'sfuso',
	  'sgabello',
	  'sgarbato',
	  'sgonfiare',
	  'sgorbio',
	  'sgrassato',
	  'sguardo',
	  'sibilo',
	  'siccome',
	  'sierra',
	  'sigla',
	  'signore',
	  'silenzio',
	  'sillaba',
	  'simbolo',
	  'simpatico',
	  'simulato',
	  'sinfonia',
	  'singolo',
	  'sinistro',
	  'sino',
	  'sintesi',
	  'sinusoide',
	  'sipario',
	  'sisma',
	  'sistole',
	  'situato',
	  'slitta',
	  'slogatura',
	  'sloveno',
	  'smarrito',
	  'smemorato',
	  'smentito',
	  'smeraldo',
	  'smilzo',
	  'smontare',
	  'smottato',
	  'smussato',
	  'snellire',
	  'snervato',
	  'snodo',
	  'sobbalzo',
	  'sobrio',
	  'soccorso',
	  'sociale',
	  'sodale',
	  'soffitto',
	  'sogno',
	  'soldato',
	  'solenne',
	  'solido',
	  'sollazzo',
	  'solo',
	  'solubile',
	  'solvente',
	  'somatico',
	  'somma',
	  'sonda',
	  'sonetto',
	  'sonnifero',
	  'sopire',
	  'soppeso',
	  'sopra',
	  'sorgere',
	  'sorpasso',
	  'sorriso',
	  'sorso',
	  'sorteggio',
	  'sorvolato',
	  'sospiro',
	  'sosta',
	  'sottile',
	  'spada',
	  'spalla',
	  'spargere',
	  'spatola',
	  'spavento',
	  'spazzola',
	  'specie',
	  'spedire',
	  'spegnere',
	  'spelatura',
	  'speranza',
	  'spessore',
	  'spettrale',
	  'spezzato',
	  'spia',
	  'spigoloso',
	  'spillato',
	  'spinoso',
	  'spirale',
	  'splendido',
	  'sportivo',
	  'sposo',
	  'spranga',
	  'sprecare',
	  'spronato',
	  'spruzzo',
	  'spuntino',
	  'squillo',
	  'sradicare',
	  'srotolato',
	  'stabile',
	  'stacco',
	  'staffa',
	  'stagnare',
	  'stampato',
	  'stantio',
	  'starnuto',
	  'stasera',
	  'statuto',
	  'stelo',
	  'steppa',
	  'sterzo',
	  'stiletto',
	  'stima',
	  'stirpe',
	  'stivale',
	  'stizzoso',
	  'stonato',
	  'storico',
	  'strappo',
	  'stregato',
	  'stridulo',
	  'strozzare',
	  'strutto',
	  'stuccare',
	  'stufo',
	  'stupendo',
	  'subentro',
	  'succoso',
	  'sudore',
	  'suggerito',
	  'sugo',
	  'sultano',
	  'suonare',
	  'superbo',
	  'supporto',
	  'surgelato',
	  'surrogato',
	  'sussurro',
	  'sutura',
	  'svagare',
	  'svedese',
	  'sveglio',
	  'svelare',
	  'svenuto',
	  'svezia',
	  'sviluppo',
	  'svista',
	  'svizzera',
	  'svolta',
	  'svuotare',
	  'tabacco',
	  'tabulato',
	  'tacciare',
	  'taciturno',
	  'tale',
	  'talismano',
	  'tampone',
	  'tannino',
	  'tara',
	  'tardivo',
	  'targato',
	  'tariffa',
	  'tarpare',
	  'tartaruga',
	  'tasto',
	  'tattico',
	  'taverna',
	  'tavolata',
	  'tazza',
	  'teca',
	  'tecnico',
	  'telefono',
	  'temerario',
	  'tempo',
	  'temuto',
	  'tendone',
	  'tenero',
	  'tensione',
	  'tentacolo',
	  'teorema',
	  'terme',
	  'terrazzo',
	  'terzetto',
	  'tesi',
	  'tesserato',
	  'testato',
	  'tetro',
	  'tettoia',
	  'tifare',
	  'tigella',
	  'timbro',
	  'tinto',
	  'tipico',
	  'tipografo',
	  'tiraggio',
	  'tiro',
	  'titanio',
	  'titolo',
	  'titubante',
	  'tizio',
	  'tizzone',
	  'toccare',
	  'tollerare',
	  'tolto',
	  'tombola',
	  'tomo',
	  'tonfo',
	  'tonsilla',
	  'topazio',
	  'topologia',
	  'toppa',
	  'torba',
	  'tornare',
	  'torrone',
	  'tortora',
	  'toscano',
	  'tossire',
	  'tostatura',
	  'totano',
	  'trabocco',
	  'trachea',
	  'trafila',
	  'tragedia',
	  'tralcio',
	  'tramonto',
	  'transito',
	  'trapano',
	  'trarre',
	  'trasloco',
	  'trattato',
	  'trave',
	  'treccia',
	  'tremolio',
	  'trespolo',
	  'tributo',
	  'tricheco',
	  'trifoglio',
	  'trillo',
	  'trincea',
	  'trio',
	  'tristezza',
	  'triturato',
	  'trivella',
	  'tromba',
	  'trono',
	  'troppo',
	  'trottola',
	  'trovare',
	  'truccato',
	  'tubatura',
	  'tuffato',
	  'tulipano',
	  'tumulto',
	  'tunisia',
	  'turbare',
	  'turchino',
	  'tuta',
	  'tutela',
	  'ubicato',
	  'uccello',
	  'uccisore',
	  'udire',
	  'uditivo',
	  'uffa',
	  'ufficio',
	  'uguale',
	  'ulisse',
	  'ultimato',
	  'umano',
	  'umile',
	  'umorismo',
	  'uncinetto',
	  'ungere',
	  'ungherese',
	  'unicorno',
	  'unificato',
	  'unisono',
	  'unitario',
	  'unte',
	  'uovo',
	  'upupa',
	  'uragano',
	  'urgenza',
	  'urlo',
	  'usanza',
	  'usato',
	  'uscito',
	  'usignolo',
	  'usuraio',
	  'utensile',
	  'utilizzo',
	  'utopia',
	  'vacante',
	  'vaccinato',
	  'vagabondo',
	  'vagliato',
	  'valanga',
	  'valgo',
	  'valico',
	  'valletta',
	  'valoroso',
	  'valutare',
	  'valvola',
	  'vampata',
	  'vangare',
	  'vanitoso',
	  'vano',
	  'vantaggio',
	  'vanvera',
	  'vapore',
	  'varano',
	  'varcato',
	  'variante',
	  'vasca',
	  'vedetta',
	  'vedova',
	  'veduto',
	  'vegetale',
	  'veicolo',
	  'velcro',
	  'velina',
	  'velluto',
	  'veloce',
	  'venato',
	  'vendemmia',
	  'vento',
	  'verace',
	  'verbale',
	  'vergogna',
	  'verifica',
	  'vero',
	  'verruca',
	  'verticale',
	  'vescica',
	  'vessillo',
	  'vestale',
	  'veterano',
	  'vetrina',
	  'vetusto',
	  'viandante',
	  'vibrante',
	  'vicenda',
	  'vichingo',
	  'vicinanza',
	  'vidimare',
	  'vigilia',
	  'vigneto',
	  'vigore',
	  'vile',
	  'villano',
	  'vimini',
	  'vincitore',
	  'viola',
	  'vipera',
	  'virgola',
	  'virologo',
	  'virulento',
	  'viscoso',
	  'visione',
	  'vispo',
	  'vissuto',
	  'visura',
	  'vita',
	  'vitello',
	  'vittima',
	  'vivanda',
	  'vivido',
	  'viziare',
	  'voce',
	  'voga',
	  'volatile',
	  'volere',
	  'volpe',
	  'voragine',
	  'vulcano',
	  'zampogna',
	  'zanna',
	  'zappato',
	  'zattera',
	  'zavorra',
	  'zefiro',
	  'zelante',
	  'zelo',
	  'zenzero',
	  'zerbino',
	  'zibetto',
	  'zinco',
	  'zircone',
	  'zitto',
	  'zolla',
	  'zotico',
	  'zucchero',
	  'zufolo',
	  'zulu',
	  'zuppa'
	];
	return italian;
}

var japanese;
var hasRequiredJapanese;

function requireJapanese () {
	if (hasRequiredJapanese) return japanese;
	hasRequiredJapanese = 1;

	japanese = [
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  '',
	  ''
	];
	return japanese;
}

var spanish;
var hasRequiredSpanish;

function requireSpanish () {
	if (hasRequiredSpanish) return spanish;
	hasRequiredSpanish = 1;

	spanish = [
	  'abaco',
	  'abdomen',
	  'abeja',
	  'abierto',
	  'abogado',
	  'abono',
	  'aborto',
	  'abrazo',
	  'abrir',
	  'abuelo',
	  'abuso',
	  'acabar',
	  'academia',
	  'acceso',
	  'accion',
	  'aceite',
	  'acelga',
	  'acento',
	  'aceptar',
	  'acido',
	  'aclarar',
	  'acne',
	  'acoger',
	  'acoso',
	  'activo',
	  'acto',
	  'actriz',
	  'actuar',
	  'acudir',
	  'acuerdo',
	  'acusar',
	  'adicto',
	  'admitir',
	  'adoptar',
	  'adorno',
	  'aduana',
	  'adulto',
	  'aereo',
	  'afectar',
	  'aficion',
	  'afinar',
	  'afirmar',
	  'agil',
	  'agitar',
	  'agonia',
	  'agosto',
	  'agotar',
	  'agregar',
	  'agrio',
	  'agua',
	  'agudo',
	  'aguila',
	  'aguja',
	  'ahogo',
	  'ahorro',
	  'aire',
	  'aislar',
	  'ajedrez',
	  'ajeno',
	  'ajuste',
	  'alacran',
	  'alambre',
	  'alarma',
	  'alba',
	  'album',
	  'alcalde',
	  'aldea',
	  'alegre',
	  'alejar',
	  'alerta',
	  'aleta',
	  'alfiler',
	  'alga',
	  'algodon',
	  'aliado',
	  'aliento',
	  'alivio',
	  'alma',
	  'almeja',
	  'almibar',
	  'altar',
	  'alteza',
	  'altivo',
	  'alto',
	  'altura',
	  'alumno',
	  'alzar',
	  'amable',
	  'amante',
	  'amapola',
	  'amargo',
	  'amasar',
	  'ambar',
	  'ambito',
	  'ameno',
	  'amigo',
	  'amistad',
	  'amor',
	  'amparo',
	  'amplio',
	  'ancho',
	  'anciano',
	  'ancla',
	  'andar',
	  'anden',
	  'anemia',
	  'angulo',
	  'anillo',
	  'animo',
	  'anis',
	  'anotar',
	  'antena',
	  'antiguo',
	  'antojo',
	  'anual',
	  'anular',
	  'anuncio',
	  'anadir',
	  'anejo',
	  'ano',
	  'apagar',
	  'aparato',
	  'apetito',
	  'apio',
	  'aplicar',
	  'apodo',
	  'aporte',
	  'apoyo',
	  'aprender',
	  'aprobar',
	  'apuesta',
	  'apuro',
	  'arado',
	  'arana',
	  'arar',
	  'arbitro',
	  'arbol',
	  'arbusto',
	  'archivo',
	  'arco',
	  'arder',
	  'ardilla',
	  'arduo',
	  'area',
	  'arido',
	  'aries',
	  'armonia',
	  'arnes',
	  'aroma',
	  'arpa',
	  'arpon',
	  'arreglo',
	  'arroz',
	  'arruga',
	  'arte',
	  'artista',
	  'asa',
	  'asado',
	  'asalto',
	  'ascenso',
	  'asegurar',
	  'aseo',
	  'asesor',
	  'asiento',
	  'asilo',
	  'asistir',
	  'asno',
	  'asombro',
	  'aspero',
	  'astilla',
	  'astro',
	  'astuto',
	  'asumir',
	  'asunto',
	  'atajo',
	  'ataque',
	  'atar',
	  'atento',
	  'ateo',
	  'atico',
	  'atleta',
	  'atomo',
	  'atraer',
	  'atroz',
	  'atun',
	  'audaz',
	  'audio',
	  'auge',
	  'aula',
	  'aumento',
	  'ausente',
	  'autor',
	  'aval',
	  'avance',
	  'avaro',
	  'ave',
	  'avellana',
	  'avena',
	  'avestruz',
	  'avion',
	  'aviso',
	  'ayer',
	  'ayuda',
	  'ayuno',
	  'azafran',
	  'azar',
	  'azote',
	  'azucar',
	  'azufre',
	  'azul',
	  'baba',
	  'babor',
	  'bache',
	  'bahia',
	  'baile',
	  'bajar',
	  'balanza',
	  'balcon',
	  'balde',
	  'bambu',
	  'banco',
	  'banda',
	  'bano',
	  'barba',
	  'barco',
	  'barniz',
	  'barro',
	  'bascula',
	  'baston',
	  'basura',
	  'batalla',
	  'bateria',
	  'batir',
	  'batuta',
	  'baul',
	  'bazar',
	  'bebe',
	  'bebida',
	  'bello',
	  'besar',
	  'beso',
	  'bestia',
	  'bicho',
	  'bien',
	  'bingo',
	  'blanco',
	  'bloque',
	  'blusa',
	  'boa',
	  'bobina',
	  'bobo',
	  'boca',
	  'bocina',
	  'boda',
	  'bodega',
	  'boina',
	  'bola',
	  'bolero',
	  'bolsa',
	  'bomba',
	  'bondad',
	  'bonito',
	  'bono',
	  'bonsai',
	  'borde',
	  'borrar',
	  'bosque',
	  'bote',
	  'botin',
	  'boveda',
	  'bozal',
	  'bravo',
	  'brazo',
	  'brecha',
	  'breve',
	  'brillo',
	  'brinco',
	  'brisa',
	  'broca',
	  'broma',
	  'bronce',
	  'brote',
	  'bruja',
	  'brusco',
	  'bruto',
	  'buceo',
	  'bucle',
	  'bueno',
	  'buey',
	  'bufanda',
	  'bufon',
	  'buho',
	  'buitre',
	  'bulto',
	  'burbuja',
	  'burla',
	  'burro',
	  'buscar',
	  'butaca',
	  'buzon',
	  'caballo',
	  'cabeza',
	  'cabina',
	  'cabra',
	  'cacao',
	  'cadaver',
	  'cadena',
	  'caer',
	  'cafe',
	  'caida',
	  'caiman',
	  'caja',
	  'cajon',
	  'cal',
	  'calamar',
	  'calcio',
	  'caldo',
	  'calidad',
	  'calle',
	  'calma',
	  'calor',
	  'calvo',
	  'cama',
	  'cambio',
	  'camello',
	  'camino',
	  'campo',
	  'cancer',
	  'candil',
	  'canela',
	  'canguro',
	  'canica',
	  'canto',
	  'cana',
	  'canon',
	  'caoba',
	  'caos',
	  'capaz',
	  'capitan',
	  'capote',
	  'captar',
	  'capucha',
	  'cara',
	  'carbon',
	  'carcel',
	  'careta',
	  'carga',
	  'carino',
	  'carne',
	  'carpeta',
	  'carro',
	  'carta',
	  'casa',
	  'casco',
	  'casero',
	  'caspa',
	  'castor',
	  'catorce',
	  'catre',
	  'caudal',
	  'causa',
	  'cazo',
	  'cebolla',
	  'ceder',
	  'cedro',
	  'celda',
	  'celebre',
	  'celoso',
	  'celula',
	  'cemento',
	  'ceniza',
	  'centro',
	  'cerca',
	  'cerdo',
	  'cereza',
	  'cero',
	  'cerrar',
	  'certeza',
	  'cesped',
	  'cetro',
	  'chacal',
	  'chaleco',
	  'champu',
	  'chancla',
	  'chapa',
	  'charla',
	  'chico',
	  'chiste',
	  'chivo',
	  'choque',
	  'choza',
	  'chuleta',
	  'chupar',
	  'ciclon',
	  'ciego',
	  'cielo',
	  'cien',
	  'cierto',
	  'cifra',
	  'cigarro',
	  'cima',
	  'cinco',
	  'cine',
	  'cinta',
	  'cipres',
	  'circo',
	  'ciruela',
	  'cisne',
	  'cita',
	  'ciudad',
	  'clamor',
	  'clan',
	  'claro',
	  'clase',
	  'clave',
	  'cliente',
	  'clima',
	  'clinica',
	  'cobre',
	  'coccion',
	  'cochino',
	  'cocina',
	  'coco',
	  'codigo',
	  'codo',
	  'cofre',
	  'coger',
	  'cohete',
	  'cojin',
	  'cojo',
	  'cola',
	  'colcha',
	  'colegio',
	  'colgar',
	  'colina',
	  'collar',
	  'colmo',
	  'columna',
	  'combate',
	  'comer',
	  'comida',
	  'comodo',
	  'compra',
	  'conde',
	  'conejo',
	  'conga',
	  'conocer',
	  'consejo',
	  'contar',
	  'copa',
	  'copia',
	  'corazon',
	  'corbata',
	  'corcho',
	  'cordon',
	  'corona',
	  'correr',
	  'coser',
	  'cosmos',
	  'costa',
	  'craneo',
	  'crater',
	  'crear',
	  'crecer',
	  'creido',
	  'crema',
	  'cria',
	  'crimen',
	  'cripta',
	  'crisis',
	  'cromo',
	  'cronica',
	  'croqueta',
	  'crudo',
	  'cruz',
	  'cuadro',
	  'cuarto',
	  'cuatro',
	  'cubo',
	  'cubrir',
	  'cuchara',
	  'cuello',
	  'cuento',
	  'cuerda',
	  'cuesta',
	  'cueva',
	  'cuidar',
	  'culebra',
	  'culpa',
	  'culto',
	  'cumbre',
	  'cumplir',
	  'cuna',
	  'cuneta',
	  'cuota',
	  'cupon',
	  'cupula',
	  'curar',
	  'curioso',
	  'curso',
	  'curva',
	  'cutis',
	  'dama',
	  'danza',
	  'dar',
	  'dardo',
	  'datil',
	  'deber',
	  'debil',
	  'decada',
	  'decir',
	  'dedo',
	  'defensa',
	  'definir',
	  'dejar',
	  'delfin',
	  'delgado',
	  'delito',
	  'demora',
	  'denso',
	  'dental',
	  'deporte',
	  'derecho',
	  'derrota',
	  'desayuno',
	  'deseo',
	  'desfile',
	  'desnudo',
	  'destino',
	  'desvio',
	  'detalle',
	  'detener',
	  'deuda',
	  'dia',
	  'diablo',
	  'diadema',
	  'diamante',
	  'diana',
	  'diario',
	  'dibujo',
	  'dictar',
	  'diente',
	  'dieta',
	  'diez',
	  'dificil',
	  'digno',
	  'dilema',
	  'diluir',
	  'dinero',
	  'directo',
	  'dirigir',
	  'disco',
	  'diseno',
	  'disfraz',
	  'diva',
	  'divino',
	  'doble',
	  'doce',
	  'dolor',
	  'domingo',
	  'don',
	  'donar',
	  'dorado',
	  'dormir',
	  'dorso',
	  'dos',
	  'dosis',
	  'dragon',
	  'droga',
	  'ducha',
	  'duda',
	  'duelo',
	  'dueno',
	  'dulce',
	  'duo',
	  'duque',
	  'durar',
	  'dureza',
	  'duro',
	  'ebano',
	  'ebrio',
	  'echar',
	  'eco',
	  'ecuador',
	  'edad',
	  'edicion',
	  'edificio',
	  'editor',
	  'educar',
	  'efecto',
	  'eficaz',
	  'eje',
	  'ejemplo',
	  'elefante',
	  'elegir',
	  'elemento',
	  'elevar',
	  'elipse',
	  'elite',
	  'elixir',
	  'elogio',
	  'eludir',
	  'embudo',
	  'emitir',
	  'emocion',
	  'empate',
	  'empeno',
	  'empleo',
	  'empresa',
	  'enano',
	  'encargo',
	  'enchufe',
	  'encia',
	  'enemigo',
	  'enero',
	  'enfado',
	  'enfermo',
	  'engano',
	  'enigma',
	  'enlace',
	  'enorme',
	  'enredo',
	  'ensayo',
	  'ensenar',
	  'entero',
	  'entrar',
	  'envase',
	  'envio',
	  'epoca',
	  'equipo',
	  'erizo',
	  'escala',
	  'escena',
	  'escolar',
	  'escribir',
	  'escudo',
	  'esencia',
	  'esfera',
	  'esfuerzo',
	  'espada',
	  'espejo',
	  'espia',
	  'esposa',
	  'espuma',
	  'esqui',
	  'estar',
	  'este',
	  'estilo',
	  'estufa',
	  'etapa',
	  'eterno',
	  'etica',
	  'etnia',
	  'evadir',
	  'evaluar',
	  'evento',
	  'evitar',
	  'exacto',
	  'examen',
	  'exceso',
	  'excusa',
	  'exento',
	  'exigir',
	  'exilio',
	  'existir',
	  'exito',
	  'experto',
	  'explicar',
	  'exponer',
	  'extremo',
	  'fabrica',
	  'fabula',
	  'fachada',
	  'facil',
	  'factor',
	  'faena',
	  'faja',
	  'falda',
	  'fallo',
	  'falso',
	  'faltar',
	  'fama',
	  'familia',
	  'famoso',
	  'faraon',
	  'farmacia',
	  'farol',
	  'farsa',
	  'fase',
	  'fatiga',
	  'fauna',
	  'favor',
	  'fax',
	  'febrero',
	  'fecha',
	  'feliz',
	  'feo',
	  'feria',
	  'feroz',
	  'fertil',
	  'fervor',
	  'festin',
	  'fiable',
	  'fianza',
	  'fiar',
	  'fibra',
	  'ficcion',
	  'ficha',
	  'fideo',
	  'fiebre',
	  'fiel',
	  'fiera',
	  'fiesta',
	  'figura',
	  'fijar',
	  'fijo',
	  'fila',
	  'filete',
	  'filial',
	  'filtro',
	  'fin',
	  'finca',
	  'fingir',
	  'finito',
	  'firma',
	  'flaco',
	  'flauta',
	  'flecha',
	  'flor',
	  'flota',
	  'fluir',
	  'flujo',
	  'fluor',
	  'fobia',
	  'foca',
	  'fogata',
	  'fogon',
	  'folio',
	  'folleto',
	  'fondo',
	  'forma',
	  'forro',
	  'fortuna',
	  'forzar',
	  'fosa',
	  'foto',
	  'fracaso',
	  'fragil',
	  'franja',
	  'frase',
	  'fraude',
	  'freir',
	  'freno',
	  'fresa',
	  'frio',
	  'frito',
	  'fruta',
	  'fuego',
	  'fuente',
	  'fuerza',
	  'fuga',
	  'fumar',
	  'funcion',
	  'funda',
	  'furgon',
	  'furia',
	  'fusil',
	  'futbol',
	  'futuro',
	  'gacela',
	  'gafas',
	  'gaita',
	  'gajo',
	  'gala',
	  'galeria',
	  'gallo',
	  'gamba',
	  'ganar',
	  'gancho',
	  'ganga',
	  'ganso',
	  'garaje',
	  'garza',
	  'gasolina',
	  'gastar',
	  'gato',
	  'gavilan',
	  'gemelo',
	  'gemir',
	  'gen',
	  'genero',
	  'genio',
	  'gente',
	  'geranio',
	  'gerente',
	  'germen',
	  'gesto',
	  'gigante',
	  'gimnasio',
	  'girar',
	  'giro',
	  'glaciar',
	  'globo',
	  'gloria',
	  'gol',
	  'golfo',
	  'goloso',
	  'golpe',
	  'goma',
	  'gordo',
	  'gorila',
	  'gorra',
	  'gota',
	  'goteo',
	  'gozar',
	  'grada',
	  'grafico',
	  'grano',
	  'grasa',
	  'gratis',
	  'grave',
	  'grieta',
	  'grillo',
	  'gripe',
	  'gris',
	  'grito',
	  'grosor',
	  'grua',
	  'grueso',
	  'grumo',
	  'grupo',
	  'guante',
	  'guapo',
	  'guardia',
	  'guerra',
	  'guia',
	  'guino',
	  'guion',
	  'guiso',
	  'guitarra',
	  'gusano',
	  'gustar',
	  'haber',
	  'habil',
	  'hablar',
	  'hacer',
	  'hacha',
	  'hada',
	  'hallar',
	  'hamaca',
	  'harina',
	  'haz',
	  'hazana',
	  'hebilla',
	  'hebra',
	  'hecho',
	  'helado',
	  'helio',
	  'hembra',
	  'herir',
	  'hermano',
	  'heroe',
	  'hervir',
	  'hielo',
	  'hierro',
	  'higado',
	  'higiene',
	  'hijo',
	  'himno',
	  'historia',
	  'hocico',
	  'hogar',
	  'hoguera',
	  'hoja',
	  'hombre',
	  'hongo',
	  'honor',
	  'honra',
	  'hora',
	  'hormiga',
	  'horno',
	  'hostil',
	  'hoyo',
	  'hueco',
	  'huelga',
	  'huerta',
	  'hueso',
	  'huevo',
	  'huida',
	  'huir',
	  'humano',
	  'humedo',
	  'humilde',
	  'humo',
	  'hundir',
	  'huracan',
	  'hurto',
	  'icono',
	  'ideal',
	  'idioma',
	  'idolo',
	  'iglesia',
	  'iglu',
	  'igual',
	  'ilegal',
	  'ilusion',
	  'imagen',
	  'iman',
	  'imitar',
	  'impar',
	  'imperio',
	  'imponer',
	  'impulso',
	  'incapaz',
	  'indice',
	  'inerte',
	  'infiel',
	  'informe',
	  'ingenio',
	  'inicio',
	  'inmenso',
	  'inmune',
	  'innato',
	  'insecto',
	  'instante',
	  'interes',
	  'intimo',
	  'intuir',
	  'inutil',
	  'invierno',
	  'ira',
	  'iris',
	  'ironia',
	  'isla',
	  'islote',
	  'jabali',
	  'jabon',
	  'jamon',
	  'jarabe',
	  'jardin',
	  'jarra',
	  'jaula',
	  'jazmin',
	  'jefe',
	  'jeringa',
	  'jinete',
	  'jornada',
	  'joroba',
	  'joven',
	  'joya',
	  'juerga',
	  'jueves',
	  'juez',
	  'jugador',
	  'jugo',
	  'juguete',
	  'juicio',
	  'junco',
	  'jungla',
	  'junio',
	  'juntar',
	  'jupiter',
	  'jurar',
	  'justo',
	  'juvenil',
	  'juzgar',
	  'kilo',
	  'koala',
	  'labio',
	  'lacio',
	  'lacra',
	  'lado',
	  'ladron',
	  'lagarto',
	  'lagrima',
	  'laguna',
	  'laico',
	  'lamer',
	  'lamina',
	  'lampara',
	  'lana',
	  'lancha',
	  'langosta',
	  'lanza',
	  'lapiz',
	  'largo',
	  'larva',
	  'lastima',
	  'lata',
	  'latex',
	  'latir',
	  'laurel',
	  'lavar',
	  'lazo',
	  'leal',
	  'leccion',
	  'leche',
	  'lector',
	  'leer',
	  'legion',
	  'legumbre',
	  'lejano',
	  'lengua',
	  'lento',
	  'lena',
	  'leon',
	  'leopardo',
	  'lesion',
	  'letal',
	  'letra',
	  'leve',
	  'leyenda',
	  'libertad',
	  'libro',
	  'licor',
	  'lider',
	  'lidiar',
	  'lienzo',
	  'liga',
	  'ligero',
	  'lima',
	  'limite',
	  'limon',
	  'limpio',
	  'lince',
	  'lindo',
	  'linea',
	  'lingote',
	  'lino',
	  'linterna',
	  'liquido',
	  'liso',
	  'lista',
	  'litera',
	  'litio',
	  'litro',
	  'llaga',
	  'llama',
	  'llanto',
	  'llave',
	  'llegar',
	  'llenar',
	  'llevar',
	  'llorar',
	  'llover',
	  'lluvia',
	  'lobo',
	  'locion',
	  'loco',
	  'locura',
	  'logica',
	  'logro',
	  'lombriz',
	  'lomo',
	  'lonja',
	  'lote',
	  'lucha',
	  'lucir',
	  'lugar',
	  'lujo',
	  'luna',
	  'lunes',
	  'lupa',
	  'lustro',
	  'luto',
	  'luz',
	  'maceta',
	  'macho',
	  'madera',
	  'madre',
	  'maduro',
	  'maestro',
	  'mafia',
	  'magia',
	  'mago',
	  'maiz',
	  'maldad',
	  'maleta',
	  'malla',
	  'malo',
	  'mama',
	  'mambo',
	  'mamut',
	  'manco',
	  'mando',
	  'manejar',
	  'manga',
	  'maniqui',
	  'manjar',
	  'mano',
	  'manso',
	  'manta',
	  'manana',
	  'mapa',
	  'maquina',
	  'mar',
	  'marco',
	  'marea',
	  'marfil',
	  'margen',
	  'marido',
	  'marmol',
	  'marron',
	  'martes',
	  'marzo',
	  'masa',
	  'mascara',
	  'masivo',
	  'matar',
	  'materia',
	  'matiz',
	  'matriz',
	  'maximo',
	  'mayor',
	  'mazorca',
	  'mecha',
	  'medalla',
	  'medio',
	  'medula',
	  'mejilla',
	  'mejor',
	  'melena',
	  'melon',
	  'memoria',
	  'menor',
	  'mensaje',
	  'mente',
	  'menu',
	  'mercado',
	  'merengue',
	  'merito',
	  'mes',
	  'meson',
	  'meta',
	  'meter',
	  'metodo',
	  'metro',
	  'mezcla',
	  'miedo',
	  'miel',
	  'miembro',
	  'miga',
	  'mil',
	  'milagro',
	  'militar',
	  'millon',
	  'mimo',
	  'mina',
	  'minero',
	  'minimo',
	  'minuto',
	  'miope',
	  'mirar',
	  'misa',
	  'miseria',
	  'misil',
	  'mismo',
	  'mitad',
	  'mito',
	  'mochila',
	  'mocion',
	  'moda',
	  'modelo',
	  'moho',
	  'mojar',
	  'molde',
	  'moler',
	  'molino',
	  'momento',
	  'momia',
	  'monarca',
	  'moneda',
	  'monja',
	  'monto',
	  'mono',
	  'morada',
	  'morder',
	  'moreno',
	  'morir',
	  'morro',
	  'morsa',
	  'mortal',
	  'mosca',
	  'mostrar',
	  'motivo',
	  'mover',
	  'movil',
	  'mozo',
	  'mucho',
	  'mudar',
	  'mueble',
	  'muela',
	  'muerte',
	  'muestra',
	  'mugre',
	  'mujer',
	  'mula',
	  'muleta',
	  'multa',
	  'mundo',
	  'muneca',
	  'mural',
	  'muro',
	  'musculo',
	  'museo',
	  'musgo',
	  'musica',
	  'muslo',
	  'nacar',
	  'nacion',
	  'nadar',
	  'naipe',
	  'naranja',
	  'nariz',
	  'narrar',
	  'nasal',
	  'natal',
	  'nativo',
	  'natural',
	  'nausea',
	  'naval',
	  'nave',
	  'navidad',
	  'necio',
	  'nectar',
	  'negar',
	  'negocio',
	  'negro',
	  'neon',
	  'nervio',
	  'neto',
	  'neutro',
	  'nevar',
	  'nevera',
	  'nicho',
	  'nido',
	  'niebla',
	  'nieto',
	  'ninez',
	  'nino',
	  'nitido',
	  'nivel',
	  'nobleza',
	  'noche',
	  'nomina',
	  'noria',
	  'norma',
	  'norte',
	  'nota',
	  'noticia',
	  'novato',
	  'novela',
	  'novio',
	  'nube',
	  'nuca',
	  'nucleo',
	  'nudillo',
	  'nudo',
	  'nuera',
	  'nueve',
	  'nuez',
	  'nulo',
	  'numero',
	  'nutria',
	  'oasis',
	  'obeso',
	  'obispo',
	  'objeto',
	  'obra',
	  'obrero',
	  'observar',
	  'obtener',
	  'obvio',
	  'oca',
	  'ocaso',
	  'oceano',
	  'ochenta',
	  'ocho',
	  'ocio',
	  'ocre',
	  'octavo',
	  'octubre',
	  'oculto',
	  'ocupar',
	  'ocurrir',
	  'odiar',
	  'odio',
	  'odisea',
	  'oeste',
	  'ofensa',
	  'oferta',
	  'oficio',
	  'ofrecer',
	  'ogro',
	  'oido',
	  'oir',
	  'ojo',
	  'ola',
	  'oleada',
	  'olfato',
	  'olivo',
	  'olla',
	  'olmo',
	  'olor',
	  'olvido',
	  'ombligo',
	  'onda',
	  'onza',
	  'opaco',
	  'opcion',
	  'opera',
	  'opinar',
	  'oponer',
	  'optar',
	  'optica',
	  'opuesto',
	  'oracion',
	  'orador',
	  'oral',
	  'orbita',
	  'orca',
	  'orden',
	  'oreja',
	  'organo',
	  'orgia',
	  'orgullo',
	  'oriente',
	  'origen',
	  'orilla',
	  'oro',
	  'orquesta',
	  'oruga',
	  'osadia',
	  'oscuro',
	  'osezno',
	  'oso',
	  'ostra',
	  'otono',
	  'otro',
	  'oveja',
	  'ovulo',
	  'oxido',
	  'oxigeno',
	  'oyente',
	  'ozono',
	  'pacto',
	  'padre',
	  'paella',
	  'pagina',
	  'pago',
	  'pais',
	  'pajaro',
	  'palabra',
	  'palco',
	  'paleta',
	  'palido',
	  'palma',
	  'paloma',
	  'palpar',
	  'pan',
	  'panal',
	  'panico',
	  'pantera',
	  'panuelo',
	  'papa',
	  'papel',
	  'papilla',
	  'paquete',
	  'parar',
	  'parcela',
	  'pared',
	  'parir',
	  'paro',
	  'parpado',
	  'parque',
	  'parrafo',
	  'parte',
	  'pasar',
	  'paseo',
	  'pasion',
	  'paso',
	  'pasta',
	  'pata',
	  'patio',
	  'patria',
	  'pausa',
	  'pauta',
	  'pavo',
	  'payaso',
	  'peaton',
	  'pecado',
	  'pecera',
	  'pecho',
	  'pedal',
	  'pedir',
	  'pegar',
	  'peine',
	  'pelar',
	  'peldano',
	  'pelea',
	  'peligro',
	  'pellejo',
	  'pelo',
	  'peluca',
	  'pena',
	  'pensar',
	  'penon',
	  'peon',
	  'peor',
	  'pepino',
	  'pequeno',
	  'pera',
	  'percha',
	  'perder',
	  'pereza',
	  'perfil',
	  'perico',
	  'perla',
	  'permiso',
	  'perro',
	  'persona',
	  'pesa',
	  'pesca',
	  'pesimo',
	  'pestana',
	  'petalo',
	  'petroleo',
	  'pez',
	  'pezuna',
	  'picar',
	  'pichon',
	  'pie',
	  'piedra',
	  'pierna',
	  'pieza',
	  'pijama',
	  'pilar',
	  'piloto',
	  'pimienta',
	  'pino',
	  'pintor',
	  'pinza',
	  'pina',
	  'piojo',
	  'pipa',
	  'pirata',
	  'pisar',
	  'piscina',
	  'piso',
	  'pista',
	  'piton',
	  'pizca',
	  'placa',
	  'plan',
	  'plata',
	  'playa',
	  'plaza',
	  'pleito',
	  'pleno',
	  'plomo',
	  'pluma',
	  'plural',
	  'pobre',
	  'poco',
	  'poder',
	  'podio',
	  'poema',
	  'poesia',
	  'poeta',
	  'polen',
	  'policia',
	  'pollo',
	  'polvo',
	  'pomada',
	  'pomelo',
	  'pomo',
	  'pompa',
	  'poner',
	  'porcion',
	  'portal',
	  'posada',
	  'poseer',
	  'posible',
	  'poste',
	  'potencia',
	  'potro',
	  'pozo',
	  'prado',
	  'precoz',
	  'pregunta',
	  'premio',
	  'prensa',
	  'preso',
	  'previo',
	  'primo',
	  'principe',
	  'prision',
	  'privar',
	  'proa',
	  'probar',
	  'proceso',
	  'producto',
	  'proeza',
	  'profesor',
	  'programa',
	  'prole',
	  'promesa',
	  'pronto',
	  'propio',
	  'proximo',
	  'prueba',
	  'publico',
	  'puchero',
	  'pudor',
	  'pueblo',
	  'puerta',
	  'puesto',
	  'pulga',
	  'pulir',
	  'pulmon',
	  'pulpo',
	  'pulso',
	  'puma',
	  'punto',
	  'punal',
	  'puno',
	  'pupa',
	  'pupila',
	  'pure',
	  'quedar',
	  'queja',
	  'quemar',
	  'querer',
	  'queso',
	  'quieto',
	  'quimica',
	  'quince',
	  'quitar',
	  'rabano',
	  'rabia',
	  'rabo',
	  'racion',
	  'radical',
	  'raiz',
	  'rama',
	  'rampa',
	  'rancho',
	  'rango',
	  'rapaz',
	  'rapido',
	  'rapto',
	  'rasgo',
	  'raspa',
	  'rato',
	  'rayo',
	  'raza',
	  'razon',
	  'reaccion',
	  'realidad',
	  'rebano',
	  'rebote',
	  'recaer',
	  'receta',
	  'rechazo',
	  'recoger',
	  'recreo',
	  'recto',
	  'recurso',
	  'red',
	  'redondo',
	  'reducir',
	  'reflejo',
	  'reforma',
	  'refran',
	  'refugio',
	  'regalo',
	  'regir',
	  'regla',
	  'regreso',
	  'rehen',
	  'reino',
	  'reir',
	  'reja',
	  'relato',
	  'relevo',
	  'relieve',
	  'relleno',
	  'reloj',
	  'remar',
	  'remedio',
	  'remo',
	  'rencor',
	  'rendir',
	  'renta',
	  'reparto',
	  'repetir',
	  'reposo',
	  'reptil',
	  'res',
	  'rescate',
	  'resina',
	  'respeto',
	  'resto',
	  'resumen',
	  'retiro',
	  'retorno',
	  'retrato',
	  'reunir',
	  'reves',
	  'revista',
	  'rey',
	  'rezar',
	  'rico',
	  'riego',
	  'rienda',
	  'riesgo',
	  'rifa',
	  'rigido',
	  'rigor',
	  'rincon',
	  'rinon',
	  'rio',
	  'riqueza',
	  'risa',
	  'ritmo',
	  'rito',
	  'rizo',
	  'roble',
	  'roce',
	  'rociar',
	  'rodar',
	  'rodeo',
	  'rodilla',
	  'roer',
	  'rojizo',
	  'rojo',
	  'romero',
	  'romper',
	  'ron',
	  'ronco',
	  'ronda',
	  'ropa',
	  'ropero',
	  'rosa',
	  'rosca',
	  'rostro',
	  'rotar',
	  'rubi',
	  'rubor',
	  'rudo',
	  'rueda',
	  'rugir',
	  'ruido',
	  'ruina',
	  'ruleta',
	  'rulo',
	  'rumbo',
	  'rumor',
	  'ruptura',
	  'ruta',
	  'rutina',
	  'sabado',
	  'saber',
	  'sabio',
	  'sable',
	  'sacar',
	  'sagaz',
	  'sagrado',
	  'sala',
	  'saldo',
	  'salero',
	  'salir',
	  'salmon',
	  'salon',
	  'salsa',
	  'salto',
	  'salud',
	  'salvar',
	  'samba',
	  'sancion',
	  'sandia',
	  'sanear',
	  'sangre',
	  'sanidad',
	  'sano',
	  'santo',
	  'sapo',
	  'saque',
	  'sardina',
	  'sarten',
	  'sastre',
	  'satan',
	  'sauna',
	  'saxofon',
	  'seccion',
	  'seco',
	  'secreto',
	  'secta',
	  'sed',
	  'seguir',
	  'seis',
	  'sello',
	  'selva',
	  'semana',
	  'semilla',
	  'senda',
	  'sensor',
	  'senal',
	  'senor',
	  'separar',
	  'sepia',
	  'sequia',
	  'ser',
	  'serie',
	  'sermon',
	  'servir',
	  'sesenta',
	  'sesion',
	  'seta',
	  'setenta',
	  'severo',
	  'sexo',
	  'sexto',
	  'sidra',
	  'siesta',
	  'siete',
	  'siglo',
	  'signo',
	  'silaba',
	  'silbar',
	  'silencio',
	  'silla',
	  'simbolo',
	  'simio',
	  'sirena',
	  'sistema',
	  'sitio',
	  'situar',
	  'sobre',
	  'socio',
	  'sodio',
	  'sol',
	  'solapa',
	  'soldado',
	  'soledad',
	  'solido',
	  'soltar',
	  'solucion',
	  'sombra',
	  'sondeo',
	  'sonido',
	  'sonoro',
	  'sonrisa',
	  'sopa',
	  'soplar',
	  'soporte',
	  'sordo',
	  'sorpresa',
	  'sorteo',
	  'sosten',
	  'sotano',
	  'suave',
	  'subir',
	  'suceso',
	  'sudor',
	  'suegra',
	  'suelo',
	  'sueno',
	  'suerte',
	  'sufrir',
	  'sujeto',
	  'sultan',
	  'sumar',
	  'superar',
	  'suplir',
	  'suponer',
	  'supremo',
	  'sur',
	  'surco',
	  'sureno',
	  'surgir',
	  'susto',
	  'sutil',
	  'tabaco',
	  'tabique',
	  'tabla',
	  'tabu',
	  'taco',
	  'tacto',
	  'tajo',
	  'talar',
	  'talco',
	  'talento',
	  'talla',
	  'talon',
	  'tamano',
	  'tambor',
	  'tango',
	  'tanque',
	  'tapa',
	  'tapete',
	  'tapia',
	  'tapon',
	  'taquilla',
	  'tarde',
	  'tarea',
	  'tarifa',
	  'tarjeta',
	  'tarot',
	  'tarro',
	  'tarta',
	  'tatuaje',
	  'tauro',
	  'taza',
	  'tazon',
	  'teatro',
	  'techo',
	  'tecla',
	  'tecnica',
	  'tejado',
	  'tejer',
	  'tejido',
	  'tela',
	  'telefono',
	  'tema',
	  'temor',
	  'templo',
	  'tenaz',
	  'tender',
	  'tener',
	  'tenis',
	  'tenso',
	  'teoria',
	  'terapia',
	  'terco',
	  'termino',
	  'ternura',
	  'terror',
	  'tesis',
	  'tesoro',
	  'testigo',
	  'tetera',
	  'texto',
	  'tez',
	  'tibio',
	  'tiburon',
	  'tiempo',
	  'tienda',
	  'tierra',
	  'tieso',
	  'tigre',
	  'tijera',
	  'tilde',
	  'timbre',
	  'timido',
	  'timo',
	  'tinta',
	  'tio',
	  'tipico',
	  'tipo',
	  'tira',
	  'tiron',
	  'titan',
	  'titere',
	  'titulo',
	  'tiza',
	  'toalla',
	  'tobillo',
	  'tocar',
	  'tocino',
	  'todo',
	  'toga',
	  'toldo',
	  'tomar',
	  'tono',
	  'tonto',
	  'topar',
	  'tope',
	  'toque',
	  'torax',
	  'torero',
	  'tormenta',
	  'torneo',
	  'toro',
	  'torpedo',
	  'torre',
	  'torso',
	  'tortuga',
	  'tos',
	  'tosco',
	  'toser',
	  'toxico',
	  'trabajo',
	  'tractor',
	  'traer',
	  'trafico',
	  'trago',
	  'traje',
	  'tramo',
	  'trance',
	  'trato',
	  'trauma',
	  'trazar',
	  'trebol',
	  'tregua',
	  'treinta',
	  'tren',
	  'trepar',
	  'tres',
	  'tribu',
	  'trigo',
	  'tripa',
	  'triste',
	  'triunfo',
	  'trofeo',
	  'trompa',
	  'tronco',
	  'tropa',
	  'trote',
	  'trozo',
	  'truco',
	  'trueno',
	  'trufa',
	  'tuberia',
	  'tubo',
	  'tuerto',
	  'tumba',
	  'tumor',
	  'tunel',
	  'tunica',
	  'turbina',
	  'turismo',
	  'turno',
	  'tutor',
	  'ubicar',
	  'ulcera',
	  'umbral',
	  'unidad',
	  'unir',
	  'universo',
	  'uno',
	  'untar',
	  'una',
	  'urbano',
	  'urbe',
	  'urgente',
	  'urna',
	  'usar',
	  'usuario',
	  'util',
	  'utopia',
	  'uva',
	  'vaca',
	  'vacio',
	  'vacuna',
	  'vagar',
	  'vago',
	  'vaina',
	  'vajilla',
	  'vale',
	  'valido',
	  'valle',
	  'valor',
	  'valvula',
	  'vampiro',
	  'vara',
	  'variar',
	  'varon',
	  'vaso',
	  'vecino',
	  'vector',
	  'vehiculo',
	  'veinte',
	  'vejez',
	  'vela',
	  'velero',
	  'veloz',
	  'vena',
	  'vencer',
	  'venda',
	  'veneno',
	  'vengar',
	  'venir',
	  'venta',
	  'venus',
	  'ver',
	  'verano',
	  'verbo',
	  'verde',
	  'vereda',
	  'verja',
	  'verso',
	  'verter',
	  'via',
	  'viaje',
	  'vibrar',
	  'vicio',
	  'victima',
	  'vida',
	  'video',
	  'vidrio',
	  'viejo',
	  'viernes',
	  'vigor',
	  'vil',
	  'villa',
	  'vinagre',
	  'vino',
	  'vinedo',
	  'violin',
	  'viral',
	  'virgo',
	  'virtud',
	  'visor',
	  'vispera',
	  'vista',
	  'vitamina',
	  'viudo',
	  'vivaz',
	  'vivero',
	  'vivir',
	  'vivo',
	  'volcan',
	  'volumen',
	  'volver',
	  'voraz',
	  'votar',
	  'voto',
	  'voz',
	  'vuelo',
	  'vulgar',
	  'yacer',
	  'yate',
	  'yegua',
	  'yema',
	  'yerno',
	  'yeso',
	  'yodo',
	  'yoga',
	  'yogur',
	  'zafiro',
	  'zanja',
	  'zapato',
	  'zarza',
	  'zona',
	  'zorro',
	  'zumo',
	  'zurdo'
	];
	return spanish;
}

/*!
 * wordlist.js - wordlists for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredWordlist;

function requireWordlist () {
	if (hasRequiredWordlist) return wordlist;
	hasRequiredWordlist = 1;

	wordlist.get = function get(name) {
	  switch (name) {
	    case 'simplified chinese':
	      return requireChineseSimplified();
	    case 'traditional chinese':
	      return requireChineseTraditional();
	    case 'english':
	      return requireEnglish();
	    case 'french':
	      return requireFrench();
	    case 'italian':
	      return requireItalian();
	    case 'japanese':
	      return requireJapanese();
	    case 'spanish':
	      return requireSpanish();
	    default:
	      throw new Error(`Unknown language: ${name}.`);
	  }
	};
	return wordlist;
}

/*!
 * nfkd.js - unicode normalization for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var nfkd_1;
var hasRequiredNfkd;

function requireNfkd () {
	if (hasRequiredNfkd) return nfkd_1;
	hasRequiredNfkd = 1;

	/**
	 * Normalize unicode string.
	 * @alias module:utils.nfkd
	 * @param {String} str
	 * @returns {String}
	 */

	function nfkd(str) {
	  return str.normalize('NFKD');
	}

	/*
	 * Expose
	 */

	nfkd_1 = nfkd;
	return nfkd_1;
}

/*!
 * mnemonic.js - hd mnemonics for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var mnemonic;
var hasRequiredMnemonic;

function requireMnemonic () {
	if (hasRequiredMnemonic) return mnemonic;
	hasRequiredMnemonic = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const sha256 = requireSha256();
	const cleanse = requireCleanse();
	const random = requireRandom();
	const pbkdf2 = requirePbkdf2();
	const sha512 = requireSha512();
	const wordlist = requireWordlist();
	const common = requireCommon();
	const nfkd = requireNfkd();
	const {inspectSymbol} = requireUtils();

	/*
	 * Constants
	 */

	const wordlistCache = Object.create(null);

	/**
	 * HD Mnemonic
	 * @alias module:hd.Mnemonic
	 */

	class Mnemonic {
	  /**
	   * Create a mnemonic.
	   * @constructor
	   * @param {Object} options
	   * @param {Number?} options.bit - Bits of entropy (Must
	   * be a multiple of 8) (default=128).
	   * @param {Buffer?} options.entropy - Entropy bytes. Will
	   * be generated with `options.bits` bits of entropy
	   * if not present.
	   * @param {String?} options.phrase - Mnemonic phrase (will
	   * be generated if not present).
	   * @param {String?} options.language - Language.
	   */

	  constructor(options) {
	    this.bits = common.MIN_ENTROPY;
	    this.language = 'english';
	    this.entropy = null;
	    this.phrase = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    if (typeof options === 'string')
	      options = { phrase: options };

	    if (options.bits != null) {
	      assert((options.bits & 0xffff) === options.bits);
	      assert(options.bits >= common.MIN_ENTROPY);
	      assert(options.bits <= common.MAX_ENTROPY);
	      assert(options.bits % 32 === 0);
	      this.bits = options.bits;
	    }

	    if (options.language) {
	      assert(typeof options.language === 'string');
	      assert(Mnemonic.languages.indexOf(options.language) !== -1);
	      this.language = options.language;
	    }

	    if (options.phrase) {
	      this.fromPhrase(options.phrase);
	      return this;
	    }

	    if (options.entropy) {
	      this.fromEntropy(options.entropy);
	      return this;
	    }

	    return this;
	  }

	  /**
	   * Instantiate mnemonic from options.
	   * @param {Object} options
	   * @returns {Mnemonic}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Destroy the mnemonic (zeroes entropy).
	   */

	  destroy() {
	    this.bits = common.MIN_ENTROPY;
	    this.language = 'english';
	    if (this.entropy) {
	      cleanse(this.entropy);
	      this.entropy = null;
	    }
	    this.phrase = null;
	  }

	  /**
	   * Generate the seed.
	   * @param {String?} passphrase
	   * @returns {Buffer} pbkdf2 seed.
	   */

	  toSeed(passphrase) {
	    if (!passphrase)
	      passphrase = '';

	    const phrase = nfkd(this.getPhrase());
	    const passwd = nfkd(`mnemonic${passphrase}`);

	    return pbkdf2.derive(sha512,
	      Buffer.from(phrase, 'utf8'),
	      Buffer.from(passwd, 'utf8'),
	      2048, 64);
	  }

	  /**
	   * Get or generate entropy.
	   * @returns {Buffer}
	   */

	  getEntropy() {
	    if (!this.entropy)
	      this.entropy = random.randomBytes(this.bits / 8);

	    assert(this.bits / 8 === this.entropy.length);

	    return this.entropy;
	  }

	  /**
	   * Generate a mnemonic phrase from chosen language.
	   * @returns {String}
	   */

	  getPhrase() {
	    if (this.phrase)
	      return this.phrase;

	    // Include the first `ENT / 32` bits
	    // of the hash (the checksum).
	    const wbits = this.bits + (this.bits / 32);

	    // Get entropy and checksum.
	    const entropy = this.getEntropy();
	    const chk = sha256.digest(entropy);

	    // Append the hash to the entropy to
	    // make things easy when grabbing
	    // the checksum bits.
	    const size = Math.ceil(wbits / 8);
	    const data = Buffer.allocUnsafe(size);
	    entropy.copy(data, 0);
	    chk.copy(data, entropy.length);

	    // Build the mnemonic by reading
	    // 11 bit indexes from the entropy.
	    const list = Mnemonic.getWordlist(this.language);

	    let phrase = [];
	    for (let i = 0; i < wbits / 11; i++) {
	      let index = 0;
	      for (let j = 0; j < 11; j++) {
	        const pos = i * 11 + j;
	        const bit = pos % 8;
	        const oct = (pos - bit) / 8;
	        index <<= 1;
	        index |= (data[oct] >>> (7 - bit)) & 1;
	      }
	      phrase.push(list.words[index]);
	    }

	    // Japanese likes double-width spaces.
	    if (this.language === 'japanese')
	      phrase = phrase.join('\u3000');
	    else
	      phrase = phrase.join(' ');

	    this.phrase = phrase;

	    return phrase;
	  }

	  /**
	   * Inject properties from phrase.
	   * @private
	   * @param {String} phrase
	   */

	  fromPhrase(phrase) {
	    assert(typeof phrase === 'string');
	    assert(phrase.length <= 1000);

	    const words = phrase.trim().split(/[\s\u3000]+/);
	    const wbits = words.length * 11;
	    const cbits = wbits % 32;

	    assert(cbits !== 0, 'Invalid checksum.');

	    const bits = wbits - cbits;

	    assert(bits >= common.MIN_ENTROPY);
	    assert(bits <= common.MAX_ENTROPY);
	    assert(bits % 32 === 0);

	    const size = Math.ceil(wbits / 8);
	    const data = Buffer.allocUnsafe(size);
	    data.fill(0);

	    const lang = Mnemonic.getLanguage(words[0]);
	    const list = Mnemonic.getWordlist(lang);

	    // Rebuild entropy bytes.
	    for (let i = 0; i < words.length; i++) {
	      const word = words[i];
	      const index = list.map[word];

	      if (index == null)
	        throw new Error('Could not find word.');

	      for (let j = 0; j < 11; j++) {
	        const pos = i * 11 + j;
	        const bit = pos % 8;
	        const oct = (pos - bit) / 8;
	        const val = (index >>> (10 - j)) & 1;
	        data[oct] |= val << (7 - bit);
	      }
	    }

	    const cbytes = Math.ceil(cbits / 8);
	    const entropy = data.slice(0, data.length - cbytes);
	    const chk1 = data.slice(data.length - cbytes);
	    const chk2 = sha256.digest(entropy);

	    // Verify checksum.
	    for (let i = 0; i < cbits; i++) {
	      const bit = i % 8;
	      const oct = (i - bit) / 8;
	      const b1 = (chk1[oct] >>> (7 - bit)) & 1;
	      const b2 = (chk2[oct] >>> (7 - bit)) & 1;
	      if (b1 !== b2)
	        throw new Error('Invalid checksum.');
	    }

	    assert(bits / 8 === entropy.length);

	    this.bits = bits;
	    this.language = lang;
	    this.entropy = entropy;
	    this.phrase = phrase;

	    return this;
	  }

	  /**
	   * Instantiate mnemonic from a phrase (validates checksum).
	   * @param {String} phrase
	   * @returns {Mnemonic}
	   * @throws on bad checksum
	   */

	  static fromPhrase(phrase) {
	    return new this().fromPhrase(phrase);
	  }

	  /**
	   * Inject properties from entropy.
	   * @private
	   * @param {Buffer} entropy
	   * @param {String?} lang
	   */

	  fromEntropy(entropy, lang) {
	    assert(Buffer.isBuffer(entropy));
	    assert(entropy.length * 8 >= common.MIN_ENTROPY);
	    assert(entropy.length * 8 <= common.MAX_ENTROPY);
	    assert((entropy.length * 8) % 32 === 0);
	    assert(!lang || Mnemonic.languages.indexOf(lang) !== -1);

	    this.entropy = entropy;
	    this.bits = entropy.length * 8;

	    if (lang)
	      this.language = lang;

	    return this;
	  }

	  /**
	   * Instantiate mnemonic from entropy.
	   * @param {Buffer} entropy
	   * @param {String?} lang
	   * @returns {Mnemonic}
	   */

	  static fromEntropy(entropy, lang) {
	    return new this().fromEntropy(entropy, lang);
	  }

	  /**
	   * Determine a single word's language.
	   * @param {String} word
	   * @returns {String} Language.
	   * @throws on not found.
	   */

	  static getLanguage(word) {
	    for (const lang of Mnemonic.languages) {
	      const list = Mnemonic.getWordlist(lang);
	      if (list.map[word] != null)
	        return lang;
	    }

	    throw new Error('Could not determine language.');
	  }

	  /**
	   * Retrieve the wordlist for a language.
	   * @param {String} lang
	   * @returns {Object}
	   */

	  static getWordlist(lang) {
	    const cache = wordlistCache[lang];

	    if (cache)
	      return cache;

	    const words = wordlist.get(lang);
	    const list = new WordList(words);

	    wordlistCache[lang] = list;

	    return list;
	  }

	  /**
	   * Convert mnemonic to a json-friendly object.
	   * @returns {Object}
	   */

	  toJSON() {
	    return {
	      bits: this.bits,
	      language: this.language,
	      entropy: this.getEntropy().toString('hex'),
	      phrase: this.getPhrase()
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json);
	    assert((json.bits & 0xffff) === json.bits);
	    assert(typeof json.language === 'string');
	    assert(typeof json.entropy === 'string');
	    assert(typeof json.phrase === 'string');
	    assert(json.bits >= common.MIN_ENTROPY);
	    assert(json.bits <= common.MAX_ENTROPY);
	    assert(json.bits % 32 === 0);
	    assert(json.bits / 8 === json.entropy.length / 2);

	    this.bits = json.bits;
	    this.language = json.language;
	    this.entropy = Buffer.from(json.entropy, 'hex');
	    this.phrase = json.phrase;

	    return this;
	  }

	  /**
	   * Instantiate mnemonic from json object.
	   * @param {Object} json
	   * @returns {Mnemonic}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += 3;
	    size += this.getEntropy().length;
	    return size;
	  }

	  /**
	   * Write the mnemonic to a buffer writer.
	   * @params {BufferWriter} bw
	   */

	  toWriter(bw) {
	    const lang = Mnemonic.languages.indexOf(this.language);

	    assert(lang !== -1);

	    bw.writeU16(this.bits);
	    bw.writeU8(lang);
	    bw.writeBytes(this.getEntropy());

	    return bw;
	  }

	  /**
	   * Serialize mnemonic.
	   * @returns {Buffer}
	   */

	  toRaw(writer) {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    const bits = br.readU16();

	    assert(bits >= common.MIN_ENTROPY);
	    assert(bits <= common.MAX_ENTROPY);
	    assert(bits % 32 === 0);

	    const language = Mnemonic.languages[br.readU8()];
	    assert(language);

	    this.bits = bits;
	    this.language = language;
	    this.entropy = br.readBytes(bits / 8);

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate mnemonic from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Mnemonic}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate mnemonic from serialized data.
	   * @param {Buffer} data
	   * @returns {Mnemonic}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the mnemonic to a string.
	   * @returns {String}
	   */

	  toString() {
	    return this.getPhrase();
	  }

	  /**
	   * Inspect the mnemonic.
	   * @returns {String}
	   */

	  [inspectSymbol]() {
	    return `<Mnemonic: ${this.getPhrase()}>`;
	  }

	  /**
	   * Test whether an object is a Mnemonic.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMnemonic(obj) {
	    return obj instanceof Mnemonic;
	  }
	}

	/**
	 * List of languages.
	 * @const {String[]}
	 * @default
	 */

	Mnemonic.languages = [
	  'simplified chinese',
	  'traditional chinese',
	  'english',
	  'french',
	  'italian',
	  'japanese',
	  'spanish'
	];

	/**
	 * Word List
	 * @ignore
	 */

	class WordList {
	  /**
	   * Create word list.
	   * @constructor
	   * @ignore
	   * @param {Array} words
	   */

	  constructor(words) {
	    this.words = words;
	    this.map = Object.create(null);

	    for (let i = 0; i < words.length; i++) {
	      const word = words[i];
	      this.map[word] = i;
	    }
	  }
	}

	/*
	 * Expose
	 */

	mnemonic = Mnemonic;
	return mnemonic;
}

/*!
 * public.js - hd public keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var _public;
var hasRequired_public;

function require_public () {
	if (hasRequired_public) return _public;
	hasRequired_public = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {base58} = require$$2$1;
	const sha512 = requireSha512();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const cleanse = requireCleanse();
	const secp256k1 = requireSecp256k1();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const common = requireCommon();

	/**
	 * HDPublicKey
	 * @alias module:hd.PublicKey
	 * @property {Number} depth
	 * @property {Number} parentFingerPrint
	 * @property {Number} childIndex
	 * @property {Buffer} chainCode
	 * @property {Buffer} publicKey
	 */

	class HDPublicKey {
	  /**
	   * Create an HD public key.
	   * @constructor
	   * @param {Object|Base58String} options
	   * @param {Base58String?} options.xkey - Serialized base58 key.
	   * @param {Number?} options.depth
	   * @param {Number?} options.parentFingerPrint
	   * @param {Number?} options.childIndex
	   * @param {Buffer?} options.chainCode
	   * @param {Buffer?} options.publicKey
	   */

	  constructor(options) {
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = consensus.ZERO_HASH;
	    this.publicKey = common.ZERO_KEY;

	    this.fingerPrint = -1;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'No options for HDPublicKey');
	    assert((options.depth & 0xff) === options.depth);
	    assert((options.parentFingerPrint >>> 0) === options.parentFingerPrint);
	    assert((options.childIndex >>> 0) === options.childIndex);
	    assert(Buffer.isBuffer(options.chainCode));
	    assert(Buffer.isBuffer(options.publicKey));

	    this.depth = options.depth;
	    this.parentFingerPrint = options.parentFingerPrint;
	    this.childIndex = options.childIndex;
	    this.chainCode = options.chainCode;
	    this.publicKey = options.publicKey;

	    return this;
	  }

	  /**
	   * Instantiate HD public key from options object.
	   * @param {Object} options
	   * @returns {HDPublicKey}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Get HD public key (self).
	   * @returns {HDPublicKey}
	   */

	  toPublic() {
	    return this;
	  }

	  /**
	   * Get cached base58 xprivkey (always null here).
	   * @returns {null}
	   */

	  xprivkey(network) {
	    return null;
	  }

	  /**
	   * Get cached base58 xpubkey.
	   * @returns {Base58String}
	   */

	  xpubkey(network) {
	    return this.toBase58(network);
	  }

	  /**
	   * Destroy the key (zeroes chain code and pubkey).
	   */

	  destroy() {
	    this.depth = 0;
	    this.childIndex = 0;
	    this.parentFingerPrint = 0;

	    cleanse(this.chainCode);
	    cleanse(this.publicKey);

	    this.fingerPrint = -1;
	  }

	  /**
	   * Derive a child key.
	   * @param {Number} index - Derivation index.
	   * @param {Boolean?} hardened - Whether the derivation
	   * should be hardened (throws if true).
	   * @returns {HDPrivateKey}
	   * @throws on `hardened`
	   */

	  derive(index, hardened) {
	    assert(typeof index === 'number');

	    if ((index >>> 0) !== index)
	      throw new Error('Index out of range.');

	    if ((index & common.HARDENED) || hardened)
	      throw new Error('Cannot derive hardened.');

	    if (this.depth >= 0xff)
	      throw new Error('Depth too high.');

	    const id = this.getID(index);
	    const cache = common.cache.get(id);

	    if (cache)
	      return cache;

	    const bw = bio.pool(37);

	    bw.writeBytes(this.publicKey);
	    bw.writeU32BE(index);

	    const data = bw.render();

	    const hash = sha512.mac(data, this.chainCode);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);

	    let key;
	    try {
	      key = secp256k1.publicKeyTweakAdd(this.publicKey, left, true);
	    } catch (e) {
	      return this.derive(index + 1);
	    }

	    if (this.fingerPrint === -1) {
	      const fp = hash160.digest(this.publicKey);
	      this.fingerPrint = fp.readUInt32BE(0, true);
	    }

	    const child = new this.constructor();
	    child.depth = this.depth + 1;
	    child.parentFingerPrint = this.fingerPrint;
	    child.childIndex = index;
	    child.chainCode = right;
	    child.publicKey = key;

	    common.cache.set(id, child);

	    return child;
	  }

	  /**
	   * Unique HD key ID.
	   * @private
	   * @param {Number} index
	   * @returns {String}
	   */

	  getID(index) {
	    return 'b' + this.publicKey.toString('hex') + index;
	  }

	  /**
	   * Derive a BIP44 account key (does not derive, only ensures account key).
	   * @method
	   * @param {Number} purpose
	   * @param {Number} type
	   * @param {Number} account
	   * @returns {HDPublicKey}
	   * @throws Error if key is not already an account key.
	   */

	  deriveAccount(purpose, type, account) {
	    assert((purpose >>> 0) === purpose);
	    assert((type >>> 0) === type);
	    assert((account >>> 0) === account);
	    assert(this.isAccount(account), 'Cannot derive account index.');
	    return this;
	  }

	  /**
	   * Test whether the key is a master key.
	   * @method
	   * @returns {Boolean}
	   */

	  isMaster() {
	    return common.isMaster(this);
	  }

	  /**
	   * Test whether the key is (most likely) a BIP44 account key.
	   * @method
	   * @param {Number?} account
	   * @returns {Boolean}
	   */

	  isAccount(account) {
	    return common.isAccount(this, account);
	  }

	  /**
	   * Test whether a string is a valid path.
	   * @param {String} path
	   * @param {Boolean?} hardened
	   * @returns {Boolean}
	   */

	  static isValidPath(path) {
	    try {
	      common.parsePath(path, false);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Derive a key from a derivation path.
	   * @param {String} path
	   * @returns {HDPublicKey}
	   * @throws Error if `path` is not a valid path.
	   * @throws Error if hardened.
	   */

	  derivePath(path) {
	    const indexes = common.parsePath(path, false);

	    let key = this;

	    for (const index of indexes)
	      key = key.derive(index);

	    return key;
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  equals(obj) {
	    assert(HDPublicKey.isHDPublicKey(obj));

	    return this.depth === obj.depth
	      && this.parentFingerPrint === obj.parentFingerPrint
	      && this.childIndex === obj.childIndex
	      && this.chainCode.equals(obj.chainCode)
	      && this.publicKey.equals(obj.publicKey);
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  compare(key) {
	    assert(HDPublicKey.isHDPublicKey(key));

	    let cmp = this.depth - key.depth;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.parentFingerPrint - key.parentFingerPrint;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.childIndex - key.childIndex;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.chainCode.compare(key.chainCode);

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.publicKey.compare(key.publicKey);

	    if (cmp !== 0)
	      return cmp;

	    return 0;
	  }

	  /**
	   * Convert key to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      xpubkey: this.xpubkey(network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   * @param {Network?} network
	   */

	  fromJSON(json, network) {
	    assert(json.xpubkey, 'Could not handle HD key JSON.');
	    this.fromBase58(json.xpubkey, network);
	    return this;
	  }

	  /**
	   * Instantiate an HDPublicKey from a jsonified key object.
	   * @param {Object} json - The jsonified transaction object.
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromJSON(json, network) {
	    return new this().fromJSON(json, network);
	  }

	  /**
	   * Test whether an object is in the form of a base58 xpubkey.
	   * @param {String} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {Boolean}
	   */

	  static isBase58(data, network) {
	    if (typeof data !== 'string')
	      return false;

	    if (data.length < 4)
	      return false;

	    const prefix = data.substring(0, 4);

	    try {
	      Network.fromPublic58(prefix, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a buffer has a valid network prefix.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {NetworkType}
	   */

	  static isRaw(data, network) {
	    if (!Buffer.isBuffer(data))
	      return false;

	    if (data.length < 4)
	      return false;

	    const version = data.readUInt32BE(0, true);

	    try {
	      Network.fromPublic(version, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Inject properties from a base58 key.
	   * @private
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   */

	  fromBase58(xkey, network) {
	    assert(typeof xkey === 'string');
	    return this.fromRaw(base58.decode(xkey), network);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   */

	  fromReader(br, network) {
	    const version = br.readU32BE();

	    Network.fromPublic(version, network);

	    this.depth = br.readU8();
	    this.parentFingerPrint = br.readU32BE();
	    this.childIndex = br.readU32BE();
	    this.chainCode = br.readBytes(32);
	    this.publicKey = br.readBytes(33);

	    br.verifyChecksum(hash256.digest);

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   */

	  fromRaw(data, network) {
	    return this.fromReader(bio.read(data), network);
	  }

	  /**
	   * Serialize key data to base58 extended key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Write the key to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {(Network|NetworkType)?} network
	   */

	  toWriter(bw, network) {
	    network = Network.get(network);

	    bw.writeU32BE(network.keyPrefix.xpubkey);
	    bw.writeU8(this.depth);
	    bw.writeU32BE(this.parentFingerPrint);
	    bw.writeU32BE(this.childIndex);
	    bw.writeBytes(this.chainCode);
	    bw.writeBytes(this.publicKey);
	    bw.writeChecksum(hash256.digest);

	    return bw;
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return 82;
	  }

	  /**
	   * Serialize the key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Buffer}
	   */

	  toRaw(network) {
	    return this.toWriter(bio.write(82), network).render();
	  }

	  /**
	   * Instantiate an HD public key from a base58 string.
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   * @returns {HDPublicKey}
	   */

	  static fromBase58(xkey, network) {
	    return new this().fromBase58(xkey, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPublicKey}
	   */

	  static fromReader(br, network) {
	    return new this().fromReader(br, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPublicKey}
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Test whether an object is a HDPublicKey.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHDPublicKey(obj) {
	    return obj instanceof HDPublicKey;
	  }
	}

	/*
	 * Expose
	 */

	_public = HDPublicKey;
	return _public;
}

/*!
 * private.js - hd private keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var _private;
var hasRequired_private;

function require_private () {
	if (hasRequired_private) return _private;
	hasRequired_private = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {base58} = require$$2$1;
	const sha512 = requireSha512();
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const cleanse = requireCleanse();
	const random = requireRandom();
	const secp256k1 = requireSecp256k1();
	const Network = requireNetwork();
	const consensus = requireConsensus();
	const common = requireCommon();
	const Mnemonic = requireMnemonic();
	const HDPublicKey = require_public();

	/*
	 * Constants
	 */

	const SEED_SALT = Buffer.from('Bitcoin seed', 'ascii');

	/**
	 * HDPrivateKey
	 * @alias module:hd.PrivateKey
	 * @property {Number} depth
	 * @property {Number} parentFingerPrint
	 * @property {Number} childIndex
	 * @property {Buffer} chainCode
	 * @property {Buffer} privateKey
	 */

	class HDPrivateKey {
	  /**
	   * Create an hd private key.
	   * @constructor
	   * @param {Object|String} options
	   * @param {Number?} options.depth
	   * @param {Number?} options.parentFingerPrint
	   * @param {Number?} options.childIndex
	   * @param {Buffer?} options.chainCode
	   * @param {Buffer?} options.privateKey
	   */

	  constructor(options) {
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = consensus.ZERO_HASH;
	    this.privateKey = consensus.ZERO_HASH;

	    this.publicKey = common.ZERO_KEY;
	    this.fingerPrint = -1;

	    this._hdPublicKey = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'No options for HD private key.');
	    assert((options.depth & 0xff) === options.depth);
	    assert((options.parentFingerPrint >>> 0) === options.parentFingerPrint);
	    assert((options.childIndex >>> 0) === options.childIndex);
	    assert(Buffer.isBuffer(options.chainCode));
	    assert(Buffer.isBuffer(options.privateKey));

	    this.depth = options.depth;
	    this.parentFingerPrint = options.parentFingerPrint;
	    this.childIndex = options.childIndex;
	    this.chainCode = options.chainCode;
	    this.privateKey = options.privateKey;
	    this.publicKey = secp256k1.publicKeyCreate(options.privateKey, true);

	    return this;
	  }

	  /**
	   * Instantiate HD private key from options object.
	   * @param {Object} options
	   * @returns {HDPrivateKey}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Get HD public key.
	   * @returns {HDPublicKey}
	   */

	  toPublic() {
	    let key = this._hdPublicKey;

	    if (!key) {
	      key = new HDPublicKey();
	      key.depth = this.depth;
	      key.parentFingerPrint = this.parentFingerPrint;
	      key.childIndex = this.childIndex;
	      key.chainCode = this.chainCode;
	      key.publicKey = this.publicKey;
	      this._hdPublicKey = key;
	    }

	    return key;
	  }

	  /**
	   * Get cached base58 xprivkey.
	   * @returns {Base58String}
	   */

	  xprivkey(network) {
	    return this.toBase58(network);
	  }

	  /**
	   * Get cached base58 xpubkey.
	   * @returns {Base58String}
	   */

	  xpubkey(network) {
	    return this.toPublic().xpubkey(network);
	  }

	  /**
	   * Destroy the key (zeroes chain code, privkey, and pubkey).
	   * @param {Boolean} pub - Destroy hd public key as well.
	   */

	  destroy(pub) {
	    this.depth = 0;
	    this.childIndex = 0;
	    this.parentFingerPrint = 0;

	    cleanse(this.chainCode);
	    cleanse(this.privateKey);
	    cleanse(this.publicKey);

	    this.fingerPrint = -1;

	    if (this._hdPublicKey) {
	      if (pub)
	        this._hdPublicKey.destroy();
	      this._hdPublicKey = null;
	    }
	  }

	  /**
	   * Derive a child key.
	   * @param {Number} index - Derivation index.
	   * @param {Boolean?} hardened - Whether the derivation should be hardened.
	   * @returns {HDPrivateKey}
	   */

	  derive(index, hardened) {
	    assert(typeof index === 'number');

	    if ((index >>> 0) !== index)
	      throw new Error('Index out of range.');

	    if (this.depth >= 0xff)
	      throw new Error('Depth too high.');

	    if (hardened) {
	      index |= common.HARDENED;
	      index >>>= 0;
	    }

	    const id = this.getID(index);
	    const cache = common.cache.get(id);

	    if (cache)
	      return cache;

	    const bw = bio.pool(37);

	    if (index & common.HARDENED) {
	      bw.writeU8(0);
	      bw.writeBytes(this.privateKey);
	      bw.writeU32BE(index);
	    } else {
	      bw.writeBytes(this.publicKey);
	      bw.writeU32BE(index);
	    }

	    const data = bw.render();

	    const hash = sha512.mac(data, this.chainCode);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);

	    let key;
	    try {
	      key = secp256k1.privateKeyTweakAdd(this.privateKey, left);
	    } catch (e) {
	      return this.derive(index + 1);
	    }

	    if (this.fingerPrint === -1) {
	      const fp = hash160.digest(this.publicKey);
	      this.fingerPrint = fp.readUInt32BE(0, true);
	    }

	    const child = new this.constructor();
	    child.depth = this.depth + 1;
	    child.parentFingerPrint = this.fingerPrint;
	    child.childIndex = index;
	    child.chainCode = right;
	    child.privateKey = key;
	    child.publicKey = secp256k1.publicKeyCreate(key, true);

	    common.cache.set(id, child);

	    return child;
	  }

	  /**
	   * Unique HD key ID.
	   * @private
	   * @param {Number} index
	   * @returns {String}
	   */

	  getID(index) {
	    return 'v' + this.publicKey.toString('hex') + index;
	  }

	  /**
	   * Derive a BIP44 account key.
	   * @param {Number} purpose
	   * @param {Number} type
	   * @param {Number} account
	   * @returns {HDPrivateKey}
	   * @throws Error if key is not a master key.
	   */

	  deriveAccount(purpose, type, account) {
	    assert((purpose >>> 0) === purpose, 'Purpose must be a number.');
	    assert((type >>> 0) === type, 'Account index must be a number.');
	    assert((account >>> 0) === account, 'Account index must be a number.');
	    assert(this.isMaster(), 'Cannot derive account index.');
	    return this
	      .derive(purpose, true)
	      .derive(type, true)
	      .derive(account, true);
	  }

	  /**
	   * Test whether the key is a master key.
	   * @returns {Boolean}
	   */

	  isMaster() {
	    return common.isMaster(this);
	  }

	  /**
	   * Test whether the key is (most likely) a BIP44 account key.
	   * @param {Number?} account
	   * @returns {Boolean}
	   */

	  isAccount(account) {
	    return common.isAccount(this, account);
	  }

	  /**
	   * Test whether an object is in the form of a base58 xprivkey.
	   * @param {String} data
	   * @param {Network?} network
	   * @returns {Boolean}
	   */

	  static isBase58(data, network) {
	    if (typeof data !== 'string')
	      return false;

	    if (data.length < 4)
	      return false;

	    const prefix = data.substring(0, 4);

	    try {
	      Network.fromPrivate58(prefix, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a buffer has a valid network prefix.
	   * @param {Buffer} data
	   * @param {Network?} network
	   * @returns {Boolean}
	   */

	  static isRaw(data, network) {
	    if (!Buffer.isBuffer(data))
	      return false;

	    if (data.length < 4)
	      return false;

	    const version = data.readUInt32BE(0, true);

	    try {
	      Network.fromPrivate(version, network);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Test whether a string is a valid path.
	   * @param {String} path
	   * @returns {Boolean}
	   */

	  static isValidPath(path) {
	    try {
	      common.parsePath(path, true);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Derive a key from a derivation path.
	   * @param {String} path
	   * @returns {HDPrivateKey}
	   * @throws Error if `path` is not a valid path.
	   */

	  derivePath(path) {
	    const indexes = common.parsePath(path, true);

	    let key = this;

	    for (const index of indexes)
	      key = key.derive(index);

	    return key;
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  equals(obj) {
	    assert(HDPrivateKey.isHDPrivateKey(obj));

	    return this.depth === obj.depth
	      && this.parentFingerPrint === obj.parentFingerPrint
	      && this.childIndex === obj.childIndex
	      && this.chainCode.equals(obj.chainCode)
	      && this.privateKey.equals(obj.privateKey);
	  }

	  /**
	   * Compare a key against an object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  compare(key) {
	    assert(HDPrivateKey.isHDPrivateKey(key));

	    let cmp = this.depth - key.depth;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.parentFingerPrint - key.parentFingerPrint;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.childIndex - key.childIndex;

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.chainCode.compare(key.chainCode);

	    if (cmp !== 0)
	      return cmp;

	    cmp = this.privateKey.compare(key.privateKey);

	    if (cmp !== 0)
	      return cmp;

	    return 0;
	  }

	  /**
	   * Inject properties from seed.
	   * @private
	   * @param {Buffer} seed
	   */

	  fromSeed(seed) {
	    assert(Buffer.isBuffer(seed));

	    if (seed.length * 8 < common.MIN_ENTROPY
	        || seed.length * 8 > common.MAX_ENTROPY) {
	      throw new Error('Entropy not in range.');
	    }

	    const hash = sha512.mac(seed, SEED_SALT);
	    const left = hash.slice(0, 32);
	    const right = hash.slice(32, 64);

	    // Only a 1 in 2^127 chance of happening.
	    if (!secp256k1.privateKeyVerify(left))
	      throw new Error('Master private key is invalid.');

	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = right;
	    this.privateKey = left;
	    this.publicKey = secp256k1.publicKeyCreate(left, true);

	    return this;
	  }

	  /**
	   * Instantiate an hd private key from a 512 bit seed.
	   * @param {Buffer} seed
	   * @returns {HDPrivateKey}
	   */

	  static fromSeed(seed) {
	    return new this().fromSeed(seed);
	  }

	  /**
	   * Inject properties from a mnemonic.
	   * @private
	   * @param {Mnemonic} mnemonic
	   * @param {String?} passphrase
	   */

	  fromMnemonic(mnemonic, passphrase) {
	    assert(mnemonic instanceof Mnemonic);
	    return this.fromSeed(mnemonic.toSeed(passphrase));
	  }

	  /**
	   * Instantiate an hd private key from a mnemonic.
	   * @param {Mnemonic} mnemonic
	   * @param {String?} passphrase
	   * @returns {HDPrivateKey}
	   */

	  static fromMnemonic(mnemonic, passphrase) {
	    return new this().fromMnemonic(mnemonic, passphrase);
	  }

	  /**
	   * Inject properties from a mnemonic.
	   * @private
	   * @param {String} mnemonic
	   */

	  fromPhrase(phrase) {
	    const mnemonic = Mnemonic.fromPhrase(phrase);
	    this.fromMnemonic(mnemonic);
	    return this;
	  }

	  /**
	   * Instantiate an hd private key from a phrase.
	   * @param {String} phrase
	   * @returns {HDPrivateKey}
	   */

	  static fromPhrase(phrase) {
	    return new this().fromPhrase(phrase);
	  }

	  /**
	   * Inject properties from privateKey and entropy.
	   * @private
	   * @param {Buffer} key
	   * @param {Buffer} entropy
	   */

	  fromKey(key, entropy) {
	    assert(Buffer.isBuffer(key) && key.length === 32);
	    assert(Buffer.isBuffer(entropy) && entropy.length === 32);
	    this.depth = 0;
	    this.parentFingerPrint = 0;
	    this.childIndex = 0;
	    this.chainCode = entropy;
	    this.privateKey = key;
	    this.publicKey = secp256k1.publicKeyCreate(key, true);
	    return this;
	  }

	  /**
	   * Create an hd private key from a key and entropy bytes.
	   * @param {Buffer} key
	   * @param {Buffer} entropy
	   * @returns {HDPrivateKey}
	   */

	  static fromKey(key, entropy) {
	    return new this().fromKey(key, entropy);
	  }

	  /**
	   * Generate an hd private key.
	   * @returns {HDPrivateKey}
	   */

	  static generate() {
	    const key = secp256k1.privateKeyGenerate();
	    const entropy = random.randomBytes(32);
	    return HDPrivateKey.fromKey(key, entropy);
	  }

	  /**
	   * Inject properties from base58 key.
	   * @private
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   */

	  fromBase58(xkey, network) {
	    assert(typeof xkey === 'string');
	    return this.fromRaw(base58.decode(xkey), network);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   */

	  fromReader(br, network) {
	    const version = br.readU32BE();

	    Network.fromPrivate(version, network);

	    this.depth = br.readU8();
	    this.parentFingerPrint = br.readU32BE();
	    this.childIndex = br.readU32BE();
	    this.chainCode = br.readBytes(32);
	    assert(br.readU8() === 0);
	    this.privateKey = br.readBytes(32);
	    this.publicKey = secp256k1.publicKeyCreate(this.privateKey, true);

	    br.verifyChecksum(hash256.digest);

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   */

	  fromRaw(data, network) {
	    return this.fromReader(bio.read(data), network);
	  }

	  /**
	   * Serialize key to a base58 string.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toBase58(network) {
	    return base58.encode(this.toRaw(network));
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return 82;
	  }

	  /**
	   * Write the key to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {(Network|NetworkType)?} network
	   */

	  toWriter(bw, network) {
	    network = Network.get(network);

	    bw.writeU32BE(network.keyPrefix.xprivkey);
	    bw.writeU8(this.depth);
	    bw.writeU32BE(this.parentFingerPrint);
	    bw.writeU32BE(this.childIndex);
	    bw.writeBytes(this.chainCode);
	    bw.writeU8(0);
	    bw.writeBytes(this.privateKey);
	    bw.writeChecksum(hash256.digest);

	    return bw;
	  }

	  /**
	   * Serialize the key.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Buffer}
	   */

	  toRaw(network) {
	    return this.toWriter(bio.write(82), network).render();
	  }

	  /**
	   * Instantiate an HD private key from a base58 string.
	   * @param {Base58String} xkey
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromBase58(xkey, network) {
	    return new this().fromBase58(xkey, network);
	  }

	  /**
	   * Instantiate key from buffer reader.
	   * @param {BufferReader} br
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromReader(br, network) {
	    return new this().fromReader(br, network);
	  }

	  /**
	   * Instantiate key from serialized data.
	   * @param {Buffer} data
	   * @param {(Network|NetworkType)?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromRaw(data, network) {
	    return new this().fromRaw(data, network);
	  }

	  /**
	   * Convert key to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      xprivkey: this.xprivkey(network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   * @param {Network?} network
	   */

	  fromJSON(json, network) {
	    assert(json.xprivkey, 'Could not handle key JSON.');

	    this.fromBase58(json.xprivkey, network);

	    return this;
	  }

	  /**
	   * Instantiate an HDPrivateKey from a jsonified key object.
	   * @param {Object} json - The jsonified key object.
	   * @param {Network?} network
	   * @returns {HDPrivateKey}
	   */

	  static fromJSON(json, network) {
	    return new this().fromJSON(json, network);
	  }

	  /**
	   * Test whether an object is an HDPrivateKey.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHDPrivateKey(obj) {
	    return obj instanceof HDPrivateKey;
	  }
	}

	/*
	 * Expose
	 */

	_private = HDPrivateKey;
	return _private;
}

/*!
 * hd.js - hd keys for bcoin
 * Copyright (c) 2015-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredHd$1;

function requireHd$1 () {
	if (hasRequiredHd$1) return hd$1;
	hasRequiredHd$1 = 1;
	(function (exports) {

		const assert = require$$0$3;
		const common = requireCommon();
		const Mnemonic = requireMnemonic();
		const HDPrivateKey = require_private();
		const HDPublicKey = require_public();
		const wordlist = requireWordlist();

		/**
		 * @exports hd
		 */

		const HD = exports;

		/**
		 * Instantiate an HD key (public or private) from an base58 string.
		 * @param {Base58String} xkey
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromBase58 = function fromBase58(xkey, network) {
		  if (HDPrivateKey.isBase58(xkey))
		    return HDPrivateKey.fromBase58(xkey, network);
		  return HDPublicKey.fromBase58(xkey, network);
		};

		/**
		 * Generate an {@link HDPrivateKey}.
		 * @param {Object} options
		 * @param {Buffer?} options.privateKey
		 * @param {Buffer?} options.entropy
		 * @returns {HDPrivateKey}
		 */

		HD.generate = function generate() {
		  return HDPrivateKey.generate();
		};

		/**
		 * Generate an {@link HDPrivateKey} from a seed.
		 * @param {Object|Mnemonic|Buffer} options - seed,
		 * mnemonic, mnemonic options.
		 * @returns {HDPrivateKey}
		 */

		HD.fromSeed = function fromSeed(options) {
		  return HDPrivateKey.fromSeed(options);
		};

		/**
		 * Instantiate an hd private key from a mnemonic.
		 * @param {Mnemonic|Object} mnemonic
		 * @returns {HDPrivateKey}
		 */

		HD.fromMnemonic = function fromMnemonic(options) {
		  return HDPrivateKey.fromMnemonic(options);
		};

		/**
		 * Instantiate an HD key from a jsonified key object.
		 * @param {Object} json - The jsonified transaction object.
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromJSON = function fromJSON(json, network) {
		  if (json.xprivkey)
		    return HDPrivateKey.fromJSON(json, network);
		  return HDPublicKey.fromJSON(json, network);
		};

		/**
		 * Instantiate an HD key from serialized data.
		 * @param {Buffer} data
		 * @param {Network?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.fromRaw = function fromRaw(data, network) {
		  if (HDPrivateKey.isRaw(data, network))
		    return HDPrivateKey.fromRaw(data, network);
		  return HDPublicKey.fromRaw(data, network);
		};

		/**
		 * Generate an hdkey from any number of options.
		 * @param {Object|Mnemonic|Buffer} options - mnemonic, mnemonic
		 * options, seed, or base58 key.
		 * @param {(Network|NetworkType)?} network
		 * @returns {HDPrivateKey|HDPublicKey}
		 */

		HD.from = function from(options, network) {
		  assert(options, 'Options required.');

		  if (HD.isHD(options))
		    return options;

		  if (HD.isBase58(options, network))
		    return HD.fromBase58(options, network);

		  if (HD.isRaw(options, network))
		    return HD.fromRaw(options, network);

		  if (options && typeof options === 'object')
		    return HD.fromMnemonic(options);

		  throw new Error('Cannot create HD key from bad options.');
		};

		/**
		 * Test whether an object is in the form of a base58 hd key.
		 * @param {String} data
		 * @param {Network?} network
		 * @returns {Boolean}
		 */

		HD.isBase58 = function isBase58(data, network) {
		  return HDPrivateKey.isBase58(data, network)
		    || HDPublicKey.isBase58(data, network);
		};

		/**
		 * Test whether an object is in the form of a serialized hd key.
		 * @param {Buffer} data
		 * @param {Network?} network
		 * @returns {NetworkType}
		 */

		HD.isRaw = function isRaw(data, network) {
		  return HDPrivateKey.isRaw(data, network)
		    || HDPublicKey.isRaw(data, network);
		};

		/**
		 * Test whether an object is an HD key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isHD = function isHD(obj) {
		  return HDPrivateKey.isHDPrivateKey(obj)
		    || HDPublicKey.isHDPublicKey(obj);
		};

		/**
		 * Test whether an object is an HD private key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isPrivate = function isPrivate(obj) {
		  return HDPrivateKey.isHDPrivateKey(obj);
		};

		/**
		 * Test whether an object is an HD public key.
		 * @param {Object} obj
		 * @returns {Boolean}
		 */

		HD.isPublic = function isPublic(obj) {
		  return HDPublicKey.isHDPublicKey(obj);
		};

		/*
		 * Expose
		 */

		HD.common = common;
		HD.HD = HD;
		HD.Mnemonic = Mnemonic;
		HD.PrivateKey = HDPrivateKey;
		HD.PublicKey = HDPublicKey;
		HD.HDPrivateKey = HDPrivateKey;
		HD.HDPublicKey = HDPublicKey;
		HD.wordlist = wordlist; 
	} (hd$1));
	return hd$1;
}

/*!
 * hd/index.js - hd keys for bcoin
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hd;
var hasRequiredHd;

function requireHd () {
	if (hasRequiredHd) return hd;
	hasRequiredHd = 1;

	hd = requireHd$1();
	return hd;
}

var primitives = {};

/*!
 * invitem.js - inv item object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var invitem;
var hasRequiredInvitem;

function requireInvitem () {
	if (hasRequiredInvitem) return invitem;
	hasRequiredInvitem = 1;

	const bio = require$$1;
	const util = requireUtil();

	/**
	 * Inv Item
	 * @alias module:primitives.InvItem
	 * @constructor
	 * @property {InvType} type
	 * @property {Hash} hash
	 */

	class InvItem {
	  /**
	   * Create an inv item.
	   * @constructor
	   * @param {Number} type
	   * @param {Hash} hash
	   */

	  constructor(type, hash) {
	    this.type = type;
	    this.hash = hash;
	  }

	  /**
	   * Write inv item to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  getSize() {
	    return 36;
	  }

	  /**
	   * Write inv item to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    bw.writeU32(this.type);
	    bw.writeHash(this.hash);
	    return bw;
	  }

	  /**
	   * Serialize inv item.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.toWriter(bio.write(36)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.type = br.readU32();
	    this.hash = br.readHash();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate inv item from buffer reader.
	   * @param {BufferReader} br
	   * @returns {InvItem}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate inv item from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc
	   * @returns {InvItem}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether the inv item is a block.
	   * @returns {Boolean}
	   */

	  isBlock() {
	    switch (this.type) {
	      case InvItem.types.BLOCK:
	      case InvItem.types.FILTERED_BLOCK:
	      case InvItem.types.CMPCT_BLOCK:
	        return true;
	      default:
	        return false;
	    }
	  }

	  /**
	   * Test whether the inv item is a tx.
	   * @returns {Boolean}
	   */

	  isTX() {
	    switch (this.type) {
	      case InvItem.types.TX:
	        return true;
	      default:
	        return false;
	    }
	  }

	  /**
	   * Get little-endian hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash);
	  }
	}

	/**
	 * Inv types.
	 * @enum {Number}
	 * @default
	 */

	InvItem.types = {
	  TX: 1,
	  BLOCK: 2,
	  FILTERED_BLOCK: 3,
	  CMPCT_BLOCK: 4
	};

	/**
	 * Inv types by value.
	 * @const {Object}
	 */

	InvItem.typesByVal = {
	  1: 'TX',
	  2: 'BLOCK',
	  3: 'FILTERED_BLOCK',
	  4: 'CMPCT_BLOCK'
	};

	/*
	 * Expose
	 */

	invitem = InvItem;
	return invitem;
}

/*!
 * abstractblock.js - abstract block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var abstractblock;
var hasRequiredAbstractblock;

function requireAbstractblock () {
	if (hasRequiredAbstractblock) return abstractblock;
	hasRequiredAbstractblock = 1;

	const assert = require$$0$3;
	const hash256 = requireHash256();
	const bio = require$$1;
	const util = requireUtil();
	const InvItem = requireInvitem();
	const consensus = requireConsensus();

	/**
	 * Abstract Block
	 * The class which all block-like objects inherit from.
	 * @alias module:primitives.AbstractBlock
	 * @abstract
	 * @property {Number} version
	 * @property {Hash} prevBlock
	 * @property {Hash} merkleRoot
	 * @property {Number} time
	 * @property {Number} bits
	 * @property {Number} nonce
	 */

	class AbstractBlock {
	  /**
	   * Create an abstract block.
	   * @constructor
	   */

	  constructor() {
	    this.version = 1;
	    this.prevBlock = consensus.ZERO_HASH;
	    this.merkleRoot = consensus.ZERO_HASH;
	    this.time = 0;
	    this.bits = 0;
	    this.nonce = 0;

	    this.mutable = false;

	    this._hash = null;
	    this._hhash = null;
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  parseOptions(options) {
	    assert(options, 'Block data is required.');
	    assert((options.version >>> 0) === options.version);
	    assert(Buffer.isBuffer(options.prevBlock));
	    assert(Buffer.isBuffer(options.merkleRoot));
	    assert((options.time >>> 0) === options.time);
	    assert((options.bits >>> 0) === options.bits);
	    assert((options.nonce >>> 0) === options.nonce);

	    this.version = options.version;
	    this.prevBlock = options.prevBlock;
	    this.merkleRoot = options.merkleRoot;
	    this.time = options.time;
	    this.bits = options.bits;
	    this.nonce = options.nonce;

	    if (options.mutable != null) {
	      assert(typeof options.mutable === 'boolean');
	      this.mutable = options.mutable;
	    }

	    return this;
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  parseJSON(json) {
	    assert(json, 'Block data is required.');
	    assert((json.version >>> 0) === json.version);
	    assert(typeof json.prevBlock === 'string');
	    assert(typeof json.merkleRoot === 'string');
	    assert((json.time >>> 0) === json.time);
	    assert((json.bits >>> 0) === json.bits);
	    assert((json.nonce >>> 0) === json.nonce);

	    this.version = json.version;
	    this.prevBlock = util.fromRev(json.prevBlock);
	    this.merkleRoot = util.fromRev(json.merkleRoot);
	    this.time = json.time;
	    this.bits = json.bits;
	    this.nonce = json.nonce;

	    return this;
	  }

	  /**
	   * Test whether the block is a memblock.
	   * @returns {Boolean}
	   */

	  isMemory() {
	    return false;
	  }

	  /**
	   * Clear any cached values (abstract).
	   */

	  _refresh() {
	    this._hash = null;
	    this._hhash = null;
	  }

	  /**
	   * Clear any cached values.
	   */

	  refresh() {
	    return this._refresh();
	  }

	  /**
	   * Hash the block headers.
	   * @param {String?} enc - Can be `'hex'` or `null`.
	   * @returns {Hash|Buffer} hash
	   */

	  hash(enc) {
	    let h = this._hash;

	    if (!h) {
	      h = hash256.digest(this.toHead());
	      if (!this.mutable)
	        this._hash = h;
	    }

	    if (enc === 'hex') {
	      let hex = this._hhash;
	      if (!hex) {
	        hex = h.toString('hex');
	        if (!this.mutable)
	          this._hhash = hex;
	      }
	      h = hex;
	    }

	    return h;
	  }

	  /**
	   * Serialize the block headers.
	   * @returns {Buffer}
	   */

	  toHead() {
	    return this.writeHead(bio.write(80)).render();
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromHead(data) {
	    return this.readHead(bio.read(data));
	  }

	  /**
	   * Serialize the block headers.
	   * @param {BufferWriter} bw
	   */

	  writeHead(bw) {
	    bw.writeU32(this.version);
	    bw.writeHash(this.prevBlock);
	    bw.writeHash(this.merkleRoot);
	    bw.writeU32(this.time);
	    bw.writeU32(this.bits);
	    bw.writeU32(this.nonce);
	    return bw;
	  }

	  /**
	   * Parse the block headers.
	   * @param {BufferReader} br
	   */

	  readHead(br) {
	    this.version = br.readU32();
	    this.prevBlock = br.readHash();
	    this.merkleRoot = br.readHash();
	    this.time = br.readU32();
	    this.bits = br.readU32();
	    this.nonce = br.readU32();
	    return this;
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verify() {
	    if (!this.verifyPOW())
	      return false;

	    if (!this.verifyBody())
	      return false;

	    return true;
	  }

	  /**
	   * Verify proof-of-work.
	   * @returns {Boolean}
	   */

	  verifyPOW() {
	    return consensus.verifyPOW(this.hash(), this.bits);
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    throw new Error('Abstract method.');
	  }

	  /**
	   * Get little-endian block hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash());
	  }

	  /**
	   * Convert the block to an inv item.
	   * @returns {InvItem}
	   */

	  toInv() {
	    return new InvItem(InvItem.types.BLOCK, this.hash());
	  }
	}

	/*
	 * Expose
	 */

	abstractblock = AbstractBlock;
	return abstractblock;
}

var merkle = {};

/*!
 * merkle.js - merkle trees for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 */

var hasRequiredMerkle;

function requireMerkle () {
	if (hasRequiredMerkle) return merkle;
	hasRequiredMerkle = 1;

	const assert = requireAssert();

	// Notes about unbalanced merkle trees:
	//
	// Bitcoin hashes odd nodes with themselves,
	// allowing an attacker to add a duplicate
	// TXID, creating an even number of leaves
	// and computing the same root (CVE-2012-2459).
	// In contrast, RFC 6962 simply propagates
	// odd nodes up.
	//
	// RFC 6962:
	//
	//              R
	//             / \
	//            /   \
	//           /     \
	//          /       \
	//         /         \
	//        k           j <-- same as below
	//       / \          |
	//      /   \         |
	//     /     \        |
	//    h       i       j
	//   / \     / \     / \
	//  a   b   c   d   e   f
	//
	// Bitcoin Behavior:
	//
	//              R
	//             / \
	//            /   \
	//           /     \
	//          /       \
	//         /         \
	//        k           l <-- HASH(j || j)
	//       / \          |
	//      /   \         |
	//     /     \        |
	//    h       i       j
	//   / \     / \     / \
	//  a   b   c   d   e   f
	//
	// This creates a situation where these leaves:
	//
	//        R
	//       / \
	//      /   \
	//     /     \
	//    d       e <-- HASH(c || c)
	//   / \     / \
	//  a   b   c   c
	//
	// Compute the same root as:
	//
	//       R
	//      / \
	//     /   \
	//    d     e <-- HASH(c || c)
	//   / \    |
	//  a   b   c
	//
	// Why does this matter? Duplicate TXIDs are
	// invalid right? They're spending the same
	// inputs! The problem arises in certain
	// implementation optimizations which may
	// mark a block hash invalid. In other words,
	// an invalid block shares the same block
	// hash as a valid one!
	//
	// See:
	//   https://tools.ietf.org/html/rfc6962#section-2.1
	//   https://nvd.nist.gov/vuln/detail/CVE-2012-2459
	//   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459
	//   https://bitcointalk.org/?topic=81749

	/**
	 * Build a merkle tree from leaves.
	 * @param {Object} alg
	 * @param {Buffer[]} leaves
	 * @returns {Array} [nodes, malleated]
	 */

	function createTree(alg, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Array.isArray(leaves));

	  const nodes = new Array(leaves.length);

	  for (let i = 0; i < leaves.length; i++)
	    nodes[i] = leaves[i];

	  let size = nodes.length;
	  let malleated = false;
	  let i = 0;

	  if (size === 0) {
	    nodes.push(alg.zero);
	    return [nodes, malleated];
	  }

	  while (size > 1) {
	    for (let j = 0; j < size; j += 2) {
	      const k = Math.min(j + 1, size - 1);
	      const left = nodes[i + j];
	      const right = nodes[i + k];

	      if (k === j + 1 && k + 1 === size
	          && left.equals(right)) {
	        malleated = true;
	      }

	      const hash = alg.root(left, right);

	      nodes.push(hash);
	    }

	    i += size;

	    size = (size + 1) >>> 1;
	  }

	  return [nodes, malleated];
	}

	/**
	 * Calculate merkle root from leaves.
	 * @param {Object} alg
	 * @param {Buffer[]} leaves
	 * @returns {Array} [root, malleated]
	 */

	function createRoot(alg, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Array.isArray(leaves));

	  const [nodes, malleated] = createTree(alg, leaves);
	  const root = nodes[nodes.length - 1];

	  return [root, malleated];
	}

	/**
	 * Collect a merkle branch from vector index.
	 * @param {Object} alg
	 * @param {Number} index
	 * @param {Buffer[]} leaves
	 * @returns {Buffer[]} branch
	 */

	function createBranch(alg, index, leaves) {
	  assert(alg && typeof alg.root === 'function');
	  assert((index >>> 0) === index);
	  assert(Array.isArray(leaves));
	  assert(index < leaves.length);

	  let size = leaves.length;

	  const [nodes] = createTree(alg, leaves);
	  const branch = [];

	  let i = 0;

	  while (size > 1) {
	    const j = Math.min(index ^ 1, size - 1);

	    branch.push(nodes[i + j]);

	    index >>>= 1;

	    i += size;

	    size = (size + 1) >>> 1;
	  }

	  return branch;
	}

	/**
	 * Derive merkle root from branch.
	 * @param {Object} alg
	 * @param {Buffer} hash
	 * @param {Buffer[]} branch
	 * @param {Number} index
	 * @returns {Buffer} root
	 */

	function deriveRoot(alg, hash, branch, index) {
	  assert(alg && typeof alg.root === 'function');
	  assert(Buffer.isBuffer(hash));
	  assert(Array.isArray(branch));
	  assert((index >>> 0) === index);

	  let root = hash;

	  for (const hash of branch) {
	    if ((index & 1) && hash.equals(root))
	      return alg.zero;

	    if (index & 1)
	      root = alg.root(hash, root);
	    else
	      root = alg.root(root, hash);

	    index >>>= 1;
	  }

	  return root;
	}

	/*
	 * Expose
	 */

	merkle.createTree = createTree;
	merkle.createRoot = createRoot;
	merkle.createBranch = createBranch;
	merkle.deriveRoot = deriveRoot;
	return merkle;
}

/*!
 * input.js - input object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const Network = requireNetwork();
	const Script = requireScript$1();
	const Outpoint = requireOutpoint();
	const {inspectSymbol} = requireUtils();


	/**
	 * Input
	 * Represents a transaction input.
	 * @alias module:primitives.Input
	 * @property {Outpoint} prevout - Outpoint.
	 * @property {Script} script - Input script / scriptSig.
	 * @property {Number} sequence - nSequence.
	 */

	class Input {
	  /**
	   * Create transaction input.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    this.prevout = new Outpoint();
	    this.script = new Script();
	    this.sequence = 0xffffffff;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'Input data is required.');

	    this.prevout.fromOptions(options.prevout);

	    if (options.script)
	      this.script.fromOptions(options.script);

	    if (options.sequence != null) {
	      assert((options.sequence >>> 0) === options.sequence,
	        'Sequence must be a uint32.');
	      this.sequence = options.sequence;
	    }

	    return this;
	  }

	  /**
	   * Instantiate an Input from options object.
	   * @param {Object} options
	   * @returns {Input}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the input.
	   * @returns {Input}
	   */

	  clone() {
	    const input = new this.constructor();
	    input.prevout = this.prevout;
	    input.script.inject(this.script);
	    input.sequence = this.sequence;
	    return input;
	  }

	  /**
	   * Test equality against another input.
	   * @param {Input} input
	   * @returns {Boolean}
	   */

	  equals(input) {
	    assert(Input.isInput(input));
	    return this.prevout.equals(input.prevout);
	  }

	  /**
	   * Compare against another input (BIP69).
	   * @param {Input} input
	   * @returns {Number}
	   */

	  compare(input) {
	    assert(Input.isInput(input));
	    return this.prevout.compare(input.prevout);
	  }

	  /**
	   * Get the previous output script type as a string.
	   * Will "guess" based on the input script and/or
	   * witness if coin is not available.
	   * @param {Coin?} coin
	   * @returns {ScriptType} type
	   */

	  getType(coin) {
	    if (this.isCoinbase())
	      return 'coinbase';

	    if (coin)
	      return coin.getType();

	    const type = this.script.getInputType();

	    return Script.typesByVal[type].toLowerCase();
	  }

	  /**
	   * Get the redeem script.
	   * @param {Coin?} coin
	   * @returns {Script?} Redeem script.
	   */

	  getRedeem(coin) {
	    if (this.isCoinbase())
	      return null;

	    if (!coin) {
	      if (this.script.isScripthashInput())
	        return this.script.getRedeem();

	      return null;
	    }

	    let prev = coin.script;
	    let redeem = null;

	    if (prev.isScripthash()) {
	      prev = this.script.getRedeem();
	      redeem = prev;
	    }

	    return redeem;
	  }

	  /**
	   * Get the redeem script type.
	   * @param {Coin?} coin
	   * @returns {String} subtype
	   */

	  getSubtype(coin) {
	    if (this.isCoinbase())
	      return null;

	    const redeem = this.getRedeem(coin);

	    if (!redeem)
	      return null;

	    const type = redeem.getType();

	    return Script.typesByVal[type].toLowerCase();
	  }

	  /**
	   * Get the previous output script's address. Will "guess"
	   * based on the input script and/or witness if coin
	   * is not available.
	   * @param {Coin?} coin
	   * @returns {Address?} addr
	   */

	  getAddress(coin) {
	    if (this.isCoinbase())
	      return null;

	    if (coin)
	      return coin.getAddress();

	    if (this.script.code.length > 0)
	      return this.script.getInputAddress();

	    return null;
	  }

	  /**
	   * Get the address hash.
	   * @param {Coin?} coin
	   * @param {String?} enc
	   * @returns {Hash} hash
	   */

	  getHash(coin, enc) {
	    const addr = this.getAddress(coin);

	    if (!addr)
	      return null;

	    return addr.getHash(enc);
	  }

	  /**
	   * Test to see if nSequence is equal to uint32max.
	   * @returns {Boolean}
	   */

	  isFinal() {
	    return this.sequence === 0xffffffff;
	  }

	  /**
	   * Test to see if nSequence is less than 0xfffffffe.
	   * @returns {Boolean}
	   */

	  isRBF() {
	    return this.sequence < 0xfffffffe;
	  }

	  /**
	   * Test to see if outpoint is null.
	   * @returns {Boolean}
	   */

	  isCoinbase() {
	    return this.prevout.isNull();
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Convert the input to a more user-friendly object.
	   * @param {Coin?} coin
	   * @returns {Object}
	   */

	  format(coin) {
	    return {
	      type: this.getType(coin),
	      subtype: this.getSubtype(coin),
	      address: this.getAddress(coin),
	      script: this.script,
	      redeem: this.getRedeem(coin),
	      sequence: this.sequence,
	      prevout: this.prevout,
	      coin: coin || null
	    };
	  }

	  /**
	   * Convert the input to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON(network, coin) {
	    return this.getJSON();
	  }

	  /**
	   * Convert the input to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {Coin} coin
	   * @returns {Object}
	   */

	  getJSON(network, coin) {
	    network = Network.get(network);

	    let addr;
	    if (!coin) {
	      addr = this.getAddress();
	      if (addr)
	        addr = addr.toString(network);
	    }

	    return {
	      prevout: this.prevout.toJSON(),
	      script: this.script.toJSON(),
	      sequence: this.sequence,
	      address: addr,
	      coin: coin ? coin.getJSON(network, true) : undefined
	    };
	  }

	  /**
	   * Inject properties from a JSON object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Input data is required.');
	    assert((json.sequence >>> 0) === json.sequence,
	      'Sequence must be a uint32.');
	    this.prevout.fromJSON(json.prevout);
	    this.script.fromJSON(json.script);
	    this.sequence = json.sequence;
	    return this;
	  }

	  /**
	   * Instantiate an Input from a jsonified input object.
	   * @param {Object} json - The jsonified input object.
	   * @returns {Input}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate size of serialized input.
	   * @returns {Number}
	   */

	  getSize() {
	    return 40 + this.script.getVarSize();
	  }

	  /**
	   * Serialize the input.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Write the input to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.prevout.toWriter(bw);
	    bw.writeVarBytes(this.script.toRaw());
	    bw.writeU32(this.sequence);
	    return bw;
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.prevout.fromReader(br);
	    this.script.fromRaw(br.readVarBytes());
	    this.sequence = br.readU32();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate an input from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {Input}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate an input from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Input}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Inject properties from outpoint.
	   * @private
	   * @param {Outpoint} outpoint
	   */

	  fromOutpoint(outpoint) {
	    assert(Buffer.isBuffer(outpoint.hash));
	    assert(typeof outpoint.index === 'number');
	    this.prevout.hash = outpoint.hash;
	    this.prevout.index = outpoint.index;
	    return this;
	  }

	  /**
	   * Instantiate input from outpoint.
	   * @param {Outpoint}
	   * @returns {Input}
	   */

	  static fromOutpoint(outpoint) {
	    return new this().fromOutpoint(outpoint);
	  }

	  /**
	   * Inject properties from coin.
	   * @private
	   * @param {Coin} coin
	   */

	  fromCoin(coin) {
	    assert(Buffer.isBuffer(coin.hash));
	    assert(typeof coin.index === 'number');
	    this.prevout.hash = coin.hash;
	    this.prevout.index = coin.index;
	    return this;
	  }

	  /**
	   * Instantiate input from coin.
	   * @param {Coin}
	   * @returns {Input}
	   */

	  static fromCoin(coin) {
	    return new this().fromCoin(coin);
	  }

	  /**
	   * Inject properties from transaction.
	   * @private
	   * @param {TX} tx
	   * @param {Number} index
	   */

	  fromTX(tx, index) {
	    assert(tx);
	    assert(typeof index === 'number');
	    assert(index >= 0 && index < tx.outputs.length);
	    this.prevout.hash = tx.hash();
	    this.prevout.index = index;
	    return this;
	  }

	  /**
	   * Instantiate input from tx.
	   * @param {TX} tx
	   * @param {Number} index
	   * @returns {Input}
	   */

	  static fromTX(tx, index) {
	    return new this().fromTX(tx, index);
	  }

	  /**
	   * Test an object to see if it is an Input.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isInput(obj) {
	    return obj instanceof Input;
	  }
	}

	/*
	 * Expose
	 */

	input = Input;
	return input;
}

/*!
 * tx.js - transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var tx;
var hasRequiredTx;

function requireTx () {
	if (hasRequiredTx) return tx;
	hasRequiredTx = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const hash256 = requireHash256();
	const secp256k1 = requireSecp256k1();
	const {BufferSet} = require$$2$2;
	const util = requireUtil();
	const Amount = requireAmount();
	const Network = requireNetwork();
	const Script = requireScript$1();
	const SLP = requireSlp();
	const Input = requireInput();
	const Output = requireOutput();
	const Outpoint = requireOutpoint();
	const InvItem = requireInvitem();
	const consensus = requireConsensus();
	const policy = requirePolicy();
	const ScriptError = requireScripterror();
	const {encoding} = bio;
	const {hashType} = Script;
	const common = requireCommon$1();
	const {inspectSymbol} = requireUtils();

	/**
	 * TX
	 * A static transaction object.
	 * @alias module:primitives.TX
	 * @property {Number} version
	 * @property {Input[]} inputs
	 * @property {Output[]} outputs
	 * @property {Number} locktime
	 * @property {SlpTokenRecord?} slpToken
	 */

	class TX {
	  /**
	   * Create a transaction.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.version = 1;
	    this.inputs = [];
	    this.outputs = [];
	    this.locktime = 0;

	    this.mutable = false;

	    this._hash = null;
	    this._hhash = null;

	    this._raw = null;
	    this._offset = -1;
	    this._block = false;
	    this._size = -1;
	    this._sigops = -1;

	    this._hashPrevouts = null;
	    this._hashSequence = null;
	    this._hashOutputs = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    assert(options, 'TX data is required.');

	    if (options.version != null) {
	      assert((options.version >>> 0) === options.version,
	        'Version must be a uint32.');
	      this.version = options.version;
	    }

	    if (options.inputs) {
	      assert(Array.isArray(options.inputs), 'Inputs must be an array.');
	      for (const input of options.inputs)
	        this.inputs.push(new Input(input));
	    }

	    if (options.outputs) {
	      assert(Array.isArray(options.outputs), 'Outputs must be an array.');
	      for (const output of options.outputs)
	        this.outputs.push(new Output(output));
	    }

	    if (options.locktime != null) {
	      assert((options.locktime >>> 0) === options.locktime,
	        'Locktime must be a uint32.');
	      this.locktime = options.locktime;
	    }

	    if (options.slpToken) {
	      if (options.slpToken.constructor === SLP.TokenRecord().constructor) {
	        this.slpToken = options.slpToken;
	      }
	    }

	    return this;
	  }

	  /**
	   * Instantiate TX from options object.
	   * @param {Object} options
	   * @returns {TX}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clone the transaction.
	   * @returns {TX}
	   */

	  clone() {
	    return new this.constructor().inject(this);
	  }

	  /**
	   * Inject properties from tx.
	   * Used for cloning.
	   * @private
	   * @param {TX} tx
	   * @returns {TX}
	   */

	  inject(tx) {
	    this.version = tx.version;

	    for (const input of tx.inputs)
	      this.inputs.push(input.clone());

	    for (const output of tx.outputs)
	      this.outputs.push(output.clone());

	    this.locktime = tx.locktime;

	    return this;
	  }

	  /**
	   * Clear any cached values.
	   */

	  refresh() {
	    this._hash = null;
	    this._hhash = null;

	    this._raw = null;
	    this._size = -1;
	    this._offset = -1;
	    this._block = false;
	    this._sigops = -1;

	    this._hashPrevouts = null;
	    this._hashSequence = null;
	    this._hashOutputs = null;
	  }

	  /**
	   * Hash the transaction with the non-witness serialization.
	   * @param {String?} enc - Can be `'hex'` or `null`.
	   * @returns {Hash|Buffer} hash
	   */

	  hash(enc) {
	    let h = this._hash;

	    if (!h) {
	      h = hash256.digest(this.toRaw());
	      if (!this.mutable)
	        this._hash = h;
	    }

	    if (enc === 'hex') {
	      let hex = this._hhash;
	      if (!hex) {
	        hex = h.toString('hex');
	        if (!this.mutable)
	          this._hhash = hex;
	      }
	      h = hex;
	    }

	    return h;
	  }

	  /**
	   * Serialize the transaction. Note
	   * that this is cached.
	   * @returns {Buffer} Serialized transaction.
	   */

	  toRaw() {
	    return this.frame().data;
	  }

	  /**
	   * Write the transaction to a buffer writer.
	   * @param {BufferWriter} bw
	   * @param {Boolean} block
	   */

	  toWriter(bw, block) {
	    if (this.mutable)
	      return this.writeNormal(bw);

	    if (block) {
	      this._offset = bw.offset;
	      this._block = true;
	    }

	    bw.writeBytes(this.toRaw());

	    return bw;
	  }

	  /**
	   * Serialize the transaction. Note
	   * that this is cached.
	   * @private
	   * @returns {RawTX}
	   */

	  frame() {
	    if (this.mutable) {
	      assert(!this._raw);
	      return this.frameNormal();
	    }

	    if (this._raw) {
	      assert(this._size >= 0);
	      const raw = new RawTX(this._size);
	      raw.data = this._raw;
	      return raw;
	    }

	    const raw = this.frameNormal();

	    this._raw = raw.data;
	    this._size = raw.size;

	    return raw;
	  }

	  /**
	   * Return the offset and size of the transaction. Useful
	   * when the transaction is deserialized within a block.
	   * @returns {Object} contains `size` and `offset`.
	   */

	  getPosition() {
	    if (!(this._block && this._offset > 80))
	      console.log(this);
	    assert(this._block && this._offset > 80, 'Position not available.');

	    return {
	      offset: this._offset,
	      size: this._size
	    };
	  }

	  /**
	   * Calculate the real size of the transaction.
	   * @returns {Number} size
	   */

	  getSize() {
	    if (this.mutable)
	      return this.getNormalSizes().size;
	    return this.frame().size;
	  }

	  /**
	   * Get the signature hash of the transaction for signing verifying.
	   * @param {Number} index - Index of input being signed/verified.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {SighashType} type - Sighash type.
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature hash.
	   */

	  signatureHash(index, prev, value, type, flags) {
	    assert(index >= 0 && index < this.inputs.length);
	    assert(prev instanceof Script);
	    assert(typeof value === 'number');
	    assert(typeof type === 'number');

	    if (flags == null)
	      flags = Script.flags.STANDARD_VERIFY_FLAGS;

	    if (flags & Script.flags.VERIFY_REPLAY_PROTECTION) {
	      const newForkValue = (common.getHashTypeForkValue(type) ^ 0xdead);
	      type = common.hashTypeWithForkValue(type, newForkValue | 0xff0000);
	    }

	    if ((type & Script.hashType.SIGHASH_FORKID)
	        && (flags & Script.flags.VERIFY_SIGHASH_FORKID)) {
	      return this.signatureHashV1(index, prev, value, type);
	    }

	    return this.signatureHashV0(index, prev, type);
	  }

	  /**
	   * Legacy sighashing -- O(n^2).
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {SighashType} type
	   * @returns {Buffer}
	   */

	  signatureHashV0(index, prev, type) {
	    if ((type & 0x1f) === hashType.SINGLE) {
	      // Bitcoind used to return 1 as an error code:
	      // it ended up being treated like a hash.
	      if (index >= this.outputs.length) {
	        const hash = Buffer.alloc(32, 0x00);
	        hash[0] = 0x01;
	        return hash;
	      }
	    }

	    // Remove all code separators.
	    prev = prev.removeSeparators();

	    // Calculate buffer size.
	    const size = this.hashSize(index, prev, type);
	    const bw = bio.pool(size);

	    bw.writeU32(this.version);

	    // Serialize inputs.
	    if (type & hashType.ANYONECANPAY) {
	      // Serialize only the current
	      // input if ANYONECANPAY.
	      const input = this.inputs[index];

	      // Count.
	      bw.writeVarint(1);

	      // Outpoint.
	      input.prevout.toWriter(bw);

	      // Replace script with previous
	      // output script if current index.
	      bw.writeVarBytes(prev.toRaw());
	      bw.writeU32(input.sequence);
	    } else {
	      bw.writeVarint(this.inputs.length);
	      for (let i = 0; i < this.inputs.length; i++) {
	        const input = this.inputs[i];

	        // Outpoint.
	        input.prevout.toWriter(bw);

	        // Replace script with previous
	        // output script if current index.
	        if (i === index) {
	          bw.writeVarBytes(prev.toRaw());
	          bw.writeU32(input.sequence);
	          continue;
	        }

	        // Script is null.
	        bw.writeVarint(0);

	        // Sequences are 0 if NONE or SINGLE.
	        switch (type & 0x1f) {
	          case hashType.NONE:
	          case hashType.SINGLE:
	            bw.writeU32(0);
	            break;
	          default:
	            bw.writeU32(input.sequence);
	            break;
	        }
	      }
	    }

	    // Serialize outputs.
	    switch (type & 0x1f) {
	      case hashType.NONE: {
	        // No outputs if NONE.
	        bw.writeVarint(0);
	        break;
	      }
	      case hashType.SINGLE: {
	        const output = this.outputs[index];

	        // Drop all outputs after the
	        // current input index if SINGLE.
	        bw.writeVarint(index + 1);

	        for (let i = 0; i < index; i++) {
	          // Null all outputs not at
	          // current input index.
	          bw.writeI64(-1);
	          bw.writeVarint(0);
	        }

	        // Regular serialization
	        // at current input index.
	        output.toWriter(bw);

	        break;
	      }
	      default: {
	        // Regular output serialization if ALL.
	        bw.writeVarint(this.outputs.length);
	        for (const output of this.outputs)
	          output.toWriter(bw);
	        break;
	      }
	    }

	    bw.writeU32(this.locktime);

	    // Append the hash type.
	    bw.writeU32(type);

	    return hash256.digest(bw.render());
	  }

	  /**
	   * Calculate sighash size.
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Number} type
	   * @returns {Number}
	   */

	  hashSize(index, prev, type) {
	    let size = 0;

	    size += 4;

	    if (type & hashType.ANYONECANPAY) {
	      size += 1;
	      size += 36;
	      size += prev.getVarSize();
	      size += 4;
	    } else {
	      size += encoding.sizeVarint(this.inputs.length);
	      size += 41 * (this.inputs.length - 1);
	      size += 36;
	      size += prev.getVarSize();
	      size += 4;
	    }

	    switch (type & 0x1f) {
	      case hashType.NONE:
	        size += 1;
	        break;
	      case hashType.SINGLE:
	        size += encoding.sizeVarint(index + 1);
	        size += 9 * index;
	        size += this.outputs[index].getSize();
	        break;
	      default:
	        size += encoding.sizeVarint(this.outputs.length);
	        for (const output of this.outputs)
	          size += output.getSize();
	        break;
	    }

	    size += 8;

	    return size;
	  }

	  /**
	   * Witness sighashing -- O(n).
	   * @private
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Amount} value
	   * @param {SighashType} type
	   * @returns {Buffer}
	   */

	  signatureHashV1(index, prev, value, type) {
	    const input = this.inputs[index];
	    let prevouts = consensus.ZERO_HASH;
	    let sequences = consensus.ZERO_HASH;
	    let outputs = consensus.ZERO_HASH;

	    if (!(type & hashType.ANYONECANPAY)) {
	      if (this._hashPrevouts) {
	        prevouts = this._hashPrevouts;
	      } else {
	        const bw = bio.pool(this.inputs.length * 36);

	        for (const input of this.inputs)
	          input.prevout.toWriter(bw);

	        prevouts = hash256.digest(bw.render());

	        if (!this.mutable)
	          this._hashPrevouts = prevouts;
	      }
	    }

	    if (!(type & hashType.ANYONECANPAY)
	        && (type & 0x1f) !== hashType.SINGLE
	        && (type & 0x1f) !== hashType.NONE) {
	      if (this._hashSequence) {
	        sequences = this._hashSequence;
	      } else {
	        const bw = bio.pool(this.inputs.length * 4);

	        for (const input of this.inputs)
	          bw.writeU32(input.sequence);

	        sequences = hash256.digest(bw.render());

	        if (!this.mutable)
	          this._hashSequence = sequences;
	      }
	    }

	    if ((type & 0x1f) !== hashType.SINGLE
	        && (type & 0x1f) !== hashType.NONE) {
	      if (this._hashOutputs) {
	        outputs = this._hashOutputs;
	      } else {
	        let size = 0;

	        for (const output of this.outputs)
	          size += output.getSize();

	        const bw = bio.pool(size);

	        for (const output of this.outputs)
	          output.toWriter(bw);

	        outputs = hash256.digest(bw.render());

	        if (!this.mutable)
	          this._hashOutputs = outputs;
	      }
	    } else if ((type & 0x1f) === hashType.SINGLE) {
	      if (index < this.outputs.length) {
	        const output = this.outputs[index];
	        outputs = hash256.digest(output.toRaw());
	      }
	    }

	    const size = 156 + prev.getVarSize();
	    const bw = bio.pool(size);

	    bw.writeU32(this.version);
	    bw.writeBytes(prevouts);
	    bw.writeBytes(sequences);
	    bw.writeHash(input.prevout.hash);
	    bw.writeU32(input.prevout.index);
	    bw.writeVarBytes(prev.toRaw());
	    bw.writeI64(value);
	    bw.writeU32(input.sequence);
	    bw.writeBytes(outputs);
	    bw.writeU32(this.locktime);
	    bw.writeU32(type);

	    return hash256.digest(bw.render());
	  }

	  /**
	   * Verify signature.
	   * @param {Number} index
	   * @param {Script} prev
	   * @param {Amount} value
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @param {Number} flags
	   * @returns {Boolean}
	   */

	  checksig(index, prev, value, sig, key, flags) {
	    if (sig.length === 0)
	      return false;

	    const type = sig[sig.length - 1];
	    const hash = this.signatureHash(index, prev, value, type, flags);

	    let res;

	    if (common.isSchnorr(sig)) {
	      res = secp256k1.schnorrVerify(hash, sig.slice(0, -1), key);
	    } else {
	      res = secp256k1.verifyDER(hash, sig.slice(0, -1), key);
	    }

	    return res;
	  }

	  /**
	   * Create a signature suitable for inserting into scriptSigs.
	   * @param {Number} index - Index of input being signed.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {Buffer} key
	   * @param {SighashType} type
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature in SCHNORR / DER format.
	   */

	  signature(index, prev, value, key, type, flags) {
	    let sig;

	    if (type == null)
	      type = hashType.ALL;

	    if (flags == null)
	      flags = Script.flags.VERIFY_SIGHASH_FORKID;

	    const hash = this.signatureHash(index, prev, value, type, flags);

	    const DER = secp256k1.signDER(hash, key);
	    const SCHNORR = secp256k1.schnorrSign(hash, key);

	    if (common.isSchnorr(SCHNORR)) {
	      sig = SCHNORR;
	    } else {
	      sig = DER;
	    }
	    const bw = bio.write(sig.length + 1);

	    bw.writeBytes(sig);
	    bw.writeU8(type);

	    return bw.render();
	  }

	  /**
	   * Create a signature suitable for inserting into scriptSigs.
	   * @param {Number} index - Index of input being signed.
	   * @param {Script} prev - Previous output script or redeem script.
	   * @param {Amount} value - Previous output value.
	   * @param {Buffer} key
	   * @param {SighashType} type
	   * @param {Number} flags - Script flags.
	   * @returns {Buffer} Signature in Schnorr format.
	   */

	  schnorrSignature(index, prev, value, key, type, flags) {
	    if (type == null)
	      type = hashType.ALL;

	    if (flags == null)
	      flags = Script.flags.VERIFY_SIGHASH_FORKID;

	    const hash = this.signatureHash(index, prev, value, type, flags);
	    const sig = secp256k1.schnorrSign(hash, key);
	    const bw = bio.write(sig.length + 1);

	    bw.writeBytes(sig);
	    bw.writeU8(type);

	    return bw.render();
	  }

	  /**
	   * Verify all transaction inputs.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @throws {ScriptError} on invalid inputs
	   */

	  check(view, flags) {
	    if (this.inputs.length === 0)
	      throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');

	    if (this.isCoinbase())
	      return;

	    for (let i = 0; i < this.inputs.length; i++) {
	      const {prevout} = this.inputs[i];
	      const coin = view.getOutput(prevout);

	      if (!coin)
	        throw new ScriptError('UNKNOWN_ERROR', 'No coin available.');

	      this.checkInput(i, coin, flags);
	    }
	  }

	  /**
	   * Verify a transaction input.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @throws {ScriptError} on invalid input
	   */

	  checkInput(index, coin, flags) {
	    const input = this.inputs[index];

	    assert(input, 'Input does not exist.');
	    assert(coin, 'No coin passed.');

	    Script.verify(
	      input.script,
	      null,
	      coin.script,
	      this,
	      index,
	      coin.value,
	      flags
	    );
	  }

	  /**
	   * Verify the transaction inputs on the worker pool
	   * (if workers are enabled).
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async checkAsync(view, flags, pool) {
	    if (this.inputs.length === 0)
	      throw new ScriptError('UNKNOWN_ERROR', 'No inputs.');

	    if (this.isCoinbase())
	      return;

	    if (!pool) {
	      this.check(view, flags);
	      return;
	    }

	    await pool.check(this, view, flags);
	  }

	  /**
	   * Verify a transaction input asynchronously.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async checkInputAsync(index, coin, flags, pool) {
	    const input = this.inputs[index];

	    assert(input, 'Input does not exist.');
	    assert(coin, 'No coin passed.');

	    if (!pool) {
	      this.checkInput(index, coin, flags);
	      return;
	    }

	    await pool.checkInput(this, index, coin, flags);
	  }

	  /**
	   * Verify all transaction inputs.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @returns {Boolean} Whether the inputs are valid.
	   */

	  verify(view, flags) {
	    try {
	      this.check(view, flags);
	    } catch (e) {
	      if (e.type === 'ScriptError')
	        return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify a transaction input.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @returns {Boolean} Whether the input is valid.
	   */

	  verifyInput(index, coin, flags) {
	    try {
	      this.checkInput(index, coin, flags);
	    } catch (e) {
	      if (e.type === 'ScriptError')
	        return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify the transaction inputs on the worker pool
	   * (if workers are enabled).
	   * @param {CoinView} view
	   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async verifyAsync(view, flags, pool) {
	    try {
	      await this.checkAsync(view, flags, pool);
	    } catch (e) {
	      if (e.type === 'ScriptError')
	        return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Verify a transaction input asynchronously.
	   * @param {Number} index - Index of output being
	   * verified.
	   * @param {Coin|Output} coin - Previous output.
	   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
	   * @param {WorkerPool?} pool
	   * @returns {Promise}
	   */

	  async verifyInputAsync(index, coin, flags, pool) {
	    try {
	      await this.checkInput(index, coin, flags, pool);
	    } catch (e) {
	      if (e.type === 'ScriptError')
	        return false;
	      throw e;
	    }
	    return true;
	  }

	  /**
	   * Test whether the transaction is a coinbase
	   * by examining the inputs.
	   * @returns {Boolean}
	   */

	  isCoinbase() {
	    return this.inputs.length === 1 && this.inputs[0].prevout.isNull();
	  }

	  /**
	   * Test whether the transaction is replaceable.
	   * @returns {Boolean}
	   */

	  isRBF() {
	    // Core doesn't do this, but it should:
	    if (this.version === 2)
	      return false;

	    for (const input of this.inputs) {
	      if (input.isRBF())
	        return true;
	    }

	    return false;
	  }

	  /**
	   * Calculate the fee for the transaction.
	   * @param {CoinView} view
	   * @returns {Amount} fee (zero if not all coins are available).
	   */

	  getFee(view) {
	    if (!this.hasCoins(view))
	      return 0;

	    return this.getInputValue(view) - this.getOutputValue();
	  }

	  /**
	   * Calculate the total input value.
	   * @param {CoinView} view
	   * @returns {Amount} value
	   */

	  getInputValue(view) {
	    let total = 0;

	    for (const {prevout} of this.inputs) {
	      const coin = view.getOutput(prevout);

	      if (!coin)
	        return 0;

	      total += coin.value;
	    }

	    return total;
	  }

	  /**
	   * Calculate the total output value.
	   * @returns {Amount} value
	   */

	  getOutputValue() {
	    let total = 0;

	    for (const output of this.outputs)
	      total += output.value;

	    return total;
	  }

	  /**
	   * Get all input addresses.
	   * @private
	   * @param {CoinView} view
	   * @returns {Array} [addrs, table]
	   */

	  _getInputAddresses(view) {
	    const table = new BufferSet();
	    const addrs = [];

	    if (this.isCoinbase())
	      return [addrs, table];

	    for (const input of this.inputs) {
	      const coin = view ? view.getOutputFor(input) : null;
	      const addr = input.getAddress(coin);

	      if (!addr)
	        continue;

	      const hash = addr.getHash();

	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }

	    return [addrs, table];
	  }

	  /**
	   * Get all output addresses.
	   * @private
	   * @returns {Array} [addrs, table]
	   */

	  _getOutputAddresses() {
	    const table = new BufferSet();
	    const addrs = [];

	    for (const output of this.outputs) {
	      const addr = output.getAddress();

	      if (!addr)
	        continue;

	      const hash = addr.getHash();

	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }

	    return [addrs, table];
	  }

	  /**
	   * Get all addresses.
	   * @private
	   * @param {CoinView} view
	   * @returns {Array} [addrs, table]
	   */

	  _getAddresses(view) {
	    const [addrs, table] = this._getInputAddresses(view);
	    const output = this.getOutputAddresses();

	    for (const addr of output) {
	      const hash = addr.getHash();

	      if (!table.has(hash)) {
	        table.add(hash);
	        addrs.push(addr);
	      }
	    }

	    return [addrs, table];
	  }

	  /**
	   * Get all input addresses.
	   * @param {CoinView|null} view
	   * @returns {Address[]} addresses
	   */

	  getInputAddresses(view) {
	    const [addrs] = this._getInputAddresses(view);
	    return addrs;
	  }

	  /**
	   * Get all output addresses.
	   * @returns {Address[]} addresses
	   */

	  getOutputAddresses() {
	    const [addrs] = this._getOutputAddresses();
	    return addrs;
	  }

	  /**
	   * Get all addresses.
	   * @param {CoinView|null} view
	   * @returns {Address[]} addresses
	   */

	  getAddresses(view) {
	    const [addrs] = this._getAddresses(view);
	    return addrs;
	  }

	  /**
	   * Get all input address hashes.
	   * @param {CoinView|null} view
	   * @returns {Hash[]} hashes
	   */

	  getInputHashes(view, enc) {
	    const [, table] = this._getInputAddresses(view);

	    if (enc !== 'hex')
	      return table.toArray();

	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Get all output address hashes.
	   * @returns {Hash[]} hashes
	   */

	  getOutputHashes(enc) {
	    const [, table] = this._getOutputAddresses();

	    if (enc !== 'hex')
	      return table.toArray();

	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Get all address hashes.
	   * @param {CoinView|null} view
	   * @returns {Hash[]} hashes
	   */

	  getHashes(view, enc) {
	    const [, table] = this._getAddresses(view);

	    if (enc !== 'hex')
	      return table.toArray();

	    return table.toArray().map(h => h.toString('hex'));
	  }

	  /**
	   * Test whether the transaction has
	   * all coins available.
	   * @param {CoinView} view
	   * @returns {Boolean}
	   */

	  hasCoins(view) {
	    if (this.inputs.length === 0)
	      return false;

	    for (const {prevout} of this.inputs) {
	      if (!view.hasEntry(prevout))
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Check finality of transaction by examining
	   * nLocktime and nSequence values.
	   * @example
	   * tx.isFinal(chain.height + 1, network.now());
	   * @param {Number} height - Height at which to test. This
	   * is usually the chain height, or the chain height + 1
	   * when the transaction entered the mempool.
	   * @param {Number} time - Time at which to test. This is
	   * usually the chain tip's parent's median time, or the
	   * time at which the transaction entered the mempool. If
	   * MEDIAN_TIME_PAST is enabled this will be the median
	   * time of the chain tip's previous entry's median time.
	   * @returns {Boolean}
	   */

	  isFinal(height, time) {
	    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;

	    if (this.locktime === 0)
	      return true;

	    if (this.locktime < (this.locktime < THRESHOLD ? height : time))
	      return true;

	    for (const input of this.inputs) {
	      if (input.sequence !== 0xffffffff)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Verify the absolute locktime of a transaction.
	   * Called by OP_CHECKLOCKTIMEVERIFY.
	   * @param {Number} index - Index of input being verified.
	   * @param {Number} predicate - Locktime to verify against.
	   * @returns {Boolean}
	   */

	  verifyLocktime(index, predicate) {
	    const THRESHOLD = consensus.LOCKTIME_THRESHOLD;
	    const input = this.inputs[index];

	    assert(input, 'Input does not exist.');
	    assert(predicate >= 0, 'Locktime must be non-negative.');

	    // Locktimes must be of the same type (blocks or seconds).
	    if ((this.locktime < THRESHOLD) !== (predicate < THRESHOLD))
	      return false;

	    if (predicate > this.locktime)
	      return false;

	    if (input.sequence === 0xffffffff)
	      return false;

	    return true;
	  }

	  /**
	   * Verify the relative locktime of an input.
	   * Called by OP_CHECKSEQUENCEVERIFY.
	   * @param {Number} index - Index of input being verified.
	   * @param {Number} predicate - Relative locktime to verify against.
	   * @returns {Boolean}
	   */

	  verifySequence(index, predicate) {
	    const DISABLE_FLAG = consensus.SEQUENCE_DISABLE_FLAG;
	    const TYPE_FLAG = consensus.SEQUENCE_TYPE_FLAG;
	    const MASK = consensus.SEQUENCE_MASK;
	    const input = this.inputs[index];

	    assert(input, 'Input does not exist.');
	    assert(predicate >= 0, 'Locktime must be non-negative.');

	    // For future softfork capability.
	    if (predicate & DISABLE_FLAG)
	      return true;

	    // Version must be >=2.
	    if (this.version < 2)
	      return false;

	    // Cannot use the disable flag without
	    // the predicate also having the disable
	    // flag (for future softfork capability).
	    if (input.sequence & DISABLE_FLAG)
	      return false;

	    // Locktimes must be of the same type (blocks or seconds).
	    if ((input.sequence & TYPE_FLAG) !== (predicate & TYPE_FLAG))
	      return false;

	    if ((predicate & MASK) > (input.sequence & MASK))
	      return false;

	    return true;
	  }

	  /**
	   * Calculate legacy (inaccurate) sigop count.
	   * @returns {Number} sigop count
	   */

	  getLegacySigops() {
	    if (this._sigops !== -1)
	      return this._sigops;

	    let total = 0;

	    for (const input of this.inputs)
	      total += input.script.getSigops(false);

	    for (const output of this.outputs)
	      total += output.script.getSigops(false);

	    if (!this.mutable)
	      this._sigops = total;

	    return total;
	  }

	  /**
	   * Calculate accurate sigop count, taking into account redeem scripts.
	   * @param {CoinView} view
	   * @param {VerifyFlags} flags
	   * @returns {Number} sigop count
	   */

	  getScripthashSigops(view, flags) {
	    if (this.isCoinbase())
	      return 0;

	    let total = 0;

	    for (const input of this.inputs) {
	      const coin = view.getOutputFor(input);

	      if (!coin)
	        continue;

	      if (!coin.script.isScripthash())
	        continue;

	      total += coin.script.getScripthashSigops(input.script, flags);
	    }

	    return total;
	  }

	  /**
	   * Calculate sigops count.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Number} sigop count
	   */

	  getSigopsCount(view, flags) {
	    if (flags === null)
	      flags = Script.flags.STANDARD_VERIFY_FLAGS;

	    let cost = this.getLegacySigops();

	    if (flags & Script.flags.VERIFY_P2SH)
	      cost += this.getScripthashSigops(view, flags);

	    return cost;
	  }

	  /**
	   * Calculate sigop count.
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Number} sigop count
	   */

	  getSigops(view, flags) {
	    return this.getSigopsCount(view, flags);
	  }

	  /**
	   * Non-contextual sanity checks for the transaction.
	   * Will mostly verify coin and output values.
	   * @see CheckTransaction()
	   * @returns {Array} [result, reason, score]
	   */

	  isSane() {
	    const [valid] = this.checkSanity();
	    return valid;
	  }

	  /**
	   * Non-contextual sanity checks for the transaction.
	   * Will mostly verify coin and output values.
	   * @see CheckTransaction()
	   * @returns {Array} [valid, reason, score]
	   */

	  checkSanity() {
	    if (this.inputs.length === 0)
	      return [false, 'bad-txns-vin-empty', 100];

	    if (this.outputs.length === 0)
	      return [false, 'bad-txns-vout-empty', 100];

	    if (this.getSize() > consensus.MAX_TX_SIZE)
	      return [false, 'bad-txns-oversize', 100];

	    let total = 0;

	    for (const output of this.outputs) {
	      if (output.value < 0)
	        return [false, 'bad-txns-vout-negative', 100];

	      if (output.value > consensus.MAX_MONEY)
	        return [false, 'bad-txns-vout-toolarge', 100];

	      total += output.value;

	      if (total < 0 || total > consensus.MAX_MONEY)
	        return [false, 'bad-txns-txouttotal-toolarge', 100];
	    }

	    const prevout = new BufferSet();

	    for (const input of this.inputs) {
	      const key = input.prevout.toKey();

	      if (prevout.has(key))
	        return [false, 'bad-txns-inputs-duplicate', 100];

	      prevout.add(key);
	    }

	    if (this.isCoinbase()) {
	      const size = this.inputs[0].script.getSize();
	      if (size < 2 || size > consensus.MAX_COINBASE_SCRIPTSIG_SIZE)
	        return [false, 'bad-cb-length', 100];
	    } else {
	      for (const input of this.inputs) {
	        if (input.prevout.isNull())
	          return [false, 'bad-txns-prevout-null', 10];
	      }
	    }

	    return [true, 'valid', 0];
	  }

	  /**
	   * Non-contextual checks to determine whether the
	   * transaction has all standard output script
	   * types and standard input script size with only
	   * pushdatas in the code.
	   * Will mostly verify coin and output values.
	   * @see IsStandardTx()
	   * @returns {Array} [valid, reason, score]
	   */

	  isStandard() {
	    const [valid] = this.checkStandard();
	    return valid;
	  }

	  /**
	   * Non-contextual checks to determine whether the
	   * transaction has all standard output script
	   * types and standard input script size with only
	   * pushdatas in the code.
	   * Will mostly verify coin and output values.
	   * @see IsStandardTx()
	   * @returns {Array} [valid, reason, score]
	   */

	  checkStandard() {
	    if (this.version < 1 || this.version > policy.MAX_TX_VERSION)
	      return [false, 'version', 0];

	    // MAX_STANDARD_TX_SIZE
	    if (this.getSize() >= policy.MAX_TX_SIZE)
	      return [false, 'tx-size', 0];

	    for (const input of this.inputs) {
	      if (input.script.getSize() > 1650)
	        return [false, 'scriptsig-size', 0];

	      if (!input.script.isPushOnly())
	        return [false, 'scriptsig-not-pushonly', 0];
	    }

	    let nulldata = 0;

	    for (const output of this.outputs) {
	      if (!output.script.isStandard())
	        return [false, 'scriptpubkey', 0];

	      if (output.script.isNulldata()) {
	        nulldata++;
	        continue;
	      }

	      if (output.script.isMultisig() && !policy.BARE_MULTISIG)
	        return [false, 'bare-multisig', 0];

	      if (output.isDust(policy.MIN_RELAY))
	        return [false, 'dust', 0];
	    }

	    if (nulldata > 1)
	      return [false, 'multi-op-return', 0];

	    return [true, 'valid', 0];
	  }

	  /**
	   * Perform contextual checks to verify coin and input
	   * script standardness (including the redeem script).
	   * @see AreInputsStandard()
	   * @param {CoinView} view
	   * @param {VerifyFlags?} flags
	   * @returns {Boolean}
	   */

	  hasStandardInputs(view) {
	    if (this.isCoinbase())
	      return true;

	    for (const input of this.inputs) {
	      const coin = view.getOutputFor(input);

	      if (!coin)
	        return false;

	      if (coin.script.isPubkeyhash())
	        continue;

	      if (coin.script.isScripthash()) {
	        const redeem = input.script.getRedeem();

	        if (!redeem)
	          return false;

	        if (redeem.getSigops(true) > policy.MAX_P2SH_SIGOPS)
	          return false;

	        continue;
	      }

	      if (coin.script.isUnknown())
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Perform contextual checks to verify input, output,
	   * and fee values, as well as coinbase spend maturity
	   * (coinbases can only be spent 100 blocks or more
	   * after they're created). Note that this function is
	   * consensus critical.
	   * @param {CoinView} view
	   * @param {Number} height - Height at which the
	   * transaction is being spent. In the mempool this is
	   * the chain height plus one at the time it entered the pool.
	   * @returns {Boolean}
	   */

	  verifyInputs(view, height) {
	    const [fee] = this.checkInputs(view, height);
	    return fee !== -1;
	  }

	  /**
	   * Perform contextual checks to verify input, output,
	   * and fee values, as well as coinbase spend maturity
	   * (coinbases can only be spent 100 blocks or more
	   * after they're created). Note that this function is
	   * consensus critical.
	   * @param {CoinView} view
	   * @param {Number} height - Height at which the
	   * transaction is being spent. In the mempool this is
	   * the chain height plus one at the time it entered the pool.
	   * @returns {Array} [fee, reason, score]
	   */

	  checkInputs(view, height) {
	    assert(typeof height === 'number');

	    let total = 0;

	    for (const {prevout} of this.inputs) {
	      const entry = view.getEntry(prevout);

	      if (!entry)
	        return [-1, 'bad-txns-inputs-missingorspent', 0];

	      if (entry.coinbase) {
	        if (height - entry.height < consensus.COINBASE_MATURITY)
	          return [-1, 'bad-txns-premature-spend-of-coinbase', 0];
	      }

	      const coin = view.getOutput(prevout);
	      assert(coin);

	      if (coin.value < 0 || coin.value > consensus.MAX_MONEY)
	        return [-1, 'bad-txns-inputvalues-outofrange', 100];

	      total += coin.value;

	      if (total < 0 || total > consensus.MAX_MONEY)
	        return [-1, 'bad-txns-inputvalues-outofrange', 100];
	    }

	    // Overflows already checked in `isSane()`.
	    const value = this.getOutputValue();

	    if (total < value)
	      return [-1, 'bad-txns-in-belowout', 100];

	    const fee = total - value;

	    if (fee < 0)
	      return [-1, 'bad-txns-fee-negative', 100];

	    if (fee > consensus.MAX_MONEY)
	      return [-1, 'bad-txns-fee-outofrange', 100];

	    return [fee, 'valid', 0];
	  }

	  /**
	   * Calculate the modified size of the transaction. This
	   * is used in the mempool for calculating priority.
	   * @param {Number?} size - The size to modify. If not present,
	   * virtual size will be used.
	   * @returns {Number} Modified size.
	   */

	  getModifiedSize(size) {
	    if (size == null)
	      size = this.getSize();

	    for (const input of this.inputs) {
	      const offset = 41 + Math.min(110, input.script.getSize());
	      if (size > offset)
	        size -= offset;
	    }

	    return size;
	  }

	  /**
	   * Calculate the transaction priority.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @param {Number?} size - Size to calculate priority
	   * based on. If not present, virtual size will be used.
	   * @returns {Number}
	   */

	  getPriority(view, height, size) {
	    assert(typeof height === 'number', 'Must pass in height.');

	    if (this.isCoinbase())
	      return 0;

	    if (size == null)
	      size = this.getSize();

	    let sum = 0;

	    for (const {prevout} of this.inputs) {
	      const coin = view.getOutput(prevout);

	      if (!coin)
	        continue;

	      const coinHeight = view.getHeight(prevout);

	      if (coinHeight === -1)
	        continue;

	      if (coinHeight <= height) {
	        const age = height - coinHeight;
	        sum += coin.value * age;
	      }
	    }

	    return Math.floor(sum / size);
	  }

	  /**
	   * Calculate the transaction's on-chain value.
	   * @param {CoinView} view
	   * @returns {Number}
	   */

	  getChainValue(view) {
	    if (this.isCoinbase())
	      return 0;

	    let value = 0;

	    for (const {prevout} of this.inputs) {
	      const coin = view.getOutput(prevout);

	      if (!coin)
	        continue;

	      const height = view.getHeight(prevout);

	      if (height === -1)
	        continue;

	      value += coin.value;
	    }

	    return value;
	  }

	  /**
	   * Determine whether the transaction is above the
	   * free threshold in priority. A transaction which
	   * passed this test is most likely relayable
	   * without a fee.
	   * @param {CoinView} view
	   * @param {Number?} height - If not present, tx
	   * height or network height will be used.
	   * @param {Number?} size - If not present, modified
	   * size will be calculated and used.
	   * @returns {Boolean}
	   */

	  isFree(view, height, size) {
	    const priority = this.getPriority(view, height, size);
	    return priority > policy.FREE_THRESHOLD;
	  }

	  /**
	   * Calculate minimum fee in order for the transaction
	   * to be relayable (not the constant min relay fee).
	   * @param {Number?} size - If not present, max size
	   * estimation will be calculated and used.
	   * @param {Rate?} rate - Rate of satoshi per kB.
	   * @returns {Amount} fee
	   */

	  getMinFee(size, rate) {
	    if (size == null)
	      size = this.getSize();

	    return policy.getMinFee(size, rate);
	  }

	  /**
	   * Calculate the minimum fee in order for the transaction
	   * to be relayable, but _round to the nearest kilobyte
	   * when taking into account size.
	   * @param {Number?} size - If not present, max size
	   * estimation will be calculated and used.
	   * @param {Rate?} rate - Rate of satoshi per kB.
	   * @returns {Amount} fee
	   */

	  getRoundFee(size, rate) {
	    if (size == null)
	      size = this.getSize();

	    return policy.getRoundFee(size, rate);
	  }

	  /**
	   * Calculate the transaction's rate based on size
	   * and fees. Size will be calculated if not present.
	   * @param {CoinView} view
	   * @param {Number?} size
	   * @returns {Rate}
	   */

	  getRate(view, size) {
	    const fee = this.getFee(view);

	    if (fee < 0)
	      return 0;

	    if (size == null)
	      size = this.getSize();

	    return policy.getRate(size, fee);
	  }

	  /**
	   * Get all unique outpoint hashes.
	   * @returns {Hash[]} Outpoint hashes.
	   */

	  getPrevout() {
	    if (this.isCoinbase())
	      return [];

	    const prevout = new BufferSet();

	    for (const input of this.inputs)
	      prevout.add(input.prevout.hash);

	    return prevout.toArray();
	  }

	  /**
	   * Test a transaction against a bloom filter using
	   * the BIP37 matching algorithm. Note that this may
	   * update the filter depending on what the `update`
	   * value is.
	   * @see "Filter matching algorithm":
	   * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
	   * @param {BloomFilter} filter
	   * @returns {Boolean} True if the transaction matched.
	   */

	  isWatched(filter) {
	    let found = false;

	    // 1. Test the tx hash
	    if (filter.test(this.hash()))
	      found = true;

	    // 2. Test data elements in output scripts
	    //    (may need to update filter on match)
	    for (let i = 0; i < this.outputs.length; i++) {
	      const output = this.outputs[i];
	      // Test the output script
	      if (output.script.test(filter)) {
	        if (filter.update === 1 /* ALL */) {
	          const prevout = Outpoint.fromTX(this, i);
	          filter.add(prevout.toRaw());
	        } else if (filter.update === 2 /* PUBKEY_ONLY */) {
	          if (output.script.isPubkey() || output.script.isMultisig()) {
	            const prevout = Outpoint.fromTX(this, i);
	            filter.add(prevout.toRaw());
	          }
	        }
	        found = true;
	      }
	    }

	    if (found)
	      return found;

	    // 3. Test prev_out structure
	    // 4. Test data elements in input scripts
	    for (const input of this.inputs) {
	      const prevout = input.prevout;

	      // Test the COutPoint structure
	      if (filter.test(prevout.toRaw()))
	        return true;

	      // Test the input script
	      if (input.script.test(filter))
	        return true;
	    }

	    // 5. No match
	    return false;
	  }

	  /**
	   * Get little-endian tx hash.
	   * @returns {Hash}
	   */

	  rhash() {
	    return util.revHex(this.hash());
	  }

	  /**
	   * Get little-endian tx hash.
	   * @returns {Hash}
	   */

	  txid() {
	    return this.rhash();
	  }

	  /**
	   * Convert the tx to an inv item.
	   * @returns {InvItem}
	   */

	  toInv() {
	    return new InvItem(InvItem.types.TX, this.hash());
	  }

	  /**
	   * Inspect the transaction and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the transaction and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {ChainEntry} entry
	   * @param {Number} index
	   * @returns {Object}
	   */

	  format(view, entry, index) {
	    let rate = 0;
	    let fee = 0;
	    let height = -1;
	    let block = null;
	    let time = 0;
	    let date = null;

	    if (view) {
	      fee = this.getFee(view);
	      rate = this.getRate(view);

	      // Rate can exceed 53 bits in testing.
	      if (!Number.isSafeInteger(rate))
	        rate = 0;
	    }

	    if (entry) {
	      height = entry.height;
	      block = util.revHex(entry.hash);
	      time = entry.time;
	      date = util.date(time);
	    }

	    if (index == null)
	      index = -1;

	    const hr = {
	      hash: this.txid(),
	      size: this.getSize(),
	      value: Amount.btc(this.getOutputValue()),
	      fee: Amount.btc(fee),
	      rate: Amount.btc(rate),
	      minFee: Amount.btc(this.getMinFee()),
	      height: height,
	      block: block,
	      time: time,
	      date: date,
	      index: index,
	      version: this.version,
	      inputs: this.inputs.map((input) => {
	        const coin = view ? view.getOutputFor(input) : null;
	        return input.format(coin);
	      }),
	      outputs: this.outputs,
	      locktime: this.locktime
	    };

	    if (this.slpToken) {
	      return {
	        ...hr,
	        slpToken: this.slpToken
	      };
	    }
	    return hr;
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {ChainEntry} entry
	   * @param {Number} index
	   * @returns {Object}
	   */

	  getJSON(network, view, entry, index) {
	    let rate, fee, height, block, time, date;

	    if (view) {
	      fee = this.getFee(view);
	      rate = this.getRate(view);

	      // Rate can exceed 53 bits in testing.
	      if (!Number.isSafeInteger(rate))
	        rate = 0;
	    }

	    if (entry) {
	      height = entry.height;
	      block = util.revHex(entry.hash);
	      time = entry.time;
	      date = util.date(time);
	    }

	    network = Network.get(network);

	    const json = {
	      hash: this.txid(),
	      fee: fee,
	      rate: rate,
	      mtime: util.now(),
	      height: height,
	      block: block,
	      time: time,
	      date: date,
	      index: index,
	      version: this.version,
	      inputs: this.inputs.map((input) => {
	        const coin = view ? view.getCoinFor(input) : null;
	        return input.getJSON(network, coin);
	      }),
	      outputs: this.outputs.map((output) => {
	        return output.getJSON(network);
	      }),
	      locktime: this.locktime,
	      hex: this.toRaw().toString('hex')
	    };

	    if (this.slpToken) {
	      return {
	        ...json,
	        slpToken: this.slpToken.getJSON()
	      };
	    }
	    return json;
	  }

	  /**
	   * Inject properties from a json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'TX data is required.');
	    assert((json.version >>> 0) === json.version, 'Version must be a uint32.');
	    assert(Array.isArray(json.inputs), 'Inputs must be an array.');
	    assert(Array.isArray(json.outputs), 'Outputs must be an array.');
	    assert((json.locktime >>> 0) === json.locktime,
	      'Locktime must be a uint32.');

	    this.version = json.version;

	    for (const input of json.inputs)
	      this.inputs.push(Input.fromJSON(input));

	    for (const output of json.outputs)
	      this.outputs.push(Output.fromJSON(output));

	    this.locktime = json.locktime;

	    if (json.slpToken)
	      this.slpToken = SLP.TokenRecord().fromJSON(json.slpToken);

	    return this;
	  }

	  /**
	   * Instantiate a transaction from a
	   * jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {TX}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Instantiate a transaction from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {TX}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Instantiate a transaction from a buffer reader.
	   * @param {BufferReader} br
	   * @param {Boolean} block
	   * @returns {TX}
	   */

	  static fromReader(br, block) {
	    return new this().fromReader(br, block);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   * @param {Boolean} block
	   */

	  fromReader(br, block) {
	    const start = br.start();

	    this.version = br.readU32();

	    const inCount = br.readVarint();

	    for (let i = 0; i < inCount; i++)
	      this.inputs.push(Input.fromReader(br));

	    const outCount = br.readVarint();

	    for (let i = 0; i < outCount; i++)
	      this.outputs.push(Output.fromReader(br));

	    this.locktime = br.readU32();

	    if (block) {
	      this._offset = start;
	      this._block = true;
	    }

	    if (!this.mutable) {
	      this._raw = br.endData();
	      this._size = this._raw.length;
	    } else {
	      br.end();
	    }

	    return this;
	  }

	  /**
	   * Serialize transaction without witness.
	   * @private
	   * @returns {RawTX}
	   */

	  frameNormal() {
	    const raw = this.getNormalSizes();
	    const bw = bio.write(raw.size);
	    this.writeNormal(bw);
	    raw.data = bw.render();
	    return raw;
	  }

	  /**
	   * Serialize transaction without witness.
	   * @private
	   * @param {BufferWriter} bw
	   * @returns {RawTX}
	   */

	  writeNormal(bw) {
	    if (this.inputs.length === 0 && this.outputs.length !== 0)
	      throw new Error('Cannot serialize zero-input tx.');

	    bw.writeU32(this.version);

	    bw.writeVarint(this.inputs.length);

	    for (const input of this.inputs)
	      input.toWriter(bw);

	    bw.writeVarint(this.outputs.length);

	    for (const output of this.outputs)
	      output.toWriter(bw);

	    bw.writeU32(this.locktime);

	    return bw;
	  }

	  /**
	   * Calculate the real size of the transaction
	   * without the witness vector.
	   * @returns {RawTX}
	   */

	  getNormalSizes() {
	    let base = 0;

	    base += 4;

	    base += encoding.sizeVarint(this.inputs.length);

	    for (const input of this.inputs)
	      base += input.getSize();

	    base += encoding.sizeVarint(this.outputs.length);

	    for (const output of this.outputs)
	      base += output.getSize();

	    base += 4;

	    return new RawTX(base, 0);
	  }

	  /**
	   * Test whether an object is a TX.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isTX(obj) {
	    return obj instanceof TX;
	  }
	}

	/*
	 * Helpers
	 */

	class RawTX {
	  constructor(size) {
	    this.data = null;
	    this.size = size;
	  }
	}

	/*
	 * Expose
	 */

	tx = TX;
	return tx;
}

/*!
 * headers.js - headers object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var headers;
var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;

	const bio = require$$1;
	const util = requireUtil();
	const AbstractBlock = requireAbstractblock();
	const {inspectSymbol} = requireUtils();

	/**
	 * Headers
	 * Represents block headers obtained
	 * from the network via `headers`.
	 * @alias module:primitives.Headers
	 * @extends AbstractBlock
	 */

	class Headers extends AbstractBlock {
	  /**
	   * Create headers.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();

	    if (options)
	      this.parseOptions(options);
	  }

	  /**
	   * Perform non-contextual
	   * verification on the headers.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    return true;
	  }

	  /**
	   * Get size of the headers.
	   * @returns {Number}
	   */

	  getSize() {
	    return 81;
	  }

	  /**
	   * Serialize the headers to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.writeHead(bw);
	    bw.writeVarint(0);
	    return bw;
	  }

	  /**
	   * Serialize the headers.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {Buffer} data
	   */

	  fromReader(br) {
	    this.readHead(br);
	    br.readVarint();
	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate headers from buffer reader.
	   * @param {BufferReader} br
	   * @returns {Headers}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate headers from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Headers}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Instantiate headers from serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Headers}
	   */

	  static fromHead(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromHead(data);
	  }

	  /**
	   * Instantiate headers from a chain entry.
	   * @param {ChainEntry} entry
	   * @returns {Headers}
	   */

	  static fromEntry(entry) {
	    const headers = new this();
	    headers.version = entry.version;
	    headers.prevBlock = entry.prevBlock;
	    headers.merkleRoot = entry.merkleRoot;
	    headers.time = entry.time;
	    headers.bits = entry.bits;
	    headers.nonce = entry.nonce;
	    headers._hash = entry.hash;
	    headers._hhash = entry.hash;
	    return headers;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return this;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @param {Block|MerkleBlock} block
	   * @returns {Headers}
	   */

	  static fromBlock(block) {
	    const headers = new this(block);
	    headers._hash = block._hash;
	    headers._hhash = block._hhash;
	    return headers;
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  getJSON(network, view, height) {
	    return {
	      hash: this.rhash(),
	      height: height,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    this.parseJSON(json);
	    return this;
	  }

	  /**
	   * Instantiate a merkle block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {Headers}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inspect the headers and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the headers and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce
	    };
	  }

	  /**
	   * Test an object to see if it is a Headers object.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isHeaders(obj) {
	    return obj instanceof Headers;
	  }
	}

	/*
	 * Expose
	 */

	headers = Headers;
	return headers;
}

/*!
 * merkleblock.js - merkleblock object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var merkleblock;
var hasRequiredMerkleblock;

function requireMerkleblock () {
	if (hasRequiredMerkleblock) return merkleblock;
	hasRequiredMerkleblock = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {BufferMap, BufferSet} = require$$2$2;
	const util = requireUtil();
	const hash256 = requireHash256();
	const consensus = requireConsensus();
	const AbstractBlock = requireAbstractblock();
	const Headers = requireHeaders();
	const DUMMY = Buffer.from([0]);
	const {encoding} = bio;
	const {inspectSymbol} = requireUtils();

	/**
	 * Merkle Block
	 * Represents a merkle (filtered) block.
	 * @alias module:primitives.MerkleBlock
	 * @extends AbstractBlock
	 */

	class MerkleBlock extends AbstractBlock {
	  /**
	   * Create a merkle block.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();

	    this.txs = [];
	    this.hashes = [];
	    this.flags = DUMMY;

	    this.totalTX = 0;
	    this._tree = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    this.parseOptions(options);

	    assert(options, 'MerkleBlock data is required.');
	    assert(Array.isArray(options.hashes));
	    assert(Buffer.isBuffer(options.flags));
	    assert((options.totalTX >>> 0) === options.totalTX);

	    if (options.hashes) {
	      for (const hash of options.hashes) {
	        assert(Buffer.isBuffer(hash));
	        this.hashes.push(hash);
	      }
	    }

	    if (options.flags) {
	      assert(Buffer.isBuffer(options.flags));
	      this.flags = options.flags;
	    }

	    if (options.totalTX != null) {
	      assert((options.totalTX >>> 0) === options.totalTX);
	      this.totalTX = options.totalTX;
	    }

	    return this;
	  }

	  /**
	   * Instantiate merkle block from options object.
	   * @param {Object} options
	   * @returns {MerkleBlock}
	   */

	  static fromOptions(data) {
	    return new this().fromOptions(data);
	  }

	  /**
	   * Clear any cached values.
	   * @param {Boolean?} all - Clear transactions.
	   */

	  refresh(all) {
	    this._refresh();
	    this._tree = null;

	    if (!all)
	      return;

	    for (const tx of this.txs)
	      tx.refresh();
	  }

	  /**
	   * Test the block's _matched_ transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  hasTX(hash) {
	    return this.indexOf(hash) !== -1;
	  }

	  /**
	   * Test the block's _matched_ transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Number} Index.
	   */

	  indexOf(hash) {
	    const tree = this.getTree();
	    const index = tree.map.get(hash);

	    if (index == null)
	      return -1;

	    return index;
	  }

	  /**
	   * Verify the partial merkletree.
	   * @private
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    const [valid] = this.checkBody();
	    return valid;
	  }

	  /**
	   * Verify the partial merkletree.
	   * @private
	   * @returns {Array} [valid, reason, score]
	   */

	  checkBody() {
	    const tree = this.getTree();

	    if (!tree.root.equals(this.merkleRoot))
	      return [false, 'bad-txnmrklroot', 100];

	    return [true, 'valid', 0];
	  }

	  /**
	   * Extract the matches from partial merkle
	   * tree and calculate merkle root.
	   * @returns {Object}
	   */

	  getTree() {
	    if (!this._tree) {
	      try {
	        this._tree = this.extractTree();
	      } catch (e) {
	        this._tree = new PartialTree();
	      }
	    }
	    return this._tree;
	  }

	  /**
	   * Extract the matches from partial merkle
	   * tree and calculate merkle root.
	   * @private
	   * @returns {Object}
	   */

	  extractTree() {
	    const matches = [];
	    const indexes = [];
	    const map = new BufferMap();
	    const hashes = this.hashes;
	    const flags = this.flags;
	    const totalTX = this.totalTX;

	    let bitsUsed = 0;
	    let hashUsed = 0;
	    let failed = false;
	    let height = 0;

	    const width = (height) => {
	      return (totalTX + (1 << height) - 1) >>> height;
	    };

	    const traverse = (height, pos) => {
	      if (bitsUsed >= flags.length * 8) {
	        failed = true;
	        return consensus.ZERO_HASH;
	      }

	      const parent = (flags[bitsUsed / 8 | 0] >>> (bitsUsed % 8)) & 1;

	      bitsUsed += 1;

	      if (height === 0 || !parent) {
	        if (hashUsed >= hashes.length) {
	          failed = true;
	          return consensus.ZERO_HASH;
	        }

	        const hash = hashes[hashUsed];

	        hashUsed += 1;

	        if (height === 0 && parent) {
	          matches.push(hash);
	          indexes.push(pos);
	          map.set(hash, pos);
	        }

	        return hash;
	      }

	      const left = traverse(height - 1, pos * 2);
	      let right;

	      if (pos * 2 + 1 < width(height - 1)) {
	        right = traverse(height - 1, pos * 2 + 1);
	        if (right.equals(left))
	          failed = true;
	      } else {
	        right = left;
	      }

	      return hash256.root(left, right);
	    };

	    if (totalTX === 0)
	      throw new Error('Zero transactions.');

	    // FIXME: Track the maximum block size we've seen and use it here.

	    if (hashes.length > totalTX)
	      throw new Error('Too many hashes.');

	    if (flags.length * 8 < hashes.length)
	      throw new Error('Flags too small.');

	    while (width(height) > 1)
	      height += 1;

	    const root = traverse(height, 0);

	    if (failed)
	      throw new Error('Mutated merkle tree.');

	    if (((bitsUsed + 7) / 8 | 0) !== flags.length)
	      throw new Error('Too many flag bits.');

	    if (hashUsed !== hashes.length)
	      throw new Error('Incorrect number of hashes.');

	    return new PartialTree(root, matches, indexes, map);
	  }

	  /**
	   * Extract the coinbase height (always -1).
	   * @returns {Number}
	   */

	  getCoinbaseHeight() {
	    return -1;
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      totalTX: this.totalTX,
	      hashes: this.hashes.map((hash) => {
	        return hash.toString('hex');
	      }),
	      flags: this.flags,
	      map: this.getTree().map,
	      txs: this.txs.length
	    };
	  }

	  /**
	   * Get merkleblock size.
	   * @returns {Number} Size.
	   */

	  getSize() {
	    let size = 0;
	    size += 80;
	    size += 4;
	    size += encoding.sizeVarint(this.hashes.length);
	    size += this.hashes.length * 32;
	    size += encoding.sizeVarint(this.flags.length);
	    size += this.flags.length;
	    return size;
	  }

	  /**
	   * Write the merkleblock to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    this.writeHead(bw);

	    bw.writeU32(this.totalTX);

	    bw.writeVarint(this.hashes.length);

	    for (const hash of this.hashes)
	      bw.writeHash(hash);

	    bw.writeVarBytes(this.flags);

	    return bw;
	  }

	  /**
	   * Serialize the merkleblock.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Buffer|String}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    this.readHead(br);

	    this.totalTX = br.readU32();

	    const count = br.readVarint();

	    for (let i = 0; i < count; i++)
	      this.hashes.push(br.readHash());

	    this.flags = br.readVarBytes();

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a merkleblock from a buffer reader.
	   * @param {BufferReader} br
	   * @returns {MerkleBlock}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a merkleblock from a serialized data.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {MerkleBlock}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  getJSON(network, view, height) {
	    return {
	      hash: this.rhash(),
	      height: height,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      totalTX: this.totalTX,
	      hashes: this.hashes.map((hash) => {
	        return util.revHex(hash);
	      }),
	      flags: this.flags.toString('hex')
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'MerkleBlock data is required.');
	    assert(Array.isArray(json.hashes));
	    assert(typeof json.flags === 'string');
	    assert((json.totalTX >>> 0) === json.totalTX);

	    this.parseJSON(json);

	    for (const hash of json.hashes)
	      this.hashes.push(util.fromRev(hash));

	    this.flags = Buffer.from(json.flags, 'hex');

	    this.totalTX = json.totalTX;

	    return this;
	  }

	  /**
	   * Instantiate a merkle block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {MerkleBlock}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Create a merkleblock from a {@link Block} object, passing
	   * it through a filter first. This will build the partial
	   * merkle tree.
	   * @param {Block} block
	   * @param {Bloom} filter
	   * @returns {MerkleBlock}
	   */

	  static fromBlock(block, filter) {
	    const matches = [];

	    for (const tx of block.txs)
	      matches.push(tx.isWatched(filter) ? 1 : 0);

	    return this.fromMatches(block, matches);
	  }

	  /**
	   * Create a merkleblock from an array of txids.
	   * This will build the partial merkle tree.
	   * @param {Block} block
	   * @param {Hash[]} hashes
	   * @returns {MerkleBlock}
	   */

	  static fromHashes(block, hashes) {
	    const filter = new BufferSet();

	    for (const hash of hashes)
	      filter.add(hash);

	    const matches = [];

	    for (const tx of block.txs) {
	      const hash = tx.hash();
	      matches.push(filter.has(hash) ? 1 : 0);
	    }

	    return this.fromMatches(block, matches);
	  }

	  /**
	   * Create a merkleblock from an array of matches.
	   * This will build the partial merkle tree.
	   * @param {Block} block
	   * @param {Number[]} matches
	   * @returns {MerkleBlock}
	   */

	  static fromMatches(block, matches) {
	    const txs = [];
	    const leaves = [];
	    const bits = [];
	    const hashes = [];
	    const totalTX = block.txs.length;
	    let height = 0;

	    const width = (height) => {
	      return (totalTX + (1 << height) - 1) >>> height;
	    };

	    const hash = (height, pos, leaves) => {
	      if (height === 0)
	        return leaves[pos];

	      const left = hash(height - 1, pos * 2, leaves);
	      let right;

	      if (pos * 2 + 1 < width(height - 1))
	        right = hash(height - 1, pos * 2 + 1, leaves);
	      else
	        right = left;

	      return hash256.root(left, right);
	    };

	    const traverse = (height, pos, leaves, matches) => {
	      let parent = 0;

	      for (let p = pos << height; p < ((pos + 1) << height) && p < totalTX; p++)
	        parent |= matches[p];

	      bits.push(parent);

	      if (height === 0 || !parent) {
	        hashes.push(hash(height, pos, leaves));
	        return;
	      }

	      traverse(height - 1, pos * 2, leaves, matches);

	      if (pos * 2 + 1 < width(height - 1))
	        traverse(height - 1, pos * 2 + 1, leaves, matches);
	    };

	    for (let i = 0; i < block.txs.length; i++) {
	      const tx = block.txs[i];

	      if (matches[i])
	        txs.push(tx);

	      leaves.push(tx.hash());
	    }

	    while (width(height) > 1)
	      height += 1;

	    traverse(height, 0, leaves, matches);

	    const flags = Buffer.allocUnsafe((bits.length + 7) / 8 | 0);
	    flags.fill(0);

	    for (let p = 0; p < bits.length; p++)
	      flags[p / 8 | 0] |= bits[p] << (p % 8);

	    const merkle = new this();
	    merkle._hash = block._hash;
	    merkle._hhash = block._hhash;
	    merkle.version = block.version;
	    merkle.prevBlock = block.prevBlock;
	    merkle.merkleRoot = block.merkleRoot;
	    merkle.time = block.time;
	    merkle.bits = block.bits;
	    merkle.nonce = block.nonce;
	    merkle.totalTX = totalTX;
	    merkle.hashes = hashes;
	    merkle.flags = flags;
	    merkle.txs = txs;

	    return merkle;
	  }

	  /**
	   * Test whether an object is a MerkleBlock.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMerkleBlock(obj) {
	    return obj instanceof MerkleBlock;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }
	}

	/*
	 * Helpers
	 */

	class PartialTree {
	  constructor(root, matches, indexes, map) {
	    this.root = root || consensus.ZERO_HASH;
	    this.matches = matches || [];
	    this.indexes = indexes || [];
	    this.map = map || new BufferMap();
	  }
	}

	/*
	 * Expose
	 */

	merkleblock = MerkleBlock;
	return merkleblock;
}

/*!
 * block.js - block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var block;
var hasRequiredBlock;

function requireBlock () {
	if (hasRequiredBlock) return block;
	hasRequiredBlock = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const {BufferSet} = require$$2$2;
	const hash256 = requireHash256();
	const merkle = requireMerkle();
	const consensus = requireConsensus();
	const AbstractBlock = requireAbstractblock();
	const TX = requireTx();
	const MerkleBlock = requireMerkleblock();
	const Headers = requireHeaders();
	const Network = requireNetwork();
	const util = requireUtil();
	const {encoding} = bio;
	const {inspectSymbol} = requireUtils();

	/**
	 * Block
	 * Represents a full block.
	 * @alias module:primitives.Block
	 * @extends AbstractBlock
	 */

	class Block extends AbstractBlock {
	  /**
	   * Create a block.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    super();

	    this.txs = [];

	    this._raw = null;
	    this._size = -1;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    this.parseOptions(options);

	    if (options.txs) {
	      assert(Array.isArray(options.txs));
	      for (const tx of options.txs) {
	        assert(tx instanceof TX);
	        this.txs.push(tx);
	      }
	    }

	    return this;
	  }

	  /**
	   * Instantiate block from options.
	   * @param {Object} options
	   * @returns {Block}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clear any cached values.
	   * @param {Boolean?} all - Clear transactions.
	   */

	  refresh(all) {
	    this._refresh();

	    this._raw = null;
	    this._size = -1;

	    if (!all)
	      return this;

	    for (const tx of this.txs)
	      tx.refresh();

	    return this;
	  }

	  /**
	   * Serialize the block.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this.frame().data;
	  }

	  /**
	   * Check if block has been serialized.
	   * @returns {Buffer}
	   */

	  hasRaw() {
	    return Boolean(this._raw);
	  }

	  /**
	   * Serialize the block.
	   * @returns {Buffer}
	   */

	  toNormal() {
	    return this.toRaw();
	  }

	  /**
	   * Serialize the block.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    if (this.mutable)
	      return this.writeNormal(bw);

	    const raw = this.frame();
	    bw.writeBytes(raw.data);

	    return bw;
	  }

	  /**
	   * Serialize the block.
	   * @param {BufferWriter} bw
	   */

	  toNormalWriter(bw) {
	    return this.toWriter(bw);
	  }

	  /**
	   * Get the raw block serialization.
	   * @private
	   * @returns {RawBlock}
	   */

	  frame() {
	    if (this.mutable) {
	      assert(!this._raw);
	      return this.frameNormal();
	    }

	    if (this._raw) {
	      assert(this._size >= 0);
	      const raw = new RawBlock(this._size);
	      raw.data = this._raw;
	      return raw;
	    }

	    const raw = this.frameNormal();

	    this._raw = raw.data;
	    this._size = raw.size;

	    return raw;
	  }

	  /**
	   * Calculate real block size.
	   * @returns {Object} Contains `size`
	   */

	  getSize() {
	    if (this.mutable)
	      return this.getNormalSizes().size;
	    return this.frame().size;
	  }

	  /**
	   * Test the block's transaction vector against a hash.
	   * @param {Hash} hash
	   * @returns {Boolean}
	   */

	  hasTX(hash) {
	    return this.indexOf(hash) !== -1;
	  }

	  /**
	   * Find the index of a transaction in the block.
	   * @param {Hash} hash
	   * @returns {Number} index (-1 if not present).
	   */

	  indexOf(hash) {
	    for (let i = 0; i < this.txs.length; i++) {
	      const tx = this.txs[i];
	      if (tx.hash().equals(hash))
	        return i;
	    }

	    return -1;
	  }

	  /**
	   * Calculate merkle root. Returns null
	   * if merkle tree has been malleated.
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Hash|null}
	   */

	  createMerkleRoot(enc) {
	    const leaves = [];

	    for (const tx of this.txs)
	      leaves.push(tx.hash());

	    const [root, malleated] = merkle.createRoot(hash256, leaves);

	    if (malleated)
	      return null;

	    return enc === 'hex' ? root.toString('hex') : root;
	  }

	  /**
	   * Retrieve the merkle root from the block header.
	   * @param {String?} enc
	   * @returns {Hash}
	   */

	  getMerkleRoot(enc) {
	    if (enc === 'hex')
	      return this.merkleRoot.toString('hex');
	    return this.merkleRoot;
	  }

	  /**
	   * Do non-contextual verification on the block. Including checking the block
	   * size, the coinbase and the merkle root. This is consensus-critical.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    const [valid] = this.checkBody();
	    return valid;
	  }

	  /**
	   * Do non-contextual verification on the block. Including checking the block
	   * size, the coinbase and the merkle root. This is consensus-critical.
	   * @param {Boolean?} skipSigops
	   * @returns {Array} [valid, reason, score]
	   */

	  checkBody(skipSigops) {
	    // Check base size.
	    //  MIN_TRANSACTION_SIZE = 100;
	    if (this.txs.length === 0
	        || this.txs.length > consensus.MAX_FORK_BLOCK_SIZE / 10
	        || this.getSize() > consensus.MAX_FORK_BLOCK_SIZE) {
	      return [false, 'bad-blk-length', 100];
	    }

	    // First TX must be a coinbase.
	    if (this.txs.length === 0 || !this.txs[0].isCoinbase())
	      return [false, 'bad-cb-missing', 100];

	    // Check merkle root.
	    const root = this.createMerkleRoot();

	    // If the merkle is mutated,
	    // we have duplicate txs.
	    if (!root)
	      return [false, 'bad-txns-duplicate', 100];

	    if (!this.merkleRoot.equals(root))
	      return [false, 'bad-txnmrklroot', 100];

	    // Test all transactions.
	    const size = this.getSize();

	    let sigops = 0;

	    for (let i = 0; i < this.txs.length; i++) {
	      const tx = this.txs[i];

	      // The rest of the txs must not be coinbases.
	      if (i > 0 && tx.isCoinbase())
	        return [false, 'bad-cb-multiple', 100];

	      // Sanity checks.
	      const [valid, reason, score] = tx.checkSanity();

	      if (!valid)
	        return [valid, reason, score];

	      // Count legacy sigops (do not count scripthash).
	      sigops += tx.getLegacySigops();
	      if (!skipSigops && sigops > consensus.maxBlockSigops(size))
	        return [false, 'bad-blk-sigops', 100];
	    }

	    return [true, 'valid', 0];
	  }

	  /**
	   * Retrieve the coinbase height from the coinbase input script.
	   * @returns {Number} height (-1 if not present).
	   */

	  getCoinbaseHeight() {
	    if (this.version < 2)
	      return -1;

	    if (this.txs.length === 0)
	      return -1;

	    const coinbase = this.txs[0];

	    if (coinbase.inputs.length === 0)
	      return -1;

	    return coinbase.inputs[0].script.getCoinbaseHeight();
	  }

	  /**
	   * Get the "claimed" reward by the coinbase.
	   * @returns {Amount} claimed
	   */

	  getClaimed() {
	    assert(this.txs.length > 0);
	    assert(this.txs[0].isCoinbase());
	    return this.txs[0].getOutputValue();
	  }

	  /**
	   * Get all unique outpoint hashes in the
	   * block. Coinbases are ignored.
	   * @returns {Hash[]} Outpoint hashes.
	   */

	  getPrevout() {
	    const prevout = new BufferSet();

	    for (let i = 1; i < this.txs.length; i++) {
	      const tx = this.txs[i];

	      for (const input of tx.inputs)
	        prevout.add(input.prevout.hash);
	    }

	    return prevout.toArray();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the block and return a more
	   * user-friendly representation of the data.
	   * @param {CoinView} view
	   * @param {Number} height
	   * @returns {Object}
	   */

	  format(view, height) {
	    return {
	      hash: this.rhash(),
	      height: height != null ? height : -1,
	      size: this.getSize(),
	      date: util.date(this.time),
	      version: this.version.toString(16),
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      txs: this.txs.map((tx, i) => {
	        return tx.format(view, null, i);
	      })
	    };
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the block to an object suitable
	   * for JSON serialization. Note that the hashes
	   * will be reversed to abide by bitcoind's legacy
	   * of little-endian uint256s.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @param {Number} height
	   * @param {Number} depth
	   * @returns {Object}
	   */

	  getJSON(network, view, height, depth) {
	    network = Network.get(network);
	    return {
	      hash: this.rhash(),
	      height: height,
	      depth: depth,
	      version: this.version,
	      prevBlock: util.revHex(this.prevBlock),
	      merkleRoot: util.revHex(this.merkleRoot),
	      time: this.time,
	      bits: this.bits,
	      nonce: this.nonce,
	      txs: this.txs.map((tx, i) => {
	        return tx.getJSON(network, view, null, i);
	      })
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json, 'Block data is required.');
	    assert(Array.isArray(json.txs));

	    this.parseJSON(json);

	    for (const tx of json.txs)
	      this.txs.push(TX.fromJSON(tx));

	    return this;
	  }

	  /**
	   * Instantiate a block from a jsonified block object.
	   * @param {Object} json - The jsonified block object.
	   * @returns {Block}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromReader(br) {
	    br.start();

	    this.readHead(br);

	    const count = br.readVarint();

	    for (let i = 0; i < count; i++) {
	      const tx = TX.fromReader(br, true);
	      this.txs.push(tx);
	    }

	    if (!this.mutable) {
	      this._raw = br.endData();
	      this._size = this._raw.length;
	    }

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a block from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Block}
	   */

	  static fromReader(data) {
	    return new this().fromReader(data);
	  }

	  /**
	   * Instantiate a block from a serialized Buffer.
	   * @param {Buffer} data
	   * @param {String?} enc - Encoding, can be `'hex'` or null.
	   * @returns {Block}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Convert the Block to a MerkleBlock.
	   * @param {Bloom} filter - Bloom filter for transactions
	   * to match. The merkle block will contain only the
	   * matched transactions.
	   * @returns {MerkleBlock}
	   */

	  toMerkle(filter) {
	    return MerkleBlock.fromBlock(this, filter);
	  }

	  /**
	   * Serialze block data.
	   * @private
	   * @param {BufferWriter?} writer
	   * @returns {Buffer}
	   */

	  writeNormal(bw) {
	    this.writeHead(bw);

	    bw.writeVarint(this.txs.length);

	    for (const tx of this.txs)
	      tx.toWriter(bw);

	    return bw;
	  }

	  /**
	   * Serialze block data.
	   * @private
	   * @param {BufferWriter?} writer
	   * @returns {Buffer}
	   */

	  frameNormal() {
	    const raw = this.getNormalSizes();
	    const bw = bio.write(raw.size);
	    this.writeNormal(bw);
	    raw.data = bw.render();
	    return raw;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }

	  /**
	   * Get real block size.
	   * @returns {RawBlock}
	   */

	  getNormalSizes() {
	    let size = 0;

	    size += 80;
	    size += encoding.sizeVarint(this.txs.length);

	    for (const tx of this.txs)
	      size += tx.getSize();

	    return new RawBlock(size, 0);
	  }

	  /**
	   * Test whether an object is a Block.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isBlock(obj) {
	    return obj instanceof Block;
	  }
	}

	/*
	 * Helpers
	 */

	class RawBlock {
	  constructor(size) {
	    this.data = null;
	    this.size = size;
	  }
	}

	/*
	 * Expose
	 */

	block = Block;
	return block;
}

/*!
 * keyring.js - keyring object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var keyring;
var hasRequiredKeyring;

function requireKeyring () {
	if (hasRequiredKeyring) return keyring;
	hasRequiredKeyring = 1;

	const assert = require$$0$3;
	const {base58} = require$$2$1;
	const bio = require$$1;
	const hash160 = requireHash160();
	const hash256 = requireHash256();
	const Network = requireNetwork();
	const Script = requireScript$1();
	const Address = requireAddress();
	const Output = requireOutput();
	const secp256k1 = requireSecp256k1();
	const {encoding} = bio;
	const {inspectSymbol} = requireUtils();

	/*
	 * Constants
	 */

	const ZERO_KEY = Buffer.alloc(33, 0x00);

	/**
	 * Key Ring
	 * Represents a key ring which amounts to an address.
	 * @alias module:primitives.KeyRing
	 */

	class KeyRing {
	  /**
	   * Create a key ring.
	   * @constructor
	   * @param {Object} options
	   */

	  constructor(options) {
	    this.nested = false;
	    this.publicKey = ZERO_KEY;
	    this.privateKey = null;
	    this.script = null;

	    this._keyHash = null;
	    this._keyAddress = null;
	    this._scriptHash160 = null;
	    this._scriptAddress = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    let key = toKey(options);

	    if (Buffer.isBuffer(key))
	      return this.fromKey(key);

	    key = toKey(options.key);

	    if (options.publicKey)
	      key = toKey(options.publicKey);

	    if (options.privateKey)
	      key = toKey(options.privateKey);

	    const script = options.script;
	    const compress = options.compressed;

	    if (script)
	      return this.fromScript(key, script, compress);

	    return this.fromKey(key, compress);
	  }

	  /**
	   * Instantiate key ring from options.
	   * @param {Object} options
	   * @returns {KeyRing}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Clear cached key/script hashes.
	   */

	  refresh() {
	    this._keyHash = null;
	    this._keyAddress = null;
	    this._scriptHash160 = null;
	    this._scriptAddress = null;
	  }

	  /**
	   * Inject data from private key.
	   * @private
	   * @param {Buffer} key
	   * @param {Boolean?} compress
	   */

	  fromPrivate(key, compress) {
	    assert(Buffer.isBuffer(key), 'Private key must be a buffer.');
	    assert(secp256k1.privateKeyVerify(key), 'Not a valid private key.');

	    this.privateKey = key;
	    this.publicKey = secp256k1.publicKeyCreate(key, compress !== false);

	    return this;
	  }

	  /**
	   * Instantiate keyring from a private key.
	   * @param {Buffer} key
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromPrivate(key, compress) {
	    return new this().fromPrivate(key, compress);
	  }

	  /**
	   * Inject data from public key.
	   * @private
	   * @param {Buffer} key
	   */

	  fromPublic(key) {
	    assert(Buffer.isBuffer(key), 'Public key must be a buffer.');
	    assert(secp256k1.publicKeyVerify(key), 'Not a valid public key.');
	    this.publicKey = key;
	    return this;
	  }

	  /**
	   * Generate a keyring.
	   * @private
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  generate(compress) {
	    const key = secp256k1.privateKeyGenerate();
	    return this.fromKey(key, compress);
	  }

	  /**
	   * Generate a keyring.
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static generate(compress) {
	    return new this().generate(compress);
	  }

	  /**
	   * Instantiate keyring from a public key.
	   * @param {Buffer} publicKey
	   * @returns {KeyRing}
	   */

	  static fromPublic(key) {
	    return new this().fromPublic(key);
	  }

	  /**
	   * Inject data from public key.
	   * @private
	   * @param {Buffer} privateKey
	   * @param {Boolean?} compress
	   */

	  fromKey(key, compress) {
	    assert(Buffer.isBuffer(key), 'Key must be a buffer.');

	    if (key.length === 32)
	      return this.fromPrivate(key, compress !== false);

	    return this.fromPublic(key);
	  }

	  /**
	   * Instantiate keyring from a public key.
	   * @param {Buffer} publicKey
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromKey(key, compress) {
	    return new this().fromKey(key, compress);
	  }

	  /**
	   * Inject data from script.
	   * @private
	   * @param {Buffer} key
	   * @param {Script} script
	   * @param {Boolean?} compress
	   */

	  fromScript(key, script, compress) {
	    assert(script instanceof Script, 'Non-script passed into KeyRing.');

	    this.fromKey(key, compress);
	    this.script = script;

	    return this;
	  }

	  /**
	   * Instantiate keyring from script.
	   * @param {Buffer} key
	   * @param {Script} script
	   * @param {Boolean?} compress
	   * @returns {KeyRing}
	   */

	  static fromScript(key, script, compress) {
	    return new this().fromScript(key, script, compress);
	  }

	  /**
	   * Get ith public key from multisig script.
	   * @private
	   * @param {Script} script
	   * @param {Number} i
	   * @returns {KeyRing}
	   */

	  fromMultisigScript(script, i) {
	    assert(script instanceof Script, 'Non-script passed.');
	    assert(script.isMultisig(), 'Script must be multisig');

	    const n = script.getSmall(-2);
	    assert(i >= 1 && i <= n, 'Requested `i`th key, `n` available');

	    this.fromKey(script.code[i].toData());

	    return this;
	  }

	  /**
	   * Instantiate keyring from ith key in multisig script.
	   * @param {Script} script
	   * @param {Number} i
	   * @returns {KeyRing}
	   */

	  static fromMultisigScript(script, i) {
	    return new this().fromMultisigScript(script, i);
	  }

	  /**
	   * Calculate WIF serialization size.
	   * @returns {Number}
	   */

	  getSecretSize() {
	    let size = 0;

	    size += 1;
	    size += this.privateKey.length;

	    if (this.publicKey.length === 33)
	      size += 1;

	    size += 4;

	    return size;
	  }

	  /**
	   * Convert key to a CBitcoinSecret.
	   * @param {(Network|NetworkType)?} network
	   * @returns {Base58String}
	   */

	  toSecret(network) {
	    const size = this.getSecretSize();
	    const bw = bio.write(size);

	    assert(this.privateKey, 'Cannot serialize without private key.');

	    network = Network.get(network);

	    bw.writeU8(network.keyPrefix.privkey);
	    bw.writeBytes(this.privateKey);

	    if (this.publicKey.length === 33)
	      bw.writeU8(1);

	    bw.writeChecksum(hash256.digest);

	    return base58.encode(bw.render());
	  }

	  /**
	   * Inject properties from serialized CBitcoinSecret.
	   * @private
	   * @param {Base58String} secret
	   * @param {(Network|NetworkType)?} network
	   */

	  fromSecret(data, network) {
	    const br = bio.read(base58.decode(data), true);

	    const version = br.readU8();

	    Network.fromWIF(version, network);

	    const key = br.readBytes(32);

	    let compress = false;

	    if (br.left() > 4) {
	      assert(br.readU8() === 1, 'Bad compression flag.');
	      compress = true;
	    }

	    br.verifyChecksum(hash256.digest);

	    return this.fromPrivate(key, compress);
	  }

	  /**
	   * Instantiate a keyring from a serialized CBitcoinSecret.
	   * @param {Base58String} secret
	   * @param {(Network|NetworkType)?} network
	   * @returns {KeyRing}
	   */

	  static fromSecret(data, network) {
	    return new this().fromSecret(data, network);
	  }

	  /**
	   * Get private key.
	   * @param {String?} enc - Can be `"hex"`, `"base58"`, or `null`.
	   * @returns {Buffer} Private key.
	   */

	  getPrivateKey(enc, network) {
	    if (!this.privateKey)
	      return null;

	    if (enc === 'base58')
	      return this.toSecret(network);

	    if (enc === 'hex')
	      return this.privateKey.toString('hex');

	    return this.privateKey;
	  }

	  /**
	   * Get public key.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getPublicKey(enc) {
	    if (enc === 'base58')
	      return base58.encode(this.publicKey);

	    if (enc === 'hex')
	      return this.publicKey.toString('hex');

	    return this.publicKey;
	  }

	  /**
	   * Get redeem script.
	   * @returns {Script}
	   */

	  getScript() {
	    return this.script;
	  }

	  /**
	   * Get scripthash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getScriptHash(enc) {
	    return this.getScriptHash160(enc);
	  }

	  /**
	   * Get ripemd160 scripthash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getScriptHash160(enc) {
	    if (!this.script)
	      return null;

	    if (!this._scriptHash160)
	      this._scriptHash160 = this.script.hash160();

	    return enc === 'hex'
	      ? this._scriptHash160.toString('hex')
	      : this._scriptHash160;
	  }

	  /**
	   * Get scripthash address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getScriptAddress(enc, network) {
	    if (!this.script)
	      return null;

	    if (!this._scriptAddress) {
	      const hash = this.getScriptHash160();
	      const addr = Address.fromScripthash(hash);

	      this._scriptAddress = addr;
	    }

	    if (enc === 'base58')
	      return this._scriptAddress.toBase58(network);

	    if (enc === 'string')
	      return this._scriptAddress.toString(network);

	    return this._scriptAddress;
	  }

	  /**
	   * Get public key hash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getKeyHash(enc) {
	    if (!this._keyHash)
	      this._keyHash = hash160.digest(this.publicKey);

	    return enc === 'hex'
	      ? this._keyHash.toString('hex')
	      : this._keyHash;
	  }

	  /**
	   * Get pubkeyhash address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getKeyAddress(enc, network) {
	    if (!this._keyAddress) {
	      const hash = this.getKeyHash();
	      const addr = Address.fromPubkeyhash(hash);

	      this._keyAddress = addr;
	    }

	    if (enc === 'base58')
	      return this._keyAddress.toBase58(network);

	    if (enc === 'string')
	      return this._keyAddress.toString(network);

	    return this._keyAddress;
	  }

	  /**
	   * Get hash.
	   * @param {String?} enc - `"hex"` or `null`.
	   * @returns {Buffer}
	   */

	  getHash(enc) {
	    if (this.script)
	      return this.getScriptHash(enc);

	    return this.getKeyHash(enc);
	  }

	  /**
	   * Get base58 address.
	   * @param {String?} enc - `"base58"` or `null`.
	   * @returns {Address|AddressString}
	   */

	  getAddress(enc, network) {
	    if (this.script)
	      return this.getScriptAddress(enc, network);

	    return this.getKeyAddress(enc, network);
	  }

	  /**
	   * Test an address hash against hash.
	   * @param {Buffer} hash
	   * @returns {Boolean}
	   */

	  ownHash(hash) {
	    if (!hash)
	      return false;

	    if (hash.equals(this.getKeyHash()))
	      return true;

	    if (this.script) {
	      if (hash.equals(this.getScriptHash()))
	        return true;
	    }

	    return false;
	  }

	  /**
	   * Check whether transaction output belongs to this address.
	   * @param {TX|Output} tx - Transaction or Output.
	   * @param {Number?} index - Output index.
	   * @returns {Boolean}
	   */

	  ownOutput(tx, index) {
	    let output;

	    if (tx instanceof Output) {
	      output = tx;
	    } else {
	      output = tx.outputs[index];
	      assert(output, 'Output does not exist.');
	    }

	    return this.ownHash(output.getHash());
	  }

	  /**
	   * Test a hash against script hashes to
	   * find the correct redeem script, if any.
	   * @param {Buffer} hash
	   * @returns {Script|null}
	   */

	  getRedeem(hash) {
	    if (this.script) {
	      if (hash.equals(this.getScriptHash160()))
	        return this.script;
	    }

	    return null;
	  }

	  /**
	   * Sign a message.
	   * @param {Buffer} msg
	   * @returns {Buffer} Signature in DER format.
	   */

	  sign(msg) {
	    assert(this.privateKey, 'Cannot sign without private key.');
	    return secp256k1.signDER(msg, this.privateKey);
	  }

	  /**
	   * Sign a message.
	   * @param {Buffer} msg
	   * @returns {Buffer} Signature in Schnorr format.
	   */

	  signSchnorr(msg) {
	    assert(this.privateKey, 'Cannot sign without private key.');
	    return secp256k1.schnorrSign(msg, this.privateKey);
	  }

	  /**
	   * Verify a message.
	   * @param {Buffer} msg
	   * @param {Buffer} sig - Signature in DER format.
	   * @returns {Boolean}
	   */

	  verify(msg, sig) {
	    return secp256k1.verifyDER(msg, sig, this.publicKey);
	  }

	  /**
	   * Verify a message.
	   * @param {Buffer} msg
	   * @param {Buffer} sig - Signature in Schnorr format.
	   * @returns {Boolean}
	   */

	  verifySchnorr(msg, sig) {
	    return secp256k1.schnorrVerify(msg, sig, this.publicKey);
	  }

	  /**
	   * Get witness program version.
	   * @returns {Number}
	   */

	  getVersion() {
	    return -1;
	  }

	  /**
	   * Get address type.
	   * @returns {ScriptType}
	   */

	  getType() {
	    if (this.script)
	      return Address.types.SCRIPTHASH;

	    return Address.types.PUBKEYHASH;
	  }

	  /**
	   * Inspect keyring.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.toJSON();
	  }

	  /**
	   * Convert an KeyRing to a more json-friendly object.
	   * @returns {Object}
	   */

	  toJSON(network) {
	    return {
	      publicKey: this.publicKey.toString('hex'),
	      script: this.script ? this.script.toRaw().toString('hex') : null,
	      type: Address.typesByVal[this.getType()].toLowerCase(),
	      address: this.getAddress('string', network)
	    };
	  }

	  /**
	   * Inject properties from json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    assert(json);
	    assert(typeof json.publicKey === 'string');
	    assert(!json.script || typeof json.script === 'string');

	    this.publicKey = Buffer.from(json.publicKey, 'hex');

	    if (json.script)
	      this.script = Buffer.from(json.script, 'hex');

	    return this;
	  }

	  /**
	   * Instantiate an KeyRing from a jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {KeyRing}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;
	    size += 1;
	    if (this.privateKey) {
	      size += encoding.sizeVarBytes(this.privateKey);
	      size += 1;
	    } else {
	      size += encoding.sizeVarBytes(this.publicKey);
	    }
	    size += this.script ? this.script.getVarSize() : 1;
	    return size;
	  }

	  /**
	   * Write the keyring to a buffer writer.
	   * @param {BufferWriter} bw
	   */

	  toWriter(bw) {
	    const field = 0;

	    // we don't use field for now,
	    // we can use this for flags different
	    // flags in the future.
	    bw.writeU8(field);

	    if (this.privateKey) {
	      bw.writeVarBytes(this.privateKey);
	      bw.writeU8(this.publicKey.length === 33 ? 1 : 0);
	    } else {
	      bw.writeVarBytes(this.publicKey);
	    }

	    if (this.script)
	      bw.writeVarBytes(this.script.toRaw());
	    else
	      bw.writeVarint(0);

	    return bw;
	  }

	  /**
	   * Serialize the keyring.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    return this.toWriter(bio.write(size)).render();
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  fromReader(br) {
	    // we are not interested in flags.
	    br.readU8();

	    const key = br.readVarBytes();

	    if (key.length === 32) {
	      const compress = br.readU8() === 1;
	      this.privateKey = key;
	      this.publicKey = secp256k1.publicKeyCreate(key, compress);
	    } else {
	      this.publicKey = key;
	      assert(secp256k1.publicKeyVerify(key), 'Invalid public key.');
	    }

	    const script = br.readVarBytes();

	    if (script.length > 0)
	      this.script = Script.fromRaw(script);

	    return this;
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    return this.fromReader(bio.read(data));
	  }

	  /**
	   * Instantiate a keyring from buffer reader.
	   * @param {BufferReader} br
	   * @returns {KeyRing}
	   */

	  static fromReader(br) {
	    return new this().fromReader(br);
	  }

	  /**
	   * Instantiate a keyring from serialized data.
	   * @param {Buffer} data
	   * @returns {KeyRing}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object is a KeyRing.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isKeyRing(obj) {
	    return obj instanceof KeyRing;
	  }
	}

	/*
	 * Helpers
	 */

	function toKey(opt) {
	  if (!opt)
	    return opt;

	  if (opt.privateKey)
	    return opt.privateKey;

	  if (opt.publicKey)
	    return opt.publicKey;

	  return opt;
	}

	/*
	 * Expose
	 */

	keyring = KeyRing;
	return keyring;
}

/*!
 * memblock.js - memblock block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var memblock;
var hasRequiredMemblock;

function requireMemblock () {
	if (hasRequiredMemblock) return memblock;
	hasRequiredMemblock = 1;

	const bio = require$$1;
	const AbstractBlock = requireAbstractblock();
	const Block = requireBlock();
	const Headers = requireHeaders();
	const Script = requireScript$1();
	const DUMMY = Buffer.alloc(0);

	/**
	 * Mem Block
	 * A block object which is essentially a "placeholder"
	 * for a full {@link Block} object. The v8 garbage
	 * collector's head will explode if there is too much
	 * data on the javascript heap. Blocks can currently
	 * be up to 1mb in size. In the future, they may be
	 * 2mb, 8mb, or maybe 20mb, who knows? A MemBlock
	 * is an optimization in Bcoin which defers parsing of
	 * the serialized transactions (the block Buffer) until
	 * the block has passed through the chain queue and
	 * is about to enter the chain. This keeps a lot data
	 * off of the javascript heap for most of the time a
	 * block even exists in memory, and manages to keep a
	 * lot of strain off of the garbage collector. Having
	 * 500mb of blocks on the js heap would not be a good
	 * thing.
	 * @alias module:primitives.MemBlock
	 * @extends AbstractBlock
	 */

	class MemBlock extends AbstractBlock {
	  /**
	   * Create a mem block.
	   * @constructor
	   */

	  constructor() {
	    super();

	    this._raw = DUMMY;
	  }

	  /**
	   * Test whether the block is a memblock.
	   * @returns {Boolean}
	   */

	  isMemory() {
	    return true;
	  }

	  /**
	   * Serialize the block headers.
	   * @returns {Buffer}
	   */

	  toHead() {
	    return this._raw.slice(0, 80);
	  }

	  /**
	   * Get the full block size.
	   * @returns {Number}
	   */

	  getSize() {
	    return this._raw.length;
	  }

	  /**
	   * Verify the block.
	   * @returns {Boolean}
	   */

	  verifyBody() {
	    return true;
	  }

	  /**
	   * Retrieve the coinbase height
	   * from the coinbase input script.
	   * @returns {Number} height (-1 if not present).
	   */

	  getCoinbaseHeight() {
	    if (this.version < 2)
	      return -1;

	    try {
	      return this.parseCoinbaseHeight();
	    } catch (e) {
	      return -1;
	    }
	  }

	  /**
	   * Parse the coinbase height
	   * from the coinbase input script.
	   * @private
	   * @returns {Number} height (-1 if not present).
	   */

	  parseCoinbaseHeight() {
	    const br = bio.read(this._raw, true);

	    br.seek(80);

	    const txCount = br.readVarint();

	    if (txCount === 0)
	      return -1;

	    br.seek(4);

	    let inCount = br.readVarint();

	    if (inCount === 0) {
	      if (br.readU8() !== 0)
	        inCount = br.readVarint();
	    }

	    if (inCount === 0)
	      return -1;

	    br.seek(36);

	    const script = br.readVarBytes();

	    return Script.getCoinbaseHeight(script);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    const br = bio.read(data, true);

	    this.readHead(br);

	    this._raw = br.data;

	    return this;
	  }

	  /**
	   * Insantiate a memblock from serialized data.
	   * @param {Buffer} data
	   * @returns {MemBlock}
	   */

	  static fromRaw(data) {
	    return new this().fromRaw(data);
	  }

	  /**
	   * Return serialized block data.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    return this._raw;
	  }

	  /**
	   * Parse the serialized block data
	   * and create an actual {@link Block}.
	   * @returns {Block}
	   * @throws Parse error
	   */

	  toBlock() {
	    const block = Block.fromRaw(this._raw);

	    block._hash = this._hash;
	    block._hhash = this._hhash;

	    return block;
	  }

	  /**
	   * Convert the block to a headers object.
	   * @returns {Headers}
	   */

	  toHeaders() {
	    return Headers.fromBlock(this);
	  }

	  /**
	   * Test whether an object is a MemBlock.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isMemBlock(obj) {
	    return obj instanceof MemBlock;
	  }
	}

	/*
	 * Expose
	 */

	memblock = MemBlock;
	return memblock;
}

var mtx = {exports: {}};

/*!
 * mtx.js - mutable transaction object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredMtx;

function requireMtx () {
	if (hasRequiredMtx) return mtx.exports;
	hasRequiredMtx = 1;
	(function (module, exports) {

		const assert = require$$0$3;
		const {encoding} = require$$1;
		const {BufferMap} = require$$2$2;
		const Script = requireScript$1();
		const TX = requireTx();
		const Input = requireInput();
		const Output = requireOutput();
		const Coin = requireCoin();
		const Outpoint = requireOutpoint();
		const CoinView = requireCoinview();
		const Address = requireAddress();
		const consensus = requireConsensus();
		const policy = requirePolicy();
		const Amount = requireAmount();
		const Stack = requireStack();
		const util = requireUtil();
		const {inspectSymbol} = requireUtils();

		/**
		 * MTX
		 * A mutable transaction object.
		 * @alias module:primitives.MTX
		 * @extends TX
		 * @property {Number} changeIndex
		 * @property {CoinView} view
		 */

		class MTX extends TX {
		  /**
		   * Create a mutable transaction.
		   * @alias module:primitives.MTX
		   * @constructor
		   * @param {Object} options
		   */

		  constructor(options) {
		    super();

		    this.mutable = true;
		    this.changeIndex = -1;
		    this.view = new CoinView();

		    if (options)
		      this.fromOptions(options);
		  }

		  /**
		   * Inject properties from options object.
		   * @private
		   * @param {Object} options
		   */

		  fromOptions(options) {
		    if (options.version != null) {
		      assert((options.version >>> 0) === options.version,
		        'Version must a be uint32.');
		      this.version = options.version;
		    }

		    if (options.inputs) {
		      assert(Array.isArray(options.inputs), 'Inputs must be an array.');
		      for (const input of options.inputs)
		        this.addInput(input);
		    }

		    if (options.outputs) {
		      assert(Array.isArray(options.outputs), 'Outputs must be an array.');
		      for (const output of options.outputs)
		        this.addOutput(output);
		    }

		    if (options.locktime != null) {
		      assert((options.locktime >>> 0) === options.locktime,
		        'Locktime must be a uint32.');
		      this.locktime = options.locktime;
		    }

		    if (options.changeIndex != null) {
		      if (options.changeIndex !== -1) {
		        assert((options.changeIndex >>> 0) === options.changeIndex,
		          'Change index must be a uint32.');
		        this.changeIndex = options.changeIndex;
		      } else {
		        this.changeIndex = -1;
		      }
		    }

		    return this;
		  }

		  /**
		   * Instantiate MTX from options.
		   * @param {Object} options
		   * @returns {MTX}
		   */

		  static fromOptions(options) {
		    return new this().fromOptions(options);
		  }

		  /**
		   * Clone the transaction. Note that
		   * this will not carry over the view.
		   * @returns {MTX}
		   */

		  clone() {
		    const mtx = new this.constructor();
		    mtx.inject(this);
		    mtx.changeIndex = this.changeIndex;
		    return mtx;
		  }

		  /**
		   * Add an input to the transaction.
		   * @param {Input|Object} options
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addInput({ prevout: { hash: ... }, script: ... });
		   * mtx.addInput(new Input());
		   */

		  addInput(options) {
		    const input = Input.fromOptions(options);
		    this.inputs.push(input);
		    return input;
		  }

		  /**
		   * Add an outpoint as an input.
		   * @param {Outpoint|Object} outpoint
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addOutpoint({ hash: ..., index: 0 });
		   * mtx.addOutpoint(new Outpoint(hash, index));
		   */

		  addOutpoint(outpoint) {
		    const prevout = Outpoint.fromOptions(outpoint);
		    const input = Input.fromOutpoint(prevout);
		    this.inputs.push(input);
		    return input;
		  }

		  /**
		   * Add a coin as an input. Note that this will
		   * add the coin to the internal coin viewpoint.
		   * @param {Coin} coin
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addCoin(Coin.fromTX(tx, 0, -1));
		   */

		  addCoin(coin) {
		    assert(coin instanceof Coin, 'Cannot add non-coin.');

		    const input = Input.fromCoin(coin);

		    this.inputs.push(input);
		    this.view.addCoin(coin);

		    return input;
		  }

		  /**
		   * Add a transaction as an input. Note that
		   * this will add the coin to the internal
		   * coin viewpoint.
		   * @param {TX} tx
		   * @param {Number} index
		   * @param {Number?} height
		   * @returns {Input}
		   *
		   * @example
		   * mtx.addTX(tx, 0);
		   */

		  addTX(tx, index, height) {
		    assert(tx instanceof TX, 'Cannot add non-transaction.');

		    if (height == null)
		      height = -1;

		    const input = Input.fromTX(tx, index);

		    this.inputs.push(input);

		    this.view.addIndex(tx, index, height);

		    return input;
		  }

		  /**
		   * Add an output.
		   * @param {Address|Script|Output|Object} script - Script or output options.
		   * @param {Amount?} value
		   * @returns {Output}
		   *
		   * @example
		   * mtx.addOutput(new Output());
		   * mtx.addOutput({ address: ..., value: 100000 });
		   * mtx.addOutput(address, 100000);
		   * mtx.addOutput(script, 100000);
		   */

		  addOutput(script, value) {
		    let output;

		    if (value != null)
		      output = Output.fromScript(script, value);
		    else
		      output = Output.fromOptions(script);

		    this.outputs.push(output);

		    return output;
		  }

		  /**
		   * Verify all transaction inputs.
		   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
		   * @returns {Boolean} Whether the inputs are valid.
		   * @throws {ScriptError} on invalid inputs
		   */

		  check(flags) {
		    return super.check(this.view, flags);
		  }

		  /**
		   * Verify the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  checkAsync(flags, pool) {
		    return super.checkAsync(this.view, flags, pool);
		  }

		  /**
		   * Verify all transaction inputs.
		   * @param {VerifyFlags} [flags=STANDARD_VERIFY_FLAGS]
		   * @returns {Boolean} Whether the inputs are valid.
		   */

		  verify(flags) {
		    try {
		      this.check(flags);
		    } catch (e) {
		      if (e.type === 'ScriptError')
		        return false;
		      throw e;
		    }
		    return true;
		  }

		  /**
		   * Verify the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {VerifyFlags?} [flags=STANDARD_VERIFY_FLAGS]
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async verifyAsync(flags, pool) {
		    try {
		      await this.checkAsync(flags, pool);
		    } catch (e) {
		      if (e.type === 'ScriptError')
		        return false;
		      throw e;
		    }
		    return true;
		  }

		  /**
		   * Calculate the fee for the transaction.
		   * @returns {Amount} fee (zero if not all coins are available).
		   */

		  getFee() {
		    return super.getFee(this.view);
		  }

		  /**
		   * Calculate the total input value.
		   * @returns {Amount} value
		   */

		  getInputValue() {
		    return super.getInputValue(this.view);
		  }

		  /**
		   * Get all input addresses.
		   * @returns {Address[]} addresses
		   */

		  getInputAddresses() {
		    return super.getInputAddresses(this.view);
		  }

		  /**
		   * Get all addresses.
		   * @returns {Address[]} addresses
		   */

		  getAddresses() {
		    return super.getAddresses(this.view);
		  }

		  /**
		   * Get all input address hashes.
		   * @returns {Hash[]} hashes
		   */

		  getInputHashes(enc) {
		    return super.getInputHashes(this.view, enc);
		  }

		  /**
		   * Get all address hashes.
		   * @returns {Hash[]} hashes
		   */

		  getHashes(enc) {
		    return super.getHashes(this.view, enc);
		  }

		  /**
		   * Test whether the transaction has
		   * all coins available/filled.
		   * @returns {Boolean}
		   */

		  hasCoins() {
		    return super.hasCoins(this.view);
		  }

		  /**
		   * Calculate virtual sigop count.
		   * @param {VerifyFlags?} flags
		   * @returns {Number} sigop count
		   */

		  getSigops(flags) {
		    return super.getSigops(this.view, flags);
		  }

		  /**
		   *  Calculate sigops count.
		   *  @param {CoinView} view
		   *  @param {VerifyFlags?} flags
		   *  @returns {Number} sigop count
		   */

		  getSigopsCount(flags) {
		    return super.getSigopsCount(this.view, flags);
		  }

		  /**
		   * Perform contextual checks to verify input, output,
		   * and fee values, as well as coinbase spend maturity
		   * (coinbases can only be spent 100 blocks or more
		   * after they're created). Note that this function is
		   * consensus critical.
		   * @param {Number} height - Height at which the
		   * transaction is being spent. In the mempool this is
		   * the chain height plus one at the time it entered the pool.
		   * @returns {Boolean}
		   */

		  verifyInputs(height) {
		    const [fee] = this.checkInputs(height);
		    return fee !== -1;
		  }

		  /**
		   * Perform contextual checks to verify input, output,
		   * and fee values, as well as coinbase spend maturity
		   * (coinbases can only be spent 100 blocks or more
		   * after they're created). Note that this function is
		   * consensus critical.
		   * @param {Number} height - Height at which the
		   * transaction is being spent. In the mempool this is
		   * the chain height plus one at the time it entered the pool.
		   * @returns {Array} [fee, reason, score]
		   */

		  checkInputs(height) {
		    return super.checkInputs(this.view, height);
		  }

		  /**
		   * Build input script (or witness) templates (with
		   * OP_0 in place of signatures).
		   * @param {Number} index - Input index.
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring
		   * @returns {Boolean} Whether the script was able to be built.
		   */

		  scriptInput(index, coin, ring) {
		    const input = this.inputs[index];

		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');

		    // Don't bother with any below calculation
		    // if the output is already templated.
		    if (input.script.raw.length !== 0)
		      return true;

		    // Get the previous output's script
		    const prev = coin.script;

		    // This is easily the hardest part about
		    // building a transaction with segwit:
		    // figuring out where the redeem script
		    // and witness redeem scripts go.
		    const sh = prev.getScripthash();

		    if (sh) {
		      const redeem = ring.getRedeem(sh);

		      if (!redeem)
		        return false;

		      // Regular P2SH.
		      const vector = this.scriptVector(redeem, ring);

		      if (!vector)
		        return false;

		      vector.push(redeem.toRaw());

		      input.script.fromStack(vector);

		      return true;
		    }

		    const vector = this.scriptVector(prev, ring);

		    if (!vector)
		      return false;

		    input.script.fromStack(vector);

		    return true;
		  }

		  /**
		   * Build script for a single vector
		   * based on a previous script.
		   * @param {Script} prev
		   * @param {Buffer} ring
		   * @return {Stack}
		   */

		  scriptVector(prev, ring) {
		    // P2PK
		    const pk = prev.getPubkey();
		    if (pk) {
		      if (!pk.equals(ring.publicKey))
		        return null;

		      const stack = new Stack();

		      stack.pushInt(0);

		      return stack;
		    }

		    // P2PKH
		    const pkh = prev.getPubkeyhash();
		    if (pkh) {
		      if (!pkh.equals(ring.getKeyHash()))
		        return null;

		      const stack = new Stack();

		      stack.pushInt(0);
		      stack.pushData(ring.publicKey);

		      return stack;
		    }

		    // Multisig
		    const [, n] = prev.getMultisig();
		    if (n !== -1) {
		      if (prev.indexOf(ring.publicKey) === -1)
		        return null;

		      // Technically we should create m signature slots,
		      // but we create n signature slots so we can order
		      // the signatures properly.
		      const stack = new Stack();

		      stack.pushInt(0);

		      // Fill script with `n` signature slots.
		      for (let i = 0; i < n; i++)
		        stack.pushInt(0);

		      return stack;
		    }

		    return null;
		  }

		  /**
		   * Sign a transaction input on the worker pool
		   * (if workers are enabled).
		   * @param {Number} index
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring
		   * @param {SighashType?} type
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async signInputAsync(index, coin, ring, type, pool) {
		    if (!pool)
		      return this.signInput(index, coin, ring, type);

		    return await pool.signInput(this, index, coin, ring, type, pool);
		  }

		  /**
		   * Sign an input.
		   * @param {Number} index - Index of input being signed.
		   * @param {Coin|Output} coin
		   * @param {KeyRing} ring - Private key.
		   * @param {SighashType} type
		   * @returns {Boolean} Whether the input was able to be signed.
		   */

		  signInput(index, coin, ring, type) {
		    const input = this.inputs[index];
		    const key = ring.privateKey;

		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');

		    // Get the previous output's script
		    const value = coin.value;
		    let prev = coin.script;
		    const vector = input.script;
		    let redeem = false;

		    if (type == null)
		      type = Script.hashType.ALL;

		    type |= Script.hashType.SIGHASH_FORKID;
		    const flags = Script.flags.VERIFY_SIGHASH_FORKID;

		    // Grab regular p2sh redeem script.
		    if (prev.isScripthash()) {
		      prev = input.script.getRedeem();
		      if (!prev)
		        throw new Error('Input has not been templated.');
		      redeem = true;
		    }

		    // Create our signature.
		    const sig = this.signature(index, prev, value, key, type, flags);

		    if (redeem) {
		      const stack = vector.toStack();
		      const redeem = stack.pop();

		      const result = this.signVector(prev, stack, sig, ring);

		      if (!result)
		        return false;

		      result.push(redeem);

		      vector.fromStack(result);

		      return true;
		    }

		    const stack = vector.toStack();
		    const result = this.signVector(prev, stack, sig, ring);

		    if (!result)
		      return false;

		    vector.fromStack(result);

		    return true;
		  }

		  /**
		   * Add a signature to a vector
		   * based on a previous script.
		   * @param {Script} prev
		   * @param {Stack} vector
		   * @param {Buffer} sig
		   * @param {KeyRing} ring
		   * @return {Boolean}
		   */

		  signVector(prev, vector, sig, ring) {
		    // P2PK
		    const pk = prev.getPubkey();
		    if (pk) {
		      // Make sure the pubkey is ours.
		      if (!ring.publicKey.equals(pk))
		        return null;

		      if (vector.length === 0)
		        throw new Error('Input has not been templated.');

		      // Already signed.
		      if (vector.get(0).length > 0)
		        return vector;

		      vector.set(0, sig);

		      return vector;
		    }

		    // P2PKH
		    const pkh = prev.getPubkeyhash();
		    if (pkh) {
		      // Make sure the pubkey hash is ours.
		      if (!ring.getKeyHash().equals(pkh))
		        return null;

		      if (vector.length !== 2)
		        throw new Error('Input has not been templated.');

		      if (vector.get(1).length === 0)
		        throw new Error('Input has not been templated.');

		      // Already signed.
		      if (vector.get(0).length > 0)
		        return vector;

		      vector.set(0, sig);

		      return vector;
		    }

		    // Multisig
		    const [m, n] = prev.getMultisig();
		    if (m !== -1) {
		      if (vector.length < 2)
		        throw new Error('Input has not been templated.');

		      if (vector.get(0).length !== 0)
		        throw new Error('Input has not been templated.');

		      // Too many signature slots. Abort.
		      if (vector.length - 1 > n)
		        throw new Error('Input has not been templated.');

		      // Count the number of current signatures.
		      let total = 0;
		      for (let i = 1; i < vector.length; i++) {
		        const item = vector.get(i);
		        if (item.length > 0)
		          total += 1;
		      }

		      // Signatures are already finalized.
		      if (total === m && vector.length - 1 === m)
		        return vector;

		      // Add some signature slots for us to use if
		      // there was for some reason not enough.
		      while (vector.length - 1 < n)
		        vector.pushInt(0);

		      // Grab the redeem script's keys to figure
		      // out where our key should go.
		      const keys = [];
		      for (const op of prev.code) {
		        if (op.data)
		          keys.push(op.data);
		      }

		      // Find the key index so we can place
		      // the signature in the same index.
		      let keyIndex = -1;

		      for (let i = 0; i < keys.length; i++) {
		        const key = keys[i];
		        if (key.equals(ring.publicKey)) {
		          keyIndex = i;
		          break;
		        }
		      }

		      // Our public key is not in the prev_out
		      // script. We tried to sign a transaction
		      // that is not redeemable by us.
		      if (keyIndex === -1)
		        return null;

		      // Offset key index by one to turn it into
		      // "sig index". Accounts for OP_0 byte at
		      // the start.
		      keyIndex += 1;

		      // Add our signature to the correct slot
		      // and increment the total number of
		      // signatures.
		      if (keyIndex < vector.length && total < m) {
		        if (vector.get(keyIndex).length === 0) {
		          vector.set(keyIndex, sig);
		          total += 1;
		        }
		      }

		      // All signatures added. Finalize.
		      if (total >= m) {
		        // Remove empty slots left over.
		        for (let i = vector.length - 1; i >= 1; i--) {
		          const item = vector.get(i);
		          if (item.length === 0)
		            vector.remove(i);
		        }

		        // Remove signatures which are not required.
		        // This should never happen.
		        while (total > m) {
		          vector.pop();
		          total -= 1;
		        }

		        // Sanity checks.
		        assert(total === m);
		        assert(vector.length - 1 === m);
		      }

		      return vector;
		    }

		    return null;
		  }

		  /**
		   * Test whether the transaction is fully-signed.
		   * @returns {Boolean}
		   */

		  isSigned() {
		    for (let i = 0; i < this.inputs.length; i++) {
		      const {prevout} = this.inputs[i];
		      const coin = this.view.getOutput(prevout);

		      if (!coin)
		        return false;

		      if (!this.isInputSigned(i, coin))
		        return false;
		    }

		    return true;
		  }

		  /**
		   * Test whether an input is fully-signed.
		   * @param {Number} index
		   * @param {Coin|Output} coin
		   * @returns {Boolean}
		   */

		  isInputSigned(index, coin) {
		    const input = this.inputs[index];

		    assert(input, 'Input does not exist.');
		    assert(coin, 'No coin passed.');

		    const vector = input.script;
		    let prev = coin.script;
		    let redeem = false;

		    // Grab redeem script if possible.
		    if (prev.isScripthash()) {
		      prev = input.script.getRedeem();
		      if (!prev)
		        return false;
		      redeem = true;
		    }

		    const stack = vector.toStack();

		    if (redeem)
		      stack.pop();

		    return this.isVectorSigned(prev, stack);
		  }

		  /**
		   * Test whether a vector is fully-signed.
		   * @param {Script} prev
		   * @param {Stack} vector
		   * @returns {Boolean}
		   */

		  isVectorSigned(prev, vector) {
		    if (prev.isPubkey()) {
		      if (vector.length !== 1)
		        return false;

		      if (vector.get(0).length === 0)
		        return false;

		      return true;
		    }

		    if (prev.isPubkeyhash()) {
		      if (vector.length !== 2)
		        return false;

		      if (vector.get(0).length === 0)
		        return false;

		      if (vector.get(1).length === 0)
		        return false;

		      return true;
		    }

		    const [m] = prev.getMultisig();

		    if (m !== -1) {
		      // Ensure we have the correct number
		      // of required signatures.
		      if (vector.length - 1 !== m)
		        return false;

		      // Ensure all members are signatures.
		      for (let i = 1; i < vector.length; i++) {
		        const item = vector.get(i);
		        if (item.length === 0)
		          return false;
		      }

		      return true;
		    }

		    return false;
		  }

		  /**
		   * Build input scripts (or witnesses).
		   * @param {KeyRing} ring - Address used to sign. The address
		   * must be able to redeem the coin.
		   * @returns {Number} Number of inputs templated.
		   */

		  template(ring) {
		    if (Array.isArray(ring)) {
		      let total = 0;
		      for (const key of ring)
		        total += this.template(key);
		      return total;
		    }

		    let total = 0;

		    for (let i = 0; i < this.inputs.length; i++) {
		      const {prevout} = this.inputs[i];
		      const coin = this.view.getOutput(prevout);

		      if (!coin)
		        continue;

		      if (!ring.ownOutput(coin))
		        continue;

		      // Build script for input
		      if (!this.scriptInput(i, coin, ring))
		        continue;

		      total += 1;
		    }

		    return total;
		  }

		  /**
		   * Built input scripts (or witnesses) and sign the inputs.
		   * @param {KeyRing} ring - Address used to sign. The address
		   * must be able to redeem the coin.
		   * @param {SighashType} type
		   * @returns {Number} Number of inputs signed.
		   */

		  sign(ring, type) {
		    if (Array.isArray(ring)) {
		      let total = 0;
		      for (const key of ring)
		        total += this.sign(key, type);
		      return total;
		    }

		    assert(ring.privateKey, 'No private key available.');

		    let total = 0;

		    for (let i = 0; i < this.inputs.length; i++) {
		      const {prevout} = this.inputs[i];
		      const coin = this.view.getOutput(prevout);

		      if (!coin)
		        continue;

		      if (!ring.ownOutput(coin))
		        continue;

		      // Build script for input
		      if (!this.scriptInput(i, coin, ring))
		        continue;

		      // Sign input
		      if (!this.signInput(i, coin, ring, type))
		        continue;

		      total += 1;
		    }

		    return total;
		  }

		  /**
		   * Sign the transaction inputs on the worker pool
		   * (if workers are enabled).
		   * @param {KeyRing} ring
		   * @param {SighashType?} type
		   * @param {WorkerPool?} pool
		   * @returns {Promise}
		   */

		  async signAsync(ring, type, pool) {
		    if (!pool)
		      return this.sign(ring, type);

		    return await pool.sign(this, ring, type);
		  }

		  /**
		   * Estimate maximum possible size.
		   * @param {Function?} estimate - Input script size estimator.
		   * @returns {Number}
		   */

		  async estimateSize(estimate) {
		    let total = 0;

		    // Calculate the size, minus the input scripts.
		    total += 4;
		    total += encoding.sizeVarint(this.inputs.length);
		    total += this.inputs.length * 40;

		    total += encoding.sizeVarint(this.outputs.length);

		    for (const output of this.outputs)
		      total += output.getSize();

		    total += 4;

		    // Add size for signatures and public keys
		    for (const {prevout} of this.inputs) {
		      const coin = this.view.getOutput(prevout);

		      // We're out of luck here.
		      // Just assume it's a p2pkh.
		      if (!coin) {
		        total += 110;
		        continue;
		      }

		      // Previous output script.
		      const prev = coin.script;

		      // P2PK
		      if (prev.isPubkey()) {
		        // varint script size
		        total += 1;
		        // OP_PUSHDATA0 [signature]
		        total += 1 + 73;
		        continue;
		      }

		      // P2PKH
		      if (prev.isPubkeyhash()) {
		        // varint script size
		        total += 1;
		        // OP_PUSHDATA0 [signature]
		        total += 1 + 73;
		        // OP_PUSHDATA0 [key]
		        total += 1 + 33;
		        continue;
		      }

		      const [m] = prev.getMultisig();
		      if (m !== -1) {
		        let size = 0;
		        // Bare Multisig
		        // OP_0
		        size += 1;
		        // OP_PUSHDATA0 [signature] ...
		        size += (1 + 73) * m;
		        // varint len
		        size += encoding.sizeVarint(size);
		        total += size;
		        continue;
		      }

		      // Call out to the custom estimator.
		      if (estimate) {
		        const size = await estimate(prev);
		        if (size !== -1) {
		          total += size;
		          continue;
		        }
		      }

		      // P2SH
		      if (prev.isScripthash()) {
		        // varint size
		        total += 1;
		        // 2-of-3 multisig input
		        total += 149;
		        continue;
		      }

		      // Unknown.
		      total += 110;
		    }

		    return total;
		  }

		  /**
		   * Select necessary coins based on total output value.
		   * @param {Coin[]} coins
		   * @param {Object?} options
		   * @returns {CoinSelection}
		   * @throws on not enough funds available.
		   */

		  selectCoins(coins, options) {
		    const selector = new CoinSelector(this, options);
		    return selector.select(coins);
		  }

		  /**
		   * Attempt to subtract a fee from a single output.
		   * @param {Number} index
		   * @param {Amount} fee
		   */

		  subtractIndex(index, fee) {
		    assert(typeof index === 'number');
		    assert(typeof fee === 'number');

		    const output = this.outputs[index];

		    if (!output)
		      throw new Error('Subtraction index does not exist.');

		    if (output.value < fee + output.getDustThreshold())
		      throw new Error('Could not subtract fee.');

		    output.value -= fee;
		  }

		  /**
		   * Attempt to subtract a fee from all outputs evenly.
		   * @param {Amount} fee
		   */

		  subtractFee(fee) {
		    assert(typeof fee === 'number');

		    let outputs = 0;

		    for (const output of this.outputs) {
		      // Ignore nulldatas and
		      // other OP_RETURN scripts.
		      if (output.script.isUnspendable())
		        continue;
		      outputs += 1;
		    }

		    if (outputs === 0)
		      throw new Error('Could not subtract fee.');

		    const left = fee % outputs;
		    const share = (fee - left) / outputs;

		    // First pass, remove even shares.
		    for (const output of this.outputs) {
		      if (output.script.isUnspendable())
		        continue;

		      if (output.value < share + output.getDustThreshold())
		        throw new Error('Could not subtract fee.');

		      output.value -= share;
		    }

		    // Second pass, remove the remainder
		    // for the one unlucky output.
		    for (const output of this.outputs) {
		      if (output.script.isUnspendable())
		        continue;

		      if (output.value >= left + output.getDustThreshold()) {
		        output.value -= left;
		        return;
		      }
		    }

		    throw new Error('Could not subtract fee.');
		  }

		  /**
		   * Select coins and fill the inputs.
		   * @param {Coin[]} coins
		   * @param {Object} options - See {@link MTX#selectCoins} options.
		   * @returns {CoinSelector}
		   */

		  async fund(coins, options) {
		    assert(options, 'Options are required.');
		    assert(options.changeAddress, 'Change address is required.');
		    assert(this.inputs.length === 0, 'TX is already funded.');

		    // Select necessary coins.
		    const select = await this.selectCoins(coins, options);

		    // Add coins to transaction.
		    for (const coin of select.chosen)
		      this.addCoin(coin);

		    // Attempt to subtract fee.
		    if (select.subtractFee) {
		      const index = select.subtractIndex;
		      if (index !== -1)
		        this.subtractIndex(index, select.fee);
		      else
		        this.subtractFee(select.fee);
		    }

		    // Add a change output.
		    const output = new Output();
		    output.value = select.change;
		    output.script.fromAddress(select.changeAddress);

		    if (output.isDust(policy.MIN_RELAY)) {
		      // Do nothing. Change is added to fee.
		      this.changeIndex = -1;
		      assert.strictEqual(this.getFee(), select.fee + select.change);
		    } else {
		      this.outputs.push(output);
		      this.changeIndex = this.outputs.length - 1;
		      assert.strictEqual(this.getFee(), select.fee);
		    }

		    return select;
		  }

		  /**
		   * Sort inputs and outputs according to BIP69.
		   * @see https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki
		   */

		  sortMembers() {
		    let changeOutput = null;

		    if (this.changeIndex !== -1) {
		      changeOutput = this.outputs[this.changeIndex];
		      assert(changeOutput);
		    }

		    this.inputs.sort(sortInputs);
		    this.outputs.sort(sortOutputs);

		    if (this.changeIndex !== -1) {
		      this.changeIndex = this.outputs.indexOf(changeOutput);
		      assert(this.changeIndex !== -1);
		    }
		  }

		  /**
		   * Avoid fee sniping.
		   * @param {Number} - Current chain height.
		   * @see bitcoin/src/wallet/wallet.cpp
		   */

		  avoidFeeSniping(height) {
		    assert(typeof height === 'number', 'Must pass in height.');

		    if ((Math.random() * 10 | 0) === 0) {
		      height -= Math.random() * 100 | 0;

		      if (height < 0)
		        height = 0;
		    }

		    this.setLocktime(height);
		  }

		  /**
		   * Set locktime and sequences appropriately.
		   * @param {Number} locktime
		   */

		  setLocktime(locktime) {
		    assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');
		    assert(this.inputs.length > 0, 'Cannot set sequence with no inputs.');

		    for (const input of this.inputs) {
		      if (input.sequence === 0xffffffff)
		        input.sequence = 0xfffffffe;
		    }

		    this.locktime = locktime;
		  }

		  /**
		   * Set sequence locktime.
		   * @param {Number} index - Input index.
		   * @param {Number} locktime
		   * @param {Boolean?} seconds
		   */

		  setSequence(index, locktime, seconds) {
		    const input = this.inputs[index];

		    assert(input, 'Input does not exist.');
		    assert((locktime >>> 0) === locktime, 'Locktime must be a uint32.');

		    this.version = 2;

		    if (seconds) {
		      locktime >>>= consensus.SEQUENCE_GRANULARITY;
		      locktime &= consensus.SEQUENCE_MASK;
		      locktime |= consensus.SEQUENCE_TYPE_FLAG;
		    } else {
		      locktime &= consensus.SEQUENCE_MASK;
		    }

		    input.sequence = locktime;
		  }

		  /**
		   * Inspect the transaction.
		   * @returns {Object}
		   */

		  [inspectSymbol]() {
		    return this.format();
		  }

		  /**
		   * Inspect the transaction.
		   * @returns {Object}
		   */

		  format() {
		    return super.format(this.view);
		  }

		  /**
		   * Convert transaction to JSON.
		   * @returns {Object}
		   */

		  toJSON() {
		    return super.toJSON(null, this.view);
		  }

		  /**
		   * Convert transaction to JSON.
		   * @param {Network} network
		   * @returns {Object}
		   */

		  getJSON(network) {
		    return super.getJSON(network, this.view);
		  }

		  /**
		   * Inject properties from a json object
		   * @param {Object} json
		   */

		  fromJSON(json) {
		    super.fromJSON(json);

		    for (let i = 0; i < json.inputs.length; i++) {
		      const input = json.inputs[i];
		      const {prevout} = input;

		      if (!input.coin)
		        continue;

		      const coin = Coin.fromJSON(input.coin);

		      coin.hash = util.fromRev(prevout.hash);
		      coin.index = prevout.index;

		      this.view.addCoin(coin);
		    }

		    return this;
		  }

		  /**
		   * Instantiate a transaction from a
		   * jsonified transaction object.
		   * @param {Object} json - The jsonified transaction object.
		   * @returns {MTX}
		   */

		  static fromJSON(json) {
		    return new this().fromJSON(json);
		  }

		  /**
		   * Instantiate a transaction from a buffer reader.
		   * @param {BufferReader} br
		   * @returns {MTX}
		   */

		  static fromReader(br) {
		    return new this().fromReader(br);
		  }

		  /**
		   * Instantiate a transaction from a serialized Buffer.
		   * @param {Buffer} data
		   * @param {String?} enc - Encoding, can be `'hex'` or null.
		   * @returns {MTX}
		   */

		  static fromRaw(data, enc) {
		    if (typeof data === 'string')
		      data = Buffer.from(data, enc);
		    return new this().fromRaw(data);
		  }

		  /**
		   * Convert the MTX to a TX.
		   * @returns {TX}
		   */

		  toTX() {
		    return new TX().inject(this);
		  }

		  /**
		   * Convert the MTX to a TX.
		   * @returns {Array} [tx, view]
		   */

		  commit() {
		    return [this.toTX(), this.view];
		  }

		  /**
		   * Instantiate MTX from TX.
		   * @param {TX} tx
		   * @returns {MTX}
		   */

		  static fromTX(tx) {
		    return new this().inject(tx);
		  }

		  /**
		   * Test whether an object is an MTX.
		   * @param {Object} obj
		   * @returns {Boolean}
		   */

		  static isMTX(obj) {
		    return obj instanceof MTX;
		  }
		}

		/**
		 * Coin Selector
		 * @alias module:primitives.CoinSelector
		 */

		class CoinSelector {
		  /**
		   * Create a coin selector.
		   * @constructor
		   * @param {TX} tx
		   * @param {Object?} options
		   */

		  constructor(tx, options) {
		    this.tx = tx.clone();
		    this.coins = [];
		    this.outputValue = 0;
		    this.index = 0;
		    this.chosen = [];
		    this.change = 0;
		    this.fee = CoinSelector.MIN_FEE;

		    this.selection = 'value';
		    this.subtractFee = false;
		    this.subtractIndex = -1;
		    this.height = -1;
		    this.depth = -1;
		    this.hardFee = -1;
		    this.rate = CoinSelector.FEE_RATE;
		    this.maxFee = -1;
		    this.round = false;
		    this.changeAddress = null;
		    this.inputs = new BufferMap();

		    // Needed for size estimation.
		    this.estimate = null;

		    this.injectInputs();

		    if (options)
		      this.fromOptions(options);
		  }

		  /**
		   * Initialize selector options.
		   * @param {Object} options
		   * @private
		   */

		  fromOptions(options) {
		    if (options.selection) {
		      assert(typeof options.selection === 'string');
		      this.selection = options.selection;
		    }

		    if (options.subtractFee != null) {
		      if (typeof options.subtractFee === 'number') {
		        assert(Number.isSafeInteger(options.subtractFee));
		        assert(options.subtractFee >= -1);
		        this.subtractIndex = options.subtractFee;
		        this.subtractFee = this.subtractIndex !== -1;
		      } else {
		        assert(typeof options.subtractFee === 'boolean');
		        this.subtractFee = options.subtractFee;
		      }
		    }

		    if (options.subtractIndex != null) {
		      assert(Number.isSafeInteger(options.subtractIndex));
		      assert(options.subtractIndex >= -1);
		      this.subtractIndex = options.subtractIndex;
		      this.subtractFee = this.subtractIndex !== -1;
		    }

		    if (options.height != null) {
		      assert(Number.isSafeInteger(options.height));
		      assert(options.height >= -1);
		      this.height = options.height;
		    }

		    if (options.confirmations != null) {
		      assert(Number.isSafeInteger(options.confirmations));
		      assert(options.confirmations >= -1);
		      this.depth = options.confirmations;
		    }

		    if (options.depth != null) {
		      assert(Number.isSafeInteger(options.depth));
		      assert(options.depth >= -1);
		      this.depth = options.depth;
		    }

		    if (options.hardFee != null) {
		      assert(Number.isSafeInteger(options.hardFee));
		      assert(options.hardFee >= -1);
		      this.hardFee = options.hardFee;
		    }

		    if (options.rate != null) {
		      assert(Number.isSafeInteger(options.rate));
		      assert(options.rate >= 0);
		      this.rate = options.rate;
		    }

		    if (options.maxFee != null) {
		      assert(Number.isSafeInteger(options.maxFee));
		      assert(options.maxFee >= -1);
		      this.maxFee = options.maxFee;
		    }

		    if (options.round != null) {
		      assert(typeof options.round === 'boolean');
		      this.round = options.round;
		    }

		    if (options.changeAddress) {
		      const addr = options.changeAddress;
		      if (typeof addr === 'string') {
		        this.changeAddress = Address.fromString(addr);
		      } else {
		        assert(addr instanceof Address);
		        this.changeAddress = addr;
		      }
		    }

		    if (options.estimate) {
		      assert(typeof options.estimate === 'function');
		      this.estimate = options.estimate;
		    }

		    if (options.inputs) {
		      assert(Array.isArray(options.inputs));
		      for (let i = 0; i < options.inputs.length; i++) {
		        const prevout = options.inputs[i];
		        assert(prevout && typeof prevout === 'object');
		        const {hash, index} = prevout;
		        assert(Buffer.isBuffer(hash));
		        assert(typeof index === 'number');
		        this.inputs.set(Outpoint.toKey(hash, index), i);
		      }
		    }

		    return this;
		  }

		  /**
		   * Attempt to inject existing inputs.
		   * @private
		   */

		  injectInputs() {
		    if (this.tx.inputs.length > 0) {
		      for (let i = 0; i < this.tx.inputs.length; i++) {
		        const {prevout} = this.tx.inputs[i];
		        this.inputs.set(prevout.toKey(), i);
		      }
		    }
		  }

		  /**
		   * Initialize the selector with coins to select from.
		   * @param {Coin[]} coins
		   */

		  init(coins) {
		    this.coins = coins.slice();
		    this.outputValue = this.tx.getOutputValue();
		    this.index = 0;
		    this.chosen = [];
		    this.change = 0;
		    this.fee = CoinSelector.MIN_FEE;
		    this.tx.inputs.length = 0;

		    switch (this.selection) {
		      case 'all':
		      case 'random':
		        this.coins.sort(sortRandom);
		        break;
		      case 'age':
		        this.coins.sort(sortAge);
		        break;
		      case 'value':
		        this.coins.sort(sortValue);
		        break;
		      default:
		        throw new FundingError(`Bad selection type: ${this.selection}.`);
		    }
		  }

		  /**
		   * Calculate total value required.
		   * @returns {Amount}
		   */

		  total() {
		    if (this.subtractFee)
		      return this.outputValue;
		    return this.outputValue + this.fee;
		  }

		  /**
		   * Test whether the selector has
		   * completely funded the transaction.
		   * @returns {Boolean}
		   */

		  isFull() {
		    return this.tx.getInputValue() >= this.total();
		  }

		  /**
		   * Test whether a coin is spendable
		   * with regards to the options.
		   * @param {Coin} coin
		   * @returns {Boolean}
		   */

		  isSpendable(coin) {
		    if (this.tx.view.hasEntry(coin))
		      return false;

		    if (this.height === -1)
		      return true;

		    if (coin.coinbase) {
		      if (coin.height === -1)
		        return false;

		      if (this.height + 1 < coin.height + consensus.COINBASE_MATURITY)
		        return false;

		      return true;
		    }

		    if (this.depth === -1)
		      return true;

		    const depth = coin.getDepth(this.height);

		    if (depth < this.depth)
		      return false;

		    return true;
		  }

		  /**
		   * Get the current fee based on a size.
		   * @param {Number} size
		   * @returns {Amount}
		   */

		  getFee(size) {
		    // This is mostly here for testing.
		    // i.e. A fee rounded to the nearest
		    // kb is easier to predict ahead of time.
		    if (this.round) {
		      const fee = policy.getRoundFee(size, this.rate);
		      return Math.min(fee, CoinSelector.MAX_FEE);
		    }

		    const fee = policy.getMinFee(size, this.rate);
		    return Math.min(fee, CoinSelector.MAX_FEE);
		  }

		  /**
		   * Fund the transaction with more
		   * coins if the `output value + fee`
		   * total was updated.
		   */

		  fund() {
		    // Ensure all preferred inputs first.
		    if (this.inputs.size > 0) {
		      const coins = [];

		      for (let i = 0; i < this.inputs.size; i++)
		        coins.push(null);

		      for (const coin of this.coins) {
		        const {hash, index} = coin;
		        const key = Outpoint.toKey(hash, index);
		        const i = this.inputs.get(key);

		        if (i != null) {
		          coins[i] = coin;
		          this.inputs.delete(key);
		        }
		      }

		      if (this.inputs.size > 0)
		        throw new Error('Could not resolve preferred inputs.');

		      for (const coin of coins) {
		        this.tx.addCoin(coin);
		        this.chosen.push(coin);
		      }
		    }

		    while (this.index < this.coins.length) {
		      const coin = this.coins[this.index++];

		      if (!this.isSpendable(coin))
		        continue;

		      this.tx.addCoin(coin);
		      this.chosen.push(coin);

		      if (this.selection === 'all')
		        continue;

		      if (this.isFull())
		        break;
		    }
		  }

		  /**
		   * Initiate selection from `coins`.
		   * @param {Coin[]} coins
		   * @returns {CoinSelector}
		   */

		  async select(coins) {
		    this.init(coins);

		    if (this.hardFee !== -1) {
		      this.selectHard();
		    } else {
		      // This is potentially asynchronous:
		      // it may invoke the size estimator
		      // required for redeem scripts (we
		      // may be calling out to a wallet
		      // or something similar).
		      await this.selectEstimate();
		    }

		    if (!this.isFull()) {
		      // Still failing to get enough funds.
		      throw new FundingError(
		        'Not enough funds.',
		        this.tx.getInputValue(),
		        this.total());
		    }

		    // How much money is left after filling outputs.
		    this.change = this.tx.getInputValue() - this.total();

		    return this;
		  }

		  /**
		   * Initialize selection based on size estimate.
		   */

		  async selectEstimate() {
		    // Set minimum fee and do
		    // an initial round of funding.
		    this.fee = CoinSelector.MIN_FEE;
		    this.fund();

		    // Add dummy output for change.
		    const change = new Output();

		    if (this.changeAddress) {
		      change.script.fromAddress(this.changeAddress);
		    } else {
		      // In case we don't have a change address,
		      // we use a fake p2pkh output to gauge size.
		      change.script.fromPubkeyhash(Buffer.allocUnsafe(20));
		    }

		    this.tx.outputs.push(change);

		    // Keep recalculating the fee and funding
		    // until we reach some sort of equilibrium.
		    do {
		      const size = await this.tx.estimateSize(this.estimate);

		      this.fee = this.getFee(size);

		      if (this.maxFee > 0 && this.fee > this.maxFee)
		        throw new FundingError('Fee is too high.');

		      // Failed to get enough funds, add more coins.
		      if (!this.isFull())
		        this.fund();
		    } while (!this.isFull() && this.index < this.coins.length);
		  }

		  /**
		   * Initiate selection based on a hard fee.
		   */

		  selectHard() {
		    this.fee = Math.min(this.hardFee, CoinSelector.MAX_FEE);
		    this.fund();
		  }
		}

		/**
		 * Default fee rate
		 * for coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.FEE_RATE = 10000;

		/**
		 * Minimum fee to start with
		 * during coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.MIN_FEE = 10000;

		/**
		 * Maximum fee to allow
		 * after coin selection.
		 * @const {Amount}
		 * @default
		 */

		CoinSelector.MAX_FEE = consensus.COIN / 10;

		/**
		 * Funding Error
		 * An error thrown from the coin selector.
		 * @ignore
		 * @extends Error
		 * @property {String} message - Error message.
		 * @property {Amount} availableFunds
		 * @property {Amount} requiredFunds
		 */

		class FundingError extends Error {
		  /**
		   * Create a funding error.
		   * @constructor
		   * @param {String} msg
		   * @param {Amount} available
		   * @param {Amount} required
		   */

		  constructor(msg, available, required) {
		    super();

		    this.type = 'FundingError';
		    this.message = msg;
		    this.availableFunds = -1;
		    this.requiredFunds = -1;

		    if (available != null) {
		      this.message += ` (available=${Amount.btc(available)},`;
		      this.message += ` required=${Amount.btc(required)})`;
		      this.availableFunds = available;
		      this.requiredFunds = required;
		    }

		    if (Error.captureStackTrace)
		      Error.captureStackTrace(this, FundingError);
		  }
		}

		/*
		 * Helpers
		 */

		function sortAge(a, b) {
		  a = a.height === -1 ? 0x7fffffff : a.height;
		  b = b.height === -1 ? 0x7fffffff : b.height;
		  return a - b;
		}

		function sortRandom(a, b) {
		  return Math.random() > 0.5 ? 1 : -1;
		}

		function sortValue(a, b) {
		  if (a.height === -1 && b.height !== -1)
		    return 1;

		  if (a.height !== -1 && b.height === -1)
		    return -1;

		  return b.value - a.value;
		}

		function sortInputs(a, b) {
		  return a.compare(b);
		}

		function sortOutputs(a, b) {
		  return a.compare(b);
		}

		/*
		 * Expose
		 */

		exports = MTX;
		exports.MTX = MTX;
		exports.Selector = CoinSelector;
		exports.FundingError = FundingError;

		module.exports = exports; 
	} (mtx, mtx.exports));
	return mtx.exports;
}

/*!
 * txmeta.js - extended transaction object for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var txmeta;
var hasRequiredTxmeta;

function requireTxmeta () {
	if (hasRequiredTxmeta) return txmeta;
	hasRequiredTxmeta = 1;

	const assert = require$$0$3;
	const bio = require$$1;
	const util = requireUtil();
	const TX = requireTx();
	const {inspectSymbol} = requireUtils();

	/**
	 * TXMeta
	 * An extended transaction object.
	 * @alias module:primitives.TXMeta
	 */

	class TXMeta {
	  /**
	   * Create an extended transaction.
	   * @constructor
	   * @param {Object?} options
	   */

	  constructor(options) {
	    this.tx = new TX();
	    this.mtime = util.now();
	    this.height = -1;
	    this.block = null;
	    this.time = 0;
	    this.index = -1;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromOptions(options) {
	    if (options.tx) {
	      assert(options.tx instanceof TX);
	      this.tx = options.tx;
	    }

	    if (options.mtime != null) {
	      assert((options.mtime >>> 0) === options.mtime);
	      this.mtime = options.mtime;
	    }

	    if (options.height != null) {
	      assert(Number.isSafeInteger(options.height));
	      this.height = options.height;
	    }

	    if (options.block !== undefined) {
	      assert(options.block == null || Buffer.isBuffer(options.block));
	      this.block = options.block;
	    }

	    if (options.time != null) {
	      assert((options.time >>> 0) === options.time);
	      this.time = options.time;
	    }

	    if (options.index != null) {
	      assert(Number.isSafeInteger(options.index));
	      this.index = options.index;
	    }

	    return this;
	  }

	  /**
	   * Instantiate TXMeta from options.
	   * @param {Object} options
	   * @returns {TXMeta}
	   */

	  static fromOptions(options) {
	    return new this().fromOptions(options);
	  }

	  /**
	   * Inject properties from options object.
	   * @private
	   * @param {Object} options
	   */

	  fromTX(tx, entry, index) {
	    this.tx = tx;
	    if (entry) {
	      this.height = entry.height;
	      this.block = entry.hash;
	      this.time = entry.time;
	      this.index = index;
	    }
	    return this;
	  }

	  /**
	   * Instantiate TXMeta from options.
	   * @param {Object} options
	   * @returns {TXMeta}
	   */

	  static fromTX(tx, entry, index) {
	    return new this().fromTX(tx, entry, index);
	  }

	  /**
	   * Inspect the transaction.
	   * @returns {Object}
	   */

	  [inspectSymbol]() {
	    return this.format();
	  }

	  /**
	   * Inspect the transaction.
	   * @returns {Object}
	   */

	  format(view) {
	    const data = this.tx.format(view, null, this.index);
	    data.mtime = this.mtime;
	    data.height = this.height;
	    data.block = this.block ? util.revHex(this.block) : null;
	    data.time = this.time;
	    return data;
	  }

	  /**
	   * Convert transaction to JSON.
	   * @returns {Object}
	   */

	  toJSON() {
	    return this.getJSON();
	  }

	  /**
	   * Convert the transaction to an object suitable
	   * for JSON serialization.
	   * @param {Network} network
	   * @param {CoinView} view
	   * @returns {Object}
	   */

	  getJSON(network, view, chainHeight) {
	    const json = this.tx.getJSON(network, view, null, this.index);
	    json.mtime = this.mtime;
	    json.height = this.height;
	    json.block = this.block ? util.revHex(this.block) : null;
	    json.time = this.time;
	    json.confirmations = 0;

	    if (chainHeight != null && this.height !== -1)
	      json.confirmations = chainHeight - this.height + 1;

	    return json;
	  }

	  /**
	   * Inject properties from a json object.
	   * @private
	   * @param {Object} json
	   */

	  fromJSON(json) {
	    this.tx.fromJSON(json);

	    assert((json.mtime >>> 0) === json.mtime);
	    assert(Number.isSafeInteger(json.height));
	    assert(!json.block || typeof json.block === 'string');
	    assert((json.time >>> 0) === json.time);
	    assert(Number.isSafeInteger(json.index));

	    this.mtime = json.mtime;
	    this.height = json.height;
	    this.block = util.fromRev(json.block);
	    this.index = json.index;

	    return this;
	  }

	  /**
	   * Instantiate a transaction from a
	   * jsonified transaction object.
	   * @param {Object} json - The jsonified transaction object.
	   * @returns {TX}
	   */

	  static fromJSON(json) {
	    return new this().fromJSON(json);
	  }

	  /**
	   * Calculate serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    let size = 0;

	    size += this.tx.getSize();
	    size += 4;

	    if (this.block) {
	      size += 1;
	      size += 32;
	      size += 4 * 3;
	    } else {
	      size += 1;
	    }

	    return size;
	  }

	  /**
	   * Serialize a transaction to "extended format".
	   * This is the serialization format bcoin uses internally
	   * to store transactions in the database. The extended
	   * serialization includes the height, block hash, index,
	   * timestamp, and pending-since time.
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const size = this.getSize();
	    const bw = bio.write(size);

	    this.tx.toWriter(bw);

	    bw.writeU32(this.mtime);

	    if (this.block) {
	      bw.writeU8(1);
	      bw.writeHash(this.block);
	      bw.writeU32(this.height);
	      bw.writeU32(this.time);
	      bw.writeU32(this.index);
	    } else {
	      bw.writeU8(0);
	    }

	    return bw.render();
	  }

	  /**
	   * Inject properties from "extended" serialization format.
	   * @private
	   * @param {Buffer} data
	   */

	  fromRaw(data) {
	    const br = bio.read(data);

	    this.tx.fromReader(br);

	    this.mtime = br.readU32();

	    if (br.readU8() === 1) {
	      this.block = br.readHash();
	      this.height = br.readU32();
	      this.time = br.readU32();
	      this.index = br.readU32();
	      if (this.index === 0x7fffffff)
	        this.index = -1;
	    }

	    return this;
	  }

	  /**
	   * Instantiate a transaction from a Buffer
	   * in "extended" serialization format.
	   * @param {Buffer} data
	   * @param {String?} enc - One of `"hex"` or `null`.
	   * @returns {TX}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new this().fromRaw(data);
	  }

	  /**
	   * Test whether an object is an TXMeta.
	   * @param {Object} obj
	   * @returns {Boolean}
	   */

	  static isTXMeta(obj) {
	    return obj instanceof TXMeta;
	  }
	}

	/*
	 * Expose
	 */

	txmeta = TXMeta;
	return txmeta;
}

/*!
 * primitives/index.js - bitcoin primitives for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredPrimitives;

function requirePrimitives () {
	if (hasRequiredPrimitives) return primitives;
	hasRequiredPrimitives = 1;

	/**
	 * @module primitives
	 */

	primitives.AbstractBlock = requireAbstractblock();
	primitives.Address = requireAddress();
	primitives.Block = requireBlock();
	primitives.Coin = requireCoin();
	primitives.Headers = requireHeaders();
	primitives.Input = requireInput();
	primitives.InvItem = requireInvitem();
	primitives.KeyRing = requireKeyring();
	primitives.MemBlock = requireMemblock();
	primitives.MerkleBlock = requireMerkleblock();
	primitives.MTX = requireMtx();
	primitives.Outpoint = requireOutpoint();
	primitives.Output = requireOutput();
	primitives.TX = requireTx();
	primitives.TXMeta = requireTxmeta();
	return primitives;
}

var protocol = {};

var errors = {};

/*!
 * errors.js - error objects for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	/**
	 * @module protocol/errors
	 */

	const assert = require$$0$3;

	/**
	 * Verify Error
	 * An error thrown during verification. Can be either
	 * a mempool transaction validation error or a blockchain
	 * block verification error. Ultimately used to send
	 * `reject` packets to peers.
	 * @extends Error
	 * @param {Block|TX} msg
	 * @param {String} code - Reject packet code.
	 * @param {String} reason - Reject packet reason.
	 * @param {Number} score - Ban score increase
	 * (can be -1 for no reject packet).
	 * @param {Boolean} malleated
	 */

	class VerifyError extends Error {
	  /**
	   * Create a verify error.
	   * @constructor
	   * @param {Block|TX} msg
	   * @param {String} code - Reject packet code.
	   * @param {String} reason - Reject packet reason.
	   * @param {Number} score - Ban score increase
	   * (can be -1 for no reject packet).
	   * @param {Boolean} malleated
	   */

	  constructor(msg, code, reason, score, malleated) {
	    super();

	    assert(typeof code === 'string');
	    assert(typeof reason === 'string');
	    assert(score >= 0);

	    this.type = 'VerifyError';
	    this.message = '';
	    this.code = code;
	    this.reason = reason;
	    this.score = score;
	    this.hash = msg.hash();
	    this.malleated = malleated || false;

	    this.message = `Verification failure: ${reason}`
	      + ` (code=${code} score=${score} hash=${msg.rhash()})`;

	    if (Error.captureStackTrace)
	      Error.captureStackTrace(this, VerifyError);
	  }
	}

	/*
	 * Expose
	 */

	errors.VerifyError = VerifyError;
	return errors;
}

/*!
 * protocol/index.js - protocol constants for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredProtocol;

function requireProtocol () {
	if (hasRequiredProtocol) return protocol;
	hasRequiredProtocol = 1;

	/**
	 * @module protocol
	 */

	protocol.consensus = requireConsensus();
	protocol.errors = requireErrors();
	protocol.Network = requireNetwork();
	protocol.networks = requireNetworks();
	protocol.policy = requirePolicy();
	protocol.timedata = requireTimedata();
	return protocol;
}

var script = {};

/*!
 * sigcache.js - signature cache for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var sigcache;
var hasRequiredSigcache;

function requireSigcache () {
	if (hasRequiredSigcache) return sigcache;
	hasRequiredSigcache = 1;

	const assert = require$$0$3;
	const {BufferMap} = require$$2$2;
	const secp256k1 = requireSecp256k1();

	/**
	 * Signature cache.
	 * @alias module:script.SigCache
	 * @property {Number} size
	 * @property {Hash[]} keys
	 * @property {Object} valid
	 */

	class SigCache {
	  /**
	   * Create a signature cache.
	   * @constructor
	   * @param {Number} [size=10000]
	   */

	  constructor(size) {
	    if (size == null)
	      size = 10000;

	    assert((size >>> 0) === size);

	    this.size = size;
	    this.keys = [];
	    this.valid = new BufferMap();
	  }

	  /**
	   * Resize the sigcache.
	   * @param {Number} size
	   */

	  resize(size) {
	    assert((size >>> 0) === size);

	    this.size = size;
	    this.keys.length = 0;
	    this.valid.clear();
	  }

	  /**
	   * Add item to the sigcache.
	   * Potentially evict a random member.
	   * @param {Hash} msg - Sig hash.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   */

	  add(msg, sig, key) {
	    if (this.size === 0)
	      return;

	    this.valid.set(msg, new SigCacheEntry(sig, key));

	    if (this.keys.length >= this.size) {
	      const i = Math.floor(Math.random() * this.keys.length);
	      const k = this.keys[i];
	      this.valid.delete(k);
	      this.keys[i] = msg;
	    } else {
	      this.keys.push(msg);
	    }
	  }

	  /**
	   * Test whether the sig exists.
	   * @param {Hash} msg - Sig hash.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  has(msg, sig, key) {
	    const entry = this.valid.get(msg);

	    if (!entry)
	      return false;

	    return entry.equals(sig, key);
	  }

	  /**
	   * Verify a signature, testing
	   * it against the cache first.
	   * @param {Buffer} msg
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  verify(msg, sig, key) {
	    if (this.size === 0)
	      return secp256k1.verifyDER(msg, sig, key);

	    if (this.has(msg, sig, key))
	      return true;

	    const result = secp256k1.verifyDER(msg, sig, key);

	    if (!result)
	      return false;

	    this.add(msg, sig, key);

	    return true;
	  }

	  /**
	   * Verify a schnorr signature, testing
	   * it against the cache first.
	   * @param {Buffer} msg
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  verifySchnorr(msg, sig, key) {
	    if (this.size === 0)
	      return secp256k1.schnorrVerify(msg, sig, key);

	    if (this.has(msg, sig, key))
	      return true;

	    const result = secp256k1.schnorrVerify(msg, sig, key);

	    if (!result)
	      return false;

	    this.add(msg, sig, key);

	    return true;
	  }
	}

	/**
	 * Signature Cache Entry
	 * @ignore
	 * @property {Buffer} sig
	 * @property {Buffer} key
	 */

	class SigCacheEntry {
	  /**
	   * Create a cache entry.
	   * @constructor
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   */

	  constructor(sig, key) {
	    this.sig = Buffer.from(sig);
	    this.key = Buffer.from(key);
	  }

	  /**
	   * Compare an entry to a sig and key.
	   * @param {Buffer} sig
	   * @param {Buffer} key
	   * @returns {Boolean}
	   */

	  equals(sig, key) {
	    return this.sig.equals(sig) && this.key.equals(key);
	  }
	}

	/*
	 * Expose
	 */

	sigcache = SigCache;
	return sigcache;
}

/*!
 * script/index.js - bitcoin scripting for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredScript;

function requireScript () {
	if (hasRequiredScript) return script;
	hasRequiredScript = 1;

	/**
	 * @module script
	 */

	script.common = requireCommon$1();
	script.Opcode = requireOpcode();
	script.Script = requireScript$1();
	script.ScriptError = requireScripterror();
	script.ScriptNum = requireScriptnum();
	script.sigcache = requireSigcache();
	script.Stack = requireStack();
	script.Metrics = requireMetrics();
	script.SLP = requireSlp();
	return script;
}

var bcrypto = {};

var aes$1 = {};

/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on openssl/openssl:
 *   Based on code entered into the public domain by Vincent Rijmen.
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 *   http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf
 *   https://github.com/openssl/openssl/blob/master/crypto/aes/aes_core.c
 */

var aes;
var hasRequiredAes$1;

function requireAes$1 () {
	if (hasRequiredAes$1) return aes;
	hasRequiredAes$1 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const TE0 = new Uint32Array([
	  0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,
	  0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
	  0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,
	  0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
	  0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87,
	  0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
	  0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea,
	  0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
	  0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,
	  0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
	  0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108,
	  0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
	  0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e,
	  0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
	  0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,
	  0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
	  0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e,
	  0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
	  0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce,
	  0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
	  0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,
	  0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
	  0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b,
	  0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
	  0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16,
	  0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
	  0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,
	  0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
	  0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a,
	  0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
	  0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163,
	  0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
	  0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,
	  0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
	  0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47,
	  0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
	  0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f,
	  0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
	  0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,
	  0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
	  0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e,
	  0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
	  0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6,
	  0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
	  0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,
	  0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
	  0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25,
	  0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
	  0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72,
	  0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
	  0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,
	  0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
	  0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa,
	  0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
	  0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0,
	  0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
	  0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,
	  0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
	  0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920,
	  0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
	  0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17,
	  0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
	  0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,
	  0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a
	]);

	const TE1 = new Uint32Array([
	  0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b,
	  0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,
	  0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b,
	  0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,
	  0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d,
	  0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0,
	  0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf,
	  0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,
	  0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626,
	  0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc,
	  0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1,
	  0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,
	  0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3,
	  0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a,
	  0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2,
	  0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,
	  0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a,
	  0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,
	  0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3,
	  0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,
	  0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded,
	  0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,
	  0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939,
	  0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,
	  0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb,
	  0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,
	  0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f,
	  0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,
	  0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f,
	  0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5,
	  0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121,
	  0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2,
	  0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec,
	  0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,
	  0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d,
	  0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,
	  0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc,
	  0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,
	  0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414,
	  0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,
	  0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a,
	  0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c,
	  0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262,
	  0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,
	  0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d,
	  0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,
	  0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea,
	  0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,
	  0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e,
	  0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,
	  0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f,
	  0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,
	  0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666,
	  0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e,
	  0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9,
	  0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,
	  0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111,
	  0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,
	  0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9,
	  0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,
	  0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d,
	  0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,
	  0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f,
	  0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616
	]);

	const TE2 = new Uint32Array([
	  0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b,
	  0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,
	  0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b,
	  0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,
	  0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d,
	  0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,
	  0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af,
	  0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,
	  0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26,
	  0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,
	  0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1,
	  0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,
	  0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3,
	  0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a,
	  0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2,
	  0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,
	  0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a,
	  0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,
	  0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3,
	  0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,
	  0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed,
	  0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,
	  0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239,
	  0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,
	  0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb,
	  0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,
	  0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f,
	  0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,
	  0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f,
	  0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,
	  0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221,
	  0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,
	  0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec,
	  0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,
	  0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d,
	  0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,
	  0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc,
	  0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,
	  0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814,
	  0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb,
	  0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a,
	  0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c,
	  0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462,
	  0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,
	  0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d,
	  0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,
	  0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea,
	  0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008,
	  0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e,
	  0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,
	  0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f,
	  0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,
	  0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66,
	  0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e,
	  0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9,
	  0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,
	  0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211,
	  0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,
	  0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9,
	  0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,
	  0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d,
	  0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,
	  0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f,
	  0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16
	]);

	const TE3 = new Uint32Array([
	  0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6,
	  0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,
	  0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56,
	  0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,
	  0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa,
	  0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,
	  0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45,
	  0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,
	  0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c,
	  0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,
	  0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9,
	  0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,
	  0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d,
	  0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f,
	  0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf,
	  0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,
	  0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34,
	  0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,
	  0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d,
	  0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,
	  0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1,
	  0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,
	  0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72,
	  0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,
	  0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed,
	  0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,
	  0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe,
	  0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,
	  0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05,
	  0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,
	  0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342,
	  0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,
	  0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3,
	  0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,
	  0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a,
	  0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,
	  0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3,
	  0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,
	  0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28,
	  0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad,
	  0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14,
	  0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8,
	  0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4,
	  0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,
	  0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da,
	  0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,
	  0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf,
	  0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810,
	  0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c,
	  0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,
	  0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e,
	  0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,
	  0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc,
	  0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c,
	  0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069,
	  0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,
	  0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322,
	  0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,
	  0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9,
	  0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,
	  0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a,
	  0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,
	  0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e,
	  0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c
	]);

	const TD0 = new Uint32Array([
	  0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96,
	  0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393,
	  0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,
	  0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f,
	  0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1,
	  0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,
	  0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da,
	  0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844,
	  0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,
	  0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4,
	  0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45,
	  0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,
	  0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7,
	  0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a,
	  0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,
	  0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c,
	  0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1,
	  0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,
	  0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75,
	  0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051,
	  0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,
	  0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff,
	  0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77,
	  0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,
	  0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000,
	  0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e,
	  0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927,
	  0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a,
	  0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e,
	  0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,
	  0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d,
	  0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8,
	  0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,
	  0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34,
	  0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163,
	  0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,
	  0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d,
	  0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0,
	  0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,
	  0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef,
	  0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36,
	  0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,
	  0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662,
	  0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5,
	  0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,
	  0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b,
	  0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8,
	  0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,
	  0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6,
	  0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0,
	  0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,
	  0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f,
	  0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df,
	  0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,
	  0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e,
	  0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713,
	  0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,
	  0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c,
	  0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf,
	  0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,
	  0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f,
	  0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541,
	  0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190,
	  0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742
	]);

	const TD1 = new Uint32Array([
	  0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e,
	  0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303,
	  0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c,
	  0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3,
	  0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0,
	  0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9,
	  0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259,
	  0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8,
	  0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971,
	  0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a,
	  0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f,
	  0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b,
	  0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8,
	  0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab,
	  0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708,
	  0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682,
	  0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2,
	  0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe,
	  0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb,
	  0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10,
	  0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd,
	  0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015,
	  0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e,
	  0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee,
	  0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000,
	  0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72,
	  0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39,
	  0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e,
	  0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91,
	  0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a,
	  0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17,
	  0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9,
	  0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60,
	  0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e,
	  0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1,
	  0xcad731dc, 0x10426385, 0x40139722, 0x2084c611,
	  0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1,
	  0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3,
	  0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964,
	  0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390,
	  0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b,
	  0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf,
	  0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46,
	  0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af,
	  0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512,
	  0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb,
	  0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a,
	  0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8,
	  0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c,
	  0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266,
	  0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8,
	  0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6,
	  0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604,
	  0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551,
	  0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41,
	  0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647,
	  0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c,
	  0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1,
	  0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737,
	  0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db,
	  0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340,
	  0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95,
	  0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1,
	  0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857
	]);

	const TD2 = new Uint32Array([
	  0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27,
	  0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3,
	  0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502,
	  0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562,
	  0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe,
	  0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3,
	  0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552,
	  0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9,
	  0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9,
	  0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce,
	  0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253,
	  0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908,
	  0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b,
	  0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655,
	  0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337,
	  0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16,
	  0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69,
	  0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6,
	  0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6,
	  0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e,
	  0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6,
	  0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050,
	  0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9,
	  0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8,
	  0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000,
	  0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a,
	  0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d,
	  0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436,
	  0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b,
	  0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12,
	  0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b,
	  0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e,
	  0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f,
	  0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb,
	  0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4,
	  0xdccad731, 0x85104263, 0x22401397, 0x112084c6,
	  0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729,
	  0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1,
	  0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9,
	  0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233,
	  0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4,
	  0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad,
	  0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e,
	  0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3,
	  0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25,
	  0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b,
	  0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f,
	  0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15,
	  0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0,
	  0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2,
	  0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7,
	  0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791,
	  0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496,
	  0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665,
	  0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b,
	  0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6,
	  0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13,
	  0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47,
	  0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7,
	  0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844,
	  0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3,
	  0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d,
	  0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456,
	  0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8
	]);

	const TD3 = new Uint32Array([
	  0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a,
	  0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b,
	  0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5,
	  0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5,
	  0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d,
	  0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b,
	  0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95,
	  0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e,
	  0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27,
	  0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d,
	  0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562,
	  0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9,
	  0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752,
	  0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66,
	  0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3,
	  0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced,
	  0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e,
	  0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4,
	  0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4,
	  0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd,
	  0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d,
	  0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60,
	  0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767,
	  0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79,
	  0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000,
	  0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c,
	  0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736,
	  0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24,
	  0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b,
	  0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c,
	  0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12,
	  0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814,
	  0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3,
	  0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b,
	  0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8,
	  0x31dccad7, 0x63851042, 0x97224013, 0xc6112084,
	  0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7,
	  0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077,
	  0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247,
	  0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22,
	  0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698,
	  0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f,
	  0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254,
	  0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582,
	  0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf,
	  0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb,
	  0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883,
	  0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef,
	  0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629,
	  0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035,
	  0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533,
	  0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17,
	  0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4,
	  0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46,
	  0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb,
	  0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d,
	  0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb,
	  0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a,
	  0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73,
	  0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678,
	  0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2,
	  0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff,
	  0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064,
	  0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0
	]);

	const TD4 = new Uint8Array([
	  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	  0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	  0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	  0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	  0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	  0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	  0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	  0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	  0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	  0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	  0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	  0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	  0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	  0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	  0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	  0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	  0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	]);

	const RCON = new Uint32Array([
	  0x01000000, 0x02000000, 0x04000000, 0x08000000,
	  0x10000000, 0x20000000, 0x40000000, 0x80000000,
	  0x1b000000, 0x36000000
	]);

	/**
	 * AES
	 */

	class AES {
	  constructor(bits = 256) {
	    assert((bits >>> 0) === bits);

	    this.bits = bits;
	    this.rounds = getRounds(bits);
	    this.key = null;
	    this.encKey = null;
	    this.decKey = null;
	  }

	  get blockSize() {
	    return 16;
	  }

	  init(key) {
	    assert(Buffer.isBuffer(key));

	    if (key.length !== (this.bits >>> 3))
	      throw new Error('Invalid key size.');

	    this.destroy();
	    this.key = Buffer.from(key);
	    this.encKey = null;
	    this.decKey = null;

	    return this;
	  }

	  createEncryptKey() {
	    if (!this.key)
	      throw new Error('Cipher is not initialized.');

	    const ukey = this.key;

	    if (ukey.length !== (this.bits >>> 3))
	      throw new Error('Invalid key size.');

	    const key = new Uint32Array(60);

	    key[0] = readU32(ukey, 0);
	    key[1] = readU32(ukey, 4);
	    key[2] = readU32(ukey, 8);
	    key[3] = readU32(ukey, 12);

	    let p = 0;
	    let i = 0;

	    if (this.bits === 128) {
	      for (;;) {
	        const tmp = key[p + 3];

	        key[p + 4] = key[p]
	          ^ (TE2[(tmp >>> 16) & 0xff] & 0xff000000)
	          ^ (TE3[(tmp >>>  8) & 0xff] & 0x00ff0000)
	          ^ (TE0[(tmp >>>  0) & 0xff] & 0x0000ff00)
	          ^ (TE1[(tmp >>> 24) & 0xff] & 0x000000ff)
	          ^ RCON[i];

	        key[p + 5] = key[p + 1] ^ key[p + 4];
	        key[p + 6] = key[p + 2] ^ key[p + 5];
	        key[p + 7] = key[p + 3] ^ key[p + 6];

	        i += 1;

	        if (i === 10)
	          break;

	        p += 4;
	      }

	      return key;
	    }

	    key[p + 4] = readU32(ukey, 16);
	    key[p + 5] = readU32(ukey, 20);

	    if (this.bits === 192) {
	      for (;;) {
	        const tmp = key[p + 5];

	        key[p + 6] = key[p]
	          ^ (TE2[(tmp >>> 16) & 0xff] & 0xff000000)
	          ^ (TE3[(tmp >>>  8) & 0xff] & 0x00ff0000)
	          ^ (TE0[(tmp >>>  0) & 0xff] & 0x0000ff00)
	          ^ (TE1[(tmp >>> 24) & 0xff] & 0x000000ff)
	          ^ RCON[i];

	        key[p + 7] = key[p + 1] ^ key[p + 6];
	        key[p + 8] = key[p + 2] ^ key[p + 7];
	        key[p + 9] = key[p + 3] ^ key[p + 8];

	        i += 1;

	        if (i === 8)
	          break;

	        key[p + 10] = key[p + 4] ^ key[p + 9];
	        key[p + 11] = key[p + 5] ^ key[p + 10];
	        p += 6;
	      }

	      return key;
	    }

	    key[p + 6] = readU32(ukey, 24);
	    key[p + 7] = readU32(ukey, 28);

	    if (this.bits === 256) {
	      for (;;) {
	        let tmp = key[p + 7];

	        key[p + 8] = key[p]
	          ^ (TE2[(tmp >>> 16) & 0xff] & 0xff000000)
	          ^ (TE3[(tmp >>>  8) & 0xff] & 0x00ff0000)
	          ^ (TE0[(tmp >>>  0) & 0xff] & 0x0000ff00)
	          ^ (TE1[(tmp >>> 24) & 0xff] & 0x000000ff)
	          ^ RCON[i];

	        key[p + 9] = key[p + 1] ^ key[p + 8];
	        key[p + 10] = key[p + 2] ^ key[p + 9];
	        key[p + 11] = key[p + 3] ^ key[p + 10];

	        i += 1;

	        if (i === 7)
	          break;

	        tmp = key[p + 11];

	        key[p + 12] = key[p + 4]
	          ^ (TE2[(tmp >>> 24) & 0xff] & 0xff000000)
	          ^ (TE3[(tmp >>> 16) & 0xff] & 0x00ff0000)
	          ^ (TE0[(tmp >>>  8) & 0xff] & 0x0000ff00)
	          ^ (TE1[(tmp >>>  0) & 0xff] & 0x000000ff);

	        key[p + 13] = key[p +  5] ^ key[p + 12];
	        key[p + 14] = key[p +  6] ^ key[p + 13];
	        key[p + 15] = key[p +  7] ^ key[p + 14];

	        p += 8;
	      }

	      return key;
	    }

	    throw new Error('Bad key size.');
	  }

	  createDecryptKey() {
	    // First, start with an encryption schedule.
	    const key = this.createEncryptKey();

	    let p = 0;

	    // Invert the order of the round keys.
	    for (let i = 0, j = 4 * this.rounds; i < j; i += 4, j -= 4) {
	      let tmp = key[p + i + 0];

	      key[p + i + 0] = key[p + j + 0];
	      key[p + j + 0] = tmp;

	      tmp = key[p + i + 1];
	      key[p + i + 1] = key[p + j + 1];
	      key[p + j + 1] = tmp;

	      tmp = key[p + i + 2];
	      key[p + i + 2] = key[p + j + 2];
	      key[p + j + 2] = tmp;

	      tmp = key[p + i + 3];
	      key[p + i + 3] = key[p + j + 3];
	      key[p + j + 3] = tmp;
	    }

	    // Apply the inverse MixColumn transform to
	    // all round keys but the first and the last.
	    for (let i = 1; i < this.rounds; i++) {
	      p += 4;

	      key[p + 0] = TD0[TE1[(key[p + 0] >>> 24) & 0xff] & 0xff]
	                 ^ TD1[TE1[(key[p + 0] >>> 16) & 0xff] & 0xff]
	                 ^ TD2[TE1[(key[p + 0] >>>  8) & 0xff] & 0xff]
	                 ^ TD3[TE1[(key[p + 0] >>>  0) & 0xff] & 0xff];

	      key[p + 1] = TD0[TE1[(key[p + 1] >>> 24) & 0xff] & 0xff]
	                 ^ TD1[TE1[(key[p + 1] >>> 16) & 0xff] & 0xff]
	                 ^ TD2[TE1[(key[p + 1] >>>  8) & 0xff] & 0xff]
	                 ^ TD3[TE1[(key[p + 1] >>>  0) & 0xff] & 0xff];

	      key[p + 2] = TD0[TE1[(key[p + 2] >>> 24) & 0xff] & 0xff]
	                 ^ TD1[TE1[(key[p + 2] >>> 16) & 0xff] & 0xff]
	                 ^ TD2[TE1[(key[p + 2] >>>  8) & 0xff] & 0xff]
	                 ^ TD3[TE1[(key[p + 2] >>>  0) & 0xff] & 0xff];

	      key[p + 3] = TD0[TE1[(key[p + 3] >>> 24) & 0xff] & 0xff]
	                 ^ TD1[TE1[(key[p + 3] >>> 16) & 0xff] & 0xff]
	                 ^ TD2[TE1[(key[p + 3] >>>  8) & 0xff] & 0xff]
	                 ^ TD3[TE1[(key[p + 3] >>>  0) & 0xff] & 0xff];
	    }

	    return key;
	  }

	  getEncryptKey() {
	    if (!this.encKey)
	      this.encKey = this.createEncryptKey();
	    return this.encKey;
	  }

	  getDecryptKey() {
	    if (!this.decKey)
	      this.decKey = this.createDecryptKey();
	    return this.decKey;
	  }

	  encrypt(output, opos, input, ipos) {
	    const key = this.getEncryptKey();

	    // Map byte array block to cipher
	    // state and add initial round key.
	    let s0 = readU32(input, ipos +  0) ^ key[0];
	    let s1 = readU32(input, ipos +  4) ^ key[1];
	    let s2 = readU32(input, ipos +  8) ^ key[2];
	    let s3 = readU32(input, ipos + 12) ^ key[3];

	    // Nr - 1 full rounds
	    let r = this.rounds >>> 1;
	    let p = 0;
	    let t0, t1, t2, t3;

	    for (;;) {
	      t0 = TE0[(s0 >>> 24) & 0xff]
	         ^ TE1[(s1 >>> 16) & 0xff]
	         ^ TE2[(s2 >>>  8) & 0xff]
	         ^ TE3[(s3 >>>  0) & 0xff]
	         ^ key[p + 4];

	      t1 = TE0[(s1 >>> 24) & 0xff]
	         ^ TE1[(s2 >>> 16) & 0xff]
	         ^ TE2[(s3 >>>  8) & 0xff]
	         ^ TE3[(s0 >>>  0) & 0xff]
	         ^ key[p + 5];

	      t2 = TE0[(s2 >>> 24) & 0xff]
	         ^ TE1[(s3 >>> 16) & 0xff]
	         ^ TE2[(s0 >>>  8) & 0xff]
	         ^ TE3[(s1 >>>  0) & 0xff]
	         ^ key[p + 6];

	      t3 = TE0[(s3 >>> 24) & 0xff]
	         ^ TE1[(s0 >>> 16) & 0xff]
	         ^ TE2[(s1 >>>  8) & 0xff]
	         ^ TE3[(s2 >>>  0) & 0xff]
	         ^ key[p + 7];

	      p += 8;
	      r -= 1;

	      if (r === 0)
	        break;

	      s0 = TE0[(t0 >>> 24) & 0xff]
	         ^ TE1[(t1 >>> 16) & 0xff]
	         ^ TE2[(t2 >>>  8) & 0xff]
	         ^ TE3[(t3 >>>  0) & 0xff]
	         ^ key[p + 0];

	      s1 = TE0[(t1 >>> 24) & 0xff]
	         ^ TE1[(t2 >>> 16) & 0xff]
	         ^ TE2[(t3 >>>  8) & 0xff]
	         ^ TE3[(t0 >>>  0) & 0xff]
	         ^ key[p + 1];

	      s2 = TE0[(t2 >>> 24) & 0xff]
	         ^ TE1[(t3 >>> 16) & 0xff]
	         ^ TE2[(t0 >>>  8) & 0xff]
	         ^ TE3[(t1 >>>  0) & 0xff]
	         ^ key[p + 2];

	      s3 = TE0[(t3 >>> 24) & 0xff]
	         ^ TE1[(t0 >>> 16) & 0xff]
	         ^ TE2[(t1 >>>  8) & 0xff]
	         ^ TE3[(t2 >>>  0) & 0xff]
	         ^ key[p + 3];
	    }

	    // Apply last round and map cipher
	    // state to byte array block.
	    s0 = (TE2[(t0 >>> 24) & 0xff] & 0xff000000)
	       ^ (TE3[(t1 >>> 16) & 0xff] & 0x00ff0000)
	       ^ (TE0[(t2 >>>  8) & 0xff] & 0x0000ff00)
	       ^ (TE1[(t3 >>>  0) & 0xff] & 0x000000ff)
	       ^ key[p + 0];

	    s1 = (TE2[(t1 >>> 24) & 0xff] & 0xff000000)
	       ^ (TE3[(t2 >>> 16) & 0xff] & 0x00ff0000)
	       ^ (TE0[(t3 >>>  8) & 0xff] & 0x0000ff00)
	       ^ (TE1[(t0 >>>  0) & 0xff] & 0x000000ff)
	       ^ key[p + 1];

	    s2 = (TE2[(t2 >>> 24) & 0xff] & 0xff000000)
	       ^ (TE3[(t3 >>> 16) & 0xff] & 0x00ff0000)
	       ^ (TE0[(t0 >>>  8) & 0xff] & 0x0000ff00)
	       ^ (TE1[(t1 >>>  0) & 0xff] & 0x000000ff)
	       ^ key[p + 2];

	    s3 = (TE2[(t3 >>> 24) & 0xff] & 0xff000000)
	       ^ (TE3[(t0 >>> 16) & 0xff] & 0x00ff0000)
	       ^ (TE0[(t1 >>>  8) & 0xff] & 0x0000ff00)
	       ^ (TE1[(t2 >>>  0) & 0xff] & 0x000000ff)
	       ^ key[p + 3];

	    writeU32(output, s0, opos + 0);
	    writeU32(output, s1, opos + 4);
	    writeU32(output, s2, opos + 8);
	    writeU32(output, s3, opos + 12);

	    return this;
	  }

	  decrypt(output, opos, input, ipos) {
	    const key = this.getDecryptKey();

	    // Map byte array block to cipher
	    // state and add initial round key.
	    let s0 = readU32(input, ipos +  0) ^ key[0];
	    let s1 = readU32(input, ipos +  4) ^ key[1];
	    let s2 = readU32(input, ipos +  8) ^ key[2];
	    let s3 = readU32(input, ipos + 12) ^ key[3];

	    // Nr - 1 full rounds
	    let r = this.rounds >>> 1;
	    let p = 0;
	    let t0, t1, t2, t3;

	    for (;;) {
	      t0 = TD0[(s0 >>> 24) & 0xff]
	         ^ TD1[(s3 >>> 16) & 0xff]
	         ^ TD2[(s2 >>>  8) & 0xff]
	         ^ TD3[(s1 >>>  0) & 0xff]
	         ^ key[p + 4];

	      t1 = TD0[(s1 >>> 24) & 0xff]
	         ^ TD1[(s0 >>> 16) & 0xff]
	         ^ TD2[(s3 >>>  8) & 0xff]
	         ^ TD3[(s2 >>>  0) & 0xff]
	         ^ key[p + 5];

	      t2 = TD0[(s2 >>> 24) & 0xff]
	         ^ TD1[(s1 >>> 16) & 0xff]
	         ^ TD2[(s0 >>>  8) & 0xff]
	         ^ TD3[(s3 >>>  0) & 0xff]
	         ^ key[p + 6];

	      t3 = TD0[(s3 >>> 24) & 0xff]
	         ^ TD1[(s2 >>> 16) & 0xff]
	         ^ TD2[(s1 >>>  8) & 0xff]
	         ^ TD3[(s0 >>>  0) & 0xff]
	         ^ key[p + 7];

	      p += 8;
	      r -= 1;

	      if (r === 0)
	        break;

	      s0 = TD0[(t0 >>> 24) & 0xff]
	         ^ TD1[(t3 >>> 16) & 0xff]
	         ^ TD2[(t2 >>>  8) & 0xff]
	         ^ TD3[(t1 >>>  0) & 0xff]
	         ^ key[p + 0];

	      s1 = TD0[(t1 >>> 24) & 0xff]
	         ^ TD1[(t0 >>> 16) & 0xff]
	         ^ TD2[(t3 >>>  8) & 0xff]
	         ^ TD3[(t2 >>>  0) & 0xff]
	         ^ key[p + 1];

	      s2 = TD0[(t2 >>> 24) & 0xff]
	         ^ TD1[(t1 >>> 16) & 0xff]
	         ^ TD2[(t0 >>>  8) & 0xff]
	         ^ TD3[(t3 >>>  0) & 0xff]
	         ^ key[p + 2];

	      s3 = TD0[(t3 >>> 24) & 0xff]
	         ^ TD1[(t2 >>> 16) & 0xff]
	         ^ TD2[(t1 >>>  8) & 0xff]
	         ^ TD3[(t0 >>>  0) & 0xff]
	         ^ key[p + 3];
	    }

	    // Apply last round and map cipher
	    // state to byte array block.
	    s0 = (TD4[(t0 >>> 24) & 0xff] << 24)
	       ^ (TD4[(t3 >>> 16) & 0xff] << 16)
	       ^ (TD4[(t2 >>>  8) & 0xff] <<  8)
	       ^ (TD4[(t1 >>>  0) & 0xff] <<  0)
	       ^ key[p + 0];

	    s1 = (TD4[(t1 >>> 24) & 0xff] << 24)
	       ^ (TD4[(t0 >>> 16) & 0xff] << 16)
	       ^ (TD4[(t3 >>>  8) & 0xff] <<  8)
	       ^ (TD4[(t2 >>>  0) & 0xff] <<  0)
	       ^ key[p + 1];

	    s2 = (TD4[(t2 >>> 24) & 0xff] << 24)
	       ^ (TD4[(t1 >>> 16) & 0xff] << 16)
	       ^ (TD4[(t0 >>>  8) & 0xff] <<  8)
	       ^ (TD4[(t3 >>>  0) & 0xff] <<  0)
	       ^ key[p + 2];

	    s3 = (TD4[(t3 >>> 24) & 0xff] << 24)
	       ^ (TD4[(t2 >>> 16) & 0xff] << 16)
	       ^ (TD4[(t1 >>>  8) & 0xff] <<  8)
	       ^ (TD4[(t0 >>>  0) & 0xff] <<  0)
	       ^ key[p + 3];

	    writeU32(output, s0, opos + 0);
	    writeU32(output, s1, opos + 4);
	    writeU32(output, s2, opos + 8);
	    writeU32(output, s3, opos + 12);

	    return this;
	  }

	  destroy() {
	    if (this.key) {
	      for (let i = 0; i < this.key.length; i++)
	        this.key[i] = 0;
	    }

	    if (this.encKey) {
	      for (let i = 0; i < 60; i++)
	        this.encKey[i] = 0;
	    }

	    if (this.decKey) {
	      for (let i = 0; i < 60; i++)
	        this.decKey[i] = 0;
	    }

	    this.key = null;
	    this.encKey = null;
	    this.decKey = null;

	    return this;
	  }
	}

	/*
	 * Helpers
	 */

	function getRounds(bits) {
	  switch (bits) {
	    case 128:
	      return 10;
	    case 192:
	      return 12;
	    case 256:
	      return 14;
	    default:
	      throw new Error('Bad key size.');
	  }
	}

	function readU32(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off]);
	}

	function writeU32(dst, num, off) {
	  dst[off++] = num >>> 24;
	  dst[off++] = num >>> 16;
	  dst[off++] = num >>> 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	aes = AES;
	return aes;
}

var modes = {};

/*!
 * ghash.js - ghash for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Galois/Counter_Mode
 *   https://dx.doi.org/10.6028/NIST.SP.800-38D
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm.go
 *   https://github.com/golang/go/blob/master/src/crypto/cipher/gcm_test.go
 *   https://github.com/DaGenix/rust-crypto/blob/master/src/ghash.rs
 */

var ghash;
var hasRequiredGhash;

function requireGhash () {
	if (hasRequiredGhash) return ghash;
	hasRequiredGhash = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const PADDING = Buffer.alloc(16, 0x00);
	const FINALIZED = -1;

	const REDUCTION = new Uint16Array([
	  0x0000, 0x1c20, 0x3840, 0x2460,
	  0x7080, 0x6ca0, 0x48c0, 0x54e0,
	  0xe100, 0xfd20, 0xd940, 0xc560,
	  0x9180, 0x8da0, 0xa9c0, 0xb5e0
	]);

	/**
	 * GHASH
	 */

	class GHASH {
	  constructor() {
	    this.state = new Uint32Array(4);
	    this.block = Buffer.alloc(16);
	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;
	    this.table = new Array(16);

	    for (let i = 0; i < 16; i++)
	      this.table[i] = new Uint32Array(4);
	  }

	  init(key) {
	    assert(Buffer.isBuffer(key));
	    assert(key.length === 16);

	    for (let i = 0; i < 4; i++)
	      this.state[i] = 0;

	    this.size = 0;
	    this.adLen = 0;
	    this.ctLen = 0;

	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++)
	        this.table[i][j] = 0;
	    }

	    const x = new Uint32Array(4);

	    x[1] = readU32(key, 0);
	    x[0] = readU32(key, 4);
	    x[3] = readU32(key, 8);
	    x[2] = readU32(key, 12);

	    this.table[reverse(1)] = x;

	    for (let i = 2; i < 16; i += 2) {
	      this.table[reverse(i)] = this.double(this.table[reverse(i >>> 1)]);
	      this.table[reverse(i + 1)] = this.add(this.table[reverse(i)], x);
	    }

	    return this;
	  }

	  absorb(data) {
	    this._absorb(data, data.length);
	    return this;
	  }

	  _absorb(data, len) {
	    assert(this.size !== FINALIZED, 'Context is not initialized.');

	    let pos = this.size & 15;
	    let off = 0;

	    this.size += len;

	    if (pos > 0) {
	      let want = 16 - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < 16)
	        return;

	      this.transform(this.block, 0);
	    }

	    while (len >= 16) {
	      this.transform(data, off);
	      off += 16;
	      len -= 16;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);
	  }

	  transform(block, off) {
	    this.state[1] ^= readU32(block, off + 0);
	    this.state[0] ^= readU32(block, off + 4);
	    this.state[3] ^= readU32(block, off + 8);
	    this.state[2] ^= readU32(block, off + 12);
	    this.mul(this.state);
	  }

	  pad() {
	    const pos = this.size & 15;

	    if (pos !== 0)
	      this._absorb(PADDING, 16 - pos);
	  }

	  aad(data) {
	    assert(Buffer.isBuffer(data));
	    assert(this.ctLen === 0);

	    this.adLen += data.length;

	    return this.absorb(data);
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));

	    if (data.length === 0)
	      return this;

	    if (this.ctLen === 0)
	      this.pad();

	    this.ctLen += data.length;

	    return this.absorb(data);
	  }

	  final() {
	    const out = Buffer.alloc(16);

	    this.pad();

	    const adLen = this.adLen * 8;
	    const ctLen = this.ctLen * 8;

	    this.state[1] ^= hi32(adLen);
	    this.state[0] ^= lo32(adLen);
	    this.state[3] ^= hi32(ctLen);
	    this.state[2] ^= lo32(ctLen);

	    this.mul(this.state);

	    writeU32(out, this.state[1], 0);
	    writeU32(out, this.state[0], 4);
	    writeU32(out, this.state[3], 8);
	    writeU32(out, this.state[2], 12);

	    for (let i = 0; i < 4; i++)
	      this.state[i] = 0;

	    for (let i = 0; i < 16; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;

	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++)
	        this.table[i][j] = 0;
	    }

	    return out;
	  }

	  destroy() {
	    for (let i = 0; i < 4; i++)
	      this.state[i] = 0;

	    for (let i = 0; i < 16; i++)
	      this.block[i] = 0;

	    this.size = FINALIZED;
	    this.adLen = 0;
	    this.ctLen = 0;

	    for (let i = 0; i < 16; i++) {
	      for (let j = 0; j < 4; j++)
	        this.table[i][j] = 0;
	    }
	  }

	  add(x, y) {
	    assert(x instanceof Uint32Array);
	    assert(x.length === 4);
	    assert(y instanceof Uint32Array);
	    assert(y.length === 4);

	    const z = new Uint32Array(4);

	    z[0] = x[0] ^ y[0];
	    z[1] = x[1] ^ y[1];
	    z[2] = x[2] ^ y[2];
	    z[3] = x[3] ^ y[3];

	    return z;
	  }

	  double(x) {
	    assert(x instanceof Uint32Array);
	    assert(x.length === 4);

	    const d = new Uint32Array(4);
	    const msb = (x[2] & 1) === 1;

	    let v;

	    d[3] = x[3];
	    d[2] = x[2];
	    v = d[3] & 1;
	    d[3] >>>= 1;
	    d[2] >>>= 1;
	    d[2] |= v << 31;

	    d[3] |= (x[0] & 1) << 31;

	    d[1] = x[1];
	    d[0] = x[0];
	    v = d[1] & 1;
	    d[1] >>>= 1;
	    d[0] >>>= 1;
	    d[0] |= v << 31;

	    if (msb) {
	      d[1] ^= 0xe1000000;
	      d[0] ^= 0x00000000;
	    }

	    return d;
	  }

	  mul(y) {
	    assert(y instanceof Uint32Array);
	    assert(y.length === 4);

	    const z = new Uint32Array(4);
	    const w = new Uint32Array(2);

	    let v, t;

	    for (let i = 0; i < 2; i++) {
	      w[0] = y[2];
	      w[1] = y[3];

	      if (i === 1) {
	        w[0] = y[0];
	        w[1] = y[1];
	      }

	      for (let j = 0; j < 64; j += 4) {
	        const msw = z[2] & 0x0f;

	        v = z[3] & 0x0f;
	        z[3] >>>= 4;
	        z[2] >>>= 4;
	        z[2] |= v << 28;

	        z[3] |= z[0] << 28;

	        v = z[1] & 0x0f;
	        z[1] >>>= 4;
	        z[0] >>>= 4;
	        z[0] |= v << 28;

	        z[1] ^= REDUCTION[msw] << 16;

	        t = this.table[w[0] & 0x0f];

	        z[0] ^= t[0];
	        z[1] ^= t[1];

	        z[2] ^= t[2];
	        z[3] ^= t[3];

	        v = w[1] & 0x0f;
	        w[1] >>>= 4;
	        w[0] >>>= 4;
	        w[0] |= v << 28;
	      }
	    }

	    y[0] = z[0];
	    y[1] = z[1];
	    y[2] = z[2];
	    y[3] = z[3];
	  }
	}

	/*
	 * Helpers
	 */

	function hi32(num) {
	  return (num * (1 / 0x100000000)) >>> 0;
	}

	function lo32(num) {
	  return num >>> 0;
	}

	function reverse(i) {
	  i = ((i << 2) & 0x0c) | ((i >>> 2) & 0x03);
	  i = ((i << 1) & 0x0a) | ((i >>> 1) & 0x05);
	  return i;
	}

	function readU32(data, off) {
	  return (data[off++] * 0x1000000
	        + data[off++] * 0x10000
	        + data[off++] * 0x100
	        + data[off++]);
	}

	function writeU32(dst, num, off) {
	  dst[off++] = num >>> 24;
	  dst[off++] = num >>> 16;
	  dst[off++] = num >>> 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	ghash = GHASH;
	return ghash;
}

/*!
 * modes.js - cipher modes for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
 */

var hasRequiredModes;

function requireModes () {
	if (hasRequiredModes) return modes;
	hasRequiredModes = 1;

	const assert = requireAssert();
	const GHASH = requireGhash();

	/*
	 * Constants
	 */

	const EMPTY = Buffer.alloc(0);

	// Shifted by four.
	const polyTable = new Uint32Array([
	  0x00001b, // 8
	  0x000087, // 16
	  0x000425, // 32
	  0x000000,
	  0x000125, // 64
	  0x000000,
	  0x000000,
	  0x000000,
	  0x080043  // 128
	]);

	/*
	 * Mode
	 */

	class Mode {
	  constructor(ctx) {
	    assert(ctx && typeof ctx.encrypt === 'function');
	    assert(typeof ctx.blockSize === 'number');

	    this.ctx = ctx;
	  }

	  get blockSize() {
	    return this.ctx.blockSize;
	  }

	  init(key, iv) {
	    throw new Error('Not implemented.');
	  }

	  update(data) {
	    throw new Error('Not implemented.');
	  }

	  crypt(output, input) {
	    throw new Error('Not implemented.');
	  }

	  final() {
	    throw new Error('Not implemented.');
	  }

	  destroy() {
	    throw new Error('Not implemented.');
	  }

	  setAutoPadding(padding) {
	    assert(typeof padding === 'boolean');

	    this._setAutoPadding(padding);

	    return this;
	  }

	  setAAD(data) {
	    assert(Buffer.isBuffer(data));
	    this._setAAD(data);
	    return this;
	  }

	  setCCM(msgLen, tagLen, aad) {
	    assert((msgLen >>> 0) === msgLen);
	    assert((tagLen >>> 0) === tagLen);
	    assert(aad == null || Buffer.isBuffer(aad));

	    this._setCCM(msgLen, tagLen, aad);

	    return this;
	  }

	  getAuthTag() {
	    return this._getAuthTag();
	  }

	  setAuthTag(tag) {
	    assert(Buffer.isBuffer(tag));
	    this._setAuthTag(tag);
	    return this;
	  }

	  _setAutoPadding(padding) {
	    throw new Error('Not available.');
	  }

	  _setAAD(data) {
	    throw new Error('Cipher is not authenticated.');
	  }

	  _setCCM(msgLen, tagLen, aad) {
	    throw new Error('Not available.');
	  }

	  _getAuthTag() {
	    throw new Error('Cipher is not authenticated.');
	  }

	  _setAuthTag(tag) {
	    throw new Error('Cipher is not authenticated.');
	  }
	}

	/**
	 * Block Mode
	 */

	class Block extends Mode {
	  constructor(ctx, unpad) {
	    super(ctx);

	    this.padding = true;
	    this.unpad = unpad;
	    this.block = Buffer.alloc(this.blockSize);
	    this.blockPos = -1;
	    this.last = null;
	    this.lastSize = 0;

	    if (unpad)
	      this.last = Buffer.alloc(this.blockSize);
	  }

	  init(key, iv) {
	    if (iv == null)
	      iv = EMPTY;

	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));

	    this.ctx.init(key);

	    this.blockPos = 0;
	    this.lastSize = 0;

	    this._init(key, iv);

	    return this;
	  }

	  _updateSize(ilen) {
	    if (this.blockPos + ilen < this.blockSize)
	      return 0;

	    let olen = 0;

	    if (this.unpad)
	      olen += this.lastSize;

	    if (this.blockPos > 0) {
	      ilen -= this.blockSize - this.blockPos;
	      olen += this.blockSize;
	    }

	    if (ilen >= this.blockSize)
	      olen += ilen - (ilen % this.blockSize);

	    assert(olen >= this.blockSize);

	    return olen;
	  }

	  update(input) {
	    assert(Buffer.isBuffer(input));

	    if (this.blockPos === -1)
	      throw new Error('Cipher is not initialized.');

	    const olen = this._updateSize(input.length);
	    const output = Buffer.alloc(olen);

	    if (this.blockPos + input.length < this.blockSize) {
	      this.blockPos += input.copy(this.block, this.blockPos, 0, input.length);
	      return output;
	    }

	    let ilen = input.length;
	    let ipos = 0;
	    let opos = 0;

	    if (this.unpad)
	      opos += this.last.copy(output, opos, 0, this.lastSize);

	    if (this.blockPos > 0) {
	      const want = this.blockSize - this.blockPos;

	      ipos += input.copy(this.block, this.blockPos, ipos, ipos + want);
	      ilen -= want;

	      this._update(output, opos, this.block, 0);

	      opos += this.blockSize;

	      this.blockPos = 0;
	    }

	    while (ilen >= this.blockSize) {
	      this._update(output, opos, input, ipos);

	      ipos += this.blockSize;
	      ilen -= this.blockSize;
	      opos += this.blockSize;
	    }

	    if (ilen > 0)
	      this.blockPos = input.copy(this.block, 0, ipos, ipos + ilen);

	    assert(opos === olen);

	    if (this.unpad) {
	      this.lastSize = output.copy(this.last, 0, olen - this.blockSize, olen);
	      return output.slice(0, olen - this.blockSize);
	    }

	    return output;
	  }

	  crypt(output, input) {
	    assert(Buffer.isBuffer(output));
	    assert(Buffer.isBuffer(input));
	    assert(output.length === input.length);

	    if (this.blockPos === -1)
	      throw new Error('Cipher is not initialized.');

	    if (this.unpad || this.blockPos !== 0)
	      throw new Error('Cannot crypt while buffering.');

	    if ((input.length % this.blockSize) !== 0)
	      throw new Error('Input must be a multiple of the block size.');

	    const size = this.blockSize;

	    let len = input.length;
	    let pos = 0;

	    while (len > 0) {
	      this._update(output, pos, input, pos);
	      pos += size;
	      len -= size;
	    }

	    return output;
	  }

	  final() {
	    if (this.blockPos === -1)
	      throw new Error('Cipher is not initialized.');

	    try {
	      return this._final();
	    } finally {
	      this.destroy();
	    }
	  }

	  destroy() {
	    this.ctx.destroy();

	    this.blockPos = -1;
	    this.lastSize = 0;

	    for (let i = 0; i < this.blockSize; i++)
	      this.block[i] = 0;

	    if (this.unpad) {
	      for (let i = 0; i < this.blockSize; i++)
	        this.last[i] = 0;
	    }

	    this._destroy();

	    return this;
	  }

	  _init(key, iv) {
	    throw new Error('Not implemented.');
	  }

	  _update(output, opos, input, ipos) {
	    throw new Error('Not implemented.');
	  }

	  _final() {
	    throw new Error('Not implemented.');
	  }

	  _destroy() {
	    throw new Error('Not implemented.');
	  }
	}

	/*
	 * Stream Mode
	 */

	class Stream extends Mode {
	  constructor(ctx) {
	    super(ctx);
	    this.pos = -1;
	  }

	  init(key, iv) {
	    if (iv == null)
	      iv = EMPTY;

	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));

	    this.ctx.init(key);

	    this.pos = 0;

	    this._init(key, iv);

	    return this;
	  }

	  update(input) {
	    assert(Buffer.isBuffer(input));

	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    const output = Buffer.alloc(input.length);

	    this._crypt(output, input);

	    return output;
	  }

	  crypt(output, input) {
	    assert(Buffer.isBuffer(output));
	    assert(Buffer.isBuffer(input));
	    assert(output.length === input.length);

	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    this._crypt(output, input);

	    return output;
	  }

	  final() {
	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    try {
	      return this._final();
	    } finally {
	      this.destroy();
	    }
	  }

	  destroy() {
	    this.ctx.destroy();

	    this.pos = -1;

	    this._destroy();

	    return this;
	  }

	  _init(key, iv) {
	    throw new Error('Not implemented.');
	  }

	  _crypt(output, input) {
	    throw new Error('Not implemented.');
	  }

	  _final() {
	    throw new Error('Not implemented.');
	  }

	  _destroy() {
	    throw new Error('Not implemented.');
	  }
	}

	/**
	 * Raw Cipher
	 */

	class RawCipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }

	  _init(key, iv) {
	    assert(iv.length === 0);
	  }

	  _update(output, opos, input, ipos) {
	    this.ctx.encrypt(output, opos, input, ipos);
	  }

	  _final() {
	    if (this.blockPos !== 0)
	      throw new Error('Bad encrypt (trailing bytes).');

	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    return;
	  }
	}

	/**
	 * Raw Decipher
	 */

	class RawDecipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }

	  _init(key, iv) {
	    assert(iv.length === 0);
	  }

	  _update(output, opos, input, ipos) {
	    this.ctx.decrypt(output, opos, input, ipos);
	  }

	  _final() {
	    if (this.blockPos !== 0)
	      throw new Error('Bad decrypt (trailing bytes).');

	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    return;
	  }
	}

	/**
	 * PKCS#7 Cipher
	 */

	class PKCS7Cipher extends Block {
	  constructor(ctx) {
	    super(ctx, false);
	  }

	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0)
	        throw new Error('Bad encrypt (trailing bytes).');

	      return Buffer.alloc(0);
	    }

	    const left = this.blockSize - this.blockPos;
	    const block = Buffer.from(this.block);

	    for (let i = this.blockPos; i < this.blockSize; i++)
	      block[i] = left;

	    this._update(block, 0, block, 0);

	    return block;
	  }

	  _setAutoPadding(padding) {
	    this.padding = padding;
	  }
	}

	/**
	 * PKCS#7 Decipher
	 */

	class PKCS7Decipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);
	  }

	  _final() {
	    if (this.blockPos !== 0)
	      throw new Error('Bad decrypt (trailing bytes).');

	    if (!this.padding)
	      return Buffer.alloc(0);

	    if (this.lastSize === 0)
	      throw new Error('Bad decrypt (no data).');

	    assert(this.lastSize === this.last.length);
	    assert(this.lastSize === this.blockSize);

	    const block = Buffer.from(this.last);

	    let left = block[block.length - 1];
	    let res = 1;

	    // left != 0
	    res &= ((left - 1) >>> 31) ^ 1;

	    // left <= block_size
	    res &= (left - this.blockSize - 1) >>> 31;

	    // left = 0 if left == 0 or left > block_size
	    left &= -res;

	    // Verify padding in constant time.
	    const end = this.blockSize - left;

	    for (let i = 0; i < this.blockSize; i++) {
	      const ch = block[i];

	      // i < end or ch == left
	      res &= ((i - end) >>> 31) | (((ch ^ left) - 1) >>> 31);
	    }

	    if (!res)
	      throw new Error('Bad decrypt (padding).');

	    return block.slice(0, end);
	  }

	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0)
	      throw new Error('Cannot set auto padding.');

	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * ECB Cipher
	 */

	class ECBCipher extends PKCS7Cipher {
	  constructor(ctx) {
	    super(ctx);
	  }

	  _init(key, iv) {
	    assert(iv.length === 0);
	  }

	  _update(output, opos, input, ipos) {
	    this.ctx.encrypt(output, opos, input, ipos);
	  }

	  _destroy() {
	    return;
	  }
	}

	/**
	 * ECB Decipher
	 */

	class ECBDecipher extends PKCS7Decipher {
	  constructor(ctx) {
	    super(ctx);
	  }

	  _init(key, iv) {
	    assert(iv.length === 0);
	  }

	  _update(output, opos, input, ipos) {
	    this.ctx.decrypt(output, opos, input, ipos);
	  }

	  _destroy() {
	    return;
	  }
	}

	/**
	 * CBC Cipher
	 */

	class CBCCipher extends PKCS7Cipher {
	  constructor(ctx) {
	    super(ctx);

	    this.prev = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }

	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++)
	      this.prev[i] ^= input[ipos + i];

	    this.ctx.encrypt(output, opos, this.prev, 0);

	    output.copy(this.prev, 0, opos, opos + this.blockSize);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++)
	      this.prev[i] = 0;
	  }
	}

	/**
	 * CBC Decipher
	 */

	class CBCDecipher extends PKCS7Decipher {
	  constructor(ctx) {
	    super(ctx);

	    this.prev = Buffer.alloc(this.blockSize);
	    this.tmp = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }

	  _update(output, opos, input, ipos) {
	    if (overlap(output, opos, input, ipos)) {
	      this.prev.copy(this.tmp, 0);

	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);

	      this.ctx.decrypt(output, opos, input, ipos);

	      for (let i = 0; i < this.blockSize; i++)
	        output[opos + i] ^= this.tmp[i];
	    } else {
	      this.ctx.decrypt(output, opos, input, ipos);

	      for (let i = 0; i < this.blockSize; i++)
	        output[opos + i] ^= this.prev[i];

	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	    }
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.prev[i] = 0;
	      this.tmp[i] = 0;
	    }
	  }
	}

	/**
	 * CTS Cipher
	 */

	class CTSCipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);

	    this.prev = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }

	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++)
	      this.prev[i] ^= input[ipos + i];

	    this.ctx.encrypt(output, opos, this.prev, 0);

	    output.copy(this.prev, 0, opos, opos + this.blockSize);
	  }

	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0)
	        throw new Error('Bad encrypt (trailing bytes).');

	      return Buffer.alloc(0);
	    }

	    if (this.lastSize === 0)
	      throw new Error('Bad encrypt (no data).');

	    for (let i = 0; i < this.blockPos; i++)
	      this.prev[i] ^= this.block[i];

	    this.ctx.encrypt(this.prev, 0, this.prev, 0);

	    const last = this.last.slice(0, this.blockPos);

	    return Buffer.concat([this.prev, last]);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++)
	      this.prev[i] = 0;
	  }

	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0)
	      throw new Error('Cannot set auto padding.');

	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * CTS Decipher
	 */

	class CTSDecipher extends Block {
	  constructor(ctx) {
	    super(ctx, true);

	    this.prev = Buffer.alloc(this.blockSize);
	    this.tmp = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);
	    iv.copy(this.prev, 0);
	  }

	  _update(output, opos, input, ipos) {
	    if (overlap(output, opos, input, ipos)) {
	      this.prev.copy(this.tmp, 0);

	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);

	      this.ctx.decrypt(output, opos, input, ipos);

	      for (let i = 0; i < this.blockSize; i++)
	        output[opos + i] ^= this.tmp[i];
	    } else {
	      this.ctx.decrypt(output, opos, input, ipos);

	      for (let i = 0; i < this.blockSize; i++)
	        output[opos + i] ^= this.prev[i];

	      input.copy(this.prev, 0, ipos, ipos + this.blockSize);
	    }
	  }

	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0)
	        throw new Error('Bad decrypt (trailing bytes).');

	      return Buffer.alloc(0);
	    }

	    if (this.lastSize === 0)
	      throw new Error('Bad decrypt (no data).');

	    const tmp = Buffer.alloc(this.blockSize);

	    this.ctx.decrypt(this.prev, 0, this.prev, 0);

	    // Recreate the previous (x2) ciphertext (`this.tmp`),
	    // which is normally only available on overlap.
	    for (let i = 0; i < this.blockSize; i++)
	      tmp[i] = this.last[i] ^ this.prev[i];

	    for (let i = 0; i < this.blockPos; i++) {
	      this.last[i] = this.block[i];
	      this.block[i] ^= this.prev[i];
	    }

	    for (let i = this.blockPos; i < this.blockSize; i++)
	      this.last[i] = this.prev[i];

	    this.ctx.decrypt(this.last, 0, this.last, 0);

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= tmp[i];

	    const block = this.block.slice(0, this.blockPos);

	    return Buffer.concat([this.last, block]);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.prev[i] = 0;
	      this.tmp[i] = 0;
	    }
	  }

	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0)
	      throw new Error('Cannot set auto padding.');

	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/**
	 * XTS
	 */

	class XTS extends Block {
	  constructor(ctx, encrypt) {
	    super(ctx, true);

	    this.encrypt = encrypt;
	    this.poly = polyTable[this.blockSize >>> 4];
	    this.tweak = Buffer.alloc(this.blockSize);
	    this.prev = Buffer.alloc(this.blockSize);
	  }

	  init(key, iv) {
	    assert(Buffer.isBuffer(key));
	    assert(Buffer.isBuffer(iv));
	    assert(key.length > 0 && (key.length & 1) === 0);
	    assert(iv.length === this.blockSize);

	    const size = key.length >>> 1;
	    const k1 = key.slice(0, size);
	    const k2 = key.slice(size);

	    if (safeEqual(k1, k2, size))
	      throw new Error('XTS keys are equal.');

	    this.ctx.init(k2);
	    this.ctx.encrypt(this.tweak, 0, iv, 0);

	    this.ctx.init(k1);

	    this.blockPos = 0;
	    this.lastSize = 0;

	    return this;
	  }

	  _shift() {
	    let cy = 0;

	    if (!this.encrypt)
	      this.tweak.copy(this.prev, 0);

	    for (let i = 0; i < this.blockSize; i++) {
	      const c = this.tweak[i] >> 7;

	      this.tweak[i] <<= 1;
	      this.tweak[i] |= cy;

	      cy = c;
	    }

	    cy = -cy & 0xff;

	    this.tweak[2] ^= (this.poly >> 16) & cy;
	    this.tweak[1] ^= (this.poly >>  8) & cy;
	    this.tweak[0] ^= (this.poly >>  0) & cy;
	  }

	  _update(output, opos, input, ipos) {
	    for (let i = 0; i < this.blockSize; i++)
	      output[opos + i] = input[ipos + i] ^ this.tweak[i];

	    if (this.encrypt)
	      this.ctx.encrypt(output, opos, output, opos);
	    else
	      this.ctx.decrypt(output, opos, output, opos);

	    for (let i = 0; i < this.blockSize; i++)
	      output[opos + i] ^= this.tweak[i];

	    this._shift();
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.tweak[i] = 0;
	      this.prev[i] = 0;
	    }
	  }

	  _setAutoPadding(padding) {
	    if (this.lastSize !== 0 || this.blockPos !== 0)
	      throw new Error('Cannot set auto padding.');

	    this.padding = padding;
	    this.unpad = padding;
	  }
	}

	/*
	 * XTS Cipher
	 */

	class XTSCipher extends XTS {
	  constructor(ctx) {
	    super(ctx, true);
	  }

	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0)
	        throw new Error('Bad encrypt (trailing bytes).');

	      return Buffer.alloc(0);
	    }

	    if (this.lastSize === 0)
	      throw new Error('Bad encrypt (no data).');

	    if (this.blockPos === 0)
	      return Buffer.from(this.last);

	    // Use ciphertext stealing for partial blocks.
	    const out = Buffer.alloc(this.blockPos);

	    for (let i = 0; i < this.blockPos; i++) {
	      out[i] = this.last[i];

	      this.last[i] = this.block[i];
	    }

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.tweak[i];

	    this.ctx.encrypt(this.last, 0, this.last, 0);

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.tweak[i];

	    return Buffer.concat([this.last, out]);
	  }
	}

	/*
	 * XTS Decipher
	 */

	class XTSDecipher extends XTS {
	  constructor(ctx) {
	    super(ctx, false);
	  }

	  _final() {
	    if (!this.padding) {
	      if (this.blockPos !== 0)
	        throw new Error('Bad decrypt (trailing bytes).');

	      return Buffer.alloc(0);
	    }

	    if (this.lastSize === 0)
	      throw new Error('Bad decrypt (no data).');

	    if (this.blockPos === 0)
	      return Buffer.from(this.last);

	    // Undo Block mode object's behavior of
	    // running _update on the last full block.
	    // Could avoid this somehow in the future.
	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.prev[i];

	    this.ctx.encrypt(this.last, 0, this.last, 0);

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.prev[i];

	    // Recreate the last partial plaintext
	    // block (out) and the last ciphertext
	    // block (last).
	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.tweak[i];

	    this.ctx.decrypt(this.last, 0, this.last, 0);

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.tweak[i];

	    const out = Buffer.alloc(this.blockPos);

	    for (let i = 0; i < this.blockPos; i++) {
	      out[i] = this.last[i];

	      this.last[i] = this.block[i];
	    }

	    // Now decrypt the last ciphertext block.
	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.prev[i];

	    this.ctx.decrypt(this.last, 0, this.last, 0);

	    for (let i = 0; i < this.blockSize; i++)
	      this.last[i] ^= this.prev[i];

	    return Buffer.concat([this.last, out]);
	  }
	}

	/**
	 * CTR
	 */

	class CTR extends Stream {
	  constructor(ctx) {
	    super(ctx);

	    this.state = Buffer.alloc(this.blockSize);
	    this.ctr = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);

	    iv.copy(this.ctr, 0);
	  }

	  _increment() {
	    for (let i = this.ctr.length - 1; i >= 0; i--) {
	      this.ctr[i] += 1;

	      if (this.ctr[i] !== 0x00)
	        break;
	    }
	  }

	  _crypt(output, input) {
	    const mask = this.blockSize - 1;

	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }

	  _final() {
	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	    }
	  }
	}

	/**
	 * CTR Cipher
	 */

	class CTRCipher extends CTR {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * CTR Decipher
	 */

	class CTRDecipher extends CTR {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * CFB
	 */

	class CFB extends Stream {
	  constructor(ctx) {
	    super(ctx);

	    this.state = Buffer.alloc(this.blockSize);
	    this.prev = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(iv.length === this.blockSize);

	    iv.copy(this.prev, 0);
	  }

	  _final() {
	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.prev[i] = 0;
	    }
	  }
	}

	/**
	 * CFB Cipher
	 */

	class CFBCipher extends CFB {
	  constructor(ctx) {
	    super(ctx);
	  }

	  _crypt(output, input) {
	    const mask = this.blockSize - 1;

	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.prev, 0);
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos];

	      this.prev[this.pos] = output[i];

	      this.pos += 1;
	    }
	  }
	}

	/**
	 * CFB Decipher
	 */

	class CFBDecipher extends CFB {
	  constructor(ctx) {
	    super(ctx);
	  }

	  _crypt(output, input) {
	    const mask = this.blockSize - 1;

	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.prev, 0);
	        this.pos = 0;
	      }

	      this.prev[this.pos] = input[i];

	      output[i] = input[i] ^ this.state[this.pos];

	      this.pos += 1;
	    }
	  }
	}

	/**
	 * OFB
	 */

	class OFB extends Stream {
	  constructor(ctx) {
	    super(ctx);

	    this.state = Buffer.alloc(this.blockSize);
	  }

	  _init(key, iv) {
	    assert(Buffer.isBuffer(iv));
	    assert(iv.length === this.blockSize);

	    iv.copy(this.state, 0);
	  }

	  _crypt(output, input) {
	    const mask = this.blockSize - 1;

	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.state, 0);
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }

	  _final() {
	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++)
	      this.state[i] = 0;
	  }
	}

	/**
	 * OFB Cipher
	 */

	class OFBCipher extends OFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * OFB Decipher
	 */

	class OFBDecipher extends OFB {
	  constructor(ctx) {
	    super(ctx);
	  }
	}

	/**
	 * GCM
	 */

	class GCM extends Stream {
	  constructor(ctx, encrypt) {
	    assert(ctx.blockSize === 16);

	    super(ctx);

	    this.encrypt = encrypt;
	    this.hash = new GHASH();
	    this.ctr = Buffer.alloc(16);
	    this.state = Buffer.alloc(16);
	    this.key = Buffer.alloc(16);
	    this.mask = Buffer.alloc(16);
	    this.tag = null;
	    this.mac = null;
	  }

	  _init(key, iv) {
	    for (let i = 0; i < 16; i++) {
	      this.ctr[i] = 0;
	      this.key[i] = 0;
	      this.mask[i] = 0;
	    }

	    this._encipher(this.key, this.key);

	    this.hash.init(this.key);

	    // Full round of ghash with same key.
	    if (iv.length !== 12) {
	      this.hash.update(iv);
	      iv = this.hash.final();
	      this.hash.init(this.key);
	    }

	    iv.copy(this.ctr, 0);

	    if (iv.length === 12) {
	      this.ctr[12] = 0x00;
	      this.ctr[13] = 0x00;
	      this.ctr[14] = 0x00;
	      this.ctr[15] = 0x01;
	    }

	    this._encipher(this.mask, this.mask);

	    this.tag = null;
	    this.mac = null;

	    return this;
	  }

	  _increment() {
	    let cy = 1;
	    let i = 4;

	    while (i--) {
	      cy += this.ctr[12 + i];
	      this.ctr[12 + i] = cy;
	      cy >>= 8;
	    }
	  }

	  _encipher(output, input) {
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & 15) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }

	  _crypt(output, input) {
	    if (this.encrypt) {
	      this._encipher(output, input);
	      this.hash.update(output);
	    } else {
	      this.hash.update(input);
	      this._encipher(output, input);
	    }
	  }

	  _final() {
	    const mac = this.hash.final();

	    for (let i = 0; i < 16; i++)
	      mac[i] ^= this.mask[i];

	    if (this.encrypt) {
	      this.mac = mac;
	      return Buffer.alloc(0);
	    }

	    if (!this.tag)
	      throw new Error('No tag provided.');

	    if (!safeEqual(mac, this.tag, this.tag.length))
	      throw new Error('Invalid tag.');

	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    this.hash.destroy();

	    for (let i = 0; i < 16; i++) {
	      this.ctr[i] = 0;
	      this.state[i] = 0;
	      this.key[i] = 0;
	      this.mask[i] = 0;
	    }

	    if (this.tag) {
	      for (let i = 0; i < this.tag.length; i++)
	        this.tag[i] = 0;

	      this.tag = null;
	    }
	  }

	  _setAAD(data) {
	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    this.hash.aad(data);

	    return this;
	  }

	  _getAuthTag() {
	    if (!this.encrypt)
	      throw new Error('Must be a cipher context.');

	    if (!this.mac)
	      throw new Error('Cipher is not finalized.');

	    return Buffer.from(this.mac);
	  }

	  _setAuthTag(tag) {
	    if (this.encrypt)
	      throw new Error('Must be a decipher context.');

	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    if (tag.length !== 4 && tag.length !== 8
	        && (tag.length < 12 || tag.length > 16)) {
	      throw new RangeError('Invalid tag size.');
	    }

	    this.tag = Buffer.from(tag);

	    return this;
	  }
	}

	/**
	 * GCM Cipher
	 */

	class GCMCipher extends GCM {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * GCM Decipher
	 */

	class GCMDecipher extends GCM {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/**
	 * CBC-MAC
	 */

	class CBCMAC {
	  constructor(ctx) {
	    this.ctx = ctx;
	    this.size = ctx.blockSize;
	    this.mac = Buffer.alloc(this.size);
	    this.pos = -1;
	  }

	  init() {
	    this.mac.fill(0);
	    this.pos = 0;
	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));

	    if (this.pos === -1)
	      throw new Error('Context is not initialized.');

	    for (let i = 0; i < data.length; i++) {
	      this.mac[this.pos++] ^= data[i];

	      if (this.pos === this.size) {
	        this.ctx.encrypt(this.mac, 0, this.mac, 0);
	        this.pos = 0;
	      }
	    }
	  }

	  pad() {
	    if (this.pos > 0) {
	      this.ctx.encrypt(this.mac, 0, this.mac, 0);
	      this.pos = 0;
	    }
	  }

	  final() {
	    if (this.pos === -1)
	      throw new Error('Context is not initialized.');

	    this.pad();
	    this.pos = -1;

	    return Buffer.from(this.mac);
	  }
	}

	/**
	 * CCM
	 * https://tools.ietf.org/html/rfc3610
	 */

	class CCM extends Stream {
	  constructor(ctx, encrypt) {
	    assert(ctx.blockSize === 16);

	    super(ctx);

	    this.encrypt = encrypt;
	    this.hash = new CBCMAC(ctx);
	    this.state = Buffer.alloc(16);
	    this.ctr = Buffer.alloc(16);
	    this.tagLen = 0;
	    this.iv = null;
	    this.mac = null;
	    this.tag = null;
	  }

	  _increment() {
	    for (let i = 15; i >= 1; i--) {
	      this.ctr[i] += 1;

	      if (this.ctr[i] !== 0x00)
	        break;
	    }
	  }

	  _encipher(output, input) {
	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & 15) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }

	  _init(key, iv) {
	    // sjcl compat: no upper limit on l(N).
	    if (iv.length < 7)
	      throw new RangeError('Invalid nonce length.');

	    if (iv.length > 13)
	      iv = iv.slice(0, 13);

	    this.iv = Buffer.from(iv);
	    this.pos = -1;
	    this.tagLen = 0;
	    this.mac = null;
	    this.tag = null;
	  }

	  _setCCM(msgLen, tagLen, aad) {
	    if (!this.iv)
	      throw new Error('Cipher is not initialized.');

	    // Compute L, M, and N.
	    let lm = msgLen;
	    let L = Math.ceil((32 - Math.clz32(lm)) / 8);

	    if (L < 2)
	      L = 2;

	    const M = tagLen;
	    const N = 15 - L;
	    const Adata = (aad && aad.length > 0) | 0;
	    const block = Buffer.alloc(16);

	    if (M < 4 || M > 16 || (M & 1) !== 0)
	      throw new RangeError('Invalid tag length.');

	    // Compute flags.
	    block[0] = 64 * Adata + 8 * ((M - 2) / 2) + (L - 1);

	    // sjcl compat: clamp nonces to 15-L.
	    this.iv.copy(block, 1, 0, Math.min(N, this.iv.length));

	    // Serialize message length.
	    for (let i = 15; i >= 1 + N; i--) {
	      block[i] = lm & 0xff;
	      lm >>>= 8;
	    }

	    assert(lm === 0);

	    this.hash.init();
	    this.hash.update(block);

	    if (Adata) {
	      if (aad.length < 0xff00) {
	        const buf = Buffer.alloc(2);

	        buf[0] = aad.length >>> 8;
	        buf[1] = aad.length >>> 0;

	        this.hash.update(buf);
	      } else if (aad.length < 0xffffffff) {
	        const buf = Buffer.alloc(6);

	        buf[0] = 0xff;
	        buf[1] = 0xfe;
	        buf[2] = aad.length >>> 24;
	        buf[3] = aad.length >>> 16;
	        buf[4] = aad.length >>> 8;
	        buf[5] = aad.length >>> 0;

	        this.hash.update(buf);
	      } else {
	        throw new RangeError('Invalid AAD length.');
	      }

	      this.hash.update(aad);
	      this.hash.pad();
	    }

	    block[0] &= 7;
	    block[15] = 1;

	    for (let i = 14; i >= 1 + N; i--)
	      block[i] = 0;

	    block.copy(this.ctr, 0);

	    this.pos = 0;
	    this.tagLen = M;
	    this.iv = null;
	  }

	  _crypt(output, input) {
	    if (this.encrypt) {
	      this.hash.update(input);
	      this._encipher(output, input);
	    } else {
	      this._encipher(output, input);
	      this.hash.update(output);
	    }
	  }

	  _final() {
	    const mac = this.hash.final();

	    // Recreate S_0.
	    let i = 16 - ((this.ctr[0] & 7) + 1);

	    while (i < 16)
	      this.ctr[i++] = 0;

	    this.pos = 0;
	    this._encipher(mac, mac);

	    if (this.encrypt) {
	      this.mac = mac.slice(0, this.tagLen);
	      return Buffer.alloc(0);
	    }

	    if (!this.tag)
	      throw new Error('No tag provided.');

	    if (!safeEqual(mac, this.tag, this.tagLen))
	      throw new Error('Invalid tag.');

	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    for (let i = 0; i < 16; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	    }

	    this.tagLen = 0;
	    this.iv = null;
	    this.tag = null;
	  }

	  _getAuthTag() {
	    if (!this.encrypt)
	      throw new Error('Must be a cipher context.');

	    if (!this.mac)
	      throw new Error('Cipher is not finalized.');

	    return Buffer.from(this.mac);
	  }

	  _setAuthTag(tag) {
	    if (this.encrypt)
	      throw new Error('Must be a decipher context.');

	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    if (this.tagLen === 0 || tag.length !== this.tagLen)
	      throw new RangeError('Invalid tag size.');

	    this.tag = Buffer.from(tag);

	    return this;
	  }
	}

	/**
	 * CCM Cipher
	 */

	class CCMCipher extends CCM {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * CCM Decipher
	 */

	class CCMDecipher extends CCM {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/**
	 * CMAC
	 * https://tools.ietf.org/html/rfc4493
	 */

	class CMAC {
	  constructor(ctx) {
	    this.ctx = ctx;
	    this.poly = polyTable[ctx.blockSize >>> 4];
	    this.size = ctx.blockSize;
	    this.mac = Buffer.alloc(this.size);
	    this.pos = -1;
	  }

	  init(flag) {
	    this.mac.fill(0);
	    this.pos = 0;

	    if (flag != null) {
	      this.mac[this.size - 1] ^= flag;
	      this.pos = this.size;
	    }

	    return this;
	  }

	  shift(dst, src) {
	    let cy = 0;

	    for (let i = this.size - 1; i >= 0; i--) {
	      const c = src[i] >> 7;

	      dst[i] = (src[i] << 1) | cy;

	      cy = c;
	    }

	    cy = -cy & 0xff;

	    dst[this.size - 3] ^= (this.poly >> 16) & cy;
	    dst[this.size - 2] ^= (this.poly >>  8) & cy;
	    dst[this.size - 1] ^= (this.poly >>  0) & cy;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));

	    if (this.pos === -1)
	      throw new Error('Context is not initialized.');

	    for (let i = 0; i < data.length; i++) {
	      if (this.pos === this.size) {
	        this.ctx.encrypt(this.mac, 0, this.mac, 0);
	        this.pos = 0;
	      }

	      this.mac[this.pos++] ^= data[i];
	    }
	  }

	  final() {
	    if (this.pos === -1)
	      throw new Error('Context is not initialized.');

	    const k = Buffer.alloc(this.size);

	    this.ctx.encrypt(k, 0, k, 0);

	    this.shift(k, k);

	    if (this.pos < this.size) {
	      this.mac[this.pos] ^= 0x80;
	      this.shift(k, k);
	    }

	    for (let i = 0; i < this.size; i++)
	      this.mac[i] ^= k[i];

	    this.ctx.encrypt(this.mac, 0, this.mac, 0);

	    this.pos = -1;

	    return Buffer.from(this.mac);
	  }
	}

	/**
	 * EAX
	 */

	class EAX extends Stream {
	  constructor(ctx, encrypt) {
	    super(ctx);

	    this.encrypt = encrypt;
	    this.hash1 = new CMAC(ctx);
	    this.hash2 = new CMAC(ctx);
	    this.state = Buffer.alloc(this.blockSize);
	    this.ctr = Buffer.alloc(this.blockSize);
	    this.mask = Buffer.alloc(this.blockSize);
	    this.mac = null;
	    this.tag = null;
	  }

	  _increment() {
	    let i = this.blockSize;
	    let cy = 1;

	    while (i--) {
	      cy += this.ctr[i];
	      this.ctr[i] = cy;
	      cy >>= 8;
	    }
	  }

	  _encipher(output, input) {
	    const mask = this.blockSize - 1;

	    for (let i = 0; i < input.length; i++) {
	      if ((this.pos & mask) === 0) {
	        this.ctx.encrypt(this.state, 0, this.ctr, 0);
	        this._increment();
	        this.pos = 0;
	      }

	      output[i] = input[i] ^ this.state[this.pos++];
	    }
	  }

	  _init(key, iv) {
	    assert(iv.length > 0);

	    this.hash1.init(0);
	    this.hash1.update(iv);

	    this.mask = this.hash1.final();
	    this.mask.copy(this.ctr, 0);

	    this.hash1.init(1);
	    this.hash2.init(2);

	    this.mac = null;
	    this.tag = null;
	  }

	  _crypt(output, input) {
	    if (this.encrypt) {
	      this._encipher(output, input);
	      this.hash2.update(output);
	    } else {
	      this.hash2.update(input);
	      this._encipher(output, input);
	    }
	  }

	  _final() {
	    const mac = Buffer.alloc(this.blockSize);
	    const mac1 = this.hash1.final();
	    const mac2 = this.hash2.final();

	    for (let i = 0; i < this.blockSize; i++)
	      mac[i] = mac1[i] ^ mac2[i] ^ this.mask[i];

	    if (this.encrypt) {
	      this.mac = mac;
	      return Buffer.alloc(0);
	    }

	    if (!this.tag)
	      throw new Error('No tag provided.');

	    if (!safeEqual(mac, this.tag, this.tag.length))
	      throw new Error('Invalid tag.');

	    return Buffer.alloc(0);
	  }

	  _destroy() {
	    for (let i = 0; i < this.blockSize; i++) {
	      this.state[i] = 0;
	      this.ctr[i] = 0;
	      this.mask[i] = 0;
	    }

	    this.tag = null;
	  }

	  _setAAD(data) {
	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    this.hash1.update(data);

	    return this;
	  }

	  _getAuthTag() {
	    if (!this.encrypt)
	      throw new Error('Must be a cipher context.');

	    if (!this.mac)
	      throw new Error('Cipher is not finalized.');

	    return Buffer.from(this.mac);
	  }

	  _setAuthTag(tag) {
	    if (this.encrypt)
	      throw new Error('Must be a decipher context.');

	    if (this.pos === -1)
	      throw new Error('Cipher is not initialized.');

	    if (tag.length === 0 || tag.length > this.blockSize)
	      throw new RangeError('Invalid tag size.');

	    this.tag = Buffer.from(tag);

	    return this;
	  }
	}

	/**
	 * EAX Cipher
	 */

	class EAXCipher extends EAX {
	  constructor(ctx) {
	    super(ctx, true);
	  }
	}

	/**
	 * EAX Decipher
	 */

	class EAXDecipher extends EAX {
	  constructor(ctx) {
	    super(ctx, false);
	  }
	}

	/*
	 * Helpers
	 */

	function get(name, encrypt = true) {
	  assert(typeof name === 'string');
	  assert(typeof encrypt === 'boolean');

	  switch (name) {
	    case 'RAW':
	      return encrypt ? RawCipher : RawDecipher;
	    case 'ECB':
	      return encrypt ? ECBCipher : ECBDecipher;
	    case 'CBC':
	      return encrypt ? CBCCipher : CBCDecipher;
	    case 'CTS':
	      return encrypt ? CTSCipher : CTSDecipher;
	    case 'XTS':
	      return encrypt ? XTSCipher : XTSDecipher;
	    case 'CTR':
	      return encrypt ? CTRCipher : CTRDecipher;
	    case 'CFB':
	      return encrypt ? CFBCipher : CFBDecipher;
	    case 'OFB':
	      return encrypt ? OFBCipher : OFBDecipher;
	    case 'GCM':
	      return encrypt ? GCMCipher : GCMDecipher;
	    case 'CCM':
	      return encrypt ? CCMCipher : CCMDecipher;
	    case 'EAX':
	      return encrypt ? EAXCipher : EAXDecipher;
	    default:
	      throw new Error(`Unknown mode: ${name}.`);
	  }
	}

	function overlap(output, opos, input, ipos) {
	  return output.buffer === input.buffer
	      && output.byteOffset === input.byteOffset
	      && opos === ipos;
	}

	function safeEqual(x, y, len) {
	  let z = 0;

	  for (let i = 0; i < len; i++)
	    z |= x[i] ^ y[i];

	  return (z - 1) >>> 31;
	}

	/*
	 * Expose
	 */

	modes.Mode = Mode;
	modes.Block = Block;
	modes.Stream = Stream;
	modes.RawCipher = RawCipher;
	modes.RawDecipher = RawDecipher;
	modes.PKCS7Cipher = PKCS7Cipher;
	modes.PKCS7Decipher = PKCS7Decipher;
	modes.ECBCipher = ECBCipher;
	modes.ECBDecipher = ECBDecipher;
	modes.CBCCipher = CBCCipher;
	modes.CBCDecipher = CBCDecipher;
	modes.CTSCipher = CTSCipher;
	modes.CTSDecipher = CTSDecipher;
	modes.XTS = XTS;
	modes.XTSCipher = XTSCipher;
	modes.XTSDecipher = XTSDecipher;
	modes.CTR = CTR;
	modes.CTRCipher = CTRCipher;
	modes.CTRDecipher = CTRDecipher;
	modes.CFB = CFB;
	modes.CFBCipher = CFBCipher;
	modes.CFBDecipher = CFBDecipher;
	modes.OFB = OFB;
	modes.OFBCipher = OFBCipher;
	modes.OFBDecipher = OFBDecipher;
	modes.GCM = GCM;
	modes.GCMCipher = GCMCipher;
	modes.GCMDecipher = GCMDecipher;
	modes.CBCMAC = CBCMAC;
	modes.CCM = CCM;
	modes.CCMCipher = CCMCipher;
	modes.CCMDecipher = CCMDecipher;
	modes.CMAC = CMAC;
	modes.EAX = EAX;
	modes.EAXCipher = EAXCipher;
	modes.EAXDecipher = EAXDecipher;
	modes.get = get;
	return modes;
}

/*!
 * aes.js - aes128/192/256 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredAes;

function requireAes () {
	if (hasRequiredAes) return aes$1;
	hasRequiredAes = 1;

	const AES = requireAes$1();
	const {CBCCipher, CBCDecipher} = requireModes();

	/**
	 * Encrypt data with aes 256 cbc.
	 * @param {Buffer} data
	 * @param {Buffer} key
	 * @param {Buffer} iv
	 * @returns {Buffer}
	 */

	function encipher(data, key, iv) {
	  const ctx = new CBCCipher(new AES(256));
	  ctx.init(key, iv);
	  return Buffer.concat([ctx.update(data), ctx.final()]);
	}

	/**
	 * Decrypt data with aes 256 cbc.
	 * @param {Buffer} data
	 * @param {Buffer} key
	 * @param {Buffer} iv
	 * @returns {Buffer}
	 */

	function decipher(data, key, iv) {
	  const ctx = new CBCDecipher(new AES(256));
	  ctx.init(key, iv);
	  return Buffer.concat([ctx.update(data), ctx.final()]);
	}

	/*
	 * Expose
	 */

	aes$1.native = 0;
	aes$1.encipher = encipher;
	aes$1.decipher = decipher;
	return aes$1;
}

/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */

var keccak;
var hasRequiredKeccak;

function requireKeccak () {
	if (hasRequiredKeccak) return keccak;
	hasRequiredKeccak = 1;

	const assert = requireAssert();
	const HMAC = requireHmac();

	/*
	 * Constants
	 */

	const FINALIZED = 0x80000000;

	const ROUND_CONST = new Uint32Array([
	  0x00000001, 0x00000000, 0x00008082, 0x00000000,
	  0x0000808a, 0x80000000, 0x80008000, 0x80000000,
	  0x0000808b, 0x00000000, 0x80000001, 0x00000000,
	  0x80008081, 0x80000000, 0x00008009, 0x80000000,
	  0x0000008a, 0x00000000, 0x00000088, 0x00000000,
	  0x80008009, 0x00000000, 0x8000000a, 0x00000000,
	  0x8000808b, 0x00000000, 0x0000008b, 0x80000000,
	  0x00008089, 0x80000000, 0x00008003, 0x80000000,
	  0x00008002, 0x80000000, 0x00000080, 0x80000000,
	  0x0000800a, 0x00000000, 0x8000000a, 0x80000000,
	  0x80008081, 0x80000000, 0x00008080, 0x80000000,
	  0x80000001, 0x00000000, 0x80008008, 0x80000000
	]);

	/**
	 * Keccak
	 */

	class Keccak {
	  constructor() {
	    this.state = new Uint32Array(50);
	    this.block = Buffer.alloc(200);
	    this.bs = 136;
	    this.pos = FINALIZED;
	  }

	  init(bits) {
	    if (bits == null)
	      bits = 256;

	    assert((bits >>> 0) === bits);
	    assert(bits >= 128);
	    assert(bits <= 512);

	    const rate = 1600 - bits * 2;

	    assert(rate >= 0 && (rate & 63) === 0);

	    this.bs = rate >>> 3;
	    this.pos = 0;

	    return this;
	  }

	  update(data) {
	    assert(Buffer.isBuffer(data));
	    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

	    let len = data.length;
	    let pos = this.pos;
	    let off = 0;

	    this.pos = (this.pos + len) % this.bs;

	    if (pos > 0) {
	      let want = this.bs - pos;

	      if (want > len)
	        want = len;

	      data.copy(this.block, pos, off, off + want);

	      pos += want;
	      len -= want;
	      off += want;

	      if (pos < this.bs)
	        return this;

	      this._transform(this.block, 0);
	    }

	    while (len >= this.bs) {
	      this._transform(data, off);
	      off += this.bs;
	      len -= this.bs;
	    }

	    if (len > 0)
	      data.copy(this.block, 0, off, off + len);

	    return this;
	  }

	  final(pad, len) {
	    if (pad == null)
	      pad = 0x01;

	    if (len == null || len === 0)
	      len = 100 - (this.bs >>> 1);

	    assert((pad & 0xff) === pad);
	    assert((len >>> 0) === len);
	    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

	    this.block.fill(0, this.pos, this.bs);
	    this.block[this.pos] |= pad;
	    this.block[this.bs - 1] |= 0x80;
	    this._transform(this.block, 0);
	    this.pos = FINALIZED;

	    assert(len <= this.bs);

	    const out = Buffer.alloc(len);

	    for (let i = 0; i < len; i++)
	      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

	    for (let i = 0; i < 50; i++)
	      this.state[i] = 0;

	    for (let i = 0; i < this.bs; i++)
	      this.block[i] = 0;

	    return out;
	  }

	  _transform(block, off) {
	    const count = this.bs >>> 2;
	    const s = this.state;

	    for (let i = 0; i < count; i++)
	      s[i] ^= readU32(block, off + i * 4);

	    for (let n = 0; n < 48; n += 2) {
	      const c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      const c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      const c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      const c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      const c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      const c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      const c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      const c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      const c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      const c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

	      const h0 = c8 ^ ((c2 << 1) | (c3 >>> 31));
	      const l0 = c9 ^ ((c3 << 1) | (c2 >>> 31));
	      const h1 = c0 ^ ((c4 << 1) | (c5 >>> 31));
	      const l1 = c1 ^ ((c5 << 1) | (c4 >>> 31));
	      const h2 = c2 ^ ((c6 << 1) | (c7 >>> 31));
	      const l2 = c3 ^ ((c7 << 1) | (c6 >>> 31));
	      const h3 = c4 ^ ((c8 << 1) | (c9 >>> 31));
	      const l3 = c5 ^ ((c9 << 1) | (c8 >>> 31));
	      const h4 = c6 ^ ((c0 << 1) | (c1 >>> 31));
	      const l4 = c7 ^ ((c1 << 1) | (c0 >>> 31));

	      s[0] ^= h0;
	      s[1] ^= l0;
	      s[10] ^= h0;
	      s[11] ^= l0;
	      s[20] ^= h0;
	      s[21] ^= l0;
	      s[30] ^= h0;
	      s[31] ^= l0;
	      s[40] ^= h0;
	      s[41] ^= l0;

	      s[2] ^= h1;
	      s[3] ^= l1;
	      s[12] ^= h1;
	      s[13] ^= l1;
	      s[22] ^= h1;
	      s[23] ^= l1;
	      s[32] ^= h1;
	      s[33] ^= l1;
	      s[42] ^= h1;
	      s[43] ^= l1;

	      s[4] ^= h2;
	      s[5] ^= l2;
	      s[14] ^= h2;
	      s[15] ^= l2;
	      s[24] ^= h2;
	      s[25] ^= l2;
	      s[34] ^= h2;
	      s[35] ^= l2;
	      s[44] ^= h2;
	      s[45] ^= l2;

	      s[6] ^= h3;
	      s[7] ^= l3;
	      s[16] ^= h3;
	      s[17] ^= l3;
	      s[26] ^= h3;
	      s[27] ^= l3;
	      s[36] ^= h3;
	      s[37] ^= l3;
	      s[46] ^= h3;
	      s[47] ^= l3;

	      s[8] ^= h4;
	      s[9] ^= l4;
	      s[18] ^= h4;
	      s[19] ^= l4;
	      s[28] ^= h4;
	      s[29] ^= l4;
	      s[38] ^= h4;
	      s[39] ^= l4;
	      s[48] ^= h4;
	      s[49] ^= l4;

	      const b0 = s[0];
	      const b1 = s[1];
	      const b32 = (s[11] << 4) | (s[10] >>> 28);
	      const b33 = (s[10] << 4) | (s[11] >>> 28);
	      const b14 = (s[20] << 3) | (s[21] >>> 29);
	      const b15 = (s[21] << 3) | (s[20] >>> 29);
	      const b46 = (s[31] << 9) | (s[30] >>> 23);
	      const b47 = (s[30] << 9) | (s[31] >>> 23);
	      const b28 = (s[40] << 18) | (s[41] >>> 14);
	      const b29 = (s[41] << 18) | (s[40] >>> 14);
	      const b20 = (s[2] << 1) | (s[3] >>> 31);
	      const b21 = (s[3] << 1) | (s[2] >>> 31);
	      const b2 = (s[13] << 12) | (s[12] >>> 20);
	      const b3 = (s[12] << 12) | (s[13] >>> 20);
	      const b34 = (s[22] << 10) | (s[23] >>> 22);
	      const b35 = (s[23] << 10) | (s[22] >>> 22);
	      const b16 = (s[33] << 13) | (s[32] >>> 19);
	      const b17 = (s[32] << 13) | (s[33] >>> 19);
	      const b48 = (s[42] << 2) | (s[43] >>> 30);
	      const b49 = (s[43] << 2) | (s[42] >>> 30);
	      const b40 = (s[5] << 30) | (s[4] >>> 2);
	      const b41 = (s[4] << 30) | (s[5] >>> 2);
	      const b22 = (s[14] << 6) | (s[15] >>> 26);
	      const b23 = (s[15] << 6) | (s[14] >>> 26);
	      const b4 = (s[25] << 11) | (s[24] >>> 21);
	      const b5 = (s[24] << 11) | (s[25] >>> 21);
	      const b36 = (s[34] << 15) | (s[35] >>> 17);
	      const b37 = (s[35] << 15) | (s[34] >>> 17);
	      const b18 = (s[45] << 29) | (s[44] >>> 3);
	      const b19 = (s[44] << 29) | (s[45] >>> 3);
	      const b10 = (s[6] << 28) | (s[7] >>> 4);
	      const b11 = (s[7] << 28) | (s[6] >>> 4);
	      const b42 = (s[17] << 23) | (s[16] >>> 9);
	      const b43 = (s[16] << 23) | (s[17] >>> 9);
	      const b24 = (s[26] << 25) | (s[27] >>> 7);
	      const b25 = (s[27] << 25) | (s[26] >>> 7);
	      const b6 = (s[36] << 21) | (s[37] >>> 11);
	      const b7 = (s[37] << 21) | (s[36] >>> 11);
	      const b38 = (s[47] << 24) | (s[46] >>> 8);
	      const b39 = (s[46] << 24) | (s[47] >>> 8);
	      const b30 = (s[8] << 27) | (s[9] >>> 5);
	      const b31 = (s[9] << 27) | (s[8] >>> 5);
	      const b12 = (s[18] << 20) | (s[19] >>> 12);
	      const b13 = (s[19] << 20) | (s[18] >>> 12);
	      const b44 = (s[29] << 7) | (s[28] >>> 25);
	      const b45 = (s[28] << 7) | (s[29] >>> 25);
	      const b26 = (s[38] << 8) | (s[39] >>> 24);
	      const b27 = (s[39] << 8) | (s[38] >>> 24);
	      const b8 = (s[48] << 14) | (s[49] >>> 18);
	      const b9 = (s[49] << 14) | (s[48] >>> 18);

	      s[0] = b0 ^ (~b2 & b4);
	      s[1] = b1 ^ (~b3 & b5);
	      s[10] = b10 ^ (~b12 & b14);
	      s[11] = b11 ^ (~b13 & b15);
	      s[20] = b20 ^ (~b22 & b24);
	      s[21] = b21 ^ (~b23 & b25);
	      s[30] = b30 ^ (~b32 & b34);
	      s[31] = b31 ^ (~b33 & b35);
	      s[40] = b40 ^ (~b42 & b44);
	      s[41] = b41 ^ (~b43 & b45);
	      s[2] = b2 ^ (~b4 & b6);
	      s[3] = b3 ^ (~b5 & b7);
	      s[12] = b12 ^ (~b14 & b16);
	      s[13] = b13 ^ (~b15 & b17);
	      s[22] = b22 ^ (~b24 & b26);
	      s[23] = b23 ^ (~b25 & b27);
	      s[32] = b32 ^ (~b34 & b36);
	      s[33] = b33 ^ (~b35 & b37);
	      s[42] = b42 ^ (~b44 & b46);
	      s[43] = b43 ^ (~b45 & b47);
	      s[4] = b4 ^ (~b6 & b8);
	      s[5] = b5 ^ (~b7 & b9);
	      s[14] = b14 ^ (~b16 & b18);
	      s[15] = b15 ^ (~b17 & b19);
	      s[24] = b24 ^ (~b26 & b28);
	      s[25] = b25 ^ (~b27 & b29);
	      s[34] = b34 ^ (~b36 & b38);
	      s[35] = b35 ^ (~b37 & b39);
	      s[44] = b44 ^ (~b46 & b48);
	      s[45] = b45 ^ (~b47 & b49);
	      s[6] = b6 ^ (~b8 & b0);
	      s[7] = b7 ^ (~b9 & b1);
	      s[16] = b16 ^ (~b18 & b10);
	      s[17] = b17 ^ (~b19 & b11);
	      s[26] = b26 ^ (~b28 & b20);
	      s[27] = b27 ^ (~b29 & b21);
	      s[36] = b36 ^ (~b38 & b30);
	      s[37] = b37 ^ (~b39 & b31);
	      s[46] = b46 ^ (~b48 & b40);
	      s[47] = b47 ^ (~b49 & b41);
	      s[8] = b8 ^ (~b0 & b2);
	      s[9] = b9 ^ (~b1 & b3);
	      s[18] = b18 ^ (~b10 & b12);
	      s[19] = b19 ^ (~b11 & b13);
	      s[28] = b28 ^ (~b20 & b22);
	      s[29] = b29 ^ (~b21 & b23);
	      s[38] = b38 ^ (~b30 & b32);
	      s[39] = b39 ^ (~b31 & b33);
	      s[48] = b48 ^ (~b40 & b42);
	      s[49] = b49 ^ (~b41 & b43);

	      s[0] ^= ROUND_CONST[n + 0];
	      s[1] ^= ROUND_CONST[n + 1];
	    }
	  }

	  static hash() {
	    return new Keccak();
	  }

	  static hmac(bits, pad, len) {
	    if (bits == null)
	      bits = 256;

	    assert((bits >>> 0) === bits);

	    const rate = 1600 - bits * 2;

	    assert(rate >= 0 && (rate & 63) === 0);

	    return new HMAC(Keccak, rate >>> 3, [bits], [pad, len]);
	  }

	  static digest(data, bits, pad, len) {
	    return Keccak.ctx.init(bits).update(data).final(pad, len);
	  }

	  static root(left, right, bits, pad, len) {
	    if (bits == null)
	      bits = 256;

	    if (len == null)
	      len = 0;

	    if (len === 0)
	      len = bits >>> 3;

	    assert((bits >>> 0) === bits);
	    assert((bits & 7) === 0);
	    assert((len >>> 0) === len);
	    assert(Buffer.isBuffer(left) && left.length === len);
	    assert(Buffer.isBuffer(right) && right.length === len);

	    return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);
	  }

	  static multi(x, y, z, bits, pad, len) {
	    const {ctx} = Keccak;

	    ctx.init(bits);
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final(pad, len);
	  }

	  static mac(data, key, bits, pad, len) {
	    return Keccak.hmac(bits, pad, len).init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	Keccak.native = 0;
	Keccak.id = 'KECCAK256';
	Keccak.size = 32;
	Keccak.bits = 256;
	Keccak.blockSize = 136;
	Keccak.zero = Buffer.alloc(32, 0x00);
	Keccak.ctx = new Keccak();

	/*
	 * Helpers
	 */

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	/*
	 * Expose
	 */

	keccak = Keccak;
	return keccak;
}

var murmur3 = {};

/*!
 * murmur3.js - murmur3 hash for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MurmurHash
 *   https://github.com/aappleby/smhasher
 */

var hasRequiredMurmur3;

function requireMurmur3 () {
	if (hasRequiredMurmur3) return murmur3;
	hasRequiredMurmur3 = 1;

	const assert = requireAssert();

	/**
	 * Murmur3 hash.
	 * @param {Buffer} data
	 * @param {Number} seed
	 * @returns {Number}
	 */

	function sum(data, seed) {
	  assert(Buffer.isBuffer(data));
	  assert(typeof seed === 'number');

	  const tail = data.length - (data.length & 3);
	  const c1 = 0xcc9e2d51;
	  const c2 = 0x1b873593;

	  let h1 = seed | 0;

	  for (let i = 0; i < tail; i += 4) {
	    let k1 = readU32(data, i);

	    k1 = mul32(k1, c1);
	    k1 = rotl32(k1, 15);
	    k1 = mul32(k1, c2);
	    h1 ^= k1;
	    h1 = rotl32(h1, 13);
	    h1 = (mul32(h1, 5) + 0xe6546b64) | 0;
	  }

	  let k1 = 0;

	  switch (data.length & 3) {
	    case 3:
	      k1 ^= data[tail + 2] << 16;
	    case 2:
	      k1 ^= data[tail + 1] << 8;
	    case 1:
	      k1 ^= data[tail + 0];
	      k1 = mul32(k1, c1);
	      k1 = rotl32(k1, 15);
	      k1 = mul32(k1, c2);
	      h1 ^= k1;
	  }

	  h1 ^= data.length;
	  h1 ^= h1 >>> 16;
	  h1 = mul32(h1, 0x85ebca6b);
	  h1 ^= h1 >>> 13;
	  h1 = mul32(h1, 0xc2b2ae35);
	  h1 ^= h1 >>> 16;

	  return h1 >>> 0;
	}

	/**
	 * Murmur3 hash.
	 * @param {Buffer} data
	 * @param {Number} n
	 * @param {Number} tweak
	 * @returns {Number}
	 */

	function tweak(data, n, tweak) {
	  assert(typeof n === 'number');
	  assert(typeof tweak === 'number');

	  const seed = mul32(n, 0xfba4c795) + (tweak | 0);

	  return sum(data, seed);
	}

	/*
	 * Helpers
	 */

	function mul32(a, b) {
	  const alo = a & 0xffff;
	  const blo = b & 0xffff;
	  const ahi = a >>> 16;
	  const bhi = b >>> 16;
	  const lo = alo * blo;
	  const hi = ahi * blo + bhi * alo + (lo >>> 16);

	  return (hi << 16) | (lo & 0xffff);
	}

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	/**
	 * Expose
	 */

	murmur3.native = 0;
	murmur3.sum = sum;
	murmur3.tweak = tweak;
	return murmur3;
}

/*!
 * p224.js - ECDSA-P224 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p224;
var hasRequiredP224;

function requireP224 () {
	if (hasRequiredP224) return p224;
	hasRequiredP224 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();

	/*
	 * Expose
	 */

	p224 = new ECDSA('P224', SHA256, SHA256);
	return p224;
}

/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p256;
var hasRequiredP256;

function requireP256 () {
	if (hasRequiredP256) return p256;
	hasRequiredP256 = 1;

	const ECDSA = requireEcdsa();
	const SHA256 = requireSha256();

	/*
	 * Expose
	 */

	p256 = new ECDSA('P256', SHA256, SHA256);
	return p256;
}

/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */

var sha384;
var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384;
	hasRequiredSha384 = 1;

	const assert = requireAssert();
	const SHA512 = requireSha512();
	const HMAC = requireHmac();

	/**
	 * SHA384
	 */

	class SHA384 extends SHA512 {
	  constructor() {
	    super();
	  }

	  init() {
	    this.state[0] = 0xcbbb9d5d;
	    this.state[1] = 0xc1059ed8;
	    this.state[2] = 0x629a292a;
	    this.state[3] = 0x367cd507;
	    this.state[4] = 0x9159015a;
	    this.state[5] = 0x3070dd17;
	    this.state[6] = 0x152fecd8;
	    this.state[7] = 0xf70e5939;
	    this.state[8] = 0x67332667;
	    this.state[9] = 0xffc00b31;
	    this.state[10] = 0x8eb44a87;
	    this.state[11] = 0x68581511;
	    this.state[12] = 0xdb0c2e0d;
	    this.state[13] = 0x64f98fa7;
	    this.state[14] = 0x47b5481d;
	    this.state[15] = 0xbefa4fa4;
	    this.size = 0;
	    return this;
	  }

	  final() {
	    return super.final().slice(0, 48);
	  }

	  static hash() {
	    return new SHA384();
	  }

	  static hmac() {
	    return new HMAC(SHA384, 128);
	  }

	  static digest(data) {
	    return SHA384.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 48);
	    assert(Buffer.isBuffer(right) && right.length === 48);
	    return SHA384.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = SHA384;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return SHA384.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA384.native = 0;
	SHA384.id = 'SHA384';
	SHA384.size = 48;
	SHA384.bits = 384;
	SHA384.blockSize = 128;
	SHA384.zero = Buffer.alloc(48, 0x00);
	SHA384.ctx = new SHA384();

	/*
	 * Expose
	 */

	sha384 = SHA384;
	return sha384;
}

/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p384;
var hasRequiredP384;

function requireP384 () {
	if (hasRequiredP384) return p384;
	hasRequiredP384 = 1;

	const ECDSA = requireEcdsa();
	const SHA384 = requireSha384();

	/*
	 * Expose
	 */

	p384 = new ECDSA('P384', SHA384, SHA384);
	return p384;
}

/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */

var shake;
var hasRequiredShake;

function requireShake () {
	if (hasRequiredShake) return shake;
	hasRequiredShake = 1;

	const Keccak = requireKeccak();

	/**
	 * SHAKE
	 */

	class SHAKE extends Keccak {
	  /**
	   * Create a SHAKE Context.
	   * @constructor
	   */

	  constructor() {
	    super();
	  }

	  final(len) {
	    return super.final(0x1f, len);
	  }

	  static hash() {
	    return new SHAKE();
	  }

	  static hmac(bits, len) {
	    return super.hmac(bits, 0x1f, len);
	  }

	  static digest(data, bits, len) {
	    return super.digest(data, bits, 0x1f, len);
	  }

	  static root(left, right, bits, len) {
	    return super.root(left, right, bits, 0x1f, len);
	  }

	  static multi(x, y, z, bits, len) {
	    return super.multi(x, y, z, bits, 0x1f, len);
	  }

	  static mac(data, key, bits, len) {
	    return super.mac(data, key, bits, 0x1f, len);
	  }
	}

	/*
	 * Static
	 */

	SHAKE.native = Keccak.native;
	SHAKE.id = 'SHAKE256';
	SHAKE.size = 32;
	SHAKE.bits = 256;
	SHAKE.blockSize = 136;
	SHAKE.zero = Buffer.alloc(32, 0x00);
	SHAKE.ctx = new SHAKE();

	/*
	 * Expose
	 */

	shake = SHAKE;
	return shake;
}

/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var shake256;
var hasRequiredShake256;

function requireShake256 () {
	if (hasRequiredShake256) return shake256;
	hasRequiredShake256 = 1;

	const SHAKE = requireShake();

	/**
	 * SHAKE256
	 */

	class SHAKE256 extends SHAKE {
	  constructor() {
	    super();
	  }

	  init() {
	    return super.init(256);
	  }

	  static hash() {
	    return new SHAKE256();
	  }

	  static hmac(len) {
	    return super.hmac(256, len);
	  }

	  static digest(data, len) {
	    return super.digest(data, 256, len);
	  }

	  static root(left, right, len) {
	    return super.root(left, right, 256, len);
	  }

	  static multi(x, y, z, len) {
	    return super.multi(x, y, z, 256, len);
	  }

	  static mac(data, key, len) {
	    return super.mac(data, key, 256, len);
	  }
	}

	/*
	 * Static
	 */

	SHAKE256.native = SHAKE.native;
	SHAKE256.id = 'SHAKE256';
	SHAKE256.size = 32;
	SHAKE256.bits = 256;
	SHAKE256.blockSize = 136;
	SHAKE256.zero = Buffer.alloc(32, 0x00);
	SHAKE256.ctx = new SHAKE256();

	/*
	 * Expose
	 */

	shake256 = SHAKE256;
	return shake256;
}

/*!
 * p521.js - ECDSA-P521 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var p521;
var hasRequiredP521;

function requireP521 () {
	if (hasRequiredP521) return p521;
	hasRequiredP521 = 1;

	const ECDSA = requireEcdsa();
	const SHA512 = requireSha512();
	const SHAKE256 = requireShake256();

	/*
	 * Expose
	 */

	p521 = new ECDSA('P521', SHA512, SHAKE256);
	return p521;
}

var rsa = {};

var primes = {};

/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */

var hasRequiredPrimes;

function requirePrimes () {
	if (hasRequiredPrimes) return primes;
	hasRequiredPrimes = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const random = requireRandom();

	/*
	 * Constants
	 */

	const smallPrimes = new Uint8Array([
	   3,  5,  7,
	  11, 13, 17,
	  19, 23, 29,
	  31, 37, 41,
	  43, 47, 53
	]);

	const smallPrimesProduct = new BN('16294579238595022365', 10);

	const primeBitMaskLo = 0
	  | (1 << 2)
	  | (1 << 3)
	  | (1 << 5)
	  | (1 << 7)
	  | (1 << 11)
	  | (1 << 13)
	  | (1 << 17)
	  | (1 << 19)
	  | (1 << 23)
	  | (1 << 29)
	  | (1 << 31);

	const primeBitMaskHi = 0
	  | (1 << (37 - 32))
	  | (1 << (41 - 32))
	  | (1 << (43 - 32))
	  | (1 << (47 - 32))
	  | (1 << (53 - 32))
	  | (1 << (59 - 32))
	  | (1 << (61 - 32));

	const primesA = new BN(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);
	const primesB = new BN(29 * 31 * 41 * 43 * 47 * 53);

	/*
	 * Primality
	 */

	function randomPrime(bits, reps = 20, rng = random) {
	  assert((bits >>> 0) === bits);
	  assert((reps >>> 0) === reps);
	  assert(rng != null);

	  if (bits < 2)
	    throw new Error('Prime must be at least 2 bits.');

	  for (;;) {
	    const p = BN.randomBits(rng, bits);

	    p.setn(bits - 1, 1);
	    p.setn(bits - 2, 1);
	    p.setn(0, 1);

	    const mod = p.mod(smallPrimesProduct);

	next:
	    for (let delta = 0; delta < (1 << 20); delta += 2) {
	      const m = mod.addn(delta);

	      for (let i = 0; i < smallPrimes.length; i++) {
	        const prime = smallPrimes[i];

	        if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0))
	          continue next;
	      }

	      p.iaddn(delta);

	      break;
	    }

	    if (p.bitLength() !== bits)
	      continue;

	    if (!isProbablePrime(p, reps, rng))
	      continue;

	    return p;
	  }
	}

	function isProbablePrime(x, reps, rng = random) {
	  assert(x instanceof BN);

	  if (x.sign() <= 0)
	    return false;

	  if (x.cmpn(64) < 0) {
	    const w = x.word(0);

	    if (w > 31)
	      return (primeBitMaskHi & (1 << (w - 32))) !== 0;

	    return (primeBitMaskLo & (1 << w)) !== 0;
	  }

	  if (x.isEven())
	    return false;

	  const ra = x.mod(primesA).toNumber();
	  const rb = x.mod(primesB).toNumber();

	  if (ra % 3 === 0
	      || ra % 5 === 0
	      || ra % 7 === 0
	      || ra % 11 === 0
	      || ra % 13 === 0
	      || ra % 17 === 0
	      || ra % 19 === 0
	      || ra % 23 === 0
	      || ra % 37 === 0
	      || rb % 29 === 0
	      || rb % 31 === 0
	      || rb % 41 === 0
	      || rb % 43 === 0
	      || rb % 47 === 0
	      || rb % 53 === 0) {
	    return false;
	  }

	  return x.isPrime(rng, reps);
	}

	function isSafePrime(x, reps, rng) {
	  // Safe Prime (2p + 1).
	  if (!isProbablePrime(x, reps, rng))
	    return false;

	  // Sophie Germain Prime (p).
	  const p = x.subn(1).iushrn(1);

	  if (!isProbablePrime(p, reps, rng))
	    return false;

	  return true;
	}

	/*
	 * Expose
	 */

	primes.randomPrime = randomPrime;
	primes.isProbablePrime = isProbablePrime;
	primes.isSafePrime = isSafePrime;
	return primes;
}

var base64 = {};

/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;

	const assert = requireAssert();

	/*
	 * Constants
	 */

	const CHARSET =
	  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	const CHARSET_URL =
	  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

	const TABLE = [
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, 62, -1, -1, -1, 63,
	  52, 53, 54, 55, 56, 57, 58, 59,
	  60, 61, -1, -1, -1, -1, -1, -1,
	  -1,  0,  1,  2,  3,  4,  5,  6,
	   7,  8,  9, 10, 11, 12, 13, 14,
	  15, 16, 17, 18, 19, 20, 21, 22,
	  23, 24, 25, -1, -1, -1, -1, -1,
	  -1, 26, 27, 28, 29, 30, 31, 32,
	  33, 34, 35, 36, 37, 38, 39, 40,
	  41, 42, 43, 44, 45, 46, 47, 48,
	  49, 50, 51, -1, -1, -1, -1, -1
	];

	const TABLE_URL = [
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, -1, -1, -1,
	  -1, -1, -1, -1, -1, 62, -1, -1,
	  52, 53, 54, 55, 56, 57, 58, 59,
	  60, 61, -1, -1, -1, -1, -1, -1,
	  -1,  0,  1,  2,  3,  4,  5,  6,
	   7,  8,  9, 10, 11, 12, 13, 14,
	  15, 16, 17, 18, 19, 20, 21, 22,
	  23, 24, 25, -1, -1, -1, -1, 63,
	  -1, 26, 27, 28, 29, 30, 31, 32,
	  33, 34, 35, 36, 37, 38, 39, 40,
	  41, 42, 43, 44, 45, 46, 47, 48,
	  49, 50, 51, -1, -1, -1, -1, -1
	];

	/*
	 * Encoding
	 */

	function _encode(data, charset, pad) {
	  assert(Buffer.isBuffer(data));

	  let left = data.length;
	  let str = '';
	  let i = 0;

	  while (left >= 3) {
	    const c1 = data[i++];
	    const c2 = data[i++];
	    const c3 = data[i++];

	    str += charset[c1 >> 2];
	    str += charset[((c1 & 3) << 4) | (c2 >> 4)];
	    str += charset[((c2 & 0x0f) << 2) | (c3 >> 6)];
	    str += charset[c3 & 0x3f];

	    left -= 3;
	  }

	  switch (left) {
	    case 1: {
	      const c1 = data[i++];

	      str += charset[c1 >> 2];
	      str += charset[(c1 & 3) << 4];

	      if (pad)
	        str += '==';

	      break;
	    }

	    case 2: {
	      const c1 = data[i++];
	      const c2 = data[i++];

	      str += charset[c1 >> 2];
	      str += charset[((c1 & 3) << 4) | (c2 >> 4)];
	      str += charset[(c2 & 0x0f) << 2];

	      if (pad)
	        str += '=';

	      break;
	    }
	  }

	  return str;
	}

	/*
	 * Decoding
	 */

	function _decode(str, table, size) {
	  assert(typeof str === 'string');

	  const data = Buffer.alloc(size);

	  let left = str.length;
	  let i = 0;
	  let j = 0;

	  if (left > 0 && str[left - 1] === '=')
	    left -= 1;

	  if (left > 0 && str[left - 1] === '=')
	    left -= 1;

	  if ((left & 3) === 1) // Fail early.
	    throw new Error('Invalid base64 string.');

	  while (left >= 4) {
	    const c1 = str.charCodeAt(i++);
	    const c2 = str.charCodeAt(i++);
	    const c3 = str.charCodeAt(i++);
	    const c4 = str.charCodeAt(i++);

	    if ((c1 | c2 | c3 | c4) & 0xff80)
	      throw new Error('Invalid base64 string.');

	    const t1 = table[c1];
	    const t2 = table[c2];
	    const t3 = table[c3];
	    const t4 = table[c4];

	    if ((t1 | t2 | t3 | t4) < 0)
	      throw new Error('Invalid base64 string.');

	    data[j++] = (t1 << 2) | (t2 >> 4);
	    data[j++] = (t2 << 4) | (t3 >> 2);
	    data[j++] = (t3 << 6) | (t4 >> 0);

	    left -= 4;
	  }

	  switch (left) {
	    case 1: {
	      throw new Error('Invalid base64 string.');
	    }

	    case 2: {
	      const c1 = str.charCodeAt(i++);
	      const c2 = str.charCodeAt(i++);

	      if ((c1 | c2) & 0xff80)
	        throw new Error('Invalid base64 string.');

	      const t1 = table[c1];
	      const t2 = table[c2];

	      if ((t1 | t2) < 0)
	        throw new Error('Invalid base64 string.');

	      data[j++] = (t1 << 2) | (t2 >> 4);

	      if (t2 & 15)
	        throw new Error('Invalid base64 string.');

	      break;
	    }

	    case 3: {
	      const c1 = str.charCodeAt(i++);
	      const c2 = str.charCodeAt(i++);
	      const c3 = str.charCodeAt(i++);

	      if ((c1 | c2 | c3) & 0xff80)
	        throw new Error('Invalid base64 string.');

	      const t1 = table[c1];
	      const t2 = table[c2];
	      const t3 = table[c3];

	      if ((t1 | t2 | t3) < 0)
	        throw new Error('Invalid base64 string.');

	      data[j++] = (t1 << 2) | (t2 >> 4);
	      data[j++] = (t2 << 4) | (t3 >> 2);

	      if (t3 & 3)
	        throw new Error('Invalid base64 string.');

	      break;
	    }
	  }

	  assert(j === size);

	  return data;
	}

	/*
	 * Testing
	 */

	function _test(str, table) {
	  assert(typeof str === 'string');

	  let len = str.length;

	  if (len > 0 && str[len - 1] === '=')
	    len -= 1;

	  if (len > 0 && str[len - 1] === '=')
	    len -= 1;

	  if ((len & 3) === 1)
	    return false;

	  for (let i = 0; i < len; i++) {
	    const ch = str.charCodeAt(i);

	    if (ch & 0xff80)
	      return false;

	    if (table[ch] === -1)
	      return false;
	  }

	  switch (len & 3) {
	    case 1:
	      return false;
	    case 2:
	      return (table[str.charCodeAt(len - 1)] & 15) === 0;
	    case 3:
	      return (table[str.charCodeAt(len - 1)] & 3) === 0;
	  }

	  return true;
	}

	/*
	 * Base64
	 */

	function encode(data) {
	  return _encode(data, CHARSET, true);
	}

	function decode(str) {
	  const size = decodeSize(str);

	  if (!checkPadding(str, size))
	    throw new Error('Invalid base64 padding.');

	  return _decode(str, TABLE, size);
	}

	function test(str) {
	  const size = decodeSize(str);

	  if (!checkPadding(str, size))
	    return false;

	  return _test(str, TABLE);
	}

	/*
	 * Base64-URL
	 */

	function encodeURL(data) {
	  return _encode(data, CHARSET_URL, false);
	}

	function decodeURL(str) {
	  const size = decodeSize(str);

	  if (!checkPadding(str, 0))
	    throw new Error('Invalid base64 padding.');

	  return _decode(str, TABLE_URL, size);
	}

	function testURL(str) {
	  if (!checkPadding(str, 0))
	    return false;

	  return _test(str, TABLE_URL);
	}

	/*
	 * Helpers
	 */

	function decodeSize(str) {
	  assert(typeof str === 'string');

	  let len = str.length;

	  if (len > 0 && str[len - 1] === '=')
	    len -= 1;

	  if (len > 0 && str[len - 1] === '=')
	    len -= 1;

	  let size = (len >>> 2) * 3;

	  const rem = len & 3;

	  if (rem)
	    size += rem - 1;

	  return size;
	}

	function checkPadding(str, size) {
	  assert(typeof str === 'string');

	  switch (size % 3) {
	    case 0: {
	      if (str.length === 0)
	        return true;

	      if (str.length === 1)
	        return str[0] !== '=';

	      return str[str.length - 2] !== '='
	          && str[str.length - 1] !== '=';
	    }

	    case 1: {
	      return str.length >= 4
	          && str[str.length - 2] === '='
	          && str[str.length - 1] === '=';
	    }

	    case 2: {
	      return str.length >= 4
	          && str[str.length - 2] !== '='
	          && str[str.length - 1] === '=';
	    }

	    default: {
	      throw new Error('unreachable');
	    }
	  }
	}

	/*
	 * Expose
	 */

	base64.native = 0;
	base64.encode = encode;
	base64.decode = decode;
	base64.test = test;
	base64.encodeURL = encodeURL;
	base64.decodeURL = decodeURL;
	base64.testURL = testURL;
	return base64;
}

var safe = {};

/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */

var hasRequiredSafe;

function requireSafe () {
	if (hasRequiredSafe) return safe;
	hasRequiredSafe = 1;

	const assert = requireAssert();

	/*
	 * Safe
	 */

	function safeCompare(x, y) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));

	  if (safeEqualInt(x.length, 0))
	    return safeEqualInt(y.length, 0);

	  // Assumes `y` is the "constant size"
	  // parameter. Note that constant size
	  // doesn't necessarily mean secret.
	  // Assuming we have a constant-size
	  // secret key or passphrase. This
	  // function should be called as:
	  //
	  // if (!safeCompare(input, key))
	  //   throw new Error('Bad passphrase.');
	  let v = x.length ^ y.length;

	  for (let i = 0; i < y.length; i++)
	    v |= x[i % x.length] ^ y[i];

	  return (v - 1) >>> 31;
	}

	function safeEqual(x, y) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));

	  // Assumes the lengths of both
	  // `x` and `y` are not secret.
	  if (!safeEqualInt(x.length, y.length))
	    return 0;

	  let v = 0;

	  for (let i = 0; i < x.length; i++)
	    v |= x[i] ^ y[i];

	  return (v - 1) >>> 31;
	}

	function safeEqualByte(x, y) {
	  return safeEqualInt(x & 0xff, y & 0xff);
	}

	function safeEqualInt(x, y) {
	  return ((x ^ y) - 1) >>> 31;
	}

	function safeSelect(x, y, v) {
	  return (x & (v - 1)) | (y & ~(v - 1));
	}

	function safeLT(x, y) {
	  return (x - y) >>> 31;
	}

	function safeLTE(x, y) {
	  return (x - y - 1) >>> 31;
	}

	function safeGT(x, y) {
	  return (y - x) >>> 31;
	}

	function safeGTE(x, y) {
	  return (y - x - 1) >>> 31;
	}

	function safeMin(x, y) {
	  return safeSelect(x, y, safeLT(y, x));
	}

	function safeMax(x, y) {
	  return safeSelect(x, y, safeGT(y, x));
	}

	function safeAbs(x) {
	  return (x | 0) * ((x >> 31) | 1);
	}

	function safeBool(x) {
	  return ((x >> 31) | (-x >> 31)) & 1;
	}

	function safeCopy(x, y, v) {
	  assert(Buffer.isBuffer(x));
	  assert(Buffer.isBuffer(y));
	  assert(safeEqualInt(x.length, y.length));

	  const xmask = (v - 1) & 0xff;
	  const ymask = ~(v - 1) & 0xff;

	  for (let i = 0; i < x.length; i++)
	    x[i] = (x[i] & xmask) | (y[i] & ymask);
	}

	/*
	 * Expose
	 */

	safe.safeCompare = safeCompare;
	safe.safeEqual = safeEqual;
	safe.safeEqualByte = safeEqualByte;
	safe.safeEqualInt = safeEqualInt;
	safe.safeSelect = safeSelect;
	safe.safeLT = safeLT;
	safe.safeLTE = safeLTE;
	safe.safeGT = safeGT;
	safe.safeGTE = safeGTE;
	safe.safeMin = safeMin;
	safe.safeMax = safeMax;
	safe.safeAbs = safeAbs;
	safe.safeBool = safeBool;
	safe.safeCopy = safeCopy;
	return safe;
}

/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */

var hasRequiredRsa;

function requireRsa () {
	if (hasRequiredRsa) return rsa;
	hasRequiredRsa = 1;

	const assert = requireAssert();
	const BN = requireBn();
	const rng = requireRandom();
	const {randomPrime} = requirePrimes();
	const base64 = requireBase64();
	const asn1 = requireAsn1$1();
	const safe = requireSafe();

	const {
	  safeEqual,
	  safeEqualByte,
	  safeSelect,
	  safeLTE
	} = safe;

	/*
	 * Constants
	 */

	const DEFAULT_BITS = 2048;
	const DEFAULT_EXP = 65537;
	const MIN_BITS = 512;
	const MAX_BITS = 16384;
	const MIN_EXP = 3;
	const MAX_EXP = (2 ** 33) - 1;
	const MAX_EXP_BITS = 33;
	const SALT_LENGTH_AUTO = 0;
	const SALT_LENGTH_HASH = -1;
	const PREFIX = Buffer.alloc(8, 0x00);
	const EMPTY = Buffer.alloc(0);

	/**
	 * PKCS1v1.5+ASN.1 DigestInfo prefixes.
	 * @see [RFC8017] Page 45, Section 9.2.
	 * @see [RFC8017] Page 63, Section B.1.
	 * @const {Object}
	 */

	const digestInfo = {
	  __proto__: null,
	  BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),
	  BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),
	  BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),
	  BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),
	  BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),
	  BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),
	  BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),
	  BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),
	  GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),
	  HASH160: Buffer.from([20]),
	  HASH256: Buffer.from([32]),
	  KECCAK224: Buffer.from([28]),
	  KECCAK256: Buffer.from([32]),
	  KECCAK384: Buffer.from([48]),
	  KECCAK512: Buffer.from([64]),
	  MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
	  MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),
	  MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
	  MD5SHA1: Buffer.from([36]),
	  RIPEMD160: Buffer.from('3021300906052b2403020105000414', 'hex'),
	  SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
	  SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
	  SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
	  SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
	  SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
	  SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
	  SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
	  SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
	  SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
	  SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),
	  SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),
	  WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')
	};

	/**
	 * RSAPublicKey
	 */

	class RSAPublicKey {
	  constructor() {
	    this.n = new BN(0);
	    this.e = new BN(0);
	  }

	  bits() {
	    return this.n.bitLength();
	  }

	  size() {
	    return this.n.byteLength();
	  }

	  isSane() {
	    return this.n.sign() > 0
	        && this.e.sign() > 0
	        && this.n.bitLength() <= MAX_BITS
	        && this.e.bitLength() <= MAX_EXP_BITS;
	  }

	  verify() {
	    // Sanity checks.
	    if (!this.isSane())
	      return false;

	    // n >= 2^511 and n mod 2 != 0
	    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd())
	      return false;

	    // e >= 3 and e mod 2 != 0
	    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd())
	      return false;

	    return true;
	  }

	  encrypt(msg) {
	    // [RFC8017] Page 13, Section 5.1.1.
	    //           Page 16, Section 5.2.2.
	    assert(Buffer.isBuffer(msg));

	    const {n, e} = this;
	    const m = BN.decode(msg);

	    if (m.cmp(n) >= 0)
	      throw new Error('Invalid RSA message size.');

	    // c = m^e mod n
	    const c = m.powm(e, n);

	    return c.encode('be', n.byteLength());
	  }

	  encode() {
	    const size = asn1.sizeInt(this.n) + asn1.sizeInt(this.e);
	    const out = Buffer.alloc(asn1.sizeSeq(size));

	    let pos = 0;

	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeInt(out, pos, this.n);
	    pos = asn1.writeInt(out, pos, this.e);

	    assert(pos === out.length);

	    return out;
	  }

	  decode(data) {
	    let pos = 0;

	    pos = asn1.readSeq(data, pos);

	    [this.n, pos] = asn1.readInt(data, pos);
	    [this.e, pos] = asn1.readInt(data, pos);

	    if (pos !== data.length)
	      throw new Error('Trailing bytes.');

	    return this;
	  }

	  static decode(data) {
	    return new RSAPublicKey().decode(data);
	  }
	}

	/**
	 * RSAPrivateKey
	 */

	class RSAPrivateKey extends RSAPublicKey {
	  constructor() {
	    super();
	    this.d = new BN(0);
	    this.p = new BN(0);
	    this.q = new BN(0);
	    this.dp = new BN(0);
	    this.dq = new BN(0);
	    this.qi = new BN(0);
	  }

	  isSane() {
	    return this.n.sign() > 0
	        && this.e.sign() > 0
	        && this.d.sign() > 0
	        && this.p.sign() > 0
	        && this.q.sign() > 0
	        && this.dp.sign() > 0
	        && this.dq.sign() > 0
	        && this.qi.sign() > 0
	        && this.n.bitLength() <= MAX_BITS
	        && this.e.bitLength() <= MAX_EXP_BITS
	        && this.d.bitLength() <= MAX_BITS
	        && this.p.bitLength() <= MAX_BITS
	        && this.q.bitLength() <= MAX_BITS
	        && this.dp.bitLength() <= MAX_BITS
	        && this.dq.bitLength() <= MAX_BITS
	        && this.qi.bitLength() <= MAX_BITS;
	  }

	  verify() {
	    // Sanity checks.
	    if (!this.isSane())
	      return false;

	    // n >= 2^511 and n mod 2 != 0
	    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd())
	      return false;

	    // e >= 3 and e mod 2 != 0
	    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd())
	      return false;

	    // p >= 3 and p mod 2 != 0
	    if (this.p.cmpn(3) < 0 || !this.p.isOdd())
	      return false;

	    // q >= 3 and q mod 2 != 0
	    if (this.q.cmpn(3) < 0 || !this.q.isOdd())
	      return false;

	    // phi = (p - 1) * (q - 1)
	    const pm1 = this.p.subn(1);
	    const qm1 = this.q.subn(1);
	    const phi = pm1.mul(qm1);

	    // d >= 2 and d < phi
	    if (this.d.cmpn(2) < 0 || this.d.cmp(phi) >= 0)
	      return false;

	    // dp != 0 and dp < p - 1
	    if (this.dp.sign() === 0 || this.dp.cmp(pm1) >= 0)
	      return false;

	    // dq != 0 and dq < q - 1
	    if (this.dq.sign() === 0 || this.dq.cmp(qm1) >= 0)
	      return false;

	    // qi <= 2 and qi < p
	    if (this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0)
	      return false;

	    // p != q
	    if (this.p.cmp(this.q) === 0)
	      return false;

	    // n == p * q
	    if (this.p.mul(this.q).cmp(this.n) !== 0)
	      return false;

	    // lam = lcm(p - 1, q - 1)
	    const lam = phi.div(pm1.gcd(qm1));

	    // e * d mod lam
	    if (this.e.mul(this.d).imod(lam).cmpn(1) !== 0)
	      return false;

	    // dp == d mod (p - 1)
	    if (this.d.mod(pm1).cmp(this.dp) !== 0)
	      return false;

	    // dq == d mod (q - 1)
	    if (this.d.mod(qm1).cmp(this.dq) !== 0)
	      return false;

	    // q * qi mod p == 1
	    if (this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0)
	      return false;

	    return true;
	  }

	  decrypt(msg) {
	    // [RFC8017] Page 13, Section 5.1.2.
	    //           Page 15, Section 5.2.1.
	    assert(Buffer.isBuffer(msg));

	    const {n, e, p, q, dp, dq, qi} = this;

	    // Decode message.
	    const c = BN.decode(msg);

	    // Validate params.
	    if (c.cmp(n) >= 0)
	      throw new Error('Invalid RSA message size.');

	    // Generate blinding factor.
	    let b, bi;
	    for (;;) {
	      // s = random integer in [1,n-1]
	      const s = BN.random(rng, 1, n);

	      // bi = s^-1 mod n
	      try {
	        bi = s.invert(n);
	      } catch (e) {
	        continue;
	      }

	      // b = s^e mod n
	      b = s.powm(e, n);

	      break;
	    }

	    // Blind.
	    c.imul(b).imod(n);

	    // Leverage Chinese Remainder Theorem.
	    //
	    // Computation:
	    //
	    //   mp = c^(d mod p-1) mod p
	    //   mq = c^(d mod q-1) mod q
	    //   md = (mp - mq) / q mod p
	    //   m = (md * q + mq) mod n
	    const mp = c.powm(dp, p, true);
	    const mq = c.powm(dq, q, true);
	    const md = mp.sub(mq).mul(qi).imod(p);
	    const m = md.mul(q).iadd(mq).imod(n);

	    if (m.powm(e, n).cmp(c) !== 0)
	      throw new Error('Invalid RSA private key.');

	    // Unblind.
	    m.imul(bi).imod(n);

	    return m.encode('be', n.byteLength());
	  }

	  generate(bits, exponent) {
	    // [RFC8017] Page 9, Section 3.2.
	    // [FIPS186] Page 51, Appendix B.3.1
	    //           Page 55, Appendix B.3.3
	    //
	    // There are two methods for choosing `d`.
	    // Implementations differ on whether they
	    // use Euler's totient or the Carmichael
	    // function.
	    //
	    // The best explanation of Euler's phi vs.
	    // Carmichael's lambda I've seen comes from
	    // the crypto stackexchange[1].
	    //
	    // Note that both functions are _equivalent_
	    // when used with RSA, however, Carmichael's
	    // may lend itself to some perf benefits.
	    //
	    // [1] https://crypto.stackexchange.com/a/29595
	    assert((bits >>> 0) === bits);
	    assert(Number.isSafeInteger(exponent) && exponent >= 0);
	    assert(bits >= 64);
	    assert(exponent >= 3 && (exponent & 1) !== 0);

	    const e = new BN(exponent);

	    for (;;) {
	      const p = randomPrime((bits >>> 1) + (bits & 1));
	      const q = randomPrime(bits >>> 1);

	      if (p.cmp(q) === 0)
	        continue;

	      if (p.cmp(q) < 0)
	        p.swap(q);

	      if (p.sub(q).bitLength() <= (bits >>> 1) - 99)
	        continue;

	      const n = p.mul(q);

	      if (n.bitLength() !== bits)
	        continue;

	      // Euler's totient: (p - 1) * (q - 1).
	      const pm1 = p.subn(1);
	      const qm1 = q.subn(1);
	      const phi = pm1.mul(qm1);

	      if (e.gcd(phi).cmpn(1) !== 0)
	        continue;

	      // Carmichael's function: lcm(p - 1, q - 1).
	      const lam = phi.div(pm1.gcd(qm1));
	      const d = e.invert(lam);

	      if (d.bitLength() <= ((bits + 1) >>> 1))
	        continue;

	      const dp = d.mod(pm1);
	      const dq = d.mod(qm1);
	      const qi = q.invert(p);

	      this.n = n;
	      this.e = e;
	      this.d = d;
	      this.p = p;
	      this.q = q;
	      this.dp = dp;
	      this.dq = dq;
	      this.qi = qi;

	      return this;
	    }
	  }

	  async _generateSubtle(bits, exponent) {
	    assert((bits >>> 0) === bits);
	    assert(Number.isSafeInteger(exponent) && exponent >= 0);
	    assert(bits >= 64);
	    assert(exponent >= 3 && (exponent & 1) !== 0);

	    const crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

	    if (!crypto)
	      throw new Error('Crypto API not available.');

	    const {subtle} = crypto;

	    if (!subtle || !subtle.generateKey || !subtle.exportKey)
	      throw new Error('Subtle API not available.');

	    const e = new BN(exponent);

	    const algo = {
	      name: 'RSASSA-PKCS1-v1_5',
	      modulusLength: bits,
	      publicExponent: e.toArrayLike(Uint8Array, 'be', 8),
	      hash: { name: 'SHA-256' }
	    };

	    const ck = await subtle.generateKey(algo, true, ['sign']);
	    const jwk = await subtle.exportKey('jwk', ck.privateKey);
	    const p = BN.decode(base64.decodeURL(jwk.p));
	    const q = BN.decode(base64.decodeURL(jwk.q));

	    return this.fromPQE(p, q, e);
	  }

	  async generateAsync(bits, exponent) {
	    try {
	      return await this._generateSubtle(bits, exponent);
	    } catch (e) {
	      return this.generate(bits, exponent);
	    }
	  }

	  fromPQE(p, q, e) {
	    assert(p instanceof BN);
	    assert(q instanceof BN);
	    assert(e instanceof BN);

	    if (p.cmp(q) < 0)
	      [p, q] = [q, p];

	    if (p.cmp(q) === 0)
	      throw new Error('Invalid RSA private key.');

	    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (!p.isOdd() || !q.isOdd() || !e.isOdd())
	      throw new Error('Invalid RSA private key.');

	    const n = p.mul(q);

	    assert(n.isOdd());

	    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    const pm1 = p.subn(1);
	    const qm1 = q.subn(1);
	    const lam = pm1.lcm(qm1);
	    const d = e.invert(lam);
	    const dp = d.mod(pm1);
	    const dq = d.mod(qm1);
	    const qi = q.invert(p);

	    this.n = n;
	    this.e = e;
	    this.d = d;
	    this.p = p;
	    this.q = q;
	    this.dp = dp;
	    this.dq = dq;
	    this.qi = qi;

	    return this;
	  }

	  fromPQD(p, q, d) {
	    assert(p instanceof BN);
	    assert(q instanceof BN);
	    assert(d instanceof BN);

	    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (!p.isOdd() || !q.isOdd())
	      throw new Error('Invalid RSA private key.');

	    const pm1 = p.subn(1);
	    const qm1 = q.subn(1);
	    const phi = pm1.mul(qm1);

	    if (d.cmpn(2) < 0 || d.cmp(phi) >= 0)
	      throw new Error('Invalid RSA private key.');

	    const lam = phi.div(pm1.gcd(qm1));
	    const e = d.invert(lam);

	    return this.fromPQE(p, q, e);
	  }

	  fromNED(n, e, d) {
	    // Factor an RSA modulus given (n, e, d).
	    //
	    // This is basically the same logic as the
	    // Miller-Rabin primality test[1][2].
	    //
	    // [1] https://crypto.stackexchange.com/questions/11509
	    // [2] https://crypto.stackexchange.com/questions/22374
	    assert(n instanceof BN);
	    assert(e instanceof BN);
	    assert(d instanceof BN);

	    if (n.sign() < 0)
	      throw new Error('Invalid RSA private key.');

	    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (d.cmpn(2) < 0 || d.bitLength() > MAX_BITS)
	      throw new Error('Invalid RSA private key.');

	    if (!n.isOdd() || !e.isOdd())
	      throw new Error('Invalid RSA private key.');

	    const f = e.mul(d).isubn(1);
	    const nm1 = n.subn(1);
	    const s = f.zeroBits();
	    const g = f.ushrn(s);

	    for (let i = 0; i < 64; i++) {
	      const a = BN.random(rng, 2, nm1);

	      let b = a.powm(g, n);

	      if (b.cmpn(1) === 0 || b.cmp(nm1) === 0)
	        continue;

	      for (let j = 1; j < s; j++) {
	        const c = b.sqr().imod(n);

	        if (c.cmpn(1) === 0) {
	          const p = n.gcd(b.subn(1));
	          const q = n.gcd(b.addn(1));

	          return this.fromPQE(p, q, e);
	        }

	        if (c.cmp(nm1) === 0)
	          break;

	        b = c;
	      }
	    }

	    throw new Error('Invalid RSA private key.');
	  }

	  toPublic() {
	    const pub = new RSAPublicKey();

	    pub.n = this.n;
	    pub.e = this.e;

	    return pub;
	  }

	  encode() {
	    let size = 0;

	    size += asn1.sizeVersion(0);
	    size += asn1.sizeInt(this.n);
	    size += asn1.sizeInt(this.e);
	    size += asn1.sizeInt(this.d);
	    size += asn1.sizeInt(this.p);
	    size += asn1.sizeInt(this.q);
	    size += asn1.sizeInt(this.dp);
	    size += asn1.sizeInt(this.dq);
	    size += asn1.sizeInt(this.qi);

	    const out = Buffer.alloc(asn1.sizeSeq(size));

	    let pos = 0;

	    pos = asn1.writeSeq(out, pos, size);
	    pos = asn1.writeVersion(out, pos, 0);
	    pos = asn1.writeInt(out, pos, this.n);
	    pos = asn1.writeInt(out, pos, this.e);
	    pos = asn1.writeInt(out, pos, this.d);
	    pos = asn1.writeInt(out, pos, this.p);
	    pos = asn1.writeInt(out, pos, this.q);
	    pos = asn1.writeInt(out, pos, this.dp);
	    pos = asn1.writeInt(out, pos, this.dq);
	    pos = asn1.writeInt(out, pos, this.qi);

	    assert(pos === out.length);

	    return out;
	  }

	  decode(data) {
	    let pos = 0;

	    pos = asn1.readSeq(data, pos);
	    pos = asn1.readVersion(data, pos, 0);

	    [this.n, pos] = asn1.readInt(data, pos);
	    [this.e, pos] = asn1.readInt(data, pos);
	    [this.d, pos] = asn1.readInt(data, pos);
	    [this.p, pos] = asn1.readInt(data, pos);
	    [this.q, pos] = asn1.readInt(data, pos);
	    [this.dp, pos] = asn1.readInt(data, pos);
	    [this.dq, pos] = asn1.readInt(data, pos);
	    [this.qi, pos] = asn1.readInt(data, pos);

	    if (pos !== data.length)
	      throw new Error('Trailing bytes.');

	    return this;
	  }

	  static generate(bits, exponent) {
	    return new RSAPrivateKey().generate(bits, exponent);
	  }

	  static async generateAsync(bits, exponent) {
	    return new RSAPrivateKey().generateAsync(bits, exponent);
	  }

	  static fromPQE(p, q, e) {
	    return new RSAPrivateKey().fromPQE(p, q, e);
	  }

	  static fromPQD(p, q, d) {
	    return new RSAPrivateKey().fromPQD(p, q, d);
	  }

	  static fromNED(n, e, d) {
	    return new RSAPrivateKey().fromNED(n, e, d);
	  }

	  static decode(data) {
	    return new RSAPrivateKey().decode(data);
	  }
	}

	/**
	 * Generate a private key.
	 * @param {Number} [bits=2048]
	 * @param {Number} [exponent=65537]
	 * @returns {Buffer} Private key.
	 */

	function privateKeyGenerate(bits, exponent) {
	  if (bits == null)
	    bits = DEFAULT_BITS;

	  if (exponent == null)
	    exponent = DEFAULT_EXP;

	  assert((bits >>> 0) === bits);
	  assert(Number.isSafeInteger(exponent) && exponent >= 0);

	  if (bits < MIN_BITS || bits > MAX_BITS)
	    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

	  if (exponent < MIN_EXP || exponent > MAX_EXP)
	    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

	  if (exponent === 1 || (exponent & 1) === 0)
	    throw new RangeError('"exponent" must be odd.');

	  const key = RSAPrivateKey.generate(bits, exponent);

	  return key.encode();
	}

	/**
	 * Generate a private key.
	 * @param {Number} [bits=2048]
	 * @param {Number} [exponent=65537]
	 * @returns {Buffer} Private key.
	 */

	async function privateKeyGenerateAsync(bits, exponent) {
	  if (bits == null)
	    bits = DEFAULT_BITS;

	  if (exponent == null)
	    exponent = DEFAULT_EXP;

	  assert((bits >>> 0) === bits);
	  assert(Number.isSafeInteger(exponent) && exponent >= 0);

	  if (bits < MIN_BITS || bits > MAX_BITS)
	    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

	  if (exponent < MIN_EXP || exponent > MAX_EXP)
	    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

	  if (exponent === 1 || (exponent & 1) === 0)
	    throw new RangeError('"exponent" must be odd.');

	  const key = await RSAPrivateKey.generateAsync(bits, exponent);

	  return key.encode();
	}

	/**
	 * Get a private key's modulus size in bits.
	 * @param {Buffer} key
	 * @returns {Number}
	 */

	function privateKeyBits(key) {
	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  return k.bits();
	}

	/**
	 * Verify a private key.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function privateKeyVerify(key) {
	  // [RFC8017] Page 9, Section 3.2.
	  assert(Buffer.isBuffer(key));

	  let k;

	  try {
	    k = RSAPrivateKey.decode(key);
	  } catch (e) {
	    return false;
	  }

	  return k.verify();
	}

	/**
	 * Import a private key from an object.
	 * @param {Object} json
	 * @returns {Buffer}
	 */

	function privateKeyImport(json) {
	  // [RFC8017] Page 55, Section A.1.2.
	  assert(json && typeof json === 'object');

	  let k = new RSAPrivateKey();

	  if (json.n != null)
	    k.n = BN.decode(json.n);

	  if (json.e != null)
	    k.e = BN.decode(json.e);

	  if (json.d != null)
	    k.d = BN.decode(json.d);

	  if (json.p != null)
	    k.p = BN.decode(json.p);

	  if (json.q != null)
	    k.q = BN.decode(json.q);

	  if (json.dp != null)
	    k.dp = BN.decode(json.dp);

	  if (json.dq != null)
	    k.dq = BN.decode(json.dq);

	  if (json.qi != null)
	    k.qi = BN.decode(json.qi);

	  if (!k.verify()) {
	    if (!k.p.isZero() && !k.q.isZero()) {
	      if (!k.e.isZero())
	        k = RSAPrivateKey.fromPQE(k.p, k.q, k.e);
	      else
	        k = RSAPrivateKey.fromPQD(k.p, k.q, k.d);
	    } else {
	      k = RSAPrivateKey.fromNED(k.n, k.e, k.d);
	    }
	  }

	  return k.encode();
	}

	/**
	 * Export a private key to an object.
	 * @param {Buffer} key
	 * @returns {Object}
	 */

	function privateKeyExport(key) {
	  // [RFC8017] Page 55, Section A.1.2.
	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  return {
	    n: k.n.encode(),
	    e: k.e.encode(),
	    d: k.d.encode(),
	    p: k.p.encode(),
	    q: k.q.encode(),
	    dp: k.dp.encode(),
	    dq: k.dq.encode(),
	    qi: k.qi.encode()
	  };
	}

	/**
	 * Create a public key from a private key.
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function publicKeyCreate(key) {
	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  const p = k.toPublic();

	  return p.encode();
	}

	/**
	 * Get a public key's modulus size in bits.
	 * @param {Buffer} key
	 * @returns {Number}
	 */

	function publicKeyBits(key) {
	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  return k.bits();
	}

	/**
	 * Verify a public key.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function publicKeyVerify(key) {
	  // [RFC8017] Page 8, Section 3.1.
	  assert(Buffer.isBuffer(key));

	  let k;

	  try {
	    k = RSAPublicKey.decode(key);
	  } catch (e) {
	    return false;
	  }

	  return k.verify();
	}

	/**
	 * Import a public key from an object.
	 * @param {Object} json
	 * @returns {Buffer}
	 */

	function publicKeyImport(json) {
	  // [RFC8017] Page 54, Section A.1.1.
	  assert(json && typeof json === 'object');

	  const k = new RSAPublicKey();

	  if (json.n != null)
	    k.n = BN.decode(json.n);

	  if (json.e != null)
	    k.e = BN.decode(json.e);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  return k.encode();
	}

	/**
	 * Export a public key to an object.
	 * @param {Buffer} key
	 * @returns {Object}
	 */

	function publicKeyExport(key) {
	  // [RFC8017] Page 54, Section A.1.1.
	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  return {
	    n: k.n.encode(),
	    e: k.e.encode()
	  };
	}

	/**
	 * Sign a message (PKCS1v1.5).
	 * @param {Object|String|null} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key - Private key.
	 * @returns {Buffer} PKCS#1v1.5-formatted signature.
	 */

	function sign(hash, msg, key) {
	  // [RFC8017] Page 36, Section 8.2.1.
	  //           Page 45, Section 9.2.
	  if (hash && typeof hash.id === 'string')
	    hash = hash.id;

	  assert(hash == null || typeof hash === 'string');
	  assert(Buffer.isBuffer(msg));

	  const [prefix, hlen] = getDigestInfo(hash, msg);

	  if (!prefix)
	    throw new Error('Unknown RSA hash function.');

	  if (msg.length !== hlen)
	    throw new Error('Invalid RSA message size.');

	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  const tlen = prefix.length + hlen;
	  const klen = k.size();

	  if (klen < tlen + 11)
	    throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x01 || PS || 0x00 || T
	  const em = Buffer.alloc(klen);

	  em[0] = 0x00;
	  em[1] = 0x01;

	  for (let i = 2; i < klen - tlen - 1; i++)
	    em[i] = 0xff;

	  em[klen - tlen - 1] = 0x00;

	  prefix.copy(em, klen - tlen);
	  msg.copy(em, klen - hlen);

	  return k.decrypt(em);
	}

	/**
	 * Verify a signature (PKCS1v1.5).
	 * @param {Object|String|null} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PKCS#1v1.5-formatted.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function verify(hash, msg, sig, key) {
	  if (hash && typeof hash.id === 'string')
	    hash = hash.id;

	  assert(hash == null || typeof hash === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));

	  try {
	    return _verify(hash, msg, sig, key);
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * Verify a signature (PKCS1v1.5).
	 * @private
	 * @param {String} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PKCS#1v1.5-formatted.
	 * @param {Buffer} key
	 * @returns {Boolean}
	 */

	function _verify(hash, msg, sig, key) {
	  // [RFC8017] Page 37, Section 8.2.2.
	  //           Page 45, Section 9.2.
	  const [prefix, hlen] = getDigestInfo(hash, msg);

	  if (!prefix)
	    return false;

	  if (msg.length !== hlen)
	    return false;

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    return false;

	  const klen = k.size();

	  if (sig.length !== klen)
	    return false;

	  const tlen = prefix.length + hlen;

	  if (klen < tlen + 11)
	    return false;

	  const em = k.encrypt(sig);

	  // EM = 0x00 || 0x01 || PS || 0x00 || T
	  let ok = 1;

	  ok &= safeEqualByte(em[0], 0x00);
	  ok &= safeEqualByte(em[1], 0x01);

	  for (let i = 2; i < klen - tlen - 1; i++)
	    ok &= safeEqualByte(em[i], 0xff);

	  ok &= safeEqualByte(em[klen - tlen - 1], 0x00);
	  ok &= safeEqual(em.slice(klen - tlen, klen - hlen), prefix);
	  ok &= safeEqual(em.slice(klen - hlen, klen), msg);

	  return ok === 1;
	}

	/**
	 * Encrypt a message with public key (PKCS1v1.5).
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function encrypt(msg, key) {
	  // [RFC8017] Page 28, Section 7.2.1.
	  assert(Buffer.isBuffer(msg));

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  const klen = k.size();

	  if (msg.length > klen - 11)
	    throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x02 || PS || 0x00 || M
	  const em = Buffer.alloc(klen);
	  const mlen = msg.length;
	  const plen = klen - mlen - 3;

	  em[0] = 0x00;
	  em[1] = 0x02;

	  rng.randomFill(em, 2, plen);

	  for (let i = 2; i < 2 + plen; i++) {
	    while (em[i] === 0x00)
	      rng.randomFill(em, i, 1);
	  }

	  em[klen - mlen - 1] = 0x00;

	  msg.copy(em, klen - mlen);

	  return k.encrypt(em);
	}

	/**
	 * Decrypt a message with private key (PKCS1v1.5).
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function decrypt(msg, key) {
	  // [RFC8017] Page 29, Section 7.2.2.
	  assert(Buffer.isBuffer(msg));

	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  const klen = k.size();

	  if (klen < 11)
	    throw new Error('Invalid RSA private key.');

	  if (msg.length !== klen)
	    throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || 0x02 || PS || 0x00 || M
	  const em = k.decrypt(msg);
	  const zero = safeEqualByte(em[0], 0x00);
	  const two = safeEqualByte(em[1], 0x02);

	  let index = 0;
	  let looking = 1;

	  for (let i = 2; i < em.length; i++) {
	    const equals0 = safeEqualByte(em[i], 0x00);

	    index = safeSelect(index, i, looking & equals0);
	    looking = safeSelect(looking, 0, equals0);
	  }

	  const validPS = safeLTE(2 + 8, index);
	  const valid = zero & two & (looking ^ 1) & validPS;
	  const offset = safeSelect(0, index + 1, valid);

	  if (valid === 0)
	    throw new Error('Invalid RSA ciphertext.');

	  return em.slice(offset);
	}

	/**
	 * Sign a message (PSS).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key - Private key.
	 * @param {Number} [saltLen=SALT_LENGTH_HASH]
	 * @returns {Buffer} PSS-formatted signature.
	 */

	function signPSS(hash, msg, key, saltLen) {
	  // [RFC8017] Page 33, Section 8.1.1.
	  if (saltLen == null)
	    saltLen = SALT_LENGTH_HASH;

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert((saltLen | 0) === saltLen);

	  if (msg.length !== hash.size)
	    throw new Error('Invalid RSA message size.');

	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  const bits = k.bits();
	  const klen = (bits + 7) >>> 3;
	  const emlen = (bits + 6) >>> 3;

	  if (saltLen === SALT_LENGTH_AUTO)
	    saltLen = emlen - 2 - hash.size;
	  else if (saltLen === SALT_LENGTH_HASH)
	    saltLen = hash.size;

	  if (saltLen < 0 || saltLen > klen)
	    throw new Error('Invalid PSS salt length.');

	  const salt = rng.randomBytes(saltLen);
	  const em = pssEncode(hash, msg, bits - 1, salt);

	  // Note that `em` may be one byte less
	  // than the modulus size in the case
	  // of (bits - 1) mod 8 == 0.
	  return k.decrypt(em);
	}

	/**
	 * Verify a signature (PSS).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PSS-formatted.
	 * @param {Buffer} key
	 * @param {Number} [saltLen=SALT_LENGTH_HASH]
	 * @returns {Boolean}
	 */

	function verifyPSS(hash, msg, sig, key, saltLen) {
	  if (saltLen == null)
	    saltLen = SALT_LENGTH_HASH;

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(sig));
	  assert(Buffer.isBuffer(key));
	  assert((saltLen | 0) === saltLen);

	  try {
	    return _verifyPSS(hash, msg, sig, key, saltLen);
	  } catch (e) {
	    return false;
	  }
	}

	/**
	 * Verify a signature (PSS).
	 * @private
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} sig - PSS-formatted.
	 * @param {Buffer} key
	 * @param {Number} saltLen
	 * @returns {Boolean}
	 */

	function _verifyPSS(hash, msg, sig, key, saltLen) {
	  // [RFC8017] Page 34, Section 8.1.2.
	  if (msg.length !== hash.size)
	    return false;

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    return false;

	  const bits = k.bits();
	  const klen = (bits + 7) >>> 3;

	  if (sig.length !== klen)
	    return false;

	  if (saltLen === SALT_LENGTH_AUTO)
	    saltLen = 0; // Handled in pssVerify.
	  else if (saltLen === SALT_LENGTH_HASH)
	    saltLen = hash.size;

	  if (saltLen < 0 || saltLen > klen)
	    return false;

	  let em = k.encrypt(sig);

	  // Edge case: the encoding crossed a
	  // a byte boundary. Our encryption
	  // function pads to the modulus size
	  // by default, meaning there's one
	  // extra zero byte prepended.
	  if (((bits - 1) & 7) === 0) {
	    if (em[0] !== 0x00)
	      return false;

	    em = em.slice(1);
	  }

	  return pssVerify(hash, msg, em, bits - 1, saltLen);
	}

	/**
	 * Encrypt a message with public key (OAEP).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @param {Buffer?} label
	 * @returns {Buffer}
	 */

	function encryptOAEP(hash, msg, key, label) {
	  // [RFC8017] Page 22, Section 7.1.1.
	  if (label == null)
	    label = EMPTY;

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(label));

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  const klen = k.size();
	  const mlen = msg.length;
	  const hlen = hash.size;

	  if (mlen > klen - 2 * hlen - 2)
	    throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
	  const em = Buffer.alloc(klen);
	  const lhash = hash.digest(label);
	  const seed = em.slice(1, 1 + hlen);
	  const db = em.slice(1 + hlen);
	  const dlen = db.length;

	  em[0] = 0x00;

	  rng.randomFill(seed, 0, seed.length);

	  lhash.copy(db, 0);
	  db.fill(0x00, hlen, dlen - mlen - 1);
	  db[dlen - mlen - 1] = 0x01;
	  msg.copy(db, dlen - mlen);

	  mgf1xor(hash, db, seed);
	  mgf1xor(hash, seed, db);

	  return k.encrypt(em);
	}

	/**
	 * Decrypt a message with private key (OAEP).
	 * @param {Object} hash
	 * @param {Buffer} msg
	 * @param {Buffer} key
	 * @param {Buffer?} label
	 * @returns {Buffer}
	 */

	function decryptOAEP(hash, msg, key, label) {
	  // [RFC8017] Page 25, Section 7.1.2.
	  if (label == null)
	    label = EMPTY;

	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(label));

	  const k = RSAPrivateKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA private key.');

	  const klen = k.size();
	  const mlen = msg.length;
	  const hlen = hash.size;

	  if (klen < hlen * 2 + 2)
	    throw new Error('Invalid RSA private key size.');

	  if (mlen !== klen)
	    throw new Error('Invalid RSA message size.');

	  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
	  const em = k.decrypt(msg);
	  const expect = hash.digest(label);
	  const zero = safeEqualByte(em[0], 0x00);
	  const seed = em.slice(1, hlen + 1);
	  const db = em.slice(hlen + 1);

	  mgf1xor(hash, seed, db);
	  mgf1xor(hash, db, seed);

	  const lhash = db.slice(0, hlen);
	  const lvalid = safeEqual(lhash, expect);
	  const rest = db.slice(hlen);

	  let looking = 1;
	  let index = 0;
	  let invalid = 0;

	  for (let i = 0; i < rest.length; i++) {
	    const equals0 = safeEqualByte(rest[i], 0x00);
	    const equals1 = safeEqualByte(rest[i], 0x01);

	    index = safeSelect(index, i, looking & equals1);
	    looking = safeSelect(looking, 0, equals1);
	    invalid = safeSelect(invalid, 1, looking & (equals0 ^ 1));
	  }

	  const valid = zero & lvalid & (invalid ^ 1) & (looking ^ 1);

	  if (valid === 0)
	    throw new Error('Invalid RSA ciphertext.');

	  return rest.slice(index + 1);
	}

	/**
	 * "Veil" an RSA ciphertext to hide the key size.
	 * @param {Buffer} msg
	 * @param {Number} bits
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function veil(msg, bits, key) {
	  assert(Buffer.isBuffer(msg));
	  assert((bits >>> 0) === bits);

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  if (msg.length !== k.size())
	    throw new Error('Invalid RSA ciphertext.');

	  if (bits < k.bits())
	    throw new Error('Cannot make ciphertext smaller.');

	  const bytes = (bits + 7) >>> 3;
	  const c = BN.decode(msg);

	  if (c.cmp(k.n) >= 0)
	    throw new Error('Invalid RSA ciphertext.');

	  const vmax = BN.shift(1, bits);
	  const rmax = vmax.sub(c).iadd(k.n).isubn(1).div(k.n);

	  assert(rmax.sign() > 0);

	  let v = vmax;

	  while (v.cmp(vmax) >= 0) {
	    const r = BN.random(rng, 0, rmax);

	    v = c.add(r.mul(k.n));
	  }

	  assert(v.mod(k.n).cmp(c) === 0);
	  assert(v.bitLength() <= bits);

	  return v.encode('be', bytes);
	}

	/**
	 * "Unveil" a veiled RSA ciphertext.
	 * @param {Buffer} msg
	 * @param {Number} bits
	 * @param {Buffer} key
	 * @returns {Buffer}
	 */

	function unveil(msg, bits, key) {
	  assert(Buffer.isBuffer(msg));
	  assert((bits >>> 0) === bits);

	  const k = RSAPublicKey.decode(key);

	  if (!k.verify())
	    throw new Error('Invalid RSA public key.');

	  const klen = k.size();

	  if (msg.length < klen)
	    throw new Error('Invalid RSA ciphertext.');

	  const v = BN.decode(msg);

	  if (bits !== 0 && v.bitLength() > bits)
	    throw new Error('Invalid RSA ciphertext.');

	  const c = v.imod(k.n);

	  return c.encode('be', klen);
	}

	/*
	 * Digest Info
	 */

	function getDigestInfo(name, msg) {
	  // [RFC8017] Page 63, Section B.1.
	  assert(name == null || typeof name === 'string');
	  assert(Buffer.isBuffer(msg));

	  if (name == null)
	    return [EMPTY, msg.length];

	  const prefix = digestInfo[name];

	  if (prefix == null)
	    return [null, 0];

	  if (prefix.length === 1)
	    return [EMPTY, prefix[0]];

	  return [
	    prefix,
	    prefix[prefix.length - 1]
	  ];
	}

	/*
	 * MGF1
	 */

	function mgf1xor(hash, out, seed) {
	  // [RFC8017] Page 67, Section B.2.1.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(out));
	  assert(Buffer.isBuffer(seed));

	  const ctr = Buffer.alloc(4, 0x00);

	  let i = 0;

	  while (i < out.length) {
	    const digest = hash.multi(seed, ctr);

	    let j = 0;

	    while (i < out.length && j < digest.length)
	      out[i++] ^= digest[j++];

	    for (j = 3; j >= 0; j--) {
	      ctr[j] += 1;

	      if (ctr[j] !== 0x00)
	        break;
	    }
	  }
	}

	/*
	 * PSS
	 */

	function pssEncode(hash, msg, embits, salt) {
	  // [RFC8017] Page 42, Section 9.1.1.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert((embits >>> 0) === embits);
	  assert(Buffer.isBuffer(salt));

	  const hlen = hash.size;
	  const slen = salt.length;
	  const emlen = (embits + 7) >>> 3;

	  if (msg.length !== hlen)
	    throw new Error('Invalid RSA message size.');

	  if (emlen < hlen + slen + 2)
	    throw new Error('Message too long.');

	  // EM = (PS || 0x01 || salt) || H || 0xbc
	  const em = Buffer.alloc(emlen);
	  const db = em.slice(0, emlen - hlen - 1);
	  const h = em.slice(emlen - hlen - 1, emlen - 1);
	  const h0 = hash.multi(PREFIX, msg, salt);
	  const mask = 0xff >>> (8 * emlen - embits);

	  db.fill(0x00, 0, emlen - slen - hlen - 2);
	  db[emlen - slen - hlen - 2] = 0x01;
	  salt.copy(db, emlen - slen - hlen - 1);
	  h0.copy(h, 0);
	  em[emlen - 1] = 0xbc;

	  mgf1xor(hash, db, h);

	  db[0] &= mask;

	  return em;
	}

	function pssVerify(hash, msg, em, embits, slen) {
	  // [RFC8017] Page 44, Section 9.1.2.
	  assert(hash && typeof hash.id === 'string');
	  assert(Buffer.isBuffer(msg));
	  assert(Buffer.isBuffer(em));
	  assert((embits >>> 0) === embits);
	  assert((slen >>> 0) === slen);

	  const hlen = hash.size;
	  const emlen = (embits + 7) >>> 3;

	  if (msg.length !== hlen)
	    return false;

	  if (emlen < hlen + slen + 2)
	    return false;

	  if (em[emlen - 1] !== 0xbc)
	    return false;

	  // EM = (PS || 0x01 || salt) || H || 0xbc
	  const db = em.slice(0, emlen - hlen - 1);
	  const h = em.slice(emlen - hlen - 1, emlen - 1);
	  const mask = 0xff >>> (8 * emlen - embits);

	  if (em[0] & ~mask)
	    return false;

	  mgf1xor(hash, db, h);

	  db[0] &= mask;

	  if (slen === 0) { // Auto
	    slen = -1;

	    for (let i = 0; i < db.length; i++) {
	      if (db[i] === 0x00)
	        continue;

	      if (db[i] === 0x01) {
	        slen = db.length - (i + 1);
	        break;
	      }

	      return false;
	    }

	    if (slen === -1)
	      return false;
	  } else {
	    const len = db.length - slen - 1;

	    for (let i = 0; i < len; i++) {
	      if (db[i] !== 0x00)
	        return false;
	    }

	    if (db[len] !== 0x01)
	      return false;
	  }

	  const salt = db.slice(db.length - slen);
	  const h0 = hash.multi(PREFIX, msg, salt);

	  return h0.equals(h);
	}

	/*
	 * Expose
	 */

	rsa.native = 0;
	rsa.SALT_LENGTH_AUTO = SALT_LENGTH_AUTO;
	rsa.SALT_LENGTH_HASH = SALT_LENGTH_HASH;
	rsa.privateKeyGenerate = privateKeyGenerate;
	rsa.privateKeyGenerateAsync = privateKeyGenerateAsync;
	rsa.privateKeyBits = privateKeyBits;
	rsa.privateKeyVerify = privateKeyVerify;
	rsa.privateKeyImport = privateKeyImport;
	rsa.privateKeyExport = privateKeyExport;
	rsa.publicKeyCreate = publicKeyCreate;
	rsa.publicKeyBits = publicKeyBits;
	rsa.publicKeyVerify = publicKeyVerify;
	rsa.publicKeyImport = publicKeyImport;
	rsa.publicKeyExport = publicKeyExport;
	rsa.sign = sign;
	rsa.verify = verify;
	rsa.encrypt = encrypt;
	rsa.decrypt = decrypt;
	rsa.signPSS = signPSS;
	rsa.verifyPSS = verifyPSS;
	rsa.encryptOAEP = encryptOAEP;
	rsa.decryptOAEP = decryptOAEP;
	rsa.veil = veil;
	rsa.unveil = unveil;
	return rsa;
}

var scrypt = {};

/*!
 * scrypt.js - scrypt for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *   Copyright (c) 2005-2016, Colin Percival. All rights reserved.
 *   Copyright (c) 2005-2016, Tarsnap Backup Inc. All rights reserved.
 *   Copyright (c) 2014, Sean Kelly. All rights reserved.
 *   https://github.com/Tarsnap/scrypt
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Scrypt
 *   http://www.tarsnap.com/scrypt.html
 *   http://www.tarsnap.com/scrypt/scrypt.pdf
 *   https://github.com/Tarsnap/scrypt/blob/master/lib/crypto/crypto_scrypt-ref.c
 */

var hasRequiredScrypt;

function requireScrypt () {
	if (hasRequiredScrypt) return scrypt;
	hasRequiredScrypt = 1;

	const assert = requireAssert();
	const pbkdf2 = requirePbkdf2();
	const SHA256 = requireSha256();

	/*
	 * Constants
	 */

	const SLAB1 = Buffer.alloc(64);
	const SLAB2 = new Uint32Array(16);
	const SLAB3 = new Uint32Array(16);

	/**
	 * Perform scrypt key derivation.
	 * @param {Buffer} passwd
	 * @param {Buffer} salt
	 * @param {Number} N
	 * @param {Number} r
	 * @param {Number} p
	 * @param {Number} len
	 * @returns {Buffer}
	 */

	function derive(passwd, salt, N, r, p, len) {
	  if (typeof passwd === 'string')
	    passwd = Buffer.from(passwd, 'utf8');

	  if (typeof salt === 'string')
	    salt = Buffer.from(salt, 'utf8');

	  if (salt == null)
	    salt = Buffer.alloc(0);

	  assert(Buffer.isBuffer(passwd));
	  assert(Buffer.isBuffer(salt));
	  assert((N >>> 0) === N);
	  assert((r >>> 0) === r);
	  assert((p >>> 0) === p);
	  assert((len >>> 0) === len);

	  if (r * p >= (1 << 30))
	    throw new Error('EFBIG');

	  if ((N & (N - 1)) !== 0 || N === 0)
	    throw new Error('EINVAL');

	  if (N > 0xffffffff)
	    throw new Error('EINVAL');

	  const XY = Buffer.alloc(256 * r);
	  const V = Buffer.alloc(128 * r * N);
	  const B = pbkdf2.derive(SHA256, passwd, salt, 1, p * 128 * r);

	  for (let i = 0; i < p; i++)
	    smix(B, i * 128 * r, r, N, V, XY);

	  clear();

	  return pbkdf2.derive(SHA256, passwd, B, 1, len);
	}

	/**
	 * Perform scrypt key derivation (async).
	 * @param {Buffer} passwd
	 * @param {Buffer} salt
	 * @param {Number} N
	 * @param {Number} r
	 * @param {Number} p
	 * @param {Number} len
	 * @returns {Promise}
	 */

	async function deriveAsync(passwd, salt, N, r, p, len) {
	  if (typeof passwd === 'string')
	    passwd = Buffer.from(passwd, 'utf8');

	  if (typeof salt === 'string')
	    salt = Buffer.from(salt, 'utf8');

	  if (salt == null)
	    salt = Buffer.alloc(0);

	  assert(Buffer.isBuffer(passwd));
	  assert(Buffer.isBuffer(salt));
	  assert((N >>> 0) === N);
	  assert((r >>> 0) === r);
	  assert((p >>> 0) === p);
	  assert((len >>> 0) === len);

	  if (r * p >= (1 << 30))
	    throw new Error('EFBIG');

	  if ((N & (N - 1)) !== 0 || N === 0)
	    throw new Error('EINVAL');

	  if (N > 0xffffffff)
	    throw new Error('EINVAL');

	  const XY = Buffer.alloc(256 * r);
	  const V = Buffer.alloc(128 * r * N);
	  const B = await pbkdf2.deriveAsync(SHA256, passwd, salt, 1, p * 128 * r);

	  for (let i = 0; i < p; i++)
	    await smixAsync(B, i * 128 * r, r, N, V, XY);

	  clear();

	  return pbkdf2.deriveAsync(SHA256, passwd, B, 1, len);
	}

	/*
	 * Helpers
	 */

	function salsa20_8(B) {
	  const B32 = SLAB2;
	  const X = SLAB3;

	  for (let i = 0; i < 16; i++)
	    B32[i] = readU32(B, i * 4);

	  for (let i = 0; i < 16; i++)
	    X[i] = B32[i];

	  for (let i = 0; i < 8; i += 2) {
	    X[4] ^= R(X[0] + X[12], 7);
	    X[8] ^= R(X[4] + X[0], 9);
	    X[12] ^= R(X[8] + X[4], 13);
	    X[0] ^= R(X[12] + X[8], 18);

	    X[9] ^= R(X[5] + X[1], 7);
	    X[13] ^= R(X[9] + X[5], 9);
	    X[1] ^= R(X[13] + X[9], 13);
	    X[5] ^= R(X[1] + X[13], 18);

	    X[14] ^= R(X[10] + X[6], 7);
	    X[2] ^= R(X[14] + X[10], 9);
	    X[6] ^= R(X[2] + X[14], 13);
	    X[10] ^= R(X[6] + X[2], 18);

	    X[3] ^= R(X[15] + X[11], 7);
	    X[7] ^= R(X[3] + X[15], 9);
	    X[11] ^= R(X[7] + X[3], 13);
	    X[15] ^= R(X[11] + X[7], 18);

	    X[1] ^= R(X[0] + X[3], 7);
	    X[2] ^= R(X[1] + X[0], 9);
	    X[3] ^= R(X[2] + X[1], 13);
	    X[0] ^= R(X[3] + X[2], 18);

	    X[6] ^= R(X[5] + X[4], 7);
	    X[7] ^= R(X[6] + X[5], 9);
	    X[4] ^= R(X[7] + X[6], 13);
	    X[5] ^= R(X[4] + X[7], 18);

	    X[11] ^= R(X[10] + X[9], 7);
	    X[8] ^= R(X[11] + X[10], 9);
	    X[9] ^= R(X[8] + X[11], 13);
	    X[10] ^= R(X[9] + X[8], 18);

	    X[12] ^= R(X[15] + X[14], 7);
	    X[13] ^= R(X[12] + X[15], 9);
	    X[14] ^= R(X[13] + X[12], 13);
	    X[15] ^= R(X[14] + X[13], 18);
	  }

	  for (let i = 0; i < 16; i++)
	    B32[i] += X[i];

	  for (let i = 0; i < 16; i++)
	    writeU32(B, B32[i], 4 * i);
	}

	function R(a, b) {
	  return (a << b) | (a >>> (32 - b));
	}

	function blockmix_salsa8(B, Y, Yo, r) {
	  const X = SLAB1;

	  blkcpy(X, B, 0, (2 * r - 1) * 64, 64);

	  for (let i = 0; i < 2 * r; i++) {
	    blkxor(X, B, 0, i * 64, 64);
	    salsa20_8(X);
	    blkcpy(Y, X, Yo + i * 64, 0, 64);
	  }

	  for (let i = 0; i < r; i++)
	    blkcpy(B, Y, i * 64, Yo + (i * 2) * 64, 64);

	  for (let i = 0; i < r; i++)
	    blkcpy(B, Y, (i + r) * 64, Yo + (i * 2 + 1) * 64, 64);
	}

	function integerify(B, r) {
	  return readU32(B, (2 * r - 1) * 64);
	}

	function smix(B, Bo, r, N, V, XY) {
	  const X = XY;
	  const Y = XY;

	  blkcpy(X, B, 0, Bo, 128 * r);

	  for (let i = 0; i < N; i++) {
	    blkcpy(V, X, i * (128 * r), 0, 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	  }

	  for (let i = 0; i < N; i++) {
	    const j = integerify(X, r) & (N - 1);

	    blkxor(X, V, 0, j * (128 * r), 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);
	  }

	  blkcpy(B, X, Bo, 0, 128 * r);
	}

	async function smixAsync(B, Bo, r, N, V, XY) {
	  const X = XY;
	  const Y = XY;

	  blkcpy(X, B, 0, Bo, 128 * r);

	  for (let i = 0; i < N; i++) {
	    blkcpy(V, X, i * (128 * r), 0, 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);

	    await wait();
	  }

	  for (let i = 0; i < N; i++) {
	    const j = integerify(X, r) & (N - 1);

	    blkxor(X, V, 0, j * (128 * r), 128 * r);
	    blockmix_salsa8(X, Y, 128 * r, r);

	    await wait();
	  }

	  blkcpy(B, X, Bo, 0, 128 * r);
	}

	function blkcpy(dst, src, dstOff, srcOff, len) {
	  src.copy(dst, dstOff, srcOff, srcOff + len);
	}

	function blkxor(dst, src, dstOff, srcOff, len) {
	  for (let i = 0; i < len; i++)
	    dst[dstOff + i] ^= src[srcOff + i];
	}

	function wait() {
	  return new Promise(r => setImmediate(r));
	}

	function clear() {
	  for (let i = 0; i < 64; i++)
	    SLAB1[i] = 0;

	  for (let i = 0; i < 16; i++) {
	    SLAB2[i] = 0;
	    SLAB3[i] = 0;
	  }
	}

	function readU32(data, off) {
	  return (data[off++]
	        + data[off++] * 0x100
	        + data[off++] * 0x10000
	        + data[off] * 0x1000000);
	}

	function writeU32(dst, num, off) {
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  num >>>= 8;
	  dst[off++] = num;
	  return off;
	}

	/*
	 * Expose
	 */

	scrypt.native = 0;
	scrypt.derive = derive;
	scrypt.deriveAsync = deriveAsync;
	return scrypt;
}

/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */

var sha224;
var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224;
	hasRequiredSha224 = 1;

	const assert = requireAssert();
	const SHA256 = requireSha256();
	const HMAC = requireHmac();

	/**
	 * SHA224
	 */

	class SHA224 extends SHA256 {
	  constructor() {
	    super();
	  }

	  init() {
	    this.state[0] = 0xc1059ed8;
	    this.state[1] = 0x367cd507;
	    this.state[2] = 0x3070dd17;
	    this.state[3] = 0xf70e5939;
	    this.state[4] = 0xffc00b31;
	    this.state[5] = 0x68581511;
	    this.state[6] = 0x64f98fa7;
	    this.state[7] = 0xbefa4fa4;
	    this.size = 0;
	    return this;
	  }

	  final() {
	    return super.final().slice(0, 28);
	  }

	  static hash() {
	    return new SHA224();
	  }

	  static hmac() {
	    return new HMAC(SHA224, 64);
	  }

	  static digest(data) {
	    return SHA224.ctx.init().update(data).final();
	  }

	  static root(left, right) {
	    assert(Buffer.isBuffer(left) && left.length === 28);
	    assert(Buffer.isBuffer(right) && right.length === 28);
	    return SHA224.ctx.init().update(left).update(right).final();
	  }

	  static multi(x, y, z) {
	    const {ctx} = SHA224;

	    ctx.init();
	    ctx.update(x);
	    ctx.update(y);

	    if (z)
	      ctx.update(z);

	    return ctx.final();
	  }

	  static mac(data, key) {
	    return SHA224.hmac().init(key).update(data).final();
	  }
	}

	/*
	 * Static
	 */

	SHA224.native = 0;
	SHA224.id = 'SHA224';
	SHA224.size = 28;
	SHA224.bits = 224;
	SHA224.blockSize = 64;
	SHA224.zero = Buffer.alloc(28, 0x00);
	SHA224.ctx = new SHA224();

	/*
	 * Expose
	 */

	sha224 = SHA224;
	return sha224;
}

/*!
 * bcrypto.js - crypto for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */

var hasRequiredBcrypto;

function requireBcrypto () {
	if (hasRequiredBcrypto) return bcrypto;
	hasRequiredBcrypto = 1;
	(function (exports) {

		// exports.AEAD = require('./aead');
		exports.aes = requireAes();
		// exports.ARC4 = require('./arc4');
		// exports.bcrypt = require('./bcrypt');
		// exports.BLAKE2b = require('./blake2b');
		// exports.BLAKE2b160 = require('./blake2b160');
		// exports.BLAKE2b256 = require('./blake2b256');
		// exports.BLAKE2b384 = require('./blake2b384');
		// exports.BLAKE2b512 = require('./blake2b512');
		// exports.BLAKE2s = require('./blake2s');
		// exports.BLAKE2s128 = require('./blake2s128');
		// exports.BLAKE2s160 = require('./blake2s160');
		// exports.BLAKE2s224 = require('./blake2s224');
		// exports.BLAKE2s256 = require('./blake2s256');
		exports.BN = requireBn();
		// exports.box = require('./box');
		exports.ChaCha20 = requireChacha20();
		// exports.cipher = require('./cipher');
		exports.cleanse = requireCleanse();
		// exports.CSHAKE = require('./cshake');
		// exports.CSHAKE128 = require('./cshake128');
		// exports.CSHAKE256 = require('./cshake256');
		// exports.CtrDRBG = require('./ctr-drbg');
		// exports.dsa = require('./dsa');
		// exports.dsaies = require('./dsaies');
		// exports.eb2k = require('./eb2k');
		// exports.ecies = require('./ecies');
		// exports.ed25519 = require('./ed25519');
		// exports.ed448 = require('./ed448');
		// exports.encoding = require('./encoding');
		// exports.GOST94 = require('./gost94');
		exports.Hash160 = requireHash160();
		exports.Hash256 = requireHash256();
		// exports.HashDRBG = require('./hash-drbg');
		// exports.hkdf = require('./hkdf');
		exports.HmacDRBG = requireHmacDrbg();
		exports.Keccak = requireKeccak();
		// exports.Keccak224 = require('./keccak224');
		// exports.Keccak256 = require('./keccak256');
		// exports.Keccak384 = require('./keccak384');
		// exports.Keccak512 = require('./keccak512');
		// exports.KMAC = require('./kmac');
		// exports.KMAC128 = require('./kmac128');
		// exports.KMAC256 = require('./kmac256');
		// exports.MD2 = require('./md2');
		// exports.MD4 = require('./md4');
		// exports.MD5 = require('./md5');
		// exports.MD5SHA1 = require('./md5sha1');
		exports.merkle = requireMerkle();
		// exports.mrkl = require('./mrkl');
		exports.murmur3 = requireMurmur3();
		// exports.p192 = require('./p192');
		exports.p224 = requireP224();
		exports.p256 = requireP256();
		exports.p384 = requireP384();
		exports.p521 = requireP521();
		exports.pbkdf2 = requirePbkdf2();
		// exports.pgp = require('./pgp');
		// exports.Poly1305 = require('./poly1305');
		exports.random = requireRandom();
		exports.RIPEMD160 = requireRipemd160();
		exports.rsa = requireRsa();
		// exports.rsaies = require('./rsaies');
		exports.safe = requireSafe();
		// exports.Salsa20 = require('./salsa20');
		// exports.schnorr = require('./schnorr');
		exports.scrypt = requireScrypt();
		exports.secp256k1 = requireSecp256k1();
		// exports.secretbox = require('./secretbox');
		// exports.ssh = require('./ssh');
		exports.SHA1 = requireSha1();
		exports.SHA224 = requireSha224();
		exports.SHA256 = requireSha256();
		exports.SHA384 = requireSha384();
		exports.SHA512 = requireSha512();
		// exports.SHA3 = require('./sha3');
		// exports.SHA3_224 = require('./sha3-224');
		// exports.SHA3_256 = require('./sha3-256');
		// exports.SHA3_384 = require('./sha3-384');
		// exports.SHA3_512 = require('./sha3-512');
		exports.SHAKE = requireShake();
		// exports.SHAKE128 = require('./shake128');
		exports.SHAKE256 = requireShake256();
		// exports.siphash = require('./siphash');
		// exports.Whirlpool = require('./whirlpool');
		// exports.x25519 = require('./x25519');
		// exports.x448 = require('./x448');

		exports.version = '5.5.1';
		exports.native = exports.SHA256.native; 
	} (bcrypto));
	return bcrypto;
}

var bfilter = {};

/*!
 * bloom.js - bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var bloom;
var hasRequiredBloom;

function requireBloom () {
	if (hasRequiredBloom) return bloom;
	hasRequiredBloom = 1;

	const {enforce} = require$$0$3;
	const bio = require$$1;
	const murmur3 = requireMurmur3();

	/*
	 * Constants
	 */

	const DUMMY = Buffer.alloc(0);
	const LN2SQUARED = 0.4804530139182014246671025263266649717305529515945455;
	const LN2 = 0.6931471805599453094172321214581765680755001343602552;

	/**
	 * Bloom Filter
	 */

	class BloomFilter extends bio.Struct {
	  /**
	   * Create a bloom filter.
	   * @constructor
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @property {Buffer} filter
	   * @property {Number} size
	   * @property {Number} n
	   * @property {Number} tweak
	   * @property {Number} update - Update flag (see {@link BloomFilter.flags}).
	   */

	  constructor(size, n, tweak, update) {
	    super();

	    this.filter = DUMMY;
	    this.size = 0;
	    this.n = 0;
	    this.tweak = 0;
	    this.update = BloomFilter.flags.NONE;

	    if (size != null)
	      this.fromOptions(size, n, tweak, update);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @returns {BloomFilter}
	   */

	  fromOptions(size, n, tweak, update) {
	    if (tweak == null || tweak === -1)
	      tweak = (Math.random() * 0x100000000) >>> 0;

	    if (update == null || update === -1)
	      update = BloomFilter.flags.NONE;

	    if (typeof update === 'string') {
	      update = BloomFilter.flags[update.toUpperCase()];
	      enforce(update != null, 'update', 'flag');
	    }

	    enforce(Number.isSafeInteger(size) && size >= 0, 'size', 'integer');
	    enforce(Number.isSafeInteger(n) && n >= 0, 'n', 'integer');
	    enforce((tweak >>> 0) === tweak, 'tweak', 'integer');
	    enforce((update >>> 0) === update, 'update', 'integer');
	    enforce(update <= 2, 'update', 'range between 0 and 2');

	    if (size < 8)
	      size = 8;

	    if (n === 0)
	      n = 1;

	    size -= size & 7;

	    this.filter = Buffer.alloc(size / 8, 0x00);
	    this.size = size;
	    this.n = n;
	    this.tweak = tweak;
	    this.update = update;

	    return this;
	  }

	  /**
	   * Instantiate bloom filter from options.
	   * @param {Number} size - Filter size in bits.
	   * @param {Number} n - Number of hash functions.
	   * @param {Number} tweak - Seed value.
	   * @param {Number|String} - Update type.
	   * @returns {BloomFilter}
	   */

	  static fromOptions(size, n, tweak, update) {
	    return new this().fromOptions(size, n, tweak, update);
	  }

	  /**
	   * Perform the mumur3 hash on data.
	   * @param {Buffer} value
	   * @param {Number} n
	   * @returns {Number}
	   */

	  hash(value, n) {
	    return murmur3.tweak(value, n, this.tweak) % this.size;
	  }

	  /**
	   * Reset the filter.
	   */

	  reset() {
	    this.filter.fill(0);
	  }

	  /**
	   * Add data to the filter.
	   * @param {Buffer|String}
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   */

	  add(value, enc) {
	    const val = toBuffer(value, enc);

	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      this.filter[index >>> 3] |= 1 << (7 & index);
	    }
	  }

	  /**
	   * Test whether data is present in the filter.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean}
	   */

	  test(value, enc) {
	    const val = toBuffer(value, enc);

	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      if ((this.filter[index >>> 3] & (1 << (7 & index))) === 0)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Test whether data is present in the
	   * filter and potentially add data.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean} Whether data was added.
	   */

	  added(value, enc) {
	    const val = toBuffer(value, enc);

	    let ret = false;

	    for (let i = 0; i < this.n; i++) {
	      const index = this.hash(val, i);
	      if (!ret && (this.filter[index >>> 3] & (1 << (7 & index))) === 0)
	        ret = true;
	      this.filter[index >>> 3] |= 1 << (7 & index);
	    }

	    return ret;
	  }

	  /**
	   * Create a filter from a false positive rate.
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @param {Number|String} update
	   * @example
	   * BloomFilter.fromRate(800000, 0.0001, 'none');
	   * @returns {BloomFilter}
	   */

	  static fromRate(items, rate, update) {
	    enforce(Number.isSafeInteger(items) && items > 0, 'items', 'integer');
	    enforce(typeof rate === 'number' && isFinite(rate), 'rate', 'number');
	    enforce(rate >= 0 && rate <= 1, 'rate', 'range between 0.1 and 1.0.');

	    const bits = (-1 / LN2SQUARED * items * Math.log(rate)) | 0;
	    const size = Math.max(8, bits);

	    if (update !== -1) {
	      if (size > BloomFilter.MAX_BLOOM_FILTER_SIZE * 8)
	        throw new Error('Bloom filter size violates policy limits!');
	    }

	    const n = Math.max(1, (size / items * LN2) | 0);

	    if (update !== -1) {
	      if (n > BloomFilter.MAX_HASH_FUNCS)
	        throw new Error('Bloom filter size violates policy limits!');
	    }

	    return new this(size, n, -1, update);
	  }

	  /**
	   * Ensure the filter is within the size limits.
	   * @returns {Boolean}
	   */

	  isWithinConstraints() {
	    if (this.size > BloomFilter.MAX_BLOOM_FILTER_SIZE * 8)
	      return false;

	    if (this.n > BloomFilter.MAX_HASH_FUNCS)
	      return false;

	    return true;
	  }

	  /**
	   * Get serialization size.
	   * @returns {Number}
	   */

	  getSize() {
	    return bio.sizeVarBytes(this.filter) + 9;
	  }

	  /**
	   * Write filter to buffer writer.
	   * @param {BufferWriter} bw
	   */

	  write(bw) {
	    bw.writeVarBytes(this.filter);
	    bw.writeU32(this.n);
	    bw.writeU32(this.tweak);
	    bw.writeU8(this.update);
	    return bw;
	  }

	  /**
	   * Inject properties from buffer reader.
	   * @private
	   * @param {BufferReader} br
	   */

	  read(br) {
	    this.filter = br.readVarBytes();
	    this.size = this.filter.length * 8;
	    this.n = br.readU32();
	    this.tweak = br.readU32();
	    this.update = br.readU8();

	    if (this.update > 2)
	      throw new Error('Invalid update flag.');

	    return this;
	  }
	}

	/**
	 * Max bloom filter size.
	 * @const {Number}
	 * @default
	 */

	BloomFilter.MAX_BLOOM_FILTER_SIZE = 36000;

	/**
	 * Max number of hash functions.
	 * @const {Number}
	 * @default
	 */

	BloomFilter.MAX_HASH_FUNCS = 50;

	/**
	 * Bloom filter update flags.
	 * @enum {Number}
	 * @default
	 */

	BloomFilter.flags = {
	  /**
	   * Never update the filter with outpoints.
	   */

	  NONE: 0,

	  /**
	   * Always update the filter with outpoints.
	   */

	  ALL: 1,

	  /**
	   * Only update the filter with outpoints if it is
	   * "asymmetric" in terms of addresses (pubkey/multisig).
	   */

	  PUBKEY_ONLY: 2
	};

	/**
	 * Bloom filter update flags by value.
	 * @const {RevMap}
	 */

	BloomFilter.flagsByVal = [
	  'NONE',
	  'ALL',
	  'PUBKEY_ONLY'
	];

	/*
	 * Helpers
	 */

	function toBuffer(value, enc) {
	  if (typeof value !== 'string') {
	    enforce(Buffer.isBuffer(value), 'value', 'buffer');
	    return value;
	  }

	  enforce(typeof enc === 'string', 'enc', 'string');

	  return Buffer.from(value, enc);
	}

	/*
	 * Expose
	 */

	bloom = BloomFilter;
	return bloom;
}

/*!
 * rollingfilter.js - rolling bloom filter for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var rolling;
var hasRequiredRolling;

function requireRolling () {
	if (hasRequiredRolling) return rolling;
	hasRequiredRolling = 1;

	const {enforce} = require$$0$3;
	const {encoding} = require$$1;
	const murmur3 = requireMurmur3();
	const DUMMY = Buffer.alloc(0);

	/**
	 * Rolling Bloom Filter
	 */

	class RollingFilter {
	  /**
	   * Create a rolling bloom filter.
	   * @constructor
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   */

	  constructor(items, rate) {
	    this.entries = 0;
	    this.generation = 1;
	    this.n = 0;
	    this.limit = 0;
	    this.size = 0;
	    this.items = 0;
	    this.tweak = 0;
	    this.filter = DUMMY;

	    if (items != null)
	      this.fromRate(items, rate);
	  }

	  /**
	   * Inject properties from items and FPR.
	   * @private
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @returns {RollingFilter}
	   */

	  fromRate(items, rate) {
	    enforce(Number.isSafeInteger(items) && items > 0, 'items', 'integer');
	    enforce(typeof rate === 'number' && isFinite(rate), 'rate', 'number');
	    enforce(rate >= 0 && rate <= 1, 'rate', 'range between 0.1 and 1.0.');

	    const logRate = Math.log(rate);

	    const n = Math.max(1, Math.min(Math.round(logRate / Math.log(0.5)), 50));
	    const limit = (items + 1) / 2 | 0;

	    const max = limit * 3;

	    let size = -1 * n * max / Math.log(1.0 - Math.exp(logRate / n));
	    size = Math.ceil(size);

	    items = ((size + 63) / 64 | 0) << 1;
	    items >>>= 0;
	    items = Math.max(1, items);

	    const tweak = (Math.random() * 0x100000000) >>> 0;

	    const filter = Buffer.alloc(items * 8, 0x00);

	    this.n = n;
	    this.limit = limit;
	    this.size = size;
	    this.items = items;
	    this.tweak = tweak;
	    this.filter = filter;

	    return this;
	  }

	  /**
	   * Instantiate rolling filter from items and FPR.
	   * @param {Number} items - Expected number of items.
	   * @param {Number} rate - False positive rate (0.0-1.0).
	   * @returns {RollingFilter}
	   */

	  static fromRate(items, rate) {
	    return new this().fromRate(items, rate);
	  }

	  /**
	   * Perform the mumur3 hash on data.
	   * @param {Buffer} value
	   * @param {Number} seed
	   * @returns {Number}
	   */

	  hash(value, n) {
	    return murmur3.tweak(value, n, this.tweak);
	  }

	  /**
	   * Reset the filter.
	   */

	  reset() {
	    if (this.entries === 0)
	      return;

	    this.entries = 0;
	    this.generation = 1;
	    this.filter.fill(0);
	  }

	  /**
	   * Add data to the filter.
	   * @param {Buffer|String}
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   */

	  add(value, enc) {
	    const val = toBuffer(value, enc);

	    if (this.entries === this.limit) {
	      this.entries = 0;
	      this.generation += 1;

	      if (this.generation === 4)
	        this.generation = 1;

	      const m1 = (this.generation & 1) * 0xffffffff;
	      const m2 = (this.generation >>> 1) * 0xffffffff;

	      for (let i = 0; i < this.items; i += 2) {
	        const pos1 = i * 8;
	        const pos2 = (i + 1) * 8;
	        const v1 = read(this.filter, pos1);
	        const v2 = read(this.filter, pos2);
	        const mhi = (v1.hi ^ m1) | (v2.hi ^ m2);
	        const mlo = (v1.lo ^ m1) | (v2.lo ^ m2);

	        v1.hi &= mhi;
	        v1.lo &= mlo;
	        v2.hi &= mhi;
	        v2.lo &= mlo;

	        write(this.filter, v1, pos1);
	        write(this.filter, v2, pos2);
	      }
	    }

	    this.entries += 1;

	    for (let i = 0; i < this.n; i++) {
	      const hash = this.hash(val, i);
	      const bits = hash & 0x3f;
	      const pos = (hash >>> 6) % this.items;
	      const pos1 = (pos & -2) * 8;
	      const pos2 = (pos | 1) * 8;
	      const bit = bits % 8;
	      const oct = (bits - bit) / 8;

	      this.filter[pos1 + oct] &= ~(1 << bit);
	      this.filter[pos1 + oct] |= (this.generation & 1) << bit;

	      this.filter[pos2 + oct] &= ~(1 << bit);
	      this.filter[pos2 + oct] |= (this.generation >>> 1) << bit;
	    }
	  }

	  /**
	   * Test whether data is present in the filter.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean}
	   */

	  test(value, enc) {
	    if (this.entries === 0)
	      return false;

	    const val = toBuffer(value, enc);

	    for (let i = 0; i < this.n; i++) {
	      const hash = this.hash(val, i);
	      const bits = hash & 0x3f;
	      const pos = (hash >>> 6) % this.items;
	      const pos1 = (pos & -2) * 8;
	      const pos2 = (pos | 1) * 8;
	      const bit = bits % 8;
	      const oct = (bits - bit) / 8;

	      const bit1 = (this.filter[pos1 + oct] >>> bit) & 1;
	      const bit2 = (this.filter[pos2 + oct] >>> bit) & 1;

	      if ((bit1 | bit2) === 0)
	        return false;
	    }

	    return true;
	  }

	  /**
	   * Test whether data is present in the
	   * filter and potentially add data.
	   * @param {Buffer|String} value
	   * @param {String?} enc - Can be any of the Buffer object's encodings.
	   * @returns {Boolean} Whether data was added.
	   */

	  added(value, enc) {
	    const val = toBuffer(value, enc);

	    if (!this.test(val)) {
	      this.add(val);
	      return true;
	    }

	    return false;
	  }
	}

	/*
	 * Helpers
	 */

	class U64 {
	  constructor(hi, lo) {
	    this.hi = hi;
	    this.lo = lo;
	  }
	}

	function read(data, off) {
	  const hi = encoding.readU32(data, off + 4);
	  const lo = encoding.readU32(data, off);
	  return new U64(hi, lo);
	}

	function write(data, value, off) {
	  encoding.writeU32(data, value.hi, off + 4);
	  encoding.writeU32(data, value.lo, off);
	}

	function toBuffer(value, enc) {
	  if (typeof value !== 'string') {
	    enforce(Buffer.isBuffer(value), 'value', 'buffer');
	    return value;
	  }

	  enforce(typeof enc === 'string', 'enc', 'string');

	  return Buffer.from(value, enc);
	}

	/*
	 * Expose
	 */

	rolling = RollingFilter;
	return rolling;
}

/*!
 * bfilter.js - bloom filters for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBfilter;

function requireBfilter () {
	if (hasRequiredBfilter) return bfilter;
	hasRequiredBfilter = 1;

	const BloomFilter = requireBloom();
	const RollingFilter = requireRolling();

	bfilter.BloomFilter = BloomFilter;
	bfilter.RollingFilter = RollingFilter;
	return bfilter;
}

var b70 = {};

var certs;
var hasRequiredCerts;

function requireCerts () {
	if (hasRequiredCerts) return certs;
	hasRequiredCerts = 1;

	certs = [
	  Buffer.from(
	    'ebd41040e4bb3ec742c9e381d31ef2a41a48b6685c96e7cef3c1df6cd4331c99',
	    'hex'),
	  Buffer.from(
	    'ca42dd41745fd0b81eb902362cf9d8bf719da1bd1b1efc946f5b4c99f42c1b9e',
	    'hex'),
	  Buffer.from(
	    'eb04cf5eb1f39afa762f2bb120f296cba520c1b97db1589565b81cb9a17b7244',
	    'hex'),
	  Buffer.from(
	    '6dc47172e01cbcb0bf62580d895fe2b8ac9ad4f873801e0c10b9c837d21eb177',
	    'hex'),
	  Buffer.from(
	    '16af57a9f676b0ab126095aa5ebadef22ab31119d644ac95cd4b93dbf3f26aeb',
	    'hex'),
	  Buffer.from(
	    '687fa451382278fff0c8b11f8d43d576671c6eb2bceab413fb83d965d06d2ff2',
	    'hex'),
	  Buffer.from(
	    '73c176434f1bc6d5adf45b0e76e727287c8de57616c1e6e6141a2b2cbc7d8e4c',
	    'hex'),
	  Buffer.from(
	    'ff856a2d251dcd88d36656f450126798cfabaade40799c722de4d2b5db36a73a',
	    'hex'),
	  Buffer.from(
	    'a0459b9f63b22559f5fa5d4c6db3f9f72ff19342033578f073bf1d1b46cbb912',
	    'hex'),
	  Buffer.from(
	    'a0234f3bc8527ca5628eec81ad5d69895da5680dc91d1cb8477f33f878b95b0b',
	    'hex'),
	  Buffer.from(
	    '69fac9bd55fb0ac78d53bbee5cf1d597989fd0aaab20a25151bdf1733ee7d122',
	    'hex'),
	  Buffer.from(
	    'd7a7a0fb5d7e2731d771e9484ebcdef71d5f0c3e0a2948782bc83ee0ea699ef4',
	    'hex'),
	  Buffer.from(
	    'a45ede3bbbf09c8ae15c72efc07268d693a21c996fd51e67ca079460fd6d8873',
	    'hex'),
	  Buffer.from(
	    '85a0dd7dd720adb7ff05f83d542b209dc7ff4528f7d677b18389fea5e5c49e86',
	    'hex'),
	  Buffer.from(
	    '18f1fc7f205df8adddeb7fe007dd57e3af375a9c4d8d73546bf4f1fed1e18d35',
	    'hex'),
	  Buffer.from(
	    'e75e72ed9f560eec6eb4800073a43fc3ad19195a392282017895974a99026b6c',
	    'hex'),
	  Buffer.from(
	    '7908b40314c138100b518d0735807ffbfcf8518a0095337105ba386b153dd927',
	    'hex'),
	  Buffer.from(
	    'cecddc905099d8dadfc5b1d209b737cbe2c18cfb2c10c0ff0bcf0d3286fc1aa2',
	    'hex'),
	  Buffer.from(
	    'c3846bf24b9e93ca64274c0ec67c1ecc5e024ffcacd2d74019350e81fe546ae4',
	    'hex'),
	  Buffer.from(
	    '1465fa205397b876faa6f0a9958e5590e40fcc7faa4fb7c2c8677521fb5fb658',
	    'hex'),
	  Buffer.from(
	    '7600295eefe85b9e1fd624db76062aaaae59818a54d2774cd4c0b2c01131e1b3',
	    'hex'),
	  Buffer.from(
	    '3e9099b5015e8f486c00bcea9d111ee721faba355a89bcf1df69561e3dc6325c',
	    'hex'),
	  Buffer.from(
	    '4348a0e9444c78cb265e058d5e8944b4d84f9662bd26db257f8934a443c70161',
	    'hex'),
	  Buffer.from(
	    '7431e5f4c3c1ce4690774f0b61e05440883ba9a01ed00ba6abd7806ed3b118cf',
	    'hex'),
	  Buffer.from(
	    '0f993c8aef97baaf5687140ed59ad1821bb4afacf0aa9a58b5d57a338a3afbcb',
	    'hex'),
	  Buffer.from(
	    '0687260331a72403d909f105e69bcf0d32e1bd2493ffc6d9206d11bcd6770739',
	    'hex'),
	  Buffer.from(
	    '62dd0be9b9f50a163ea0f8e75c053b1eca57ea55c8688f647c6881f2c8357b95',
	    'hex'),
	  Buffer.from(
	    'be6c4da2bbb9ba59b6f3939768374246c3c005993fa98f020d1dedbed48a81d5',
	    'hex'),
	  Buffer.from(
	    '37d51006c512eaab626421f1ec8c92013fc5f82ae98ee533eb4619b8deb4d06c',
	    'hex'),
	  Buffer.from(
	    '8d722f81a9c113c0791df136a2966db26c950a971db46b4199f4ea54b78bfb9f',
	    'hex'),
	  Buffer.from(
	    '9acfab7e43c8d880d06b262a94deeee4b4659989c3d0caf19baf6405e41ab7df',
	    'hex'),
	  Buffer.from(
	    'f1c1b50ae5a20dd8030ec9f6bc24823dd367b5255759b4e71b61fce9f7375d73',
	    'hex'),
	  Buffer.from(
	    '4200f5043ac8590ebb527d209ed1503029fbcbd41ca1b506ec27f15ade7dac69',
	    'hex'),
	  Buffer.from(
	    '0c2cd63df7806fa399ede809116b575bf87989f06518f9808c860503178baf66',
	    'hex'),
	  Buffer.from(
	    '15f0ba00a3ac7af3ac884c072b1011a077bd77c097f40164b2f8598abd83860c',
	    'hex'),
	  Buffer.from(
	    '1793927a0614549789adce2f8f34f7f0b66d0f3ae3a3b84d21ec15dbba4fadc7',
	    'hex'),
	  Buffer.from(
	    '41c923866ab4cad6b7ad578081582e020797a6cbdf4fff78ce8396b38937d7f5',
	    'hex'),
	  Buffer.from(
	    'e3b6a2db2ed7ce48842f7ac53241c7b71d54144bfb40c11f3f1d0b42f5eea12d',
	    'hex'),
	  Buffer.from(
	    'b6191a50d0c3977f7da99bcdaac86a227daeb9679ec70ba3b0c9d92271c170d3',
	    'hex'),
	  Buffer.from(
	    '960adf0063e96356750c2965dd0a0867da0b9cbd6e77714aeafb2349ab393da3',
	    'hex'),
	  Buffer.from(
	    'c0a6f4dc63a24bfdcf54ef2a6a082a0a72de35803e2ff5ff527ae5d87206dfd5',
	    'hex'),
	  Buffer.from(
	    'eaa962c4fa4a6bafebe415196d351ccd888d4f53f3fa8ae6d7c466a94e6042bb',
	    'hex'),
	  Buffer.from(
	    'b478b812250df878635c2aa7ec7d155eaa625ee82916e2cd294361886cd1fbd4',
	    'hex'),
	  Buffer.from(
	    'a4310d50af18a6447190372a86afaf8b951ffb431d837f1e5688b45971ed1557',
	    'hex'),
	  Buffer.from(
	    '4b03f45807ad70f21bfc2cae71c9fde4604c064cf5ffb686bae5dbaad7fdd34c',
	    'hex'),
	  Buffer.from(
	    '5edb7ac43b82a06a8761e8d7be4979ebf2611f7dd79bf91c1c6b566a219ed766',
	    'hex'),
	  Buffer.from(
	    '2399561127a57125de8cefea610ddf2fa078b5c8067f4e828290bfb860e84b3c',
	    'hex'),
	  Buffer.from(
	    '69ddd7ea90bb57c93e135dc85ea6fcd5480b603239bdc454fc758b2a26cf7f79',
	    'hex'),
	  Buffer.from(
	    '6c61dac3a2def031506be036d2a6fe401994fbd13df9c8d466599274c446ec98',
	    'hex'),
	  Buffer.from(
	    '668c83947da63b724bece1743c31a0e6aed0db8ec5b31be377bb784f91b6716f',
	    'hex'),
	  Buffer.from(
	    'f9e67d336c51002ac054c632022d66dda2e7e3fff10ad061ed31d8bbb410cfb2',
	    'hex'),
	  Buffer.from(
	    'bf0feefb9e3a581ad5f9e9db7589985743d261085c4d314f6f5d7259aa421612',
	    'hex'),
	  Buffer.from(
	    '3c5f81fea5fab82c64bfa2eaecafcde8e077fc8620a7cae537163df36edbf378',
	    'hex'),
	  Buffer.from(
	    'cbb522d7b7f127ad6a0113865bdf1cd4102e7d0759af635a7cf4720dc963c53b',
	    'hex'),
	  Buffer.from(
	    '04048028bf1f2864d48f9ad4d83294366a828856553f3b14303f90147f5d40ef',
	    'hex'),
	  Buffer.from(
	    '2530cc8e98321502bad96f9b1fba1b099e2d299e0f4548bb914f363bc0d4531f',
	    'hex'),
	  Buffer.from(
	    '063e4afac491dfd332f3089b8542e94617d893d7fe944e10a7937ee29d9693c0',
	    'hex'),
	  Buffer.from(
	    '136335439334a7698016a0d324de72284e079d7b5220bb8fbd747816eebebaca',
	    'hex'),
	  Buffer.from(
	    '45140b3247eb9cc8c5b4f0d7b53091f73292089e6e5a63e2749dd3aca9198eda',
	    'hex'),
	  Buffer.from(
	    '2ce1cb0bf9d2f9e102993fbe215152c3b2dd0cabde1c68e5319b839154dbb7f5',
	    'hex'),
	  Buffer.from(
	    '568d6905a2c88708a4b3025190edcfedb1974a606a13c6e5290fcb2ae63edab5',
	    'hex'),
	  Buffer.from(
	    '0376ab1d54c5f9803ce4b2e201a0ee7eef7b57b636e8a93c9b8d4860c96f5fa7',
	    'hex'),
	  Buffer.from(
	    '0a81ec5a929777f145904af38d5d509f66b5e2c58fcdb531058b0e17f3f0b41b',
	    'hex'),
	  Buffer.from(
	    '70a73f7f376b60074248904534b11482d5bf0e698ecc498df52577ebf2e93b9a',
	    'hex'),
	  Buffer.from(
	    'bd71fdf6da97e4cf62d1647add2581b07d79adf8397eb4ecba9c5e8488821423',
	    'hex'),
	  Buffer.from(
	    '5c58468d55f58e497e743982d2b50010b6d165374acf83a7d4a32db768c4408e',
	    'hex'),
	  Buffer.from(
	    'bfd88fe1101c41ae3e801bf8be56350ee9bad1a6b9bd515edc5c6d5b8711ac44',
	    'hex'),
	  Buffer.from(
	    '513b2cecb810d4cde5dd85391adfc6c2dd60d87bb736d2b521484aa47a0ebef6',
	    'hex'),
	  Buffer.from(
	    '88497f01602f3154246ae28c4d5aef10f1d87ebb76626f4ae0b7f95ba7968799',
	    'hex'),
	  Buffer.from(
	    'bc104f15a48be709dca542a7e1d4b9df6f054527e802eaa92d595444258afe71',
	    'hex'),
	  Buffer.from(
	    '55926084ec963a64b96e2abe01ce0ba86a64fbfebcc7aab5afc155b37fd76066',
	    'hex'),
	  Buffer.from(
	    'c1b48299aba5208fe9630ace55ca68a03eda5a519c8802a0d3a673be8f8e557d',
	    'hex'),
	  Buffer.from(
	    '9a114025197c5bb95d94e63d55cd43790847b646b23cdf11ada4a00eff15fb48',
	    'hex'),
	  Buffer.from(
	    'edf7ebbca27a2a384d387b7d4010c666e2edb4843e4c29b4ae1d5b9332e6b24d',
	    'hex'),
	  Buffer.from(
	    'fd73dad31c644ff1b43bef0ccdda96710b9cd9875eca7e31707af3e96d522bbd',
	    'hex'),
	  Buffer.from(
	    '3e84ba4342908516e77573c0992f0979ca084e4685681ff195ccba8a229b8a76',
	    'hex'),
	  Buffer.from(
	    '49e7a442acf0ea6287050054b52564b650e4f49e42e348d6aa38e039e957b1c1',
	    'hex'),
	  Buffer.from(
	    'eec5496b988ce98625b934092eec2908bed0b0f316c2d4730c84eaf1f3d34881',
	    'hex'),
	  Buffer.from(
	    'e23d4a036d7b70e9f595b1422079d2b91edfbb1fb651a0633eaa8a9dc5f80703',
	    'hex'),
	  Buffer.from(
	    '9a6ec012e1a7da9dbe34194d478ad7c0db1822fb071df12981496ed104384113',
	    'hex'),
	  Buffer.from(
	    '59769007f7685d0fcd50872f9f95d5755a5b2b457d81f3692b610a98672f0e1b',
	    'hex'),
	  Buffer.from(
	    'dd6936fe21f8f077c123a1a521c12224f72255b73e03a7260693e8a24b0fa389',
	    'hex'),
	  Buffer.from(
	    'b0bfd52bb0d7d9bd92bf5d4dc13da255c02c542f378365ea893911f55e55f23c',
	    'hex'),
	  Buffer.from(
	    '91e2f5788d5810eba7ba58737de1548a8ecacd014598bc0b143e041b17052552',
	    'hex'),
	  Buffer.from(
	    'f356bea244b7a91eb35d53ca9ad7864ace018e2d35d5f8f96ddf68a6f41aa474',
	    'hex'),
	  Buffer.from(
	    '8a866fd1b276b57e578e921c65828a2bed58e9f2f288054134b7f1f4bfc9cc74',
	    'hex'),
	  Buffer.from(
	    '8fe4fb0af93a4d0d67db0bebb23e37c71bf325dcbcdd240ea04daf58b47e1840',
	    'hex'),
	  Buffer.from(
	    '88ef81de202eb018452e43f864725cea5fbd1fc2d9d205730709c5d8b8690f46',
	    'hex'),
	  Buffer.from(
	    '7d05ebb682339f8c9451ee094eebfefa7953a114edb2f44949452fab7d2fc185',
	    'hex'),
	  Buffer.from(
	    '7e37cb8b4c47090cab36551ba6f45db840680fba166a952db100717f43053fc2',
	    'hex'),
	  Buffer.from(
	    'cb3ccbb76031e5e0138f8dd39a23f9de47ffc35e43c1144cea27d46a5ab1cb5f',
	    'hex'),
	  Buffer.from(
	    '31ad6648f8104138c738f39ea4320133393e3a18cc02296ef97c2ac9ef6731d0',
	    'hex'),
	  Buffer.from(
	    '552f7bdcf1a7af9e6ce672017f4f12abf77240c78e761ac203d1d9d20ac89988',
	    'hex'),
	  Buffer.from(
	    '52f0e1c4e58ec629291b60317f074671b85d7ea80d5b07273463534b32b40234',
	    'hex'),
	  Buffer.from(
	    'e793c9b02fd8aa13e21c31228accb08119643b749c898964b1746d46c3d4cbd2',
	    'hex'),
	  Buffer.from(
	    '4ff460d54b9c86dabfbcfc5712e0400d2bed3fbc4d4fbdaa86e06adcd2a9ad7a',
	    'hex'),
	  Buffer.from(
	    'bec94911c2955676db6c0a550986d76e3ba005667c442c9762b4fbb773de228c',
	    'hex'),
	  Buffer.from(
	    '179fbc148a3dd00fd24ea13458cc43bfa7f59c8182d783a513f6ebec100c8924',
	    'hex'),
	  Buffer.from(
	    '3c4fb0b95ab8b30032f432b86f535fe172c185d0fd39865837cf36187fa6f428',
	    'hex'),
	  Buffer.from(
	    '4d2491414cfe956746ec4cefa6cf6f72e28a1329432f9d8a907ac4cb5dadc15a',
	    'hex'),
	  Buffer.from(
	    '5d56499be4d2e08bcfcad08a3e38723d50503bde706948e42f55603019e528ae',
	    'hex'),
	  Buffer.from(
	    '30d0895a9a448a262091635522d1f52010b5867acae12c78ef958fd4f4389f2f',
	    'hex'),
	  Buffer.from(
	    '43df5774b03e7fef5fe40d931a7bedf1bb2e6b42738c4e6d3841103d3aa7f339',
	    'hex'),
	  Buffer.from(
	    '02ed0eb28c14da45165c566791700d6451d7fb56f0b2ab1d3b8eb070e56edff5',
	    'hex'),
	  Buffer.from(
	    '5cc3d78e4e1d5e45547a04e6873e64f90cf9536d1ccc2ef800f355c4c5fd70fd',
	    'hex'),
	  Buffer.from(
	    '49351b903444c185ccdc5c693d24d8555cb208d6a8141307699f4af063199d78',
	    'hex'),
	  Buffer.from(
	    '2a99f5bc1174b73cbb1d620884e01c34e51ccb3978da125f0e33268883bf4158',
	    'hex'),
	  Buffer.from(
	    '6b9c08e86eb0f767cfad65cd98b62149e5494a67f5845e7bd1ed019f27b86bd6',
	    'hex'),
	  Buffer.from(
	    'a1339d33281a0b56e557d3d32b1ce7f9367eb094bd5fa72a7e5004c8ded7cafe',
	    'hex'),
	  Buffer.from(
	    'b676f2eddae8775cd36cb0f63cd1d4603961f49e6265ba013a2f0307b6d0b804',
	    'hex'),
	  Buffer.from(
	    'a040929a02ce53b4acf4f2ffc6981ce4496f755e6d45fe0b2a692bcd52523f36',
	    'hex'),
	  Buffer.from(
	    '44b545aa8a25e65a73ca15dc27fc36d24c1cb9953a066539b11582dc487b4833',
	    'hex'),
	  Buffer.from(
	    '152a402bfcdf2cd548054d2275b39c7fca3ec0978078b0f0ea76e561a6c7433e',
	    'hex'),
	  Buffer.from(
	    '6cc05041e6445e74696c4cfbc9f80f543b7eabbb44b4ce6f787c6a9971c42f17',
	    'hex'),
	  Buffer.from(
	    '56c77128d98c18d91b4cfdffbc25ee9103d4758ea2abad826a90f3457d460eb4',
	    'hex'),
	  Buffer.from(
	    '27995829fe6a7515c1bfe848f9c4761db16c225929257bf40d0894f29ea8baf2',
	    'hex'),
	  Buffer.from(
	    'b7c36231706e81078c367cb896198f1e3208dd926949dd8f5709a410f75b6292',
	    'hex'),
	  Buffer.from(
	    '96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6',
	    'hex'),
	  Buffer.from(
	    'ebc5570c29018c4d67b1aa127baf12f703b4611ebc17b7dab5573894179b93fa',
	    'hex'),
	  Buffer.from(
	    '8ecde6884f3d87b1125ba31ac3fcb13d7016de7f57cc904fe1cb97c6ae98196e',
	    'hex'),
	  Buffer.from(
	    '1ba5b2aa8c65401a82960118f80bec4f62304d83cec4713a19c39c011ea46db4',
	    'hex'),
	  Buffer.from(
	    '18ce6cfe7bf14e60b2e347b8dfe868cb31d02ebb3ada271569f50343b46db3a4',
	    'hex'),
	  Buffer.from(
	    'e35d28419ed02025cfa69038cd623962458da5c695fbdea3c22b0bfb25897092',
	    'hex'),
	  Buffer.from(
	    '54455f7129c20b1447c418f997168f24c58fc5023bf5da5be2eb6e1dd8902ed5',
	    'hex'),
	  Buffer.from(
	    '46edc3689046d53a453fb3104ab80dcaec658b2660ea1629dd7e867990648716',
	    'hex'),
	  Buffer.from(
	    'bfff8fd04433487d6a8aa60c1a29767a9fc2bbb05e420f713a13b992891d3893',
	    'hex'),
	  Buffer.from(
	    'd40e9c86cd8fe468c1776959f49ea774fa548684b6c406f3909261f4dce2575c',
	    'hex'),
	  Buffer.from(
	    '0753e940378c1bd5e3836e395daea5cb839e5046f1bd0eae1951cf10fec7c965',
	    'hex'),
	  Buffer.from(
	    '5a885db19c01d912c5759388938cafbbdf031ab2d48e91ee15589b42971d039c',
	    'hex'),
	  Buffer.from(
	    '85666a562ee0be5ce925c1d8890a6f76a87ec16d4d7d5f29ea7419cf20123b69',
	    'hex'),
	  Buffer.from(
	    '3417bb06cc6007da1b961c920b8ab4ce3fad820e4aa30b9acbc4a74ebdcebc65',
	    'hex'),
	  Buffer.from(
	    '2e7bf16cc22485a7bbe2aa8696750761b0ae39be3b2fe9d0cc6d4ef73491425c',
	    'hex'),
	  Buffer.from(
	    '22a2c1f7bded704cc1e701b5f408c310880fe956b5de2a4a44f99c873a25a7c8',
	    'hex'),
	  Buffer.from(
	    '67add1166b020ae61b8f5fc96813c04c2aa589960796865572a3c7e737613dfd',
	    'hex'
	  ), // R3 (Let's Encrypt)
	  Buffer.from(
	    '96bcec06264976f37460779acf28c5a7cfe8a3c0aae11a8ffcee05c0bddf08c6',
	    'hex'
	  ) // ISRG Root X1 (Let's Encrypt)
	];
	return certs;
}

/*!
 * protoreader.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var protoreader;
var hasRequiredProtoreader;

function requireProtoreader () {
	if (hasRequiredProtoreader) return protoreader;
	hasRequiredProtoreader = 1;

	const assert = require$$0$3;
	const BufferReader = require$$1$3;

	/*
	 * Constants
	 */

	const wireType = {
	  VARINT: 0,
	  FIXED64: 1,
	  DELIMITED: 2,
	  START_GROUP: 3,
	  END_GROUP: 4,
	  FIXED32: 5
	};

	/**
	 * ProtoBuf Reader
	 * @extends {BufferReader}
	 */

	class ProtoReader extends BufferReader {
	  /**
	   * Create a protoreader.
	   * @constructor
	   */

	  constructor(data, zeroCopy) {
	    super(data, zeroCopy);
	  }

	  readVarint() {
	    const {size, value} = _readVarint(this.data, this.offset);
	    this.offset += size;
	    return value;
	  }

	  readFieldValue(tag, opt) {
	    const field = this.readField(tag, opt);

	    if (!field)
	      return -1;

	    assert(field.value != null);

	    return field.value;
	  }

	  readFieldU64(tag, opt) {
	    const field = this.readField(tag, opt);

	    if (!field)
	      return -1;

	    assert(field.type === wireType.VARINT || field.type === wireType.FIXED64);

	    return field.value;
	  }

	  readFieldU32(tag, opt) {
	    const field = this.readField(tag, opt);

	    if (!field)
	      return -1;

	    assert(field.type === wireType.VARINT || field.type === wireType.FIXED32);

	    return field.value;
	  }

	  readFieldBytes(tag, opt) {
	    const field = this.readField(tag, opt);

	    if (!field)
	      return null;

	    assert(field.data);

	    return field.data;
	  }

	  readFieldString(tag, opt, enc) {
	    const field = this.readField(tag, opt);

	    if (!field)
	      return null;

	    assert(field.data);

	    return field.data.toString(enc || 'utf8');
	  }

	  nextTag() {
	    if (this.left() === 0)
	      return -1;

	    const field = this.readField();

	    this.seek(-field.size);

	    return field.tag;
	  }

	  readField(tag, opt) {
	    const offset = this.offset;
	    const header = this.readVarint();
	    const field = new Field(header);

	    if (tag != null && field.tag !== tag) {
	      assert(opt, 'Non-optional field not present.');
	      this.offset = offset;
	      return null;
	    }

	    switch (field.type) {
	      case wireType.VARINT:
	        field.value = this.readVarint();
	        break;
	      case wireType.FIXED64:
	        field.value = this.readU64();
	        break;
	      case wireType.DELIMITED:
	        field.data = this.readVarBytes();
	        break;
	      case wireType.START_GROUP:
	        field.group = [];
	        for (;;) {
	          const inner = this.readField();
	          if (inner.type === wireType.END_GROUP)
	            break;
	          field.group.push(inner);
	        }
	        break;
	      case wireType.END_GROUP:
	        assert(false, 'Unexpected end group.');
	        break;
	      case wireType.FIXED32:
	        field.value = this.readU32();
	        break;
	      default:
	        assert(false, 'Bad wire type.');
	        break;
	    }

	    field.size = this.offset - offset;

	    return field;
	  }
	}

	/*
	 * Encoding
	 */

	function _readVarint(data, off) {
	  let num = 0;
	  let ch = 0x80;
	  let size = 0;

	  while (ch & 0x80) {
	    if (off >= data.length) {
	      num = 0;
	      break;
	    }

	    ch = data[off];

	    // Optimization for javascript insanity.
	    switch (size) {
	      case 0:
	      case 1:
	      case 2:
	      case 3:
	        num += (ch & 0x7f) << (7 * size);
	        break;
	      case 4:
	        num += (ch & 0x7f) * (1 << (7 * size));
	        break;
	      default:
	        num += (ch & 0x7f) * Math.pow(2, 7 * size);
	        break;
	    }

	    off += 1;
	    size += 1;

	    assert(size < 7, 'Number exceeds 2^53-1.');
	  }

	  return new Varint(size, num);
	}

	/*
	 * Helpers
	 */

	class Field {
	  constructor(header) {
	    this.tag = header >>> 3;
	    this.type = header & 7;
	    this.size = 0;
	    this.value = 0;
	    this.data = null;
	    this.group = null;
	  }
	}

	class Varint {
	  constructor(size, value) {
	    this.size = size;
	    this.value = value;
	  }
	}

	/*
	 * Expose
	 */

	protoreader = ProtoReader;
	return protoreader;
}

/*!
 * protowriter.js - protobufs for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var protowriter;
var hasRequiredProtowriter;

function requireProtowriter () {
	if (hasRequiredProtowriter) return protowriter;
	hasRequiredProtowriter = 1;

	const assert = require$$0$3;
	const BufferWriter = require$$1$4;

	/*
	 * Constants
	 */

	const wireType = {
	  VARINT: 0,
	  DELIMITED: 2};

	/**
	 * ProtoBuf Writer
	 * @extends {BufferWriter}
	 */

	class ProtoWriter extends BufferWriter {
	  /**
	   * Create a protowriter.
	   * @constructor
	   */

	  constructor() {
	    super();
	  }

	  writeVarint(num) {
	    const size = sizeVarint(num);

	    // Avoid an extra allocation until
	    // we make bufferwriter more hackable.
	    // More insanity here...
	    switch (size) {
	      case 6: {
	        const value = slipVarint(num);
	        this.writeU32BE(value / 0x10000 | 0);
	        this.writeU16BE(value & 0xffff);
	        break;
	      }
	      case 5: {
	        const value = slipVarint(num);
	        this.writeU32BE(value / 0x100 | 0);
	        this.writeU8(value & 0xff);
	        break;
	      }
	      case 4: {
	        const value = slipVarint(num);
	        this.writeU32BE(value);
	        break;
	      }
	      case 3: {
	        const value = slipVarint(num);
	        this.writeU16BE(value >> 8);
	        this.writeU8(value & 0xff);
	        break;
	      }
	      case 2: {
	        const value = slipVarint(num);
	        this.writeU16BE(value);
	        break;
	      }
	      case 1: {
	        const value = slipVarint(num);
	        this.writeU8(value);
	        break;
	      }
	      default: {
	        const value = Buffer.allocUnsafe(size);
	        _writeVarint(value, num, 0);
	        this.writeBytes(value);
	        break;
	      }
	    }
	  }

	  writeFieldVarint(tag, value) {
	    const header = (tag << 3) | wireType.VARINT;
	    this.writeVarint(header);
	    this.writeVarint(value);
	  }

	  writeFieldU64(tag, value) {
	    assert(Number.isSafeInteger(value));
	    this.writeFieldVarint(tag, value);
	  }

	  writeFieldU32(tag, value) {
	    assert(value <= 0xffffffff);
	    this.writeFieldVarint(tag, value);
	  }

	  writeFieldBytes(tag, data) {
	    const header = (tag << 3) | wireType.DELIMITED;
	    this.writeVarint(header);
	    this.writeVarint(data.length);
	    this.writeBytes(data);
	  }

	  writeFieldString(tag, data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc || 'utf8');
	    this.writeFieldBytes(tag, data);
	  }
	}

	/*
	 * Encoding
	 */

	function _writeVarint(data, num, off) {
	  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

	  do {
	    assert(off < data.length);

	    let ch = num & 0x7f;

	    num -= num % 0x80;
	    num /= 0x80;

	    if (num !== 0)
	      ch |= 0x80;

	    data[off] = ch;

	    off += 1;
	  } while (num > 0);

	  return off;
	}
	function slipVarint(num) {
	  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

	  let data = 0;
	  let size = 0;

	  do {
	    assert(size < 7);

	    let ch = num & 0x7f;

	    num -= num % 0x80;
	    num /= 0x80;

	    if (num !== 0)
	      ch |= 0x80;

	    data *= 256;
	    data += ch;

	    size += 1;
	  } while (num > 0);

	  return data;
	}

	function sizeVarint(num) {
	  assert(Number.isSafeInteger(num), 'Number exceeds 2^53-1.');

	  let size = 0;

	  do {
	    num -= num % 0x80;
	    num /= 0x80;

	    size += 1;
	  } while (num > 0);

	  return size;
	}
	/*
	 * Expose
	 */

	protowriter = ProtoWriter;
	return protowriter;
}

/*!
 * paymentdetails.js - bip70 paymentdetails for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var paymentdetails;
var hasRequiredPaymentdetails;

function requirePaymentdetails () {
	if (hasRequiredPaymentdetails) return paymentdetails;
	hasRequiredPaymentdetails = 1;

	const assert = require$$0$3;
	const ProtoReader = requireProtoreader();
	const ProtoWriter = requireProtowriter();

	/**
	 * BIP70 Payment Details
	 */

	class PaymentDetails {
	  /**
	   * Create payment details.
	   * @constructor
	   * @param {Object?} options
	   * @property {String|null} network
	   * @property {Object[]} outputs
	   * @property {Number} time
	   * @property {Number} expires
	   * @property {String|null} memo
	   * @property {String|null} paymentUrl
	   * @property {Buffer|null} merchantData
	   */

	  constructor(options) {
	    this.network = null;
	    this.outputs = [];
	    this.time = Math.floor(Date.now() / 1000);
	    this.expires = -1;
	    this.memo = null;
	    this.paymentUrl = null;
	    this.merchantData = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Object} options
	   * @returns {PaymentDetails}
	   */

	  fromOptions(options) {
	    if (options.network != null) {
	      assert(typeof options.network === 'string');
	      this.network = options.network;
	    }

	    if (options.outputs) {
	      assert(Array.isArray(options.outputs));
	      for (const output of options.outputs) {
	        assert(output && typeof output === 'object');
	        assert(Number.isSafeInteger(output.value) && output.value >= 0);
	        assert(Buffer.isBuffer(output.script));
	        this.outputs.push(output);
	      }
	    }

	    if (options.time != null) {
	      assert(Number.isSafeInteger(options.time));
	      this.time = options.time;
	    }

	    if (options.expires != null) {
	      assert(Number.isSafeInteger(options.expires));
	      this.expires = options.expires;
	    }

	    if (options.memo != null) {
	      assert(typeof options.memo === 'string');
	      this.memo = options.memo;
	    }

	    if (options.paymentUrl != null) {
	      assert(typeof options.paymentUrl === 'string');
	      this.paymentUrl = options.paymentUrl;
	    }

	    if (options.merchantData)
	      this.setData(options.merchantData);

	    return this;
	  }

	  /**
	   * Instantiate payment details from options.
	   * @param {Object} options
	   * @returns {PaymentDetails}
	   */

	  static fromOptions(options) {
	    return new PaymentDetails().fromOptions(options);
	  }

	  /**
	   * Test whether the payment is expired.
	   * @returns {Boolean}
	   */

	  isExpired() {
	    if (this.expires === -1)
	      return false;
	    return Math.floor(Date.now() / 1000) > this.expires;
	  }

	  /**
	   * Set payment details.
	   * @param {Object} data
	   * @param {String?} enc
	   */

	  setData(data, enc) {
	    if (data == null || Buffer.isBuffer(data)) {
	      this.merchantData = data;
	      return;
	    }

	    if (typeof data !== 'string') {
	      assert(!enc || enc === 'json');
	      this.merchantData = Buffer.from(JSON.stringify(data), 'utf8');
	      return;
	    }

	    this.merchantData = Buffer.from(data, enc);
	  }

	  /**
	   * Get payment details.
	   * @param {String?} enc
	   * @returns {String|Object|null}
	   */

	  getData(enc) {
	    let data = this.merchantData;

	    if (!data)
	      return null;

	    if (!enc)
	      return data;

	    if (enc === 'json') {
	      data = data.toString('utf8');
	      try {
	        data = JSON.parse(data);
	      } catch (e) {
	        return null;
	      }
	      return data;
	    }

	    return data.toString(enc);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {PaymentDetails}
	   */

	  fromRaw(data) {
	    const br = new ProtoReader(data);

	    this.network = br.readFieldString(1, true);

	    while (br.nextTag() === 2) {
	      const op = new ProtoReader(br.readFieldBytes(2));
	      const output = {
	        value: op.readFieldU64(1, true),
	        script: op.readFieldBytes(2, true)
	      };
	      this.outputs.push(output);
	    }

	    this.time = br.readFieldU64(3);
	    this.expires = br.readFieldU64(4, true);
	    this.memo = br.readFieldString(5, true);
	    this.paymentUrl = br.readFieldString(6, true);
	    this.merchantData = br.readFieldBytes(7, true);

	    return this;
	  }

	  /**
	   * Instantiate payment details from serialized data.
	   * @param {Buffer} data
	   * @returns {PaymentDetails}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new PaymentDetails().fromRaw(data);
	  }

	  /**
	   * Serialize the payment details (protobuf).
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const bw = new ProtoWriter();

	    if (this.network != null)
	      bw.writeFieldString(1, this.network);

	    for (const output of this.outputs) {
	      const op = new ProtoWriter();
	      op.writeFieldU64(1, output.value);
	      op.writeFieldBytes(2, output.script);
	      bw.writeFieldBytes(2, op.render());
	    }

	    bw.writeFieldU64(3, this.time);

	    if (this.expires !== -1)
	      bw.writeFieldU64(4, this.expires);

	    if (this.memo != null)
	      bw.writeFieldString(5, this.memo);

	    if (this.paymentUrl != null)
	      bw.writeFieldString(6, this.paymentUrl);

	    if (this.merchantData)
	      bw.writeFieldString(7, this.merchantData);

	    return bw.render();
	  }
	}

	/*
	 * Expose
	 */

	paymentdetails = PaymentDetails;
	return paymentdetails;
}

/*!
 * payment.js - bip70 payment for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var payment;
var hasRequiredPayment;

function requirePayment () {
	if (hasRequiredPayment) return payment;
	hasRequiredPayment = 1;

	const assert = require$$0$3;
	const ProtoReader = requireProtoreader();
	const ProtoWriter = requireProtowriter();
	const {setData, getData} = requirePaymentdetails().prototype;

	/**
	 * BIP70 Payment
	 */

	class Payment {
	  /**
	   * Create a payment.
	   * @constructor
	   * @param {Object?} options
	   * @property {Buffer} merchantData
	   * @property {Buffer[]} transactions
	   * @property {Buffer[]} refundTo
	   * @property {String|null} memo
	   */

	  constructor(options) {
	    this.merchantData = null;
	    this.transactions = [];
	    this.refundTo = [];
	    this.memo = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Object} options
	   * @returns {Payment}
	   */

	  fromOptions(options) {
	    if (options.merchantData)
	      this.setData(options.merchantData);

	    if (options.transactions) {
	      assert(Array.isArray(options.transactions));
	      for (const tx of options.transactions) {
	        assert(Buffer.isBuffer(tx));
	        this.transactions.push(tx);
	      }
	    }

	    if (options.refundTo) {
	      assert(Array.isArray(options.refundTo));
	      for (const output of options.refundTo) {
	        assert(output && typeof output === 'object');
	        assert(Number.isSafeInteger(output.value) && output.value >= 0);
	        assert(Buffer.isBuffer(output.script));
	        this.refundTo.push(output);
	      }
	    }

	    if (options.memo != null) {
	      assert(typeof options.memo === 'string');
	      this.memo = options.memo;
	    }

	    return this;
	  }

	  /**
	   * Instantiate payment from options.
	   * @param {Object} options
	   * @returns {Payment}
	   */

	  static fromOptions(options) {
	    return new Payment().fromOptions(options);
	  }

	  /**
	   * Set payment details.
	   * @param {Object} data
	   * @param {String?} enc
	   */

	  setData(data, enc) {
	    return setData.call(this, data, enc);
	  }

	  /**
	   * Get payment details.
	   * @param {String?} enc
	   * @returns {String|Object|null}
	   */

	  getData(enc) {
	    return getData.call(this, enc);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {Payment}
	   */

	  fromRaw(data) {
	    const br = new ProtoReader(data);

	    this.merchantData = br.readFieldBytes(1, true);

	    while (br.nextTag() === 2) {
	      const tx = br.readFieldBytes(2);
	      this.transactions.push(tx);
	    }

	    while (br.nextTag() === 3) {
	      const op = new ProtoReader(br.readFieldBytes(3));
	      const output = {
	        value: op.readFieldU64(1, true),
	        script: op.readFieldBytes(2, true)
	      };
	      this.refundTo.push(output);
	    }

	    this.memo = br.readFieldString(4, true);

	    return this;
	  }

	  /**
	   * Instantiate payment from serialized data.
	   * @param {Buffer} data
	   * @returns {Payment}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new Payment().fromRaw(data);
	  }

	  /**
	   * Serialize the payment (protobuf).
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const bw = new ProtoWriter();

	    if (this.merchantData)
	      bw.writeFieldBytes(1, this.merchantData);

	    for (const tx of this.transactions)
	      bw.writeFieldBytes(2, tx);

	    for (const output of this.refundTo) {
	      const op = new ProtoWriter();
	      op.writeFieldU64(1, output.value);
	      op.writeFieldBytes(2, output.script);
	      bw.writeFieldBytes(3, op.render());
	    }

	    if (this.memo != null)
	      bw.writeFieldString(4, this.memo);

	    return bw.render();
	  }
	}

	/*
	 * Expose
	 */

	payment = Payment;
	return payment;
}

/*!
 * paymentack.js - bip70 paymentack for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var paymentack;
var hasRequiredPaymentack;

function requirePaymentack () {
	if (hasRequiredPaymentack) return paymentack;
	hasRequiredPaymentack = 1;

	const assert = require$$0$3;
	const ProtoReader = requireProtoreader();
	const ProtoWriter = requireProtowriter();
	const Payment = requirePayment();

	/**
	 * BIP70 Payment ACK
	 */

	class PaymentACK {
	  /**
	   * Create a payment ack.
	   * @constructor
	   * @param {Object?} options
	   * @property {Payment} payment
	   * @property {String|null} memo
	   */

	  constructor(options) {
	    this.payment = new Payment();
	    this.memo = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Object} options
	   * @returns {PaymentACK}
	   */

	  fromOptions(options) {
	    if (options.payment)
	      this.payment.fromOptions(options.payment);

	    if (options.memo != null) {
	      assert(typeof options.memo === 'string');
	      this.memo = options.memo;
	    }

	    return this;
	  }

	  /**
	   * Instantiate payment ack from options.
	   * @param {Object} options
	   * @returns {PaymentACK}
	   */

	  static fromOptions(options) {
	    return new PaymentACK().fromOptions(options);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {PaymentACK}
	   */

	  fromRaw(data) {
	    const br = new ProtoReader(data);

	    this.payment.fromRaw(br.readFieldBytes(1));
	    this.memo = br.readFieldString(2, true);

	    return this;
	  }

	  /**
	   * Instantiate payment ack from serialized data.
	   * @param {Buffer} data
	   * @returns {PaymentACK}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new PaymentACK().fromRaw(data);
	  }

	  /**
	   * Serialize the payment ack (protobuf).
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const bw = new ProtoWriter();

	    bw.writeFieldBytes(1, this.payment.toRaw());

	    if (this.memo != null)
	      bw.writeFieldString(2, this.memo);

	    return bw.render();
	  }
	}

	/*
	 * Expose
	 */

	paymentack = PaymentACK;
	return paymentack;
}

var x509 = {};

var asn1 = {};

/*!
 * asn1.js - asn1 parsing for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on asn1.js.
 * https://github.com/indutny/asn1.js
 *
 * Copyright Fedor Indutny, 2013.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

var hasRequiredAsn1;

function requireAsn1 () {
	if (hasRequiredAsn1) return asn1;
	hasRequiredAsn1 = 1;
	(function (exports) {

		const bio = require$$1;
		const ASN1 = exports;

		/**
		 * Read next tag.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readTag = function readTag(br) {
		  let type = br.readU8();
		  const primitive = (type & 0x20) === 0;

		  if ((type & 0x1f) === 0x1f) {
		    let oct = type;
		    type = 0;
		    while ((oct & 0x80) === 0x80) {
		      oct = br.readU8();
		      type <<= 7;
		      type |= oct & 0x7f;
		    }
		  } else {
		    type &= 0x1f;
		  }

		  return {
		    type: type,
		    primitive: primitive,
		    size: ASN1.readSize(br, primitive)
		  };
		};

		/**
		 * Read tag size.
		 * @param {BufferReader} br
		 * @param {Boolean} primitive
		 * @returns {Number}
		 * @throws on indefinite size
		 */

		ASN1.readSize = function readSize(br, primitive) {
		  let size = br.readU8();

		  // Indefinite form
		  if (!primitive && size === 0x80)
		    throw new Error('Indefinite size.');

		  // Definite form
		  if ((size & 0x80) === 0) {
		    // Short form
		    return size;
		  }

		  // Long form
		  const bytes = size & 0x7f;

		  if (bytes > 3)
		    throw new Error('Length octet is too long.');

		  size = 0;
		  for (let i = 0; i < bytes; i++) {
		    size <<= 8;
		    size |= br.readU8();
		  }

		  return size;
		};

		/**
		 * Read implicit SEQ.
		 * @param {BufferReader} br
		 * @returns {Buffer}
		 */

		ASN1.readSeq = function readSeq(br) {
		  const tag = ASN1.implicit(br, 0x10);
		  return br.readBytes(tag.size);
		};

		/**
		 * Read next tag and assert implicit.
		 * @param {BufferReader} br
		 * @param {Number} type
		 * @returns {Object}
		 * @throws on unexpected tag
		 */

		ASN1.implicit = function implicit(br, type) {
		  const tag = ASN1.readTag(br);

		  if (tag.type !== type)
		    throw new Error(`Unexpected tag: ${tag.type}.`);

		  return tag;
		};

		/**
		 * Read implicit tag.
		 * @param {BufferReader} br
		 * @param {Number} type
		 * @returns {Boolean}
		 */

		ASN1.explicit = function explicit(br, type) {
		  const offset = br.offset;
		  const tag = ASN1.readTag(br);

		  if (tag.type !== type) {
		    br.offset = offset;
		    return false;
		  }

		  return true;
		};

		/**
		 * Read next implicit SEQ and return a new reader.
		 * @param {BufferReader} br
		 * @returns {BufferReader}
		 */

		ASN1.seq = function seq(br) {
		  return bio.read(ASN1.readSeq(br), true);
		};

		/**
		 * Read implicit int.
		 * @param {BufferReader} br
		 * @param {Boolean?} cast
		 * @returns {Buffer|Number}
		 */

		ASN1.readInt = function readInt(br, cast) {
		  const tag = ASN1.implicit(br, 0x02);
		  const num = br.readBytes(tag.size);

		  if (cast)
		    return num.readUIntBE(0, num.length);

		  return num;
		};

		/**
		 * Read explicit int.
		 * @param {BufferReader} br
		 * @param {Number} type
		 * @param {Boolean?} readNum
		 * @returns {Buffer|Number} `-1` on not present.
		 */

		ASN1.readExplicitInt = function readExplicitInt(br, type, readNum) {
		  if (!ASN1.explicit(br, type))
		    return -1;

		  return ASN1.readInt(br, readNum);
		};

		/**
		 * Read and align an implicit bitstr.
		 * @param {BufferReader} br
		 * @returns {Buffer}
		 */

		ASN1.readBitstr = function readBitstr(br) {
		  const tag = ASN1.implicit(br, 0x03);
		  const str = br.readBytes(tag.size);
		  return ASN1.alignBitstr(str);
		};

		/**
		 * Read an implicit string (any type).
		 * @param {BufferReader} br
		 * @returns {String}
		 */

		ASN1.readString = function readString(br) {
		  const tag = ASN1.readTag(br);

		  switch (tag.type) {
		    case 0x03: { // bitstr
		      const str = br.readBytes(tag.size);
		      return ASN1.alignBitstr(str).toString('utf8');
		    }
		    // Note:
		    // Fuck all these.
		    case 0x04: // octstr
		    case 0x12: // numstr
		    case 0x13: // prinstr
		    case 0x14: // t61str
		    case 0x15: // videostr
		    case 0x16: // ia5str
		    case 0x19: // graphstr
		    case 0x0c: // utf8str
		    case 0x1a: // iso646str
		    case 0x1b: // genstr
		    case 0x1c: // unistr
		    case 0x1d: // charstr
		    case 0x1e: { // bmpstr
		      return br.readString(tag.size, 'utf8');
		    }
		    default: {
		      throw new Error(`Unexpected tag: ${tag.type}.`);
		    }
		  }
		};

		/**
		 * Align a bitstr.
		 * @param {Buffer} data
		 * @returns {Buffer}
		 */

		ASN1.alignBitstr = function alignBitstr(data) {
		  const padding = data[0];
		  const bits = (data.length - 1) * 8 - padding;
		  const buf = data.slice(1);
		  const shift = 8 - (bits % 8);

		  if (shift === 8 || buf.length === 0)
		    return buf;

		  const out = Buffer.allocUnsafe(buf.length);
		  out[0] = buf[0] >>> shift;

		  for (let i = 1; i < buf.length; i++) {
		    out[i] = buf[i - 1] << (8 - shift);
		    out[i] |= buf[i] >>> shift;
		  }

		  return out;
		};

		/**
		 * Read an entire certificate.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readCert = function readCert(br) {
		  const buf = br;

		  buf.start();

		  br = ASN1.seq(buf);

		  return {
		    tbs: ASN1.readTBS(br),
		    sigAlg: ASN1.readAlgIdent(br),
		    sig: ASN1.readBitstr(br),
		    raw: buf.endData(true)
		  };
		};

		/**
		 * Read only the TBS certificate.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readTBS = function readTBS(br) {
		  const buf = br;

		  buf.start();

		  br = ASN1.seq(buf);

		  return {
		    version: ASN1.readExplicitInt(br, 0x00, true),
		    serial: ASN1.readInt(br),
		    sig: ASN1.readAlgIdent(br),
		    issuer: ASN1.readName(br),
		    validity: ASN1.readValidity(br),
		    subject: ASN1.readName(br),
		    pubkey: ASN1.readPubkey(br),
		    raw: buf.endData(true)
		  };
		};

		/**
		 * Read an implicit pubkey.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readPubkey = function readPubkey(br) {
		  br = ASN1.seq(br);
		  return {
		    alg: ASN1.readAlgIdent(br),
		    pubkey: ASN1.readBitstr(br)
		  };
		};

		/**
		 * Read implicit name.
		 * @param {BufferReader} br
		 * @returns {Object[]}
		 */

		ASN1.readName = function readName(br) {
		  const values = [];

		  br = ASN1.seq(br);

		  while (br.left()) {
		    ASN1.implicit(br, 0x11); // set
		    ASN1.implicit(br, 0x10); // seq
		    values.push({
		      type: ASN1.readOID(br),
		      value: ASN1.readString(br)
		    });
		  }

		  return values;
		};

		/**
		 * Read implicit validity timerange.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readValidity = function readValidity(br) {
		  br = ASN1.seq(br);
		  return {
		    notBefore: ASN1.readTime(br),
		    notAfter: ASN1.readTime(br)
		  };
		};

		/**
		 * Read implicit timestamp.
		 * @param {BufferReader} br
		 * @returns {Number}
		 */

		ASN1.readTime = function readTime(br) {
		  const tag = ASN1.readTag(br);
		  const str = br.readString(tag.size, 'ascii');
		  let year, mon, day, hour, min, sec;

		  switch (tag.type) {
		    case 0x17: // utctime
		      year = str.slice(0, 2) | 0;
		      mon = str.slice(2, 4) | 0;
		      day = str.slice(4, 6) | 0;
		      hour = str.slice(6, 8) | 0;
		      min = str.slice(8, 10) | 0;
		      sec = str.slice(10, 12) | 0;
		      if (year < 70)
		        year = 2000 + year;
		      else
		        year = 1900 + year;
		      break;
		    case 0x18: // gentime
		      year = str.slice(0, 4) | 0;
		      mon = str.slice(4, 6) | 0;
		      day = str.slice(6, 8) | 0;
		      hour = str.slice(8, 10) | 0;
		      min = str.slice(10, 12) | 0;
		      sec = str.slice(12, 14) | 0;
		      break;
		    default:
		      throw new Error(`Unexpected tag: ${tag.type}.`);
		  }

		  return Date.UTC(year, mon - 1, day, hour, min, sec, 0) / 1000;
		};

		/**
		 * Read and format OID to string.
		 * @param {BufferReader} br
		 * @returns {String}
		 */

		ASN1.readOID = function readOID(br) {
		  const tag = ASN1.implicit(br, 0x06);
		  const data = br.readBytes(tag.size);
		  return ASN1.formatOID(data);
		};

		/**
		 * Format an OID buffer to a string.
		 * @param {Buffer} data
		 * @returns {String}
		 */

		ASN1.formatOID = function formatOID(data) {
		  const br = bio.read(data);
		  const ids = [];
		  let ident = 0;
		  let subident = 0;

		  while (br.left()) {
		    subident = br.readU8();
		    ident <<= 7;
		    ident |= subident & 0x7f;
		    if ((subident & 0x80) === 0) {
		      ids.push(ident);
		      ident = 0;
		    }
		  }

		  if (subident & 0x80)
		    ids.push(ident);

		  const first = (ids[0] / 40) | 0;
		  const second = ids[0] % 40;
		  const result = [first, second].concat(ids.slice(1));

		  return result.join('.');
		};

		/**
		 * Read algorithm identifier.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readAlgIdent = function readAlgIdent(br) {
		  let params = null;

		  br = ASN1.seq(br);

		  const alg = ASN1.readOID(br);

		  if (br.left() > 0) {
		    const tag = ASN1.readTag(br);
		    params = br.readBytes(tag.size);
		    if (params.length === 0)
		      params = null;
		  }

		  return {
		    alg: alg,
		    params: params
		  };
		};

		/**
		 * Read RSA public key.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readRSAPublic = function readRSAPublic(br) {
		  br = ASN1.seq(br);
		  return {
		    modulus: ASN1.readInt(br),
		    publicExponent: ASN1.readInt(br)
		  };
		};

		/**
		 * Read RSA private key.
		 * @param {BufferReader} br
		 * @returns {Object}
		 */

		ASN1.readRSAPrivate = function readRSAPrivate(br) {
		  br = ASN1.seq(br);
		  return {
		    version: ASN1.readInt(br, true),
		    modulus: ASN1.readInt(br),
		    publicExponent: ASN1.readInt(br),
		    privateExponent: ASN1.readInt(br),
		    prime1: ASN1.readInt(br),
		    prime2: ASN1.readInt(br),
		    exponent1: ASN1.readInt(br),
		    exponent2: ASN1.readInt(br),
		    coefficient: ASN1.readInt(br)
		  };
		};

		/**
		 * Read RSA public key from buffer.
		 * @param {Buffer} data
		 * @returns {Object}
		 */

		ASN1.parseRSAPublic = function parseRSAPublic(data) {
		  return ASN1.readRSAPublic(bio.read(data, true));
		};

		/**
		 * Read RSA private key from buffer.
		 * @param {Buffer} data
		 * @returns {Object}
		 */

		ASN1.parseRSAPrivate = function parseRSAPrivate(data) {
		  return ASN1.readRSAPrivate(bio.read(data, true));
		};

		/**
		 * Read certificate from buffer.
		 * @param {Buffer} data
		 * @returns {Object}
		 */

		ASN1.parseCert = function parseCert(data) {
		  return ASN1.readCert(bio.read(data, true));
		};

		/**
		 * Read TBS certificate from buffer.
		 * @param {Buffer} data
		 * @returns {Object}
		 */

		ASN1.parseTBS = function parseTBS(data) {
		  return ASN1.readTBS(bio.read(data, true));
		}; 
	} (asn1));
	return asn1;
}

var crypto = {};

/*!
 * pk.js - public key algorithms for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredCrypto;

function requireCrypto () {
	if (hasRequiredCrypto) return crypto;
	hasRequiredCrypto = 1;

	const assert = require$$0$3;
	const SHA224 = requireSha224();
	const SHA256 = requireSha256();
	const SHA384 = requireSha384();
	const SHA512 = requireSha512();
	const rsa = requireRsa();
	const p224 = requireP224();
	const p256 = requireP256();
	const p384 = requireP384();
	const p521 = requireP521();

	/**
	 * Verify signature with public key.
	 * @param {String} alg - Hash algorithm.
	 * @param {Buffer} msg
	 * @param {Buffer} sig
	 * @param {Object} key
	 * @returns {Boolean}
	 */

	crypto.verify = function verify(alg, msg, sig, key) {
	  const hash = getHash(alg);

	  if (!hash)
	    return false;

	  switch (key.alg) {
	    case 'rsa': {
	      return rsa.verify(hash, hash.digest(msg), sig, key.data);
	    }

	    case 'ecdsa': {
	      const ec = getCurve(key.curve);

	      if (!ec)
	        return false;

	      return ec.verifyDER(hash.digest(msg), sig, key.data);
	    }

	    default: {
	      throw new Error(`Unsupported algorithm: ${key.alg}.`);
	    }
	  }
	};

	/**
	 * Sign message with private key.
	 * @param {String} alg - Hash algorithm.
	 * @param {Buffer} msg
	 * @param {Object} key
	 * @returns {Buffer}
	 */

	crypto.sign = function sign(alg, msg, key) {
	  const hash = getHash(alg);

	  if (!hash)
	    throw new Error(`Unsupported hash algorithm: ${alg}.`);

	  switch (key.alg) {
	    case 'rsa': {
	      return rsa.sign(hash, hash.digest(msg), key.data);
	    }

	    case 'ecdsa': {
	      const ec = getCurve(key.curve);

	      if (!ec)
	        throw new Error(`Unsupported curve: ${key.curve}.`);

	      return ec.signDER(hash.digest(msg), key.data);
	    }

	    default: {
	      throw new Error(`Unsupported algorithm: ${key.alg}.`);
	    }
	  }
	};

	/*
	 * Helpers
	 */

	function getHash(alg) {
	  assert(typeof alg === 'string');
	  switch (alg) {
	    case 'sha224':
	      return SHA224;
	    case 'sha256':
	      return SHA256;
	    case 'sha384':
	      return SHA384;
	    case 'sha512':
	      return SHA512;
	    default:
	      return null;
	  }
	}

	function getCurve(curve) {
	  assert(typeof curve === 'string');
	  switch (curve) {
	    case 'p224':
	      return p224;
	    case 'p256':
	      return p256;
	    case 'p384':
	      return p384;
	    case 'p521':
	      return p521;
	    default:
	      return null;
	  }
	}
	return crypto;
}

/*!
 * x509.js - x509 handling for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredX509;

function requireX509 () {
	if (hasRequiredX509) return x509;
	hasRequiredX509 = 1;
	(function (exports) {

		const assert = require$$0$3;
		const sha256 = requireSha256();
		const ASN1 = requireAsn1();
		const crypto = requireCrypto();
		const certs = requireCerts();

		/**
		 * @exports bip70/x509
		 */

		const x509 = exports;

		/**
		 * Map of trusted root certs.
		 * @type {Set}
		 */

		x509.trusted = new Set();

		/**
		 * Whether to allow untrusted root
		 * certs during verification.
		 * @type {Boolean}
		 */

		x509.allowUntrusted = false;

		/**
		 * OID to algorithm map for PKI.
		 * @const {Object}
		 * @see https://www.ietf.org/rfc/rfc2459.txt
		 * @see https://tools.ietf.org/html/rfc3279
		 * @see http://oid-info.com/get/1.2.840.10040.4
		 * @see http://oid-info.com/get/1.2.840.113549.1.1
		 * @see http://oid-info.com/get/1.2.840.10045.4.3
		 * @see https://tools.ietf.org/html/draft-jivsov-openpgp-sha3-01
		 */

		x509.oid = {
		  '1.2.840.10040.4.1'       : { key: 'dsa',   hash: null       },
		  '1.2.840.10040.4.2'       : { key: 'dsa',   hash: null       },
		  '1.2.840.10040.4.3'       : { key: 'dsa',   hash: 'sha1'     },
		  '1.2.840.113549.1.1.1'    : { key: 'rsa',   hash: null       },
		  '1.2.840.113549.1.1.2'    : { key: 'rsa',   hash: 'md2'      },
		  '1.2.840.113549.1.1.3'    : { key: 'rsa',   hash: 'md4'      },
		  '1.2.840.113549.1.1.4'    : { key: 'rsa',   hash: 'md5'      },
		  '1.2.840.113549.1.1.5'    : { key: 'rsa',   hash: 'sha1'     },
		  '1.2.840.113549.1.1.11'   : { key: 'rsa',   hash: 'sha256'   },
		  '1.2.840.113549.1.1.12'   : { key: 'rsa',   hash: 'sha384'   },
		  '1.2.840.113549.1.1.13'   : { key: 'rsa',   hash: 'sha512'   },
		  '1.2.840.113549.1.1.14'   : { key: 'rsa',   hash: 'sha224'   },
		  '2.16.840.1.101.3.4.2.8'  : { key: 'rsa',   hash: 'sha3-256' },
		  '2.16.840.1.101.3.4.2.9'  : { key: 'rsa',   hash: 'sha3-384' },
		  '2.16.840.1.101.3.4.2.10' : { key: 'rsa',   hash: 'sha3-512' },
		  '1.2.840.10045.2.1'       : { key: 'ecdsa', hash: null       },
		  '1.2.840.10045.4.1'       : { key: 'ecdsa', hash: 'sha1'     },
		  '1.2.840.10045.4.3.1'     : { key: 'ecdsa', hash: 'sha224'   },
		  '1.2.840.10045.4.3.2'     : { key: 'ecdsa', hash: 'sha256'   },
		  '1.2.840.10045.4.3.3'     : { key: 'ecdsa', hash: 'sha384'   },
		  '1.2.840.10045.4.3.4'     : { key: 'ecdsa', hash: 'sha512'   }
		};

		/**
		 * OID to curve name map for ECDSA.
		 * @type {Object}
		 */

		x509.curves = {
		  '1.3.132.0.33': 'p224',
		  '1.2.840.10045.3.1.7': 'p256',
		  '1.3.132.0.34': 'p384',
		  '1.3.132.0.35': 'p521'
		};

		/**
		 * Retrieve cert value by OID.
		 * @param {Object} cert
		 * @param {String} oid
		 * @returns {String}
		 */

		x509.getSubjectOID = function getSubjectOID(cert, oid) {
		  const subject = cert.tbs.subject;

		  for (const entry of subject) {
		    if (entry.type === oid)
		      return entry.value;
		  }

		  return null;
		};

		/**
		 * Try to retrieve CA name by checking
		 * for a few different OIDs.
		 * @param {Object} cert
		 * @returns {String}
		 */

		x509.getCAName = function getCAName(cert) {
		  // This seems to work the best in practice
		  // for getting a human-readable and
		  // descriptive name for the CA.
		  // See:
		  //   http://oid-info.com/get/2.5.4
		  // Precedence:
		  //   (3) commonName
		  //   (11) organizationUnitName
		  //   (10) organizationName
		  return x509.getSubjectOID(cert, '2.5.4.3')
		    || x509.getSubjectOID(cert, '2.5.4.11')
		    || x509.getSubjectOID(cert, '2.5.4.10')
		    || 'Unknown';
		};

		/**
		 * Test whether a cert is trusted by hashing
		 * and looking it up in the trusted map.
		 * @param {Object} cert
		 * @returns {Buffer}
		 */

		x509.isTrusted = function isTrusted(cert) {
		  const fingerprint = sha256.digest(cert.raw);
		  const hash = fingerprint.toString('hex');
		  return x509.trusted.has(hash);
		};

		/**
		 * Add root certificates to the trusted map.
		 * @param {Buffer[]} certs
		 */

		x509.setTrust = function setTrust(certs) {
		  assert(Array.isArray(certs), 'Certs must be an array.');

		  for (const raw of certs) {
		    assert(Buffer.isBuffer(raw), 'Certificates must be DER.');

		    const cert = x509.parse(raw);
		    const hash = sha256.digest(cert.raw);
		    const fingerprint = hash.toString('hex');

		    x509.trusted.add(fingerprint);
		  }
		};

		/**
		 * Add root certificate fingerprints to the trusted map.
		 * @param {Hash[]} hashes
		 */

		x509.setFingerprints = function setFingerprints(hashes) {
		  assert(Array.isArray(hashes), 'Certs must be an array.');

		  for (const hash of hashes) {
		    assert(Buffer.isBuffer(hash), 'Fingerprint must be a buffer.');
		    assert(hash.length === 32, 'Fingerprint must be a sha256 hash.');

		    const fingerprint = hash.toString('hex');

		    x509.trusted.add(fingerprint);
		  }
		};

		/**
		 * Retrieve key algorithm from cert.
		 * @param {Object} cert
		 * @returns {Object}
		 */

		x509.getKeyAlgorithm = function getKeyAlgorithm(cert) {
		  const oid = cert.tbs.pubkey.alg.alg;
		  const alg = x509.oid[oid];

		  if (!alg)
		    throw new Error(`Unknown key algorithm: ${oid}.`);

		  return alg;
		};

		/**
		 * Retrieve signature algorithm from cert.
		 * @param {Object} cert
		 * @returns {Object}
		 */

		x509.getSigAlgorithm = function getSigAlgorithm(cert) {
		  const oid = cert.sigAlg.alg;
		  const alg = x509.oid[oid];

		  if (!alg || !alg.hash)
		    throw new Error(`Unknown signature algorithm: ${oid}.`);

		  return alg;
		};

		/**
		 * Lookup curve based on key parameters.
		 * @param {Buffer} params
		 * @returns {Object}
		 */

		x509.getCurve = function getCurve(params) {
		  let oid;

		  try {
		    oid = ASN1.formatOID(params);
		  } catch (e) {
		    throw new Error('Could not parse curve OID.');
		  }

		  const curve = x509.curves[oid];

		  if (!curve)
		    throw new Error(`Unknown ECDSA curve: ${oid}.`);

		  return curve;
		};

		/**
		 * Parse a DER formatted cert.
		 * @param {Buffer} der
		 * @returns {Object|null}
		 */

		x509.parse = function parse(der) {
		  try {
		    return ASN1.parseCert(der);
		  } catch (e) {
		    throw new Error('Could not parse DER certificate.');
		  }
		};

		/**
		 * Get cert public key.
		 * @param {Object} cert
		 * @returns {Object|null}
		 */

		x509.getPublicKey = function getPublicKey(cert) {
		  const alg = x509.getKeyAlgorithm(cert);
		  const key = cert.tbs.pubkey.pubkey;
		  const params = cert.tbs.pubkey.alg.params;

		  let curve = null;

		  if (alg.key === 'ecdsa') {
		    if (!params)
		      throw new Error('No curve selected for ECDSA (cert).');

		    curve = x509.getCurve(params);
		  }

		  return {
		    alg: alg.key,
		    data: key,
		    params: params,
		    curve: curve
		  };
		};

		/**
		 * Verify cert expiration time.
		 * @param {Object} cert
		 * @returns {Boolean}
		 */

		x509.verifyTime = function verifyTime(cert) {
		  const time = cert.tbs.validity;
		  const now = Math.floor(Date.now() / 1000);
		  return now > time.notBefore && now < time.notAfter;
		};

		/**
		 * Get signature key info from cert chain.
		 * @param {Buffer} key
		 * @param {Buffer[]} chain
		 * @returns {Object}
		 */

		x509.getSigningKey = function getSigningKey(key, chain) {
		  assert(chain.length !== 0, 'No chain available.');

		  const cert = x509.parse(chain[0]);
		  const pub = x509.getPublicKey(cert);

		  return {
		    alg: pub.alg,
		    data: key,
		    params: pub.params,
		    curve: pub.curve
		  };
		};

		/**
		 * Sign a hash with the chain signing key.
		 * @param {String} hash
		 * @param {Buffer} msg
		 * @param {Buffer} key
		 * @param {Buffer[]} chain
		 * @returns {Buffer}
		 */

		x509.signSubject = function signSubject(hash, msg, key, chain) {
		  const priv = x509.getSigningKey(key, chain);
		  return crypto.sign(hash, msg, priv);
		};

		/**
		 * Get chain verification key.
		 * @param {Buffer[]} chain
		 * @returns {Object|null}
		 */

		x509.getVerifyKey = function getVerifyKey(chain) {
		  if (chain.length === 0)
		    throw new Error('No verify key available (cert chain).');

		  const cert = x509.parse(chain[0]);

		  return x509.getPublicKey(cert);
		};

		/**
		 * Verify a sighash against chain verification key.
		 * @param {String} hash
		 * @param {Buffer} msg
		 * @param {Buffer} sig
		 * @param {Buffer[]} chain
		 * @returns {Boolean}
		 */

		x509.verifySubject = function verifySubject(hash, msg, sig, chain) {
		  const key = x509.getVerifyKey(chain);
		  return crypto.verify(hash, msg, sig, key);
		};

		/**
		 * Parse certificate chain.
		 * @param {Buffer[]} chain
		 * @returns {Object[]}
		 */

		x509.parseChain = function parseChain(chain) {
		  const certs = [];

		  for (const item of chain) {
		    const cert = x509.parse(item);
		    certs.push(cert);
		  }

		  return certs;
		};

		/**
		 * Verify all expiration times in a certificate chain.
		 * @param {Object[]} chain
		 * @returns {Boolean}
		 */

		x509.verifyTimes = function verifyTimes(chain) {
		  for (const cert of chain) {
		    if (!x509.verifyTime(cert))
		      return false;
		  }

		  return true;
		};

		/**
		 * Verify that at least one parent
		 * cert in the chain is trusted.
		 * @param {Object[]} chain
		 * @returns {Boolean}
		 */

		x509.verifyTrust = function verifyTrust(chain) {
		  // If trust hasn't been
		  // setup, just return.
		  if (x509.allowUntrusted)
		    return true;

		  // Make sure we trust one
		  // of the certs in the chain.
		  for (const cert of chain) {
		    // If any certificate in the chain
		    // is trusted, assume we also trust
		    // the parent.
		    if (x509.isTrusted(cert))
		      return true;
		  }

		  // No trusted certs present.
		  return false;
		};

		/**
		 * Verify certificate chain.
		 * @param {Object[]} certs
		 */

		x509.verifyChain = function verifyChain(certs) {
		  const chain = x509.parseChain(certs);

		  // Parse certificates and
		  // check validity time.
		  if (!x509.verifyTimes(chain))
		    throw new Error('Invalid certificate times.');

		  // Verify signatures.
		  for (let i = 1; i < chain.length; i++) {
		    const child = chain[i - 1];
		    const parent = chain[i];
		    const alg = x509.getSigAlgorithm(child);
		    const key = x509.getPublicKey(parent);
		    const msg = child.tbs.raw;
		    const sig = child.sig;

		    if (!crypto.verify(alg.hash, msg, sig, key))
		      throw new Error(`${alg.key} verification failed for chain.`);
		  }

		  // Make sure we trust one
		  // of the certs in the chain.
		  if (!x509.verifyTrust(chain))
		    throw new Error('Certificate chain is untrusted.');

		  return true;
		};

		/*
		 * Load trusted certs.
		 */

		x509.setFingerprints(certs); 
	} (x509));
	return x509;
}

/*!
 * paymentrequest.js - bip70 paymentrequest for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var paymentrequest;
var hasRequiredPaymentrequest;

function requirePaymentrequest () {
	if (hasRequiredPaymentrequest) return paymentrequest;
	hasRequiredPaymentrequest = 1;

	const assert = require$$0$3;
	const ProtoReader = requireProtoreader();
	const ProtoWriter = requireProtowriter();
	const PaymentDetails = requirePaymentdetails();
	const x509 = requireX509();

	/**
	 * BIP70 Payment Request
	 */

	class PaymentRequest {
	  /**
	   * Create a payment request.
	   * @constructor
	   * @param {Object?} options
	   * @property {Number} version
	   * @property {String|null} pkiType
	   * @property {Buffer|null} pkiData
	   * @property {PaymentDetails} paymentDetails
	   * @property {Buffer|null} signature
	   */

	  constructor(options) {
	    this.version = -1;
	    this.pkiType = null;
	    this.pkiData = null;
	    this.paymentDetails = new PaymentDetails();
	    this.signature = null;

	    if (options)
	      this.fromOptions(options);
	  }

	  /**
	   * Inject properties from options.
	   * @private
	   * @param {Object} options
	   * @returns {PaymentRequest}
	   */

	  fromOptions(options) {
	    if (options.version != null) {
	      assert((options.version | 0) === options.version);
	      this.version = options.version;
	    }

	    if (options.pkiType != null) {
	      assert(typeof options.pkiType === 'string');
	      this.pkiType = options.pkiType;
	    }

	    if (options.pkiData) {
	      assert(Buffer.isBuffer(options.pkiData));
	      this.pkiData = options.pkiData;
	    }

	    if (options.paymentDetails)
	      this.paymentDetails.fromOptions(options.paymentDetails);

	    if (options.signature) {
	      assert(Buffer.isBuffer(options.signature));
	      this.signature = options.signature;
	    }

	    if (options.chain)
	      this.setChain(options.chain);

	    return this;
	  }

	  /**
	   * Instantiate payment request from options.
	   * @param {Object} options
	   * @returns {PaymentRequest}
	   */

	  static fromOptions(options) {
	    return new PaymentRequest().fromOptions(options);
	  }

	  /**
	   * Inject properties from serialized data.
	   * @private
	   * @param {Buffer} data
	   * @returns {PaymentRequest}
	   */

	  fromRaw(data) {
	    const br = new ProtoReader(data);

	    this.version = br.readFieldU32(1, true);
	    this.pkiType = br.readFieldString(2, true);
	    this.pkiData = br.readFieldBytes(3, true);
	    this.paymentDetails.fromRaw(br.readFieldBytes(4));
	    this.signature = br.readFieldBytes(5, true);

	    return this;
	  }

	  /**
	   * Instantiate payment request from serialized data.
	   * @param {Buffer} data
	   * @returns {PaymentRequest}
	   */

	  static fromRaw(data, enc) {
	    if (typeof data === 'string')
	      data = Buffer.from(data, enc);
	    return new PaymentRequest().fromRaw(data);
	  }

	  /**
	   * Serialize the payment request (protobuf).
	   * @returns {Buffer}
	   */

	  toRaw() {
	    const bw = new ProtoWriter();

	    if (this.version !== -1)
	      bw.writeFieldU32(1, this.version);

	    if (this.pkiType != null)
	      bw.writeFieldString(2, this.pkiType);

	    if (this.pkiData)
	      bw.writeFieldBytes(3, this.pkiData);

	    bw.writeFieldBytes(4, this.paymentDetails.toRaw());

	    if (this.signature)
	      bw.writeFieldBytes(5, this.signature);

	    return bw.render();
	  }

	  /**
	   * Get payment request signature algorithm.
	   * @returns {Object|null}
	   */

	  getAlgorithm() {
	    if (!this.pkiType)
	      throw new Error('No PKI type available.');

	    const parts = this.pkiType.split('+');

	    if (parts.length !== 2)
	      throw new Error('Could not parse PKI algorithm.');

	    if (parts[0] !== 'x509')
	      throw new Error(`Unknown PKI type: ${parts[0]}.`);

	    if (parts[1] !== 'sha1' && parts[1] !== 'sha256')
	      throw new Error(`Unknown hash algorithm: ${parts[1]}.`);

	    return new Algorithm(parts[0], parts[1]);
	  }

	  /**
	   * Serialize payment request for sighash.
	   * @returns {Buffer}
	   */

	  signatureData() {
	    const signature = this.signature;

	    this.signature = Buffer.alloc(0);

	    const data = this.toRaw();

	    this.signature = signature;

	    return data;
	  }

	  /**
	   * Set x509 certificate chain.
	   * @param {Buffer[]} chain
	   */

	  setChain(chain) {
	    const bw = new ProtoWriter();

	    assert(Array.isArray(chain), 'Chain must be an array.');

	    for (const cert of chain) {
	      assert(Buffer.isBuffer(cert), 'Certificates must be DER.');
	      bw.writeFieldBytes(1, cert);
	    }

	    this.pkiData = bw.render();
	  }

	  /**
	   * Get x509 certificate chain.
	   * @returns {Buffer[]}
	   */

	  getChain() {
	    const chain = [];

	    if (!this.pkiData)
	      return chain;

	    const br = new ProtoReader(this.pkiData);

	    while (br.nextTag() === 1)
	      chain.push(br.readFieldBytes(1));

	    return chain;
	  }

	  /**
	   * Sign payment request (chain must be set).
	   * @param {Buffer} key
	   * @param {Buffer[]?} certs
	   */

	  sign(key, certs) {
	    if (certs)
	      this.setChain(certs);

	    if (!this.pkiType)
	      this.pkiType = 'x509+sha256';

	    const alg = this.getAlgorithm();
	    const msg = this.signatureData();
	    const chain = this.getChain();

	    this.signature = x509.signSubject(alg.hash, msg, key, chain);
	  }

	  /**
	   * Verify payment request signature.
	   * @returns {Boolean}
	   */

	  verify() {
	    if (!this.pkiType || this.pkiType === 'none')
	      return false;

	    if (!this.signature)
	      return false;

	    let alg;
	    try {
	      alg = this.getAlgorithm();
	    } catch (e) {
	      return false;
	    }

	    const msg = this.signatureData();
	    const sig = this.signature;
	    const chain = this.getChain();

	    try {
	      return x509.verifySubject(alg.hash, msg, sig, chain);
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Verify x509 certificate chain.
	   * @returns {Boolean}
	   */

	  verifyChain() {
	    if (!this.pkiType || this.pkiType === 'none')
	      return false;

	    try {
	      return x509.verifyChain(this.getChain());
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Get root certificate authority.
	   * @returns {Object|null}
	   */

	  getCA() {
	    if (!this.pkiType || this.pkiType === 'none')
	      throw new Error('No CA found (pkiType).');

	    const chain = this.getChain();

	    if (chain.length === 0)
	      throw new Error('No CA found (chain).');

	    const root = x509.parse(chain[chain.length - 1]);

	    return new CA(root);
	  }
	}

	/**
	 * Algorithm
	 */

	class Algorithm {
	  /**
	   * Create an algorithm.
	   * @constructor
	   * @ignore
	   */

	  constructor(key, hash) {
	    this.key = key;
	    this.hash = hash;
	  }
	}

	/**
	 * CA
	 */

	class CA {
	  /**
	   * Create a CA.
	   * @constructor
	   * @ignore
	   */

	  constructor(root) {
	    this.name = x509.getCAName(root);
	    this.trusted = x509.isTrusted(root);
	    this.cert = root;
	  }
	}

	/*
	 * Expose
	 */

	paymentrequest = PaymentRequest;
	return paymentrequest;
}

/*!
 * b70.js - bip70 for bcoin
 * Copyright (c) 2016-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredB70;

function requireB70 () {
	if (hasRequiredB70) return b70;
	hasRequiredB70 = 1;

	b70.certs = requireCerts();
	b70.PaymentACK = requirePaymentack();
	b70.PaymentDetails = requirePaymentdetails();
	b70.Payment = requirePayment();
	b70.PaymentRequest = requirePaymentrequest();
	b70.x509 = requireX509();
	return b70;
}

var pkg = {};

var name = "@hansekontor/checkout-components";
var version = "1.3.0";
var require$$0 = {
	name: name,
	version: version};

/*!
 * pkg.js - package constants
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * Copyright (c) 2018, bcash developers.
 * https://github.com/bcoin-org/bcash
 */

var hasRequiredPkg;

function requirePkg () {
	if (hasRequiredPkg) return pkg;
	hasRequiredPkg = 1;
	(function (exports) {

		const pkg = exports;

		/**
		 * Package Name
		 * @const {String}
		 * @default
		 */

		pkg.name = require$$0.name;

		/**
		 * Project Name
		 * @const {String}
		 * @default
		 */

		pkg.core = 'bcash';

		/**
		 * Organization Name
		 * @const {String}
		 * @default
		 */

		pkg.organization = 'badger-cash';

		/**
		 * Currency Name
		 * @const {String}
		 * @default
		 */

		pkg.currency = 'bitcoin cash';

		/**
		 * Currency Unit
		 * @const {String}
		 * @default
		 */

		pkg.unit = 'bch';

		/**
		 * Base Unit
		 * @const {String}
		 * @default
		 */

		pkg.base = 'satoshi';

		/**
		 * Config file name.
		 * @const {String}
		 * @default
		 */

		pkg.cfg = `${pkg.core}.conf`;

		/**
		 * Repository URL.
		 * @const {String}
		 * @default
		 */

		pkg.url = `https://github.com/${pkg.organization}/${pkg.name}`;

		/**
		 * Current version string.
		 * @const {String}
		 */

		pkg.version = require$$0.version; 
	} (pkg));
	return pkg;
}

/*!
 * bcoin.js - a javascript bitcoin library.
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

var hasRequiredBcoinBrowser;

function requireBcoinBrowser () {
	if (hasRequiredBcoinBrowser) return bcoinBrowser$1.exports;
	hasRequiredBcoinBrowser = 1;
	(function (module, exports) {

		/**
		 * A bcoin "environment" which exposes all
		 * constructors for primitives, the blockchain,
		 * mempool, wallet, etc. It also exposes a
		 * global worker pool.
		 *
		 * @exports bcoin
		 * @type {Object}
		 */

		const bcoin = exports;

		/**
		 * Set the default network.
		 * @param {String} network
		 */

		bcoin.set = function set(network) {
		  bcoin.Network.set(network);
		  return bcoin;
		};

		/*
		 * Expose
		 */

		// Blockchain
		// bcoin.blockchain = require('./blockchain');
		// bcoin.Chain = require('./blockchain/chain');
		// bcoin.ChainEntry = require('./blockchain/chainentry');

		// BTC
		bcoin.btc = requireBtc();
		bcoin.Amount = requireAmount();
		bcoin.URI = requireUri();

		// Coins
		bcoin.coins = requireCoins();
		bcoin.Coins = requireCoins$1();
		bcoin.CoinEntry = requireCoinentry();
		bcoin.CoinView = requireCoinview();

		// HD
		bcoin.hd = requireHd();
		bcoin.HDPrivateKey = require_private();
		bcoin.HDPublicKey = require_public();
		// bcoin.Mnemonic = require('./hd/mnemonic');
		module.exports.Mnemonic = requireMnemonic();

		// Primitives
		bcoin.primitives = requirePrimitives();
		bcoin.Address = requireAddress();
		bcoin.Block = requireBlock();
		bcoin.Coin = requireCoin();
		bcoin.Headers = requireHeaders();
		bcoin.Input = requireInput();
		bcoin.InvItem = requireInvitem();
		bcoin.KeyRing = requireKeyring();
		bcoin.MerkleBlock = requireMerkleblock();
		bcoin.MTX = requireMtx();
		bcoin.Outpoint = requireOutpoint();
		bcoin.Output = requireOutput();
		bcoin.TX = requireTx();

		// Protocol
		bcoin.protocol = requireProtocol();
		bcoin.consensus = requireConsensus();
		bcoin.Network = requireNetwork();
		bcoin.networks = requireNetworks();
		bcoin.policy = requirePolicy();

		// Script
		bcoin.script = requireScript();
		bcoin.Opcode = requireOpcode();
		bcoin.Script = requireScript$1();
		bcoin.ScriptNum = requireScriptnum();
		bcoin.SigCache = requireSigcache();
		bcoin.Stack = requireStack();

		// Utils
		bcoin.utils = requireUtils();
		bcoin.util = requireUtil();

		// bcrypto
		bcoin.bcrypto = requireBcrypto();

		// bfilter
		bcoin.bfilter = requireBfilter();

		// b70 
		bcoin.b70 = requireB70();

		// Package Info
		bcoin.pkg = requirePkg(); 
	} (bcoinBrowser$1, bcoinBrowser$1.exports));
	return bcoinBrowser$1.exports;
}

var bcoinBrowserExports = requireBcoinBrowser();
var bcoinBrowser = /*@__PURE__*/getDefaultExportFromCjs(bcoinBrowserExports);

export { bcoinBrowser as default };
//# sourceMappingURL=index.js.map
